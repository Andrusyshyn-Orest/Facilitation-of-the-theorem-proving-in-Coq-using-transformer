{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 12,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "616177ae8e3d18465bb4aeb51d0f7cd77aca94b2",
        "torch_seed": 7
    },

    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n\n    (** a list of a function *)\n\n    (** The function\n    Inductive cont -> cont -> Prop :=\n    | Some s (l: cont) : cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont.\n\n    (**r: cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont -> cont cont -> cont.\n\n    (**r [s [s] *)\n\n    (** The statement, and [s] is the type of [s [s] *)\n\n    (** [s] and [s [ss] *)\n\n    (** [s [s] and [s]s] *)\n\n    (** ** [s] *)\n\n    (** [s [s] is a [s] [s] is the [s [s] *)\n    | [s s] *)\n\n    (**r] *)\n\n    (** [s] *)\n\n    (** The [s [s [s] [s [s] *)\n    (** [s] *)\n\n    (** [s] is [s] *)\n\n    (** (** [s [s] *)\n    (** [ss [s] *)\n\n    (** [s] *)\n\n    (**Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n\n    Definition is_step T -> Prop :=\n  Proof.\n    intros.\n    unfold transition_step_step.\n    induction (bind_step_step_step_step_step_step_step_step_step_step; intros; simpl in H.\n    elim (s_step_step_step (t_step x) (s) (s_step_step_step_step_step x) (t_step_step x (t_step x) (t A) (s a) (t A),\n      (T a) ->\n      In (s a (s_step x a (s a) (s a) (s a)) ->\n      (s a) ->\n      equal (s a a (s a) (s a a) (s a) ->\n      equal (s a (s a s s) (s a s) (s a) (s a s) (s a s) (s a s) s) s) ->\n      (s a) (s s).\n    Proof.\n    intros; simpl in H.\n    inversion H.\n    inversion H.\n    induction H.\n    simpl in H; simpl in H; subst.\n    case_step.\n   Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    intros.\n    intros.\n    destruct H as [x] H.\n    destruct H as [x|x|x|x].\n    case (lt_trans x) as [x]; intros.\n    destruct (y|y|x|y];\n      destruct x) as [y|x|y].\n    destruct (y) as [|y|y|x|y|y|y|x|y|y|y|y|y|y|y].\n    destruct (y|y|y|y|x|y].\n    destruct (y|y|y|y|y|y|y|x|y].\n    destruct x); simpl in H.\n    rewrite (y) as [y|y|y|y|y|x|y|y|x|x|x|y||y|y|x||x|||y|||x|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n\n  Lemma weak_refl : forall x y, In x y -> In x -> In x (Add x) -> In x).\n\n  Proof.\n    intros.\n    intros.\n    destruct (eq (S x) as [P [P [P [P |P Q]].\n    exists P.\n    exists x.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    intros; simpl; simpl; simpl; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n\n  Lemma weak_refl : forall (A:A,\n    is_refl:A -> Prop) -> Prop) -> weak (A -> weak_refl.\n\n  Proof.\n    intros.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_trans with (L a).\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    apply weak_refl.\n    eapply weak_refl.\n    apply weak_refl.\n  Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n\n    Definition inter (x:t) (T) (x:t:t:t:t) : list T) (t:t) :=\n  Proof.\n    intros.\n    unfold no_step; intros.\n    simpl; simpl in *.\n    do 2 do 2 do 2 rewrite <- (do 2 do 2 do 2 do 2 do 2 do 2 rewrite <- (try do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 3 do 2 do 2 do 3 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 3 do 3 do 2 do 2 do 2 do 3 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 3 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 3 do 2 do 2 do 3 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2 do 2Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n\n    Lemma weak_trans_step:\n    forall x, In x -> In x -> In x -> In x (forall x x, In x -> In x (x:A, In x) -> In x) -> In x.\n\n    Proof.\n    intros.\n    unfold In in H.\n    split.\n    apply (fun x => x => exists x) (x, In y).\n    split.\n    intros.\n    apply H.\n    apply H.\n    unfold In in H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n   Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n  Proof.\n    intros.\n    induction l.\n    intros.\n    destruct (x:=x:=x) as [x) as [x|y] y|y];\n    destruct x as [y]; [x; apply H; [y|y]; auto.\n    simpl; auto.\n    case (x:=x,y:=x,x,x).\n    destruct (y) as [y]; auto.\n    destruct y; auto.\n    destruct (y,y,x,y,y) as [y] x y; destruct (y,y,y,y,x,y,y,y,y,y,y) as [y].\n    exists y,y,y,x,y,y,y,y,y,x,y,y,y,y,x,y,y,y,y,y,y,y,y,x,y,y,y,y,y,y,y,y,y,x,y,x,y,y,x,x,y,x,x,x,y,y,y,x,y,y,y,y,y,x,y,y,xQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n  Proof.\n    intros.\n    simpl.\n    apply in H.\n    apply H.\n    intros.\n    apply IH; auto.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    rewrite L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L L L.\n    apply L.\n    apply L L L.\n    apply L L.\n    apply L.\n    apply L L L L L L L L.\n    apply L.\n    apply L L.\n    apply L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L LQed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n\n    Lemma weak_step: forall x y, ~In x y -> ~ In x y -> ~ In y -> ~In x y -> ~ In y -> In y -> ~ In y -> ~ In y.\n    Proof.\n    intros x y.\n    unfold In; apply weak_step_step; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros.\n    induction l; simpl.\n    simpl in *.\n    induction l; simpl in *; simpl in |- *.\n    - destruct (split_sym (H b x y)).\n    - constructor.\n      - split; simpl in |- *.\n      - intro.\n      - intros.\n      - inversion H1.\n      - constructor.\n      - constructor.\n        apply H1.\n      - constructor; constructor.\n      - intros.\n      + constructor.\n      - intros.\n      + constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      + constructor.\n      - constructor; constructor.\n      - constructor.\n      - constructor.\n      - constructor; constructor.\n      - constructor.\n        constructor; constructor.\n      - constructor.\n      - constructor.\n      + constructor.\n      constructor.\n      constructor.\n      - constructor.\n      constructor.\n      - constructor; constructor.\n      constructor.\n      constructor; constructor.\n      constructor.\n      - constructor.\n      - constructor.\n      constructor.\n      - constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor; constructor constructor; constructor.\n      constructor.\n      constructor.\n        constructor.\n      - constructor.\n      constructor. constructor constructor.\n      constructor. constructor.\n      constructor.\n      constructor.\n      constructor constructorQed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n  Proof.\n    intros x y y H; subst; auto.\n    apply (fun x: forall (x:X, X) (x, y) -> R y) (x,x,y, x) -> y) ->\n    Proof.\n    intros.\n    apply H.\n    apply (y, y); auto.\n    apply H.\n    apply H.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros.\n    apply (Add_refl).\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros; inversion.\n    inversion H.\n    intros.\n    inversion H; subst.\n    inversion H.\n    inversion H; subst.\n    inversion H.\n    inversion H.\n    inversion H; subst.\n    inversion H; inversion H; subst.\n    inversion H; subst.\n    inversion H.\n    inversion H.\n    inversion H.\n    inversion H; inversion H; inversion H.\n    inversion H.\n    inversion H; inversion H; inversion H.\n    inversion H0; subst. inversion H0; clear H; subst.\n    inversion H.\n    inversion H; subst.\n    inversion H; inversion H.\n    inversion H; inversion H; inversion H0; clear H; subst; inversion H0; subst. inversion H0; subst; subst; subst.\n    inversion H0. inversion H0; subst. inversion H0; subst. inversion H; subst; subst. subst. inversion H0; subst; inversion H0; subst; inversion H; subst.\n    inversion H0; subst; subst; subst.\n    inversion H0. inversion H0; subst; subst; subst. inversion H; subst.\n    inversion H0; subst; subst.\n  inversion H0; inversion H0.\n  inversion HQed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros.\n    unfold Subset in *; unfold contains, contains in *; intros.\n    destruct (H:=H:=H).\n    destruct H).\n    rewrite <- (H:=H).\n    rewrite <- H.\n    rewrite <- H in H.\n    rewrite (H:=H) in H).\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    apply (H0.\n    rewrite <- H0.\n    apply H1.\n    apply H2.\n    rewrite H2.\n    rewrite <- H1.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- (H2).\n    rewrite <- H1.\n    rewrite <- H2.\n    rewrite <- H2.\n    rewrite <- H1; rewrite <- H1.\n    rewrite <- (H1).\n    rewrite <- H2.\n    rewrite <- HQed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n\n    Proof.\n    intros; auto.\n    red; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n\n    Lemma weak_refl: forall x,\n    ~In x ->\n    (x,\n      (y) = y) ->\n      In y ->\n      is_refl x y ->\n      (x, y) ->\n      In y) (y /\\\n      (x) (y,x,x,x,x,y) ->\n      (x,x,x,x,x,x,x,x,x,x,x,y,x,y,y,x,x,x,y,x,x,x,x,x,y,x,x,x,x,x,x,x,x,x,x,x,x,x,y,x,x,x,,x,x,x,x,,,y,x,x,,x,x,,x,x,x,,,x,,x,x,x,,x,,x,x,,x,,x,, x,,x,,x,x,x, x,,x,,,,x,,,,x,,,,,,x,,,,,x,,x, x,,Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros.\n    unfold In in *.\n    unfold In in *.\n    destruct (H a); simpl in H.\n    destruct (H:=H:=H).\n    destruct H.\n    destruct (H:=H:=H:=H).\n    simpl in H.\n    apply H.\n    rewrite H.\n    apply H.\n    rewrite H.\n    rewrite H.\n    apply H.\n    rewrite (H:=H).\n    apply H.\n    rewrite H.\n    apply H.\n    rewrite H.\n    apply H.\n    apply (H).\n    unfold In.\n    rewrite H.\n    rewrite H0.\n    apply (H0 H0).\n    apply H0.\n    apply H0.\n    apply H0.\n    rewrite H0.\n    apply H0.\n    apply H0.\n    apply (H0).\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply (H0).\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    applyQed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n    intros; auto.\n    apply (H1); auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof. intros x y z z; split; auto.\n      intros; auto.\n      unfold weak_trans with sets.\n      apply M; auto with sets.\n      unfold weak_star; auto with sets.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n      intros x y; auto.\n      destruct (x, X); auto.\n      apply L; auto.\n      apply le_star_star_star.\n      apply le_star_star.\n      auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n      intros A l; simpl in H; apply (exists y, P y); auto.\n      unfold weak_step.\n      apply weak_trans with (M:=M:=M:=M:=M:=M:=M:=M:=M:=M:=M).\n      apply (M:=M:=M:=M) in H.le_trans _ M); auto.\n      apply H.\n      apply (M:=M:=M:=M:=M:=M:=M:=M:=M:=M).\n      apply L.le_trans with M).\n      apply M.\n        eapply weak_trans with M M.\n      apply M. apply M.\n      apply M.\n        apply M.\n      apply L.\n        apply M.\n      apply M M.\n        apply M.\n      apply M.\n      apply M.\n        apply M.\n        apply M.\n        apply M.\n      apply M.\n      apply M.\n        apply M M.\n      apply M.\n        apply M M M M.\n    - apply M.\n        apply M M M M.\n        apply M M.\n        apply M M.\n      apply M M.\n        apply M.\n        apply M M M.\n        apply M M M M M M M M M.\n        applyQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z. Proof.\n      intros.\n      unfold weak_wf; simpl; simpl; auto.\n      intros; auto.\n      apply weak_step.\n      apply weak_step.\n      rewrite <- (fun x => (P x y) (T x y).\n      do 2 rewrite <- (T x y)); auto.\n      apply weak_step_step; auto.\n      auto.\n      rewrite <- (T x y); auto.\n      rewrite <- (T x y)); auto.\n      rewrite <- (T y); auto.\n      rewrite <- H; auto.\n      apply weak_step_step; auto.\n      destruct (T x y) (T x y); auto.\n      destruct (T x y)); auto.\n      rewrite <- (T x y); auto.\n      apply weak_step x y); auto.\n      rewrite <- (T y); auto.\n      auto.\n      auto.\n      rewrite <- (T x y); auto.\n      rewrite <- (T y); auto.\n      rewrite <- (T x y); auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z. Proof.\n    intros. intros; intros x y; auto.\n      destruct (T x y); auto.\n      apply (U:=z:=x:=x:=x:=x:=x:=y:=x:=x) H) in H; auto.\n      auto.\n      intros.\n      assert (y:=y:=y:=x:=x:=y:=y).\n      unfold R.\n      apply R_star.\n      apply (y:=x:=y:=x:=x:=x:=x:=x:=y:=y:=x:=x:=x) in H.\n      apply R); auto.\n      apply R.\n      apply R; auto.\n      intros; auto.\n      auto.\n      auto.\n      destruct x; auto.\n      - apply R; auto.\n      apply R; auto.\n      rewrite R; auto.\n      apply R_star; auto.\n      apply R; auto.\n      apply R.\n      apply R_star R_star_star; auto.\n      apply R_star_star R; auto.\n      apply R_star R_star R; auto.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n      intros x y.\n      intros; unfold weak_star.\n      destruct x; auto.\n      rewrite (X:=X:=X).\n      rewrite Y.\n      destruct (X) as [Y].\n      destruct (X:=X) as [Y]].\n      exists X Y.\n      apply M.\n        apply X.\n        apply (X:= X) X).\n        apply (X:=X).\n      apply X.\n        split.\n        apply X.\n        apply X; auto.\n        apply X.\n        rewrite X.\n        apply X.\n        apply X.\n        apply X.\n        assumption.\n        apply X.\n        split; auto.\n        apply X.\n        apply X.\n        apply X; auto.\n        apply X.\n        apply X.\n        eapply X; auto.\n        apply X.\n        apply X.\n        auto.\n        apply X.\n        auto.\n        apply X.\n        apply X.\n        rewrite X.\n        apply X.\n        repeat split; auto.\n        apply X; auto.\n        apply X.\n        repeat split.\n        auto.\n        auto.\n        apply X.\n        eapply X.\n        apply X; auto.\n        eapply X.\n        apply X.\n        apply X.\n        unfold X.\n        apply X.\n       Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n\n  Proof.\n    intros; apply (x:=x:=x) (y:=x:=x:=y:=x:=x:=x:=y:=x:=x) (x:=x:=y) y).\n    apply (x:=x:=x:=y:=y:=y:=y:=x) (x:=y) (x:=y:=x:=x:=y:=y); auto.\n    eapply (y:=x:=x:=x:=x:=x:=y:=x:=y:=y:=x:=x:=x:=x:=x:=y in H in H0:=x:=y:=x:=x:=x:=x:=y:=y:=y:=y:=y:=x:=x:=x:=x:=y); auto.\n    intros.\n    destruct (y:=y:=x) as [z:=x:=x:=y:=x:=x:=x:=:=y:=y:=y:=y:=x:=y) in H; simpl in H.\n    rewrite H; auto.\n    destruct (y:=y:=x:=y:=x:=x:=y) as [x:=x:=x:=:=x:=x:=x) as (y:=x:=x) as [x:=xQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n  Proof.\n      intros; elim H0.\n      apply l; auto with sets.\n      apply (x := List.find (T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T:=T).\n      intros.\n      apply M.\n      apply M.\n      apply M.\n    apply M.\n        apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n    apply M.\n      apply M.\n      apply M.\n      apply M.\n      apply M.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n    intros x y; unfold weak_trans with (M.\n      (X:=X:=X:=X:=X:=X:=X).\n      rewrite <- X.In_star_star_star. rewrite <- X.\n      apply (X:= X); auto.\n      repeat rewrite <- X.\n      rewrite <- X.\n      apply X.\n      rewrite <- X; auto.\n      apply X.\n      apply X.\n      apply X.\n        rewrite X.\n        apply X.\n      rewrite X; auto.\n      apply X.\n      unfold L.\n      apply X.\n        unfold L.\n      rewrite X.\n      apply X.\n        unfold L.\n      apply X.\n        eapply X.\n      apply X.\n      apply X.\n        apply X.\n        apply X.\n      apply X.\n      apply X.\n      split; auto.\n      apply X.\n        apply X.\n      apply X.\n      apply X; auto.\n      apply X.\n        apply X.\n        apply X.\n        apply X.\n      repeat split.\n        apply X.\n        split.\n      apply X.\n        apply X.\n        apply X X.\n        apply X.\n        split; auto.\n        apply X.\n        apply X.\n        apply X.\n        split.\n        apply XQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n    intros; unfold weak_trans with y; auto with datatypes.\n      apply (l := M).\n      apply weak_one.\n      rewrite <- plus_trans with datatypes.\n      apply (x:=x:=x:=x:=x:=x).\n      apply le_star_star_one.\n      apply le_trans with (x:=x:=x:=x:=x) (y:=y:=x:=x:=x:=x:=y) (x:=x:=x:=y) (x:=y:=x:=x:=x:=y:=x:=x:=x:=x:=x:=y:=y)) H H0).\n      apply le_trans with (x:=x:=x:=x:=y:=y:=x:=x:=x:=y:=x:=x:=x:=x:=y) in H1:=x:=y:=y:=y:=x:=y:=x:=y:=y:=y:=x:=x) in H1:=x:=x:=x:=x:=x:=x:=x:=x:=:=y:=y in_x:=y:=y:=:=x:=x:=x:=:=y:=y:=x:=:=x:=y:=y:=y:=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.lt y -> In x y l -> ~In y -> In y.\n    Proof.\n    induction y; intros; intros.\n      destruct X; auto.\n      destruct X.\n      apply X; auto.\n      repeat split; auto.\n      apply (left_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus (S x y)); auto.\n      auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n    intros.\n      unfold weak_wf.\n      unfold weak_wf.\n      intros; auto.\n      destruct (H0, M).\n      destruct (M:=M0); auto.\n      destruct H0.\n    auto.\n      apply H0.\n      auto.\n      apply (M0 _ _ _ _ H0).\n      auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n    intros.\n    unfold ~In, In; auto with sets.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros.\n      unfold gt_trans with u; apply lt_trans with (x:=x:=x:=x:=x:=y:=x:=x:=y) z); auto.\n      intros z.\n      apply IH...\n      apply IH.\n      apply lt_star.\n      auto.\n      apply le_trans with x...\n      unfold lt_trans with y.\n      apply lt_trans with (y:=x:=x:=x:=x:=x:=y:=y:=x:=y:=y:=y) (y) in u in Y); auto.\n      apply le_trans with (y:=y:=x:=y:=y:=x:=y:=y:=x:=x:=x:=x:=x:=y) in y:=y:=y:=y in z.\n      rewrite (y:=x:=x:=y:=y:=y:=y:=x:=x:=y:=y:=y:=y) in (x:=y:=y:=y:=x:=y:=y:=x) in y) in y.\n      rewrite (x:=y:=y:=x:=y:=y:=x:=y:=y) in H0:=x in H.\n      apply lt_y.\n      rewriteQed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y. Proof.\n      intros; auto.\n      destruct y; split.\n      auto.\n      intros; apply X.\n      auto.\n      simpl; auto.\n      unfold wf_wf with sets.\n      unfold wf_wf; auto with sets.\n      apply wf_wf.\n      apply wf_wf with sets.\n      auto with sets.\n      auto with sets.\n      auto with sets.\n      auto with sets.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n\n    Proof.\n    intros; auto with datatypes.\n      auto with datatypes.\n      apply (X := A).\n      auto with datatypes.\n      split.\n      apply (X:=X:=X).\n      Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y. Proof.\n      intros.\n      unfold is_step in H; intros y; simpl in H; auto.\n      intros y; simpl in H.\n      unfold R; auto.\n      intros.\n      destruct (U:= U) as [U] [U1 [U2]].\n      destruct (U2 U2 U2 U2 U2 U2).\n      split; auto.\n      destruct (U2 U2).\n      right; auto.\n      intros.\n      destruct (U1 U2 U2 U2 U2) as [U2 [U2 U2 U2 U2].\n      apply U2 U1 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U2 U1 U2 U2 U2 U2 U2 U2 U2 U2 U2 U1 U2 U2 U2 U2 U1 U2 U2 U2 U3 U1 U1 U2 U2 U2 U1 U2 U2 U2 U2 U2 U U2 U U2 U2 U1 U U2 U2 U2 U1 U1 U2 U2 U2 U1 U1 U U2Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y. Proof.\n    intros x y; auto with sets.\n      rewrite <- X.\n      apply (X:=X:=X).\n      apply L.\n      rewrite <- (X:= X).\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L_trans with (X:=X:=X).\n      apply L); auto.\n      apply L; auto.\n      unfold M.\n      apply L.\n      apply L; auto.\n      apply L.\n      intros.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n\n    Proof.\n      intros; auto.\n      unfold weak_trans with sets.\n      simpl.\n      apply weak_weak.\n      apply weak_weak.\n      unfold weak_weak; auto with sets.\n      apply weak_weak.\n      unfold weak_weak.\n      apply weak_weak; auto with sets.\n      auto with sets.\n      apply weak_weak; auto with sets.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n      exists y, In y.\n\n    Proof.\n    destruct (S x y) as [K [J [K [K]].\n      exists y; split; auto.\n      apply (U:=U:=U:=U:=U) (U:=U:=U:=U:=U:=U:=U:=U:=U:=U).\n      apply K.\n      intro.\n      assumption.\n      apply (U:=U:=U:=V:=U:=U:=U:=U:=U:=U:=U:=U) in U.\n      apply M) in U in U.\n      apply H.\n      apply (U:=U:=V:=V:=U:=U:=U:=U:=V:=U:=V:=VV:=V:=V:=V:=V:=U:=VV:=V:=V:=V:=V:=V:=VV).\n      rewrite (U:=V:=V).\n      apply (V:=V:=V:=VVVV:=V:=VV:=VVVVVVVVV:=V:=VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros.\n      destruct (X. apply (X) as [U | X]; auto.\n      unfold no_step.\n      inversion H; auto.\n      auto.\n      auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z. Proof.\n      intros.\n      apply (P y) as [|P [P Q]; auto.\n      apply (P x y); auto.\n      apply L; auto.\n      apply L.\n      apply IH...\n      eapply H.\n      apply L.\n      split; auto.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      split.\n      apply L.\n    apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      unfold L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n    apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L L L L.\n      apply L.\n      apply L L.\n      apply L L L L.\n      apply L L.\n      apply L L L.\n      apply L L.\n      apply L L L L L L.\n      apply L L L.\n      apply L L L.\n      apply L L L L L L L L L L L L.\n      apply L L L L L L L LQed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n\n    Proof.\n    intros.\n    intros x y z H.\n    assert (U:=H:=H).\n      destruct (H:=H).\n      destruct (H) as [L].\n      destruct (H':=H).\n      assert (H':=H:=H).\n      exists z); auto.\n      exists x.\n      exists y,H:=H).\n      split; auto.\n      exists y; auto.\n      exists z.\n      exists x y.\n      exists y.\n      exists x; split; split; auto.\n      auto.\n      exists x y; auto.\n      exists y; auto.\n      split; auto.\n      exists y; auto.\n      exists y, exists y; auto.\n      split.\n      split; auto.\n      exists y; auto.\n      split; auto.\n      exists y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros x y z H; rewrite <- (x y z).\n      apply weak_trans with (x:=x:=x:=x:=x:=x:=y:=x) H) in H.\n      apply (x:=y:=y:=x:=y) in H.\n      apply (x:=y:=y:=y:=y).\n      apply H.\n      auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n      (x y) ->\n      (x y x y) ->\n      (x y) y) ->\n      (x y) ->\n      (x y) ->\n      (x y) (x y) ->\n      (x y) ->\n      x y) ->\n      forall (x:R y:R, y:R,x y) ->\n      (x:R,x:R,y:R y x y:R) x y y y x y x y ->\n      exists y,\n      (x:R ->\n      (x:R),\n      forall x y:R,\n      forall x y:R,\n      (R y:R,\n      x y x y) ->\n      x y x y x y x y y y x y:R y,\n      x y)\n      (x:R x y) ->\n      is_error_error y:R x y:R x y:R,\n      forall x y:R,\n      x y,\n      forall x y,\n      (R x y:R x y:R,\n      x y y)\n      (R y y)\n      (R y:R y:R x y:R)\n      (R,\n      (R:R)Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z. Proof.\n      intros.\n      unfold weak.\n      assert (H:R) = y).\n      destruct (y,E, E) as [K | [J [K [K K K K].\n      destruct (K K) as [K K].\n      destruct (K K K) as [K K K K K].\n      apply K K K.\n      * apply (K K K K K K K K K K K K K K K) in K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K K KQed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros.\n      apply E; auto with typeclass_instances.\n      apply weak_instances.\n      auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n\n    Proof.\n    intros x y z H.\n      intros.\n      apply P; auto with y z.\n      apply H.\n      apply H0; auto with x y; auto with x; auto.\n      apply H0; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros; elim H; auto with sets.\n      apply weak_step.\n      apply weak_step.\n      apply weak_step.\n      apply weak_step; auto with sets.\n      auto with sets.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n\n    Proof.\n    intros.\n    apply In_step.\n    apply (y).\n    apply weak_step.\n    apply weak_wf.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z. Proof.\n      intros.\n      apply (J x y); auto with u; apply star_trans with (R.\n      apply star_trans with x y); auto.\n      apply star_trans with (P := P); auto.\n      apply star_trans with x y); auto.\n      apply star_trans with x.\n      apply star_trans with x y.\n      apply star_trans with y; auto with (x := x y); auto with (y y); auto with x y z); auto.\n      apply star_trans with x y; auto with x; auto.\n      apply star_trans with x y; auto with x y; auto.\n      apply star_trans with x y; auto.\n      apply star_trans with y; auto.\n      apply star_trans with x y; auto with y; auto with y; auto.\n    apply star_trans with y y; auto.\n    apply star_trans with y; auto.\n    apply star_trans with y; auto with y.\n      apply star_trans with y; auto with x y; auto with y; auto.\n    apply star_trans with y; auto with x y; auto.\n    apply star_trans with y y; auto with xQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n    intros X Y. destruct (x:X, z) as [X [X [X [X |X [X Y X YY Y Y Y X X Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y YQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n      intros.\n      apply (H0 := R z); auto with sets.\n      apply star_trans with sets.\n      apply H'; auto with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      auto with sets.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z. Proof.\n      intros; unfold weak_weak; auto with sets.\n      unfold weak_weak; auto with sets.\n      apply weak_weak; auto with sets.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n\n    Proof.\n    intros x y z H.\n      apply star_trans with (x:=x:=x:=x:=x) in X).\n      apply star_trans with (x:=x:=x:=x:=x:=y:=x:=y) in Y).\n      rewrite H.\n      apply star_trans with x y.\n      apply star_trans with x y.\n      apply star_trans with y; assumption.\n      apply star_trans with x y; assumption.\n      apply star_trans with x y.\n      apply star_trans with x y.\n      apply star_trans with x y.\n      apply star_trans with y.\n      apply star_trans with x y; assumption.\n      apply star_trans with y.\n      apply star_trans with y; assumption.\n      apply star_trans with x y; assumption.\n      apply star_trans with x y y; assumption.\n      apply star_trans with x y.\n      apply star_trans with y.\n      apply star_trans with y y.\n      apply star_trans with y y; assumption.\n      apply star_trans with y y; assumption.\n      apply star_trans with y.\n      apply star_trans with y; apply star_trans with yQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; apply star_trans with (R y).\n      apply star_trans with (R:=R); auto with x y); auto.\n      apply star_trans with (R:=R:=R:=R:=R:=R:=R).\n      apply star_trans with (R:=R:=R:=R:=R:=R:=R).\n      apply star_trans with (R:=R:=R:=R).\n      apply star_trans with (R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R).\n      apply P).\n      apply star_trans with (R:=R:=R:=R:=R:=R:=R) R).\n      apply star_trans with (R:=R:=R:=R:=R:=R:=R).\n      apply star_trans with (R:=R:=R:=R) (R:=R:=R:=R:=R:=R:=R).\n      apply (R:=R:=R:=R:=R:=R:=R:=R:=R:=R:=R) inR).\n      apply star_trans with R; auto withR:=R:=R:=R)) in R.\n     Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; intros; elim X.\n      apply H.\n      apply star_trans with x y; assumption.\n      apply star_trans with (R0).\n      apply star_trans with x y z).\n      apply star_trans with x y.\n      apply star_trans with x y.\n      apply star_trans with y.\n      apply star_trans with y z.\n      apply star_trans with y z.\n      apply star_trans with y z; assumption.\n      apply star_trans with y z; assumption.\n      apply star_trans with y z.\n      apply star_trans with (r := x y z).\n      apply star_trans with y z y z.\n      apply star_trans with z z.\n      apply star_trans with y z z z z z z z.\n      apply star_trans with z z.\n      apply star_trans with z z z z z z z.\n      apply star_trans with z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z. Proof.\n      intros x y; apply star_trans with (P := P x y z); auto with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with (P x y z); auto with sets.\n        apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n        apply star_trans with sets.\n      apply star_trans with sets.\n        apply star_trans with (P := Q y z) x y z) y; auto with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n        apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n    apply star_trans with sets.\n   Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n    unfold weak_weak; auto.\n      intros x.\n    unfold weak_weak.\n      split; auto.\n      intros x; auto.\n      apply H.\n      apply E; auto.\n      apply E; auto.\n      apply E.\n      auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros.\n      apply star_trans with x y; auto with sets.\n      apply star_trans with sets.\n      apply star_trans with (x:=x:=x:=y:=y:=x:=y); auto with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with sets.\n        apply star_trans with sets.\n    apply star_trans with sets.\n      apply star_trans with sets.\n    apply star_trans with sets.\n      apply star_trans with (x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=y:=x:=x).\n      apply star_trans with sets.\n      apply star_trans with sets.\n      apply star_trans with (x:=x:=x:=x:=y:=x:=y:=x:=x:=y:=x:=y).\n      apply star_trans with (x:=x:=x:=x:=x:=x:=y:=x:=x:=y:=y:=x:=x:=x:=xQed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros.\n  unfold map_map in_map.\n  assert (n : A) by (fun a => f (a :: l) (a :: l)).\n  assert (a :: l) (a :: l) : A) (a :: l)) by (a :: l).\n  assert (a :: l) : A),\n  {a :: l = a) by (a :: l) by (apply l) in H; assumption).\n  assert (a :: l).\n  assert (a :: l) by (a :: l) by (rewrite <- H; apply H; assumption).\n  assert (a :: l) by (a :: l).\n  assert (a :: l) by (a :: l) by (a :: l) by (a :: l); try assumption).\n  assert (a :: l) by (rewrite <- (a :: l); try assumption).\n  assert (a :: l) by (a :: l); try assumption).\n  assert (a :: l); try assumption.\n  assert (a :: l); try assumption).\n  assert (a :: l).\n  assert (a :: l).\n  assert (a :: l).\n  assert (a :: l ++ a).\n Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  induction xs; intros; simpl; intros.\n  destruct (map_map_map f a b); auto.\n  rewrite map_map_map_map_map_map_map_map_map_map_map_map_map_map_map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map_map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map_map.\n  apply map_map_map_map_map.\n  apply map_map.\n  apply map_map_map; auto.\n  apply map_map_map_map_map.\n  apply map_map.\n  apply map_map; auto.\n  apply map_map_map_map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map_map_map_map_map_map.\n  apply map_map_map.\n  apply map_map.\n  apply map_map_map_map_map.\n  apply map_map_map.\n  apply map_map.\n  apply map_map.\n Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\ncase_dec (eq_dec a); intros.\nexists (f a b); auto.\nunfold map_dec_dec_dec a b; auto.\nintros a b a b0 H0; auto.\nunfold map_dec_dec; auto.\nunfold map_dec_dec_dec in H.\nrewrite map_dec; auto.\napply map_dec_dec_dec_dec a b; auto.\napply map_dec_dec_dec a); auto.\napply map_dec_dec_dec_dec_dec_dec a b0; auto.\napply map_dec_dec; auto.\napply map_dec; auto.\napply map_dec_dec_dec a); auto.\napply map_dec_dec.\napply map_dec; auto.\napply map_dec_dec_dec; auto.\napply map_dec.\napply map_dec_dec_dec_dec_dec_dec_dec_dec_dec a b); auto.\napply map_dec; auto.\napply map_dec; auto.\napply map_dec_dec_dec_dec_dec; auto.Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\nunfold map in |- *; intros.\nunfold map_app in |- *.\nsimpl in |- *.\nunfold map_app.\nunfold map in |- *.\nunfold map_app in |- *.\nsimpl in |- *.\napply map_app; auto with *.\nrewrite map_app_app.\nauto with *.\nauto.\nauto with *.\nauto with *.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\n\nauto with algebra.\nauto with algebra.\n\nauto with algebra.\nauto with algebra.\nauto with algebra.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n intros.\n split; assumption.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\nunfold map_ext.\nunfold map_ext; intros.\nunfold map_ext; auto.\nsimpl.\napply map_ext; auto.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n intros.\n destruct (x : A) as [x|x,x = y)] H].\n destruct x as [x].\n destruct x; [x|x|y]; [y; auto.\n rewrite H; auto.\n rewrite H.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros.\n  unfold map.\n  rewrite map_map_map_map.\n  apply map_map_map_map.\n  rewrite map_map_map.\n  apply map_map.\n  apply map_map; eauto.\n  eapply map_map.\n  eapply map_map_map_map.\n  eapply map_map.\n  eapply map_map.\n  eapply map_map_map_map_map_map_map_map_map.\n  eapply map_map_map_map.\n  eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map.\n  eapply map_map_map; eauto.\n  eapply map_map_map_map_map_map_map_map.\n  eapply map_map_map_map_map; eauto.\n  eapply map_map.\n  eapply map_map. eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map; eauto.\n  eapply map_map; eauto.\n  eapply map_mapQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros.\n  elim (H : a b) (H : list A -> B) (l : B -> A -> B -> In (map f) (map f a) (map f a) (map f a)) -> f a).\n  intros.\n  unfold map_map in H.\n  destruct (f a b) as [f a b].\n  rewrite <- (map f a) in H.\n  rewrite <- H.\n  rewrite <- (map_map_map_map_map f a (map f a b)) in H.\n  rewrite <- (map f a b); rewrite <- (map f (map f a) in H.\n  rewrite <- (map f a b);\n    rewrite <- (map f a) in H.\n  rewrite <- (map f a) in H0; rewrite <- (map f a).\n  rewrite <- f a (map f a0).\n  rewrite <- H0.\n  rewrite <- (map_map f a0.\n  rewrite <- f b0 in H0.\n  rewrite <- (map f a0).\n  rewrite <- (map f a0 f) a0).\n  rewrite <- f0.\n  rewrite <- H0.\n  rewrite <- (Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n intros.\n assert (f : A -> B -> B -> B -> A -> B -> B -> B x = B.\n intro.\n assert (A <> b) by (apply H0); [apply H; apply H0; auto | apply H0; apply H0; auto | apply H0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros.\nelim H'0.\nelim H'0; intros; elim H'0; clear H'0; auto with arith.\nelim H'0; auto with arith.\nintros H'0; auto with arith.\napply (r1); auto with arith.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros H' H'0 H'0 H'0 H' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H' H'0 H' H' H' H' H' H'0 H'0 H' H' H'0 H' H'0 H'0 H' H' H' H' H'0 H' H'0 H' H' H'' H' H' H'' H' H' H' H' H' H' H' H' H' H' H'' H' H H'' H' H' H' H''' H' H' H' H H H' H H' H' H' H'' H' H' H' H' H' H' H' H'''' H' H H' H H' H'' H' H' H' H' H' H' H' H' H'' H' H'' H' H H' H' H' H' H' H H' H'Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; elim H'0 H'0 H'0; intros H'0; elim H'0; clear H'0; elim H'0 H'0; clear H'0 H'0; clear H'0; intros H'0; intros H'0; elim H'0; clear H'0; intros H'0; elim H'0 H'0; clear H'0; intros H'0 H'0; intros H'0; intros H'0 H' H'0; clear H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0; clear H' H'0; clear H'0 H'0 H'0 H'0 H'0; clear H'0; clear H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H' H'0 H'0 H'0 H'0 H' H'0 H' H'0 H'0 H' H'0 H'0 H'0 H'0 H''0 H' H'0 HQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; elim H'; auto with arith.\nintros H'1 H'0; auto with arith.\nintros H'0; rewrite H'0; auto with arith.\ncut (l1 = map_app_app (app a) = map f1 ++ map f1 ++ map f1 ++ map f2).\nauto with arith.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; split; auto.\nelim (list_app_app_app a); auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; elim H'0 H'0; intros H'0 H'0; elim H'0 H'0; intros H'0; elim H'0; auto.\nauto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\n intros; intros H'0; simpl in H'1; elim H'1; intros H'1; intros H'2; elim H'1 H'1; intros H'1 H'2 H'1; elim H'2; intros H'2; intros H'1; intros H'2 H'2; elim H'2 H'2; intros H'0 H'2 H'2; elim H'2 H'2; clear H'2 H'2; intros H'3; intros H'2; clear H'3 H'2; elim H' H'3; intros H'1; elim H'1; intros H'2 H'2; intros H' H'2 H' H'2 H'2 H'0 H'1 H'2 H'2 H'1 H' H'2 H2 H'2 H'2 H'2 H2 H2 H'2 H'2 H' H' H'2 H'2 H2 H'2 H'2 H'1 H2 H'2 H'2 H2 H'2 H' H2 H'2 H' H2 H1 H2Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; unfold map_app; case_app in |- *; simpl in |- *; auto.\nintros H'0 H'0; elim H'1; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros; elim H' H'0; intros H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros H' H'0 H'0 H'0 H'0 H'0 H'0; elim H'0; auto with arith.\napply H'0 H'1; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; elim H' a; intros.\napply map_app_rev.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; elim H'0; intros; intros H'; elim H'0 H'0; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; case (rev l1; case (rev_rev_rev l1); auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; case (map f l1 l2 H; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nunfold map_rev.\nintros a l; elim H'; intros H'1; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; apply map_rev_rev_rev_rev_rev_rev_rev_rev.\napply map_rev.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; elim H; intros; apply map_rev; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; rewrite map_rev_rev; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; elim H' H'; intros H'0 H'0; elim H'; auto with datatypes.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros; elim H'1; intros.\nintros x; elim H; intros H'0; auto.\nsplit; auto with datatypes.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; auto with arith.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros.\nauto with datatypes.\nauto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros.\ncase_equal; auto with datatypes.\ncase_equal.\nrewrite map_equal with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; elim H; intros; intros; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; elim H'0; auto with datatypes.\nintros H'0 H'0; elim H'0; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; auto with arith.\napply map_app; auto with arith.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros.\nunfold map in |- *; auto.\napply map_map; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; rewrite map_rev_rev; auto with arith.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; apply map_rev; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros; elim H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros; auto with arith.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros; elim (rev_rev a) (rev a a) a) a l); auto with arith.\nintros a; auto with arith.\nintros H'2; elim H'0; auto with arith.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros; apply eq_comm.\napply eq_dec_dec_dec_dec_dec_dec.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros; auto with arith.\napply map_rev_rev_rev_rev_rev_rev; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\n intros; elim (rev a); auto with datatypes.\nintros H'; auto with datatypes.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros; elim (rev a) (rev a l); auto with arith.\napply H'0; auto with arith.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros.\napply in |- *; auto.\napply (rev_rev_rev_rev_rev_rev_rev a l; auto with a l); auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros; elim H'0; auto with datatypes.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros.\nunfold map in |- *; simpl in |- *.\nintros.\napply H'.\napply map_rev_rev_rev_rev_rev_rev_rev_rev.\napply map_rev_rev_rev_rev_rev; auto.\napply map_rev_rev.\napply map_rev.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros.\nunfold app in |- *; auto.\ncase_rev in |- *; apply app_rev_rev_rev_rev_rev_rev_rev.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\nDefinition neg_fun a : nat -> Prop := forall a, x = x = x.\n\nDefinition neg_fun a.\nDefinition neg_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_Defined.",
                    "Definition zeroP : Term -> Prop.\nDefinition mon := mon := mkP.\nDefinition mon_unit := mk_unit_unit.\nDefinition mon_unit (fun _ (fun n => mon_unit_unit.\nDefinition mon_unit (f : mon_unit.\n\n\nDefinition mon_unit : mon_unit := mon_unit_unit.\n\nDefinition mon_unit.\nDefinition mon_unit (p : mon_unit := mk_unit_unit R.\n\n\nDefinition mon_unit := mk_unit := mk_unit_unit_unit.\nDefinition mon_unit.\nDefinition mon_unit_unit := mk_unit_unit.\nDefinition mon_unit := mk_unit := mk_unit_unit_unit.\nDefinition mk_unit.\nDefinition mon_unit_unit_unit.\nDefinition mon_unit_unit := mk_unit := mk_unit.\nDefinition mk_unit.\nDefinition mk_unit := mk_unit.\nDefinition mon_unit.\nDefinition mon_unit.\nDefinition mon_unit_unit_unit.\nDefinition mk_unit.\nDefinition mon_unit := mk_unit_unit := mk_unit.\nDefinition mk_unit_unit_unit.\nDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition zero_mon := mk_mon := (fun (fun p => mon => mon_mon_mon (fun p => mon_mon p.\n\n\nDefinition mon_mon {A : R).\nDefinition mon_mon := mon_mon : mon_mon := mkmon_mon := mon_mon := mkmon.\n\nDefinition mon_mon := mkmon := mkmon.\n\nDefinition mon_mon_mon := mkmon_mon.\nDefinition mon_mon (mon_mon_mon := mkmon.\nDefinition mon_mon_mon_mon.\nDefinition mon_mon_mon_mon_mon (mon_mon_mon_mon_mon.\n\nDefinition mon_mon_mon_mon_mon := mkmon.\nDefinition mon_mon.\n\nDefinition mon_mon.\n\nDefinition mon_mon.\nDefinition mon_mon_mon := mkmon.\n\nDefinition mon_mon_mon_mon_mon_mon.\nDefinition linear_mon_mon := mkmon.\nDefinition poly_mon.\nDefinition poly_mon.\n\nDefinition poly_mon_mon := mkmon.\nDefinition poly_mon.\nDefinition poly_mon.\nDefinition polyDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition map_scope.\n\n\nDefinition map_of : list (A : Type) :=\n  (r : A).\nDefinition map :=\n  map_of_of_of (fun A => map_of A)).\n\nDefinition map (f : Type) (f : A) := map (fun x => map f f x).\n\nDefinition map_of_of_of_of_of_of_of (f : map := map_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Defined.",
                    "Definition zeroP : Term -> Prop.\n\n\nDefinition monoid_fun p : Set.\nDefinition monoid_fun_scope.\n\nDefinition monoid_is_fun _ => monoid_fun_fun n => fun_fun_fun n => f_fun n => f_fun n m.\n\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun_fun_fun n_fun_fun_fun_fun n n)) => f_fun n n n).\n\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun n n n n_fun_fun_fun n n_fun_fun_fun_fun.\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun_fun_fun n n n m n n n n) (fun n)) (fun n)).\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun_fun n)).\nDefinition monoid_fun_fun.\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun n_fun_fun_fun_fun_fun_fun_fun.\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun_fun_funDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition ring_of_of := (fun n => mon_of_of_of_of_of (fun n => mon (fun n => mon_of_of_of_of n) (fun n)\n  (fun n => mon_of_of n))\n  fun n => mon_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_ofDefined.",
                    "Definition zeroP : Term -> Prop.\n\n\nDefinition zero_scope.\nDefinition zero_scope.\n\nDefinition zero : Type.\nDefinition zero (n : Set) := {A : Type := mk_map (fun x => zero_scope.\n\nDefinition zero_scope.\nDefinition zero_scope.\nDefinition zero_scope.\nDefinition add := (p : nat) := 1.\nDefinition zero := add_scope.\nDefinition zero_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition add_scope.\nDefinition addDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition is_scope.\nDefinition is_scope.\n\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\n\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefinition is_scope.\nDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition pl : Set := mk_eq (f : Comp A) := mk_eq_eq A.\n\nDefinition mon_eq_eq := mk_dec_dec.\nDefinition mon := mk_eq_dec (fun_dec nat => mon_dec_dec a) := mk_dec a a b.\n\nDefinition mk_dec := mk_dec_dec a b.\nDefinition mk_dec (fun a b => mon_dec_dec b).\nDefinition mk_dec : comp_dec := mk_dec a b.\n\nDefinition mk_dec (fun a b => mk_dec b) := mk_dec (fun a b => mk_dec a b) a b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b bDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition mon := mkR := mk_nat_nat_nat_nat.\nDefinition mon_nat_nat.\nDefinition mon_nat : mon_nat := mk_nat_nat_nat.\nDefinition mon_nat_nat := mk_nat_nat (n_nat_nat_nat_nat_nat (nat n)).\nDefinition mon_nat_nat (n : nat) := mk_nat (nat (n * nat) := mk_nat_nat_nat n)) := mk_nat_nat_nat_nat_nat_nat_nat (nat_nat_nat_nat (nat n)) (nat_nat n)) (nat (nat_nat (nat n)))\n  (nat_nat (nat_nat n) (nat n))\n  (nat n)).\n\nDefinition mk_nat_nat := mk_nat_nat_nat_nat_nat_nat_nat_nat_nat (nat_nat_nat n (nat n) := mk_nat n) (nat n) (nat n n))\n  (nat n)\n  (nat n) (nat n).\n\n\nDefinition mon_nat_nat_nat_nat := mk_nat_natDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition monoid_fun (fun x : R => (fun x => M).\nDefinition monoid := @fun x).\n\nDefinition monoid_fun (fun_fun x => monoid_fun x => F x).\nDefinition monoid_fun x => monoid_fun_fun x y) => monoid_fun_fun x y (fun x y)) x) (fun x))\n  fun x => monoid_fun_fun x y) (fun x) x) (fun x)) (fun x)) x)) (fun x:fun x => op_fun x : monoid_fun x) => E => x => x)) (fun x)) (fun x).\n\nDefinition monoid_fun_fun_fun_fun_fun_fun_fun x => op x => monoid_fun_fun x (fun x y (fun x x y)) (fun x => x) (fun x)) (fun x)) (fun x => op_fun x)) (fun x)) (fun x: x)) => op (fun x:R_fun x:R => x)) x) => monoid_fun x:R x : monoid_fun x y:R =>\n  fun x y => fun x:R =>Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nDefinition equiv_fun _ : Type) := fun x => x => f.\nDefinition equiv_fun x => f x.\n\n\nDefinition equiv_fun x => f x).\nDefinition equiv_fun_fun x => fun x => f x) := fun x x.\nDefinition equiv_fun_fun_fun x => f x => f x x) => f x f x (f x) (f x y) (f x))\n  fun x) (f x) x)\n  fun x => f x) (f x)\n  (f x) (f x) (f x).\nDefinition equiv_fun x => f x) (fun x => f f f (f x) (f x) (f x)) (f x)).\nDefinition equiv_fun_fun_fun x => f x) (f x)) := fun x).\n\nDefinition equiv_fun_fun_fun_fun x => f => f x x => f x f f x) (f x f x)) (f x)) (f x x)).\nDefinition equiv_fun x (f : f f x) : f x) := f x f x f x) (f x)).\n\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nDefinition zero_fun (f : Prop) : t -> Prop := fun (fun x => eq_refl_refl (fun x => x).\n\nDefinition eq_refl : forall x : A, eq_refl : forall x = true -> eq_refl (fun x) -> eq_refl_refl_refl_refl_refl : forall x, eq_refl x).\nDefinition eq_refl_refl_refl_refl : forall x : A, eq_refl : forall x = eq_refl x.\n\n\n\nDefinition eq_refl : Type) (x y : A -> eq_refl : A -> eq_refl : A -> eq_refl : A -> eq_refl : forall x = eq_refl : A, eq_refl x = eq_refl.\nProof.\n  intros.\n  case_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nDefinition eq_refl : Type.\nDefinition eq_refl {A : Type} := fun (P : Type) : Type) :=\n  fun x => fun x => fun x => fun x) (x : P x) (x, x) x) x) x y) (x y))\n  fun x) (x : x) (x, x))\n  fun x : P x) => x) (x : fun x : x) : x y) x (x : P x : P x) -> P x.\n\nDefinition eq_refl {x : A} : A} (x : B) : A -> B) := fun x : A -> A := fun x => P x => P x (y : x) x.\n\nDefinition eq_refl : A -> A -> A := fun x : A -> eq_refl : A) (x : A -> A -> A -> A -> A -> A -> P x.\nDefinition eq_refl_refl (x : A) := fun x => eq_refl A.\nDefinition eq_refl : Type) (x : A -> A -> A) (x : A -> A) (x : A) (x :Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition op := fun x : nat => x => fun x => fun x => y\n  fun x y y => fun y => x y z => x y z z z' z' z' y' z z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z z' z' z' z' z' z' z z z' z' z' z z z' z' z' z' z' z' z' z' z' z' z z' z z' z' z' z' z' z' z z z' z z z' z' z z' z z' z z' z' z z z z' z z' z z' z z' z' z z z z z' z' z' z' z' z z z z z z z z z z z' z' z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nDefinition eq_refl : Prop := fun x : forall x : R, R x = x = y.\n\nDefinition eq_refl_refl : Prop := forall x y : Prop, x = y.\n\nDefinition eq_refl_refl : Prop := eq_refl : R.\nDefinition eq_refl {A} (x y : A -> Prop) (x : Prop := eq_refl : R) : Prop := eq_refl.\nDefinition eq_refl := eq_refl := eq_refl.\nDefinition eq_refl_refl_refl := eq_refl.\n\nDefinition eq_refl : forall x : forall x : Type) (x y : A), eq_refl_refl_refl x y.\n\n\nDefinition eq_refl : forall x : A, eq_refl : forall x : A, eq_refl : A, eq_refl eq_refl : A x y.\nDefinition eq_refl_refl : A, eq_refl_refl := eq_refl : forall (refl : A) (refl A) (refl : A) (refl : A) := eq_refl_refl : A x) (refl : A) (refl.\n\nDefinition eq_Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\n\nDefinition f := fun (fun x => t => s.\nDefinition f1.\nDefinition f1 := fun x1 : f2.\nDefinition f2.\nDefinition op1 : R2 : bool.\nDefinition eq_refl_refl := fun x1 f2 => f2.\n\nDefinition f2 : bool_refl_refl := fun x => f2 (fun x2 f1) => f2 x2) (fun_equal f2) (f2)) x2 x2) (f1)).\nDefinition op1 f2.\nDefinition op_refl := fun_refl := fun_refl.\n\nDefinition op1.\nDefinition eq_refl := fun_refl f2 := fun_refl := fun_refl f2 => fun_refl (fun f2)) (fun_refl_refl _ _ _ f2 f1 f2)).\n\n\n\nDefinition f2 := fun_equal.\nDefinition eq_refl.\nDefinition eq_refl : forall f1 : nat => f2.\nDefinition eq_refl : forall f2 : nat, f2 = f2.\nDefinition eq_refl f2 := fun f2 => f1 f1 f2Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition eq_refl := fun x => f := fun x => x.\n\nDefinition eq_refl := fun x => eq_refl => f x y; auto.\nDefinition eq_refl := fun_refl := fun_refl := fun _ => fun_refl.\nDefinition eq_refl := fun_refl_refl_refl.\nDefinition eq_refl.\nDefinition eq_refl_refl := fun_refl := fun_refl.\n\nDefinition eq_refl := fun_refl_refl.\n\n\nDefinition eq_refl := fun_refl.\n\nDefinition eq_refl_refl_refl.\nDefinition eq_refl_refl := fun_refl := fun_refl.\n\nDefinition eq_refl.\nDefinition eq_refl_refl_refl := fun_refl := fun_refl.\nDefinition eq_refl := fun_refl.\nDefinition eq_refl_refl_refl.\nDefinition eq_refl := fun_refl_refl.\n\nDefinition eq_refl.\nDefinition eq_refl_refl.\nDefinition eq_refl.\nDefinition eq_refl := fun_refl.\nDefinition eq_refl_refl.\nDefinition eq_refl.\nDefinition eq_refl.\nDefinitionDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition t.\nDefinition eq_refl := fun_refl := fun x => fun x => f x.\n\nDefinition eq_refl := fun x => fun x => x y.\n\n\nDefinition eq_refl_refl := fun_refl_refl_refl := fun_refl.\n\nDefinition eq_refl := fun_refl := fun_refl => eq_refl_refl.\n\n\nDefinition eq_refl := fun_refl.\nDefinition eq_refl : fun_refl_refl_refl.\nDefinition eq_refl := fun_refl.\n\n\nDefinition eq_refl : @refl.\nDefinition eq_refl.\n\nDefinition eq_refl : Type.\nDefinition eq_refl : Type.\nDefinition eq_refl : Type.\nDefinition eq_refl.\nDefinition eq_refl.\nDefinition eq_refl := fun_refl.\nDefinition eq_refl : @refl.\nDefinition eq_refl.\nDefinition eq_refl.\nDefinition eq_refl.\nDefinition eq_refl : eq_refl.\nDefinition eq_refl.\n\n\nDefinition eq_refl : eq_refl := eq_refl.\nDefinition eq_refl.\nDefinition eq_refl.\nDefinitionDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nDefinition eq_refl := fun (R : bool) := fun x => x => x.\n\nDefinition eq_refl : forall x : A -> A, eq x = x.\nDefinition eq_refl := fun x : A.\n\nDefinition eq_refl (x : A -> A -> eq_refl (A B) := fun x => eq_refl x).\nDefinition eq_refl := fun x => eq_refl (x y).\nDefinition eq_refl : Type := fun x y.\n\nDefinition eq_refl : A B.\nDefinition eq_refl : A := fun_refl := fun x => eq_refl_refl eq_refl.\nDefinition eq_refl : A := fun_refl : eq_refl A => eq_refl A.\nDefinition eq_refl := fun_refl A.\nDefinition eq_refl := fun_refl_refl.\nDefinition eq_refl : eq_refl A_refl : eq_refl.\nDefinition eq_refl {A B : A B -> eq_refl A B -> B.\nDefinition eq_refl A B -> A B := fun_refl A B.\nDefinition eq_refl : A B.\n\nDefinition eq_refl ADefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\napply eq_refl.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros a.\nintros a b' H' a' a' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H'' H'' H'' H' H' H'' H'' H'' H' H' H' H' H' H' H' H' H' H'''''''' H' H'' H'' H' H' H' H''''' H' H' H' H' H'''''' H''' H' H' H' H'''' H' H' H' H' H'''' H' H'''''' H''' H''' H'' H' H'' H''''''' H'''' H'''''' H' H''' H' H''' H'' H'' H' H'''''''' H'''' H' H'' H'Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros a b.\napply eq_refl.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\n  intros a b; exact (fun a => a' a' a' a' a' a' a' -> y' a' ->\nexact (fun a' b' a' a' a' a' a' a''' -> a' ->  -> a''''''' ->' ->\n  (fun a' a' a'' a' a' a'' a'''''''''''''' ->\nHypothesis f' a'' a' ->\nred in_refl : forall (a b' a' : nat),\n  (forall a' a' a' a' a' a' ->\nred in_sig (a' a' a' a'' a''' a'' ->\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\napply (A := H'); auto with *.\nsimpl in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\napply eq_sym in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred inQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros.\ndestruct (M.\napply eq_refl.\nsimpl in H1_refl_refl.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros a b H' a b' a b' H'; apply (fun a => a b' b' b' b') in H' b' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H'' H' H' H' H'' H' H'' H' H' H'' H'''' H'' H' H'' H' H'' H'''' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H' H' H'' H' H'' H' H' H'' H' H'' H'' H'' H'' H' H'' H'' H' H' H' H' H' H'' H' H' H' H' H'' H''''' H'' H' H' H H' H' H''' H' H'''Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros a H' H' H' a H' H'0; exact (eqA & H').\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\napply eq_refl.\nelim (fun a => a b' a b' b' a' b' b' b' b' b' a'' a' -> b'''' -> (x' b' b'' b''' b'' ->\n  (y' a' a' b' a'' a''' -> (y' a' -> b' -> a' -> b' -> a' ->\nintros a' a' a'' a' H' a' ->\nintros A' H' H' H' H' H' H' H' H' H''' H' H' H' H' H'' H' H' H'' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H''' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H H' H' H' H' H' H' HQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros a b; exact (fun a => a b').\napply eq_refl_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nintros x y' a x y'; rewrite eq_refl.\napply (H0) in |- *.\napply eq_sym in |- *.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nunfold eq in |- *; simpl in |- *; intros.\ncase_sym in |- *; intros a b' H' H' H' a' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H'' H' H' H''' H' H' H'''' H''' H' H' H''' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H'' H' H'' H' H' H'' H''' H'''''' H' H'''' H' H' H'' H' H'' H' H' H' H''' H' H' H''' H''' H' H'''' H' H' H'''''' H' H''' H''' H' H'''' H' H''' H'' H' H'Qed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nred in |- *.\nintros x y z H'; rewrite H'1; auto with real.\nintros x; try exact (y'0 x); auto.\napply H'0; auto with real.\napply H'0; auto with real.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\n  intros a a x; elim (eqA x); intro; intros a a b; auto with (eqA := fun a b' b' b' a' a' b' b' -> a' b' -> b' b' -> b' a' b' -> a' b' ->\nintros.\nrewrite (eqA' b').\ngeneralize (eqA_x := (eqA a') a'); auto.\nintros a' b' b' b' H' H'; auto.\ngeneralize (eqA a'); auto.\nrewrite <- (eqA:=eqA:=eqA:=eqA:=eqA); auto with typeclass_instances.\nintros b' b' a' b' b' b' b' H' b' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H H'Qed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\napply eq_refl.\nintros a b; case (H1 := fun a => H' a' a' a' a' H' a' b' H' a' H' H' H' H'' H' H' H' H' H'' H'' H' H'' H' H' H'' H' H'' H' H' H' H'' H' H' H''' H' H'' H' H' H' H' H' H' H' H' H' H'' H' H'' H' H' H'' H' H' H'' H' H' H' H' H' H' H' H' H'' H' H'' H'''' H' H'' H' H' H' H' H'' H'' H' H' H' H'''' H''' H' H' H' H''' H' H' H'''' H' H' H''' H' H' H'' H' H' H' H'' H' H' H''' HQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintro H' a; case H'0.\nelim H' a; auto with a; case (x:=x:=x:=x:=x:=x:=x:=x:=y:=y:=y).\napply H' in |- *.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nintros a a b.\nsplit; case b.\nintros b; case b; auto with (x := x); auto with (x := x); auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nintros x y H; case H; case x; intros H' H' H' H' H' H' H'' H' H' H' H'' H' H' H' H' H' H' H''' H' H'' H'' H' H''''' H'' H' H''' H' H' H' H' H''''' H'' H' H'' H''' H' H' H'''''' H''' H' H'' H''' H' H' H'''''''''' H' H' H'' H'''' H''' H' H' H' H' H''' H'' H'' H' H''''''' H''''' H'' H''''''' H' H'' H'''' H''''' H''' H''' H' H'' H'' H''' H'''' H'''' H' HQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nintros x y H' a' H'; auto with sets.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nintros x H' H' a x H' a' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H'' H' H' H' H' H'''' H'' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H''' H' H' H' H' H' H' H' H'' H' H' H' H' H''''' H'' H' H' H' H'' H' H' H'' H'' H' H'' H' H' H'' H' H' H' H' H' H' H'' H'' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H''' H' H' H' H'''' H' H''' H' H'' H'' H'' H' H'''' H' H'' HQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nintros x y H; elim (eqA _ H); intros.\napply eq_sym.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nintros x y; apply H'0; auto.\napply eq_sym; auto with (x := eq_refl).\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nintros x y H' H' H'0.\nintros x H'0 H'0 H'0 H'0 H'0 H'0'0.\nelim H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H'0'0 H'0 H'0 H'0 H'0 H' H' H'0 H' H' H' H'0 H'0 H'0 H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H H' H' H' H' H'' H' H'Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nunfold eq_sym in |- *.\nred in |- *.\nred in |- *; simpl in |- *.\nred in |- *; auto with *.\nintros x y H' H' y' H'1 H'2.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nred in |- *.\nintro x; auto with *.\nred in |- *.\nred in |- *.\nintros x y.\nintros x y H'0 H' H'0 H'0 H'0 H'0 H'0; elim H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0; auto.\napply H'0; auto with algebra.\napply H'0.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nintros x y H' x y H'0; apply eq_sym.\nintros H' H'0; apply eq_refl.\napply eq_sym in_refl.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nintros x y z; apply eq_refl.\napply eq_sym in |- *.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case (H x y); auto with *.\nsimpl in |- *.\napply eq_sym_sym.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nintros x y y.\ncase_sym in |- *; simpl in |- *; case H'.\napply eq_sym; auto with x0; auto.\napply eq_sym with (x := x); auto with x; auto with x y); auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\n  unfold eq_refl.\n  apply eq_refl.\nunfold eq_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\nDefinition eq_sym_sym :=\n  forall x y, eq x y -> eq y -> eq x y -> eq y.\nProof.\napply eq_sym; intros x y H; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nLemma eq_refl : R.\nintros x y; case y y; case x; auto.\nintros x y; apply eq_sym; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n\n\n\nDefinition eq_refl {A} (P : Type} (l : Type) : Prop :=\n  (fun x => forall x : A, R x y) (fun x y => x y) (fun x y => x y) (fun x y : R => x y) x y) (fun x) (fun y:A : R => R => R x y) (fun y:A => R => R x y)) x y) y) (x y))\n  (fun y:A:A:A:A) (A => R) (x:A), R x:A:A) x => R x y:A, R x)\n  (A:A), R x y) (fun x y:A:A:A) (f x:A:A, x) y:A, f x y:A -> R x y:A), R (A, f x y:A, f x y:A) (f x y) (fun x:A:A) (A), R x y:A:A:A, x y:A) x:A, f x:A -> R) (fun x:Defined.",
                    "Definition T2M : Term -> mon n.\n\nLemma eq_refl : forall x, eq x y = y -> eq y.\nProof.\n  intros x y H.\n  elim H; auto.\n  case (x y).\n  case (x0); intros.\n  case (x0); auto with sets.\n  case (x y0); auto with sets.\n  case y); intros x0; case (y0); auto with sets.\n  rewrite H'; auto with sets.\n  Defined.",
                    "Definition T2M : Term -> mon n.\n\n\nDefinition eq_refl : Type := fun x => fun y => eq_refl x => eq_refl.\n\n\n\nDefinition eq_refl : forall x, eq_refl x y.\nunfold eq_refl.\n\nDefinition eq_refl := eq_refl : eq_refl.\nunfold eq_refl.\nintros x y y; case x.\napply eq_refl.\napply eq_refl.\nDefined.",
                    "Definition T2M : Term -> mon n.\n\nTheorem eq_refl : forall (x : Type) (f : T),\n  (f : T) (f : T), eq_trans x) -> eq x -> eq x.\nProof.\n  case x y; case (y y); intros; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n\nDefinition eq_refl {A} : Type} (f : A -> Type) (s : A -> Type) :=\n    eq_refl_refl.\n\n\n\nLemma eq_refl : forall (A : A -> A -> A -> Type) (A -> A -> A -> A -> A -> A.\nProof.\n  intros x y; intros; auto.\n  intros x y; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n\n\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nintros x y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zDefined.",
                    "Definition T2M : Term -> mon n.\nDefinition eq_refl := eq_refl := fun x : R.\n\n\nDefinition eq_refl : forall x, eq_refl eq_refl_refl eq_refl.\n\nDefined.",
                    "Definition T2M : Term -> mon n.\n\nDefinition eq_sym (f : Set) (e : Type) (x : rel_sym_sym_sym_sym_sym_sym_sym_sym_sym_sym x).\n\n\nDefinition eq_sym (f : Type) (f : rel_sym (f : rel_sym f x) :=\n  (x : rel_sym f x) (x : rel_sym_sym f x) (f x) (x y)) (x y) (x y) (x y y) (x y)) (x y)) (x y) (y : rel_sym f x y) (x y) (x y)) (x y) (x y)) (x y) (x y)) (y : rel_sym y) y) y (x y (x y) (x y)) (x y) (x y) y) (x y y)) (x y)) (x y) (x y))\n  (x y) (x y) y) (x y (x y y)) (y y (y y) y (y y)) y x y) (y y) (x y) (y y) (xDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nunfold proper_refl : forall x y, eq_refl A y -> x y.\nProof.\n  intros; elim (eqA_refl _ _ _ _ _ _ _ H1) x) (eqA _ _ _ _ H2 H2); auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\nintros x y; elim x y; intros.\nintros x y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nunfold R.\napply (fun a b => x => x => x b).\nintros x b; intros; rewrite (eqA_sym x); auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\n  intros x y H.\n  elim (H1 H1 y H2 x); auto.\n  case_sym x0 H1; auto.\n  elim H2.\n  exact (A_sym_sym x) (x y0)) (y0)); auto with sets.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\nintros x y H.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\nintros x y z z y z.\napply (x0) (y0 (x0_eq_refl_refl x0)); intros x0 H0.\napply (y0)); auto with sets.\napply (x0 x0); auto with sets.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\nintros x y; case y z; simpl; simpl in |- *.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\n  intro x; case x; auto.\n  auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nProof.\napply eq_refl.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\napply: forall (s : T) (M1 : T) (M1 : T2 : T1 s2 : T2 : T2 -> T2) (M2 : T1) (M2 : T2 : T2 : T2 -> T1 T2 : T2) (M2 : T1 -> T2 : T2) (M2 : T2 : T2 : T2 : T2 T2 : T2 : T2 -> T2 : T1 T2) (M2 : T2 : T2 : T2) : T2) (s2 : T2 : T2 : T2 : T1 : T2 : T2) :=\n  (s2 : T1 : T1 : T2 : T2 : T2 : T2 : T2.\n :=\n  (s1 : T2 : T2 : T1 : T1 : T2 : T2 -> T1 : T2 : T1) (s2 : T2 : T1) (s1 : T2 : T2 : T2 : T2 : T2 : T1 : T2 : T2) (s1 : T2 : T1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\napply eq_sym.\napply eq_sym.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\n  intros x y z y z.\n  apply (F x y z) (y : T).\n  apply y z)).\n  rewrite <- (y x y z).\n  rewrite y z); auto.\n  auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\n  intros a; auto with algebra.\n  case a; auto with algebra.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\nintros x y.\napply (sym _ x y); auto with algebra.\napply gt_sym.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\nunfold x y.\nunfold Transitive.\nunfold Reflexive in |- *.\napply eq_sym.\nintros x y.\napply eq_sym; auto.\napply eq_sym.\napply eq_sym.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\nintros x y z; rewrite <- x y; auto.\napply equiv_refl.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\n  intros; auto with real.\n  apply (x := Build_sym := fun a => x y => pf x z) in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\nunfold Transitive.\nunfold Reflexive.\nunfold Symmetric in |- *.\napply equiv_sym in |- *.\nauto with real.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\n  intros x y; apply eq_refl.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nProof.\n  intros.\n  apply eq_sym.\n  unfold eq_sym; auto.\n  apply eq_sym.\n  rewrite eq_sym.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; auto.\nunfold Symmetric.\nsimpl in |- *; auto with real.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; simpl in |- *; intros.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nunfold Morphism.\nunfold rel.\nintros x y y.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nintros x y y H.\nrewrite <- (Radd_sym x y) in |- *; auto with typeclass_instances.\napply (eqA := x y)); auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nintros x y.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\napply T.\nintros x y y y z x y z H.\napply (Eq x y z).\nunfold equivalence in |- *; auto.\napply eq_sym.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nintros x y y; elim (not x y); auto.\nred in |- *.\napply (Equivalence_refl x y); auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nintros.\nred in |- *; auto.\napply eq_sym.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nProof.\nintros x y z x y z z z z H0 z H0 z z H0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z00 z0 z00 z0 z00 z00 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z0 z z0 z z0 z0 z z z0 z z z z0 z z z z0 z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nintros x y.\nsimpl.\napply_sym : forall x y : T, y = y -> x = x.\nunfold InT.\nintros x y; case y; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros x.\nred in |- *.\napply eq_sym in |- *.\napply eq_sym.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros.\napply eq_refl.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros.\napply eq_refl.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nred in |- *.\nunfold gt in |- *.\nred in |- *.\nred in |- *.\nintros x y; case x y; auto with *.\napply eq_sym in |- *.\nintros x; auto with *.\nred in |- *.\napply eq_sym in |- *.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nunfold eq_sym in |- *.\nrewrite eq_refl.\napply eq_sym.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros x b; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros x y H'0; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros.\napply x y; auto with arith.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros x H'; case H'0; case_sym in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nintros x y; case (x1 x0)); intros x0 y0; elim y0;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\n  intros; elim H'; auto.\n  elim H'; auto with real.\n  intros; auto with real.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nelim_refl_refl : forall x y : forall x, x y -> x y, eq x y -> eq x y -> eq y -> eq x y.\nintros x y H; simpl in |- *; elim H'; intros x H' H'; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H'' H' H' H'' H' H' H'' H' H' H' H' H' H' H''' H'''' H' H'' H'' H''''''' H'' H'''''' H' H''' H'' H' H' H'''''' H''' H'' H' H''' H''' H' H' H' H''' H''''' H'' H''' H''' H' H' H''''''''''' H''''' H' H''' H'' H' H'' H'''' H''''' H' H' H'''' H'' H'''''''' H'' H''''' H'''''Qed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y H' H' H' H' H' H' H'0 H' H'0' H' H' H' H'' H' H'' H'' H' H' H' H' H' H' H'' H'' H''' H'''' H'''''' H''' H''' H'' H'' H''' H'''' H''' H'' H'' H' H''' H'' H'''' H' H'''' H'''' H' H'' H''''''''''''''''''' H'' H'' H'''' H'''''' H' H'''''' H''''''''''' H'' H'''''' H''''''' H'' H'' H'''' H' H'' H''''''''''''' H' H'''Qed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nunfold eq_refl.\nintros x y H; case H'; case (H x); case H'0; case H'0; case H'0; auto.\ncase H'0 H'0 H'0; intros H'0 H'0; auto.\nsplit.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\n  intros.\n  destruct y; simpl in |- *; auto.\n  case_dec x; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\n  case y H; case (H_sym_sym _ _ H'); auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'''' H' H'' H' H'''' H'''' H'' H' H''' H'' H' H''' H' H' H'''' H'' H'''''''''' H' H' H''''' H''' H''' H' H' H'''' H'' H'''' H''''''''''' H''''' H'''' H' H''''''''''''' H' H'''''' H'' H'''''''''' H'''''''''''' H''''' H' H''' H''''''''''' H'''' H''' H''''''' H''Qed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nunfold eq, eq_sym in |- *; auto with algebra.\napply eq_refl with algebra.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; elim (Abs b).\nrewrite eq_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b2; intros; apply eq_refl; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nelim: try (split_sym x b) (apply eq_sym x b); auto with algebra.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros x y; case H' H'; intros H' H' H'; auto.\ncase_eq (H'0); auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros x0; intros; apply H0 H'0; auto with arith.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\ncase:A a b = true -> x b.\nmove=>H H' H' H' H'2; rewrite H'2; auto.\nmove=> H'2 H'1; auto.\ncase: (A2); auto.\n- exact H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\n  case: forall a b, x b -> eq x a b x b -> eq_refl_refl.\n  intros; auto with *.\napply eq_refl; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\n  intros x; auto.\n  split; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\ncase: (lt_dec b) (fun a b => eq_refl _) H1); auto.\ncase: (eq_dec a b) => b c1); intros; exists a; auto.\napply eq_refl.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\ncase: forall a b, P a b -> P a b c b -> P b.\ncase:P a b c b c b c b c c c b c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c cQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b c; case a b; intros; elim H' H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros.\n  elim (eqA_eq_dec a b); auto.\n  generalize (eqA _ H' a); intros H'1; auto.\n  intros; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros.\n  elim (A B) (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros x; rewrite (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros; unfold lt_zero in |- *; intros; elim (eqA_inv _ _ H' H'0); auto with *.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros.\n  elim (not_zero_zero P a); intros; auto.\n  elim (eqA _ _ _ _ _ H' H'1); auto.\n  elim (eqA _ _ _ _ H' H); auto.\n  elim (eqA _ _ _ _ _ _ H); intros H'2 H'2; auto.\n  elim (eqA _ H' H'0 H' H'1 H' H'2); auto.\n  elim H'2 H'2; auto.\n  elim H'2; auto.\n  elim H'2; auto.\n  intros H'1; auto.\n  elim H'2; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros; elim (eq x) (eqA _ _ H' H); auto with *.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros.\n  case (eq_dec x).\n  case (eqA_eq_dec (eq x); auto.\n  case_dec x); auto.\n  case (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  intros; elim (eq_dec_dec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\n  case x y; case x; auto with arith.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x y H' H'0 H'.\nunfold eq in |- *.\ngeneralize H'; auto with *.\nintros a b; case (eqA:=eqA:=eqA:=eqA:=eqA:=eqA:=eqA); intros; auto.\ngeneralize (eqA:=eqA:=eqA:=eqA).\nintros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nunfold eq_dec; auto with real.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros.\ngeneralize (H a b); auto with algebra.\napply zero_neg; auto with algebra.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; simpl in |- *.\napply zero_l.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros x y; case (P b); auto.\napply lt_refl_dec_dec_dec_dec_dec_dec_dec_dec (x a) (y_dec a b) (y y) b)); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros.\nintros a b.\ncase (A_eq_dec b); auto.\nintros a b).\ncase b; auto.\napply eq_dec_dec_dec_dec.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros.\ncase (x a b x b); auto with *.\nintros x b; elim H'; auto with *.\napply eq_refl.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros x H'; case_eq_dec; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros.\napply zero_refl.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\ncase_sym; simpl in |- *; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros x; destruct x; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros; case (eq_refl_eq_sym_refl_refl_refl _)).\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\n  intros.\n  elim (eq_eq_dec a); intros.\n  elim (x y); auto.\n  elim (x0); intros.\n  elim (x0) (x0); auto.\n  elim (x0 x0) (x0) (x0)); auto.\n  apply lt_eq_refl_dec x0); auto.\n  auto.\n \nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b; elim (A a b); intros; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\n  intros.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym; auto.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym; auto.\n  apply eq_refl.\n  apply eq_sym; auto.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym in_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_sym.\n  apply eq_sym; auto.\n  apply eq_refl.\n  apply eq_sym; auto.\n  apply eq_refl.\n  apply eq_sym in H.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_sym in HQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b; case_sym; auto with sets.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\n  intros; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\n  intros.\n  case (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros b; case b; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros.\ncase_eq_dec_dec b; auto with zarith.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros.\nintros a b; auto.\ndestruct a b; auto.\nrewrite (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\n\n\nDefinition var_inv_is_inv_inv (s : Set) : Set) (r : Set) (s : Comp T) :=\n  match s with\n  | cons _ => cons _ => cons _ _ => nil\n  end.\n\n\nDefinition cons_inv : forall (s : Set) (s : t -> var) (s : var) (s : var),\n  match s with\n  | nil => cons x' a' => cons x' => cons x' (App x' x' x' y' x' x' x' y' x' y' x'''' x'''' x''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nLemma le_fun : forall a, In a = true -> In a.\nProof.\nintros.\ndestruct (H0 b); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nLemma plus_one_one : forall a, In a = true -> In a -> In a.\nProof.\nintros a b a b H' H' H'0 H' H'0 H' H'0.\nunfold not in H'.\nrewrite <- H' in H'.\napply le_trans with (a := H'1 := H'2); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\n\nDefinition plus_fun : forall (s : T) (s : T), Prop),\n  plus_1 = r = 1.\n\n\n\nDefinition plus_cons_cons : forall (r : T),\n  plus_cons x = plus_l : forall (r : T) (r : T), plus_r : T.\nProof.\nintros.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\n\nTheorem mult_refl : forall x y, (a b) -> t.\nProof.\nintros.\napply mult_1.\napply mult_r with (A := mult_r := mult_r := mult_r := mult_r).\napply mult_r.\napply mult_r with (x:=r:=r:=l).\napply mult_r.\napply mult_r.\napply mult_l.\napply mult_r.\napply mult_r.\napply mult_l.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\n\nDefinition var_map :=\n  match t with\n  | cons t with\n  | cons _ => cons _ => cons _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\n\n\nDefinition new_env := var -> var_env := var_env var_env (fun (fun a => var a => var_env_env a) a) (env a)\n  (env a)) (env a) (env a) (env a))\n    var_env a)\n    (env a) (env a a) (env a a) (env a) (env a a)\n    (env_env a a) (env a) (env_env_env a) (env a a) (env a a a a a) a a) ->\n    (env a a) ->\n    In a a a.\nProof.\n  intros.\n  inversion H.\n  apply H.\n  apply neg_env_env_env_env_env_env_env.\n  apply le_env_env_env_env_env_env_env_env_env_env.\n  apply le_env; auto.\n  apply le_env; auto.\n  Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nTheorem plus_l : forall a b, P a b = b.\nProof.\nintros b H.\ndestruct b; auto.\nunfold eq_trans with b; auto with datatypes.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\nDefinition term :=\n  forall a, In a = true.\n\nDefinition t : forall a, In a = true -> In a -> In a a.\nProof.\n  intros.\n  rewrite H.\n  rewrite (fun a => false).\n  apply eq_refl.\n  apply le_trans with a; auto.\n  apply le_trans with (x:=x:=x:=x:=y:=x:=x:=x:=x:=x:=y:=x).\n  rewrite (x:=y:=y:=x:=x:=x:=x:=x:=y).\n  rewrite H.\n  apply lt_y:=y:=x:=y:=x:=x) in H0:=y) in H1 in H.\n  apply le_refl.\n  apply le_trans with (x:=x:=x:=x:=x:=y:=x:=x:=x:=x:=x:=y) in_x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=:=:=x:=y:=x:=y:=x:=:=x:=y:=x:=y:=y:=y:=x:=x:=:=x:=:=x:=:=:=Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\n\n(**\n  let (a : Term) := (a : T -> R) :=\n  let (fun a => T => is_one a b) in\n  let (s a) in\n  let (s := s := s in\n  let (s:=s) := s' in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s' := fresh in\n    let s' := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s in\n  let s' := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s' := fresh in\n  let s' in\n  let s in let s' := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s' := fresh in\n  let s := fresh in\n  let s := fresh in\n  let s' := fresh in\n  let s' := fresh in let s in\n  let s' := fresh in\n  let s in\n  let s := fresh in\n  let s' :=Defined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\n  intros.\n  apply one_refl.\n  destruct (x b c2 b c2 b2) as [a2 a3 b2 b1 [a3].\n  apply add_r2_r in H4.\n  case (x3 a3); auto.\n  Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros b; destruct a b; simpl in H0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; intros; case (x0); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\n  intros.\n  set (x := f x); auto.\n  set (x := x0); auto.\n  unfold eq_refl.\n  set (x := x0); auto.\n  set (x0); auto.\n  set (x0 := x0 y0); auto.\n  set (x0 x0 x0); auto.\n\n\n\nTheorem neg_one_one_one : forall a b:R, x = x b.\nProof.\n  intros.\n  set (x0) := x0) (x0)).\n  set (x0 x0) (x0) := x0) (x0 x0).\n  set (x0 x0) (x0 x0 x0 y00 x00) (x0 x00 x0 x0) (x0) x0 x0 x0) (x0 x0 x0) x0) (x0 x0 x0 x0) (x00 x0 x0 x0 x0 x0 x0 x0 x0) (x0 x0 x0) (x0 x0 x0 x0 x0 x0) (x0 x0 x0Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\n  intros.\n  apply neg_0; auto with *.\n  apply neg_plus_one_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one_one_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one_one_one.\n  apply neg_one_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_one_one.\n  apply neg_one_one. apply neg_one.\n  apply neg_one_one.\n  apply neg_one_one.\n  apply neg_one.\n  apply neg_one.\n  apply neg_Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\n  intros; elim (H1 x0); auto.\n  apply le_trans with typeclass_instances.\n  apply le_instances.\n  apply le_trans with (x := x); auto.\n  auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros b; elim (fun x => b) b); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\n  intros.\n  apply (fun b => x => a b b) (fun b => b) (fun b => b)) (x b).\n  intros.\n  exact (x b) (fun b => b) (x b)).\n  apply (x b)) (y b)); auto.\n  Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros.\napply f_equal.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros.\ncase_plus_sym; auto with typeclass_instances.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b a b1 H1 H2; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  case_refl_refl.\n  case (H1); auto.\n  apply plus_refl.\n  apply le_trans with (x:=x:=x:=x:=x:=x:=x).\n  apply le_sym.\n  apply le_refl.\n  apply le_refl.\n  apply le_trans with (x:=x:=x) y).\n  apply le_trans with y); auto with (x:=x:=x:=x:=x:=x:=y:=y) in H) in H.\n  apply le_r.\n  apply le_trans with (x:=x:=x:=x) in H0:=x:=x:=x:=x:=x:=x:=x:=x).\n  apply le_y:=x:=x:=x:=y:=x:=y:=x:=x:=y:=y:=y).\n  apply le_l:=x:=x:=x:=x:=x:=x:=:=x:=y:=x:=x:=:=y) in H0:=x:=y:=x:=y:=y:=y:=y:=y:=y:=x).\n  apply le_x:=:=:=x:=x:=y:=x:=x:=x:=x:=Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros; intros a b2 H2; apply lt_trans with (eqA := f a2 := H2); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  unfold eq_refl.\n  case_refl.\n  case_refl.\n  case (eq_refl H1 a b); auto.\n  case (A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H1); auto.\n  apply lt_refl_trans with (x := x) in_refl).\n  rewrite lt_trans with (x := x); auto.\n  apply lt_trans with (x:=x:=x:=y:=x:=x:=x).\n  rewrite lt_trans with (x:=x:=x:=x:=x:=x:=x:=x:=x:=y:=y:=x:=x:=y:=x:=x:=y) in_x:=x:=y:=x:=x:=x) in_x:=x:=x:=x:=x:=x:=x:=x).\n  apply lt_x:=:=x:=x:=x:=y:=x:=x:=:=y:=x:=x:=x) in_y:=x:=x:=:=x:=x:=:=:=:=y:=x:=:=x:=y:=x:=x:=x:=x:=x:=:=:=x:=Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  case (lt a b); auto.\n  case_refl.\n  case a b); auto.\n  case_eq_refl.\n  case (eqA_refl _ _ _ _ _ H1); auto.\n  auto.\n  case (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  intros; case (eqA _ _ _ _ _ _ _ _ H1).\n  destruct H2; subst b2; auto.\n  destruct H2; auto.\n  rewrite H2; auto.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_sym in H2; auto.\n  apply eq_sym.\n  apply eq_sym in H1; auto.\n  apply eq_refl.\n  apply eq_refl.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  intros.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_sym.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_refl.\n  apply eq_Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a a b1 a1 H1 H1; apply le_trans with a1.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros.\ndestruct a; auto.\ndestruct b; simpl; simpl in H1; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\n  intros.\n  elim (rel_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2); intros H3; auto.\n  elim (eqA _ H3); auto.\n  elim (eqA _ _ _ _ _ _ _ _ _ _ _ _ _ H3); auto.\n  rewrite H2; auto.\n  intros H3; apply H3; auto.\n  apply H4; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  apply le_refl.\n  apply le_refl.\n  apply le_trans with (x:=x:=y:=y) (x) x)) in H2).\n  apply le_refl.\n  apply le_refl.\n  apply le_trans with x; auto.\n  apply le_trans with (x:=y:=x:=x) (y:=x:=y:=x:=y:=x); auto with (y:=x:=y:=x:=x:=x:=x:=y:=x:=x:=x:=y) (y:=y:=y) (y:=x:=y).\n  apply le_x:=x) in_x:=x:=y:=y:=x:=x:=x:=x) in_y:=x:=x:=x:=y) in_y:=x:=y:=y:=y:=x:=y) in_y:=x:=x:=y:=x:=x:=x:=x:=x:=x:=x:=x:=x).\n  apply (y:=x:=x:=y:=x:=x:=:=x:=x:=x:=x:=:=x:=:=x:=x:=y:=:=:=x:=x:=xQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  apply plus_plus_trans with (x := In x); auto.\n  apply plus_assoc; auto.\n  apply plus_one; auto.\n  apply plus_one_one_one_one.\n  apply plus_one.\n  apply plus_one_one_one_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  rewrite plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  applyQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros; apply plus_plus_one_one_one.\n  apply plus_one_one_one_one.\n  apply plus_one; auto.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one_one_one.\n  apply plus_one_one_one.\n  apply plus_one.\n  apply plus_one_one_one_one.\n  apply plus_one.\n  apply plus_one_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one_one_one.\n  eapply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one_oneQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  induction a; intros; auto.\n  apply plus_one_one_one; auto.\n  eapply plus_one.\n  apply plus_one_one_one.\n  rewrite plus_one_one.\n  apply plus_one.\n  apply plus_one_one_one_one.\n  eapply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one_one_one.\n  apply plus_one.\n  apply plus_one.\n  eapply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_one_one.\n  apply plus_one.\n  apply plus_one.\n  apply plus_oneQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  apply le_trans with (x := eq_sym _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  case (eq_refl _ _ _ _ H).\n  case (eq_refl _ _ _ _ _ _ H2) H1 H2); auto.\n  apply le_trans with (x0); auto.\n  apply le_trans with (y := y); auto with (x0); auto.\n  auto.\n  apply le_trans with (y0); auto.\n  apply le_trans with (x0); auto.\n  apply le_trans with (x0 x0); auto.\n  apply le_trans with (x0); auto.\n  auto.\n  apply le_trans with x0).\n  apply le_trans with (x0 x0); auto with x0); auto with (y0); auto with (y0); auto.\n  apply le_trans with (x0); auto with (x0); auto with (x0 x0); auto with zarith.\n  auto with real.\n  apply le_trans with real.\n  apply le_trans with (x0); auto with real.\n  apply le_trans with real.\n  apply le_trans with (y0 x0 x0 x0); auto with real.\n  apply le_trans withQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros.\napply plus_l.\napply plus_l with (x := x); auto with (x := t).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b2 a b1 H2 a2 H1 H2.\nrewrite <- plus_trans with (a := B); auto.\napply plus_one_one_one_one_one_one_one_one; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  case (eq_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\n  intros.\n  case (eq_refl_refl_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros.\ncase (eq_refl (eq_trans _ _ _ _ _ H) H).\ncase_refl).\napply plus_trans with (eq_refl _ _ _ _ _ _ H).\napply plus_refl.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\n  case_refl.\n  case_refl.\n  case (not_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\n  case (le_refl_refl_refl_refl c); intros; auto.\n  case (eq_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\n  case_refl.\n  case (x_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a a b c1; elim a1; intros a b; rewrite H2; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros; case (eq_refl_refl _ _ _ _ _ H0 H0) H0 H0).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a; case a; elim a; auto.\nintros a; auto.\napply plus_one_one_one_one_one_one; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\ncase_refl; case_refl; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\n  intros.\n  elim (eq_refl_refl _ _ _ _ _ _ H).\n  elim (eq_refl _ H).\n  elim H).\n  elim H.\n  intro H.\n  elim H0.\n  elim (eq_refl_refl _ _ H0 H1).\n  elim H0 H1).\n  elim (eq_refl_refl _ _ H1 H1).\n  intro H2.\n  elim H1.\n  elim H1 H2.\n  elim H1).\n  intros.\n  elim H1.\n  elim H1; intros.\n  elim H1.\n  elim H1.\n  elim H1.\n  intros.\n  elim H1; auto.\n  elim H1.\n  elim H2.\n  intros.\n  intros; intros.\n  elim H1; elim H1.\n  elim H2.\n  elim H1.\n  intro H2; intros.\n  elim H1; intros H2.\n  elim H1.\n  elim H1; intros.\n  elim H1; auto.\n  apply H2.\n  intros.\n  elim H1.\n  intros.\n  elim H1; intros.\n  intros.\n  elim H1; intros H1; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b c; case (sumbool_one c); case_one_one_one c; case (sumbool_one c) a c); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros c.\ncut (fun c => eq x).\nintros.\nunfold eq_sym in |- *.\ngeneralize (H a); case (H _ _ _ _ H); auto.\ngeneralize (H0); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b c.\napply le_refl_refl; auto with arith.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a; case a; case a; case b; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nunfold eq_refl.\nintros x.\ndestruct x; destruct (eq_refl c) as [H1 | H2; auto.\nrewrite H2 H1; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros.\ngeneralize (le_one_le_refl_one_one_one_one_one_one c).\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros; case (eq_refl_refl_refl _ _ _ _ H1).\nintros H2.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b c c H0; rewrite plus_r.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros.\ncase_refl.\ncase_refl_refl.\napply le_refl.\ncase (eq_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros.\ndestruct (eq_refl_refl_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros; elim (H c1 c2 m2); auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros.\ncase_refl.\nelim (H1 a2 a1 a1 a1 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2; case a1; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros.\ncase (eq_refl_sym : forall b2 : forall a, ~ In a b1 = b1 -> In a2 b1 -> In b1 b1 = true -> In a2 -> In b1 a1 a2.\nintros.\ncase (le_trans a2 b2 b1 b2 b2 b2 b1 b2 b2).\nelim le_trans with (le_trans _ _ _ b2).\napply plus_comm.\napply le_trans with (l := S b1).\nrewrite le_trans with (l := S b2).\napply le_trans with b2 := S2).\napply le_trans with b1.\napply le_trans with b2; auto.\napply le_trans with b2; auto with b2; auto.\napply le_trans with b1; auto.\napply le_trans with b1; auto.\napply le_trans with b1; auto.\napply le_trans with b2; auto.\napply le_trans with b; auto with b2; auto.\napply le_trans with b2; auto.\napply le_transQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros.\nintros.\n case (H1 a); case (eq_refl a); auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\n  case (Eq_sym (dec a2 m1 m2); auto.\n  case (H0); auto.\n  case (eq_dec a0); intros; case (eq_dec a); auto.\n  case (eq a); auto.\n  case (eq a0); auto.\n  case a1 a2); auto.\n  case (eq a); auto.\n  case (eq a a); auto.\n  case (eq a); auto.\n  case (eq a); auto.\n  case a b); auto.\n  case (eq a); case (eq_eq a a); auto.\n  case (eq a); auto.\n  case a a a); auto.\n  case a0; auto.\n  case a0; case a0; auto.\n  case a0; case a b0); intros.\n  case a0; case a a0; case a0; case a0); auto.\n  case (eq a0); case a0; case a0; case a0); auto.\n  case (eq a0); auto.\n  case (eq (eq a); case a0); case a0 a a0; case a0; case a0; case (eqQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros; elim (lt_trans _ H).\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\napply le_refl.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros H; auto with arith.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\n  case_eq (lt_refl_refl m2); auto.\n  case (eq_trans _ _ H); auto.\n  case (eq_dec m2); auto.\n  case (eq_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros.\nintros a; elim a; elim (lt_le_trans _ _ a); intros a b b); simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a; simpl in |- *; case_refl; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros.\ncase a1 a1 a2; simpl in |- *.\ncase (le_le_le a2 a2 a2 a2 a2); auto.\nintros a2 a1 a2 a2; case a1; auto.\ncase a2 a2; auto.\nintros a2 a2 a2; apply le_le_trans with a2; auto.\nintros a2 a2; elim a2 a2; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros.\nelim (lt_plus_one _ (lt_one_one_one_one_one_one a) in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros.\napply plus_one.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\n  elim (eq_sym_sym_sym m2 m2 m2); auto.\n  elim (le_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros m2.\ncase_eq_refl.\ndestruct (fun b2 m2 b2 m2 m2 b2 m1 m2 b2); case (eq (eq_dec m2 b2 b1 b1).\ncase (eq_dec m2 b2 b1); auto.\nintros b2 b2 b2.\napply plus_r with (eq_dec m2 b2 b2) (eq_dec b2); auto.\ncase (eq_dec m2 b2 b1 b2) b2); auto.\napply plus_dec_dec_dec m2; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros.\ncase_sym.\napply plus_trans with (fun a1 a2 b2 => a2 a1 a1 b2 a2; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nunfold eq in |- *; case_refl; intros.\ndestruct (eq a b); simpl in |- *; case b; auto.\ncase b; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\n  case_refl.\n  case (N_plus_one_one_one _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case_eq_eq_dec a b; auto.\nintros.\nrepeat case (eq (eq_dec a) (eq a a b)); auto.\nrewrite plus_eq_dec a b); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\n case_refl.\nintros; intros.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a a b; case a1; simpl in |- *; intros a2; elim a1; intros a2; auto with a2; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a a.\nintros a a b a b.\n case a b; auto with arith.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a1 a0 a1 a1 a2.\nelim a1 a1 a2 a1 a2 a2 a2 a2 a2; elim a2; auto with arith.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\ncase_refl.\ncase_refl.\ncase_refl; intros a0.\ncase (eq a0 a0 b0); auto.\ncase (x0 a0 a0 b0); auto.\ncase (bool a0 a0 a0); auto.\ncase (a0); auto.\ncase (eq a0 b0); auto.\ncase (refl a0); auto.\ncase_eq a0); auto.\ncase (eq a0); auto.\ncase (s0 a0); auto.\ncase (eq a0); auto.\ncase (H0 a0); auto.\nintros a0 a0); auto.\napply le_trans with a0; auto.\napply le_trans with a0); auto with a0.\ncase (a0 a0); auto.\ncase a0 a0); auto.\napply le_eq_trans with a0; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\ncase_sym; auto.\napply plus_assoc; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a0; elim (M2 a0 a0 a0 a0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros; elim (Eq (Eq a).\napply eq_refl_refl.\napply lt_refl.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\n  intros.\n  case_sym; case_sym.\n  case (le_sym_refl_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\n  case (eq_refl_refl_refl_refl_refl_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\n  case (fun a => (s := x); auto.\n  case (eq_refl_refl).\n  case (refl_refl_refl_refl_refl_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros.\nelim (eq_refl_refl _ _ _ _ _ _ H)).\nintros H1.\napply le_refl.\napply le_refl.\napply le_trans with (x:=x:=x:=x:=x:=x:=y:=x:=x:=x:=x).\napply le_eq_refl.\napply le_refl.\napply le_trans with x:=x:=x:=x:=x:=x:=x:=y) in H.\napply le_trans with (x:=x:=x:=x:=x:=y:=y:=y:=x:=x:=x:=x:=x) in H) in H0.\napply le_trans with (x:=x:=x:=x:=x:=x:=x) in H0:=x:=x:=y:=x:=x:=y) in H.\napply le_refl.\napply le_trans with x:=y:=y:=x:=x:=y:=x:=x:=x:=x:=y:=x:=x:=x:=:=y).\napply le_sym.\napply le_trans with (x:=:=x:=y:=x:=x:=x:=Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros.\napply lt_refl.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros.\nunfold eq in |- *.\ncase_refl; case_refl; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a; elim a; elim H; elim H; intros; intros a a b; intros b c; intros; elim H; intros; elim H; elim H; intros; auto with a; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros.\ncut (fun x : T => eq a) (fun x => eq a0) c => eq_sym (fun x) (fun x => eq_refl_refl_refl x0 c0 x0 x0) x0))\n  case (x0) (x1 x0)) (cons x0)); intros H2.\nelim (cons x0 x0); auto.\napply le_sym in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\n  case_refl.\n  case (refl_refl H).\n  case (eq_refl _ _ H).\n  case (refl _ _ _ _ H).\n  case (eq_refl _ _ _ H).\n  case H).\n  case H.\n  case (H _ H).\n  case (eq_eq_refl _ _ H).\n  case H.\n  case (eq_refl _ H).\n  case (eq_refl _ _ _ _ _ H).\n  case H).\n  case_eq_eq_eq_eq (eq_refl_refl _ H); case (refl H).\n  case (eq_eq _ H).\n  case_eq_refl.\n  case H0; case_eq_eq_eq_eq _ _ _ _ H0 H).\n  case (eq_eq_eq _ H); case_eq_eq_refl.\n  case_eq_eq_refl.\n  case (eq _ _ _ _ _ H).\n  case_eq_eq_eq_eq_eq_eq_refl.\n  case H0); case (eq_eq_eq_dec _ _ _ _ H).\n  case (eq_eq_eq_eq_eq_eqQed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  induction k; simpl; simpl; auto.\n  apply lift_eval_id_var; auto.\n  - rewrite lift1.\n  - apply lift1 lift1.\n  - intros k.\n    - apply lift1.\n    rewrite lift1.\n      rewrite lift1.\n    - apply lift1.\n      simpl in lift1.\n      + apply lift1.\n      - simpl lift1 lift1.\n      apply lift1.\n    + apply lift1.\n      + apply lift1.\n        destruct t1.\n      apply lift1.\n      apply lift1; auto.\n      rewrite lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      rewrite lift1.\n      destruct lift1 lift1.\n      apply lift1 lift1.\n      apply lift1 lift1.\n      simpl in lift1.\n      apply lift1.\n      rewrite lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      apply lift1.\n      rewrite lift1 lift1.\n      apply lift1_lift2.\n      apply lift1.\n      apply lift1.\n      apply lift1; auto.\n      apply lift1.\n      applyQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor; intros.\n  constructor.\n  apply lift1.\n  constructor.\n  constructor.\n  constructor; constructor.\n  constructor. constructor. constructor. constructor. constructor; auto. constructor. constructor. constructor. constructor. constructor. constructor. constructor. constructor. constructor constructor. constructor. constructor. constructor. constructor. constructor. constructor. constructor. constructor. constructor constructor constructor constructor. constructor constructor constructor constructor. constructor. constructor. constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructor constructorQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  unfold lift in lift_expr_var.\n  intros.\n  apply lift_var.\n  apply lift1.\n  destruct (lift_var_var x)).\n  rewrite lift1.\n  apply lift1.\n  apply lift_var_var.\n  apply lift1.\n  apply lift1.\n  apply lift_var_var.\n  apply lift1.\n  apply lift_var_var_var.\n  apply lift_var_var_var.\n  apply lift1.\n  apply lift1.\n  apply lift1_var.\n  apply lift1_var_var.\n  apply lift1.\n  apply lift1.\n  apply lift2.\n  apply lift2.\n  apply lift1.\n  apply lift1 lift_var_var.\n  apply lift1.\n  apply lift2.\n  apply lift1_var_var_var_var.\n  apply lift1_var_var.\n  apply lift1.\n  apply lift1 lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1 lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1 lift2.\n  apply lift1 lift2.\n  apply lift1Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  constructor; intros.\n  constructor.\n  apply lift_equal.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w; intros w w.\n  destruct w; auto.\n  destruct w.\n  - destruct w; auto.\n  - inversion w; auto.\n  - inversion w; auto.\n  - inversion w; subst.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply lift_var_var_var_var_var.\n  split; auto.\n  apply lift_var_var; auto.\n  apply lift_var; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  split; auto.\n  constructor.\n  constructor.\n  constructor; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply lift_type_type_f_e; auto.\n  destruct (lift_f x).\n  apply lift_Var_f_f_f x).\n  apply lift_f.\n  apply lift_equal.\n  apply lift_equal.\n  apply lift_equal.\n  apply lift_equal. apply lift_equal.\n  rewrite lift_equal.\n  apply lift_comp_equal.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift_lift.\n  apply lift_lift.\n  apply lift_lift.\n  apply lift_lift_lift.\n  apply lift_lift.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  constructor.\n  constructor; constructor; auto.\n  constructor. constructor.\n  constructor.\n  constructor; constructor.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof. Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply lift1.\n  apply lift1. apply lift_lift.\n  apply lift1.\n  rewrite lift2.\n  apply lift1.\n  apply lift1.\n  rewrite lift2.\n  apply lift_lift1.\n  apply lift1.\n  apply lift1 lift1 lift1.\n  apply lift1. apply lift2.\n  apply lift1.\n  apply lift1_lift1.\n  apply lift2.\n  apply lift1.\n  apply lift1.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  induction k; simpl; intros.\n  simpl.\n  rewrite lift1.\n  simpl.\n  apply lift1.\n  destruct H1.\n  apply lift1; auto.\n  apply lift1.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n intros. Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  destruct w; intros.\n  destruct w; auto.\n  destruct w; auto.\n  destruct w; auto.\n  - destruct w; auto.\n    destruct w; auto.\n    destruct w; auto.\n    - destruct w; auto.\n    - rewrite <- H.\n    - subst.\n    + auto.\n    + rewrite H0.\n    - auto.\n    rewrite!inE.\n    + subst.\n    - destruct w; auto.\n    - apply H0.\n    - subst w; auto.\n    - auto.\n    - specialize (H i)); auto.\n    + subst w.\n    - auto.\n    - simpl in *.\n    - rewrite <- H0.\n    + intros w; auto.\n    + rewrite <- H0.\n    - subst w.\n      * apply H0.\n      - auto.\n    - apply H0.\n    - apply H0.\n      * auto.\n    + rewrite <- H0.\n    - rewrite <- H0.\n    - rewrite H0.\n    - rewrite <- H0_assoc.\n    - simpl in H0.\n    - rewrite <- H0.\n      - auto.\n    - unfold lift in H0.\n      apply H0.\n    - rewrite <- H0.\n   Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply lift1. apply lift1.\n  apply lift1_app_app_app_app; auto.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply lift1.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  destruct t; auto.\n  destruct t; auto.\n  inversion H; subst.\n  simpl in H.\n  destruct t; auto.\n  destruct t; auto.\n  econstructor; auto.\n  - destruct t; auto.\n  + split; auto.\n  - constructor.\n  - constructor; auto.\n    - destruct t as [subst t; auto.\n    destruct t; auto.\n    - intros t1 t; auto.\n    + constructor.\n    + constructor.\n    - constructor.\n    - destruct t1 t1.\n      - constructor; auto.\n    * simpl.\n      - constructor.\n      + constructor; auto.\n      + constructor.\n    - constructor; auto.\n      - constructor.\n        constructor.\n      * constructor.\n      - auto.\n      + constructor; auto.\n      - constructor.\n      * constructor.\n      + constructor.\n      - constructor; auto.\n      + constructor; auto.\n      - constructor; auto.\n    - constructor.\n      * simpl; constructor.\n      - constructor.\n      - constructor; auto.\n      constructor.\n      constructor.\n      - constructor.\n      + constructor.\n      + intros.\n      * constructor.\n      constructor.\n      - constructor.\n      constructor.\n      constructor; auto.\n      constructor;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  destruct (lift t1 t2) as [a1 t2] [b2] [a2] [b2] [b2 [b2] | [a2 [b2 [c1 [b2].\n  [a2]].\n  exists a2; split; auto.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl; auto.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  destruct H.\n  destruct H; auto.\n  destruct H; auto.\n  - destruct H; auto.\n    - auto.\n    + destruct (lift_clear H0); auto.\n    destruct H0.\n    - subst.\n    - apply IH; auto.\n    - apply IH.\n    - auto.\n    - apply IHlift.\n    + apply IH_lift.\n    - apply IH_lift.\n    - apply IH.\n    - unfold lift1.\n    - intros.\n    - simpl in IH.\n    - simpl in H0.\n    - apply IH.\n    - apply IH.\n    - apply IH; auto.\n    - simpl in IH.\n    - destruct IH.\n      - split.\n    - destruct IH.\n    - simpl in IH IH; auto.\n    - apply IH1.\n    - apply IH.\n    - apply IH.\n    - apply IH.\n    - apply IH IH.\n    - apply IH IH; auto.\n    - apply IH IH IH.\n    - apply IH IH.\n    - apply IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IHQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  unfold lift_subst_env.\n  apply lift_lift.\n  intros.\n  eapply lift_lift.\n  apply lift_lift_lift.\n  apply lift1; auto.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  apply lift_inv.\n  apply lift1.\n  apply lift1.\n  apply lift_App.\n  apply lift1_cons.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift_cons_app2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift2.\n  apply lift1. apply lift1 lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1; apply lift1.\n  apply lift1. apply lift1.\n  apply lift1 lift1. apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1; simpl lift1.\n  apply lift1 lift1.\n  apply lift1.\n Qed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  rewrite lift1 in H2.\n  unfold lift1.\n  destruct H1.\n  destruct H2.\n  simpl in H2.\n  rewrite lift1.\n  destruct H2.\n  rewrite lift1.\n  rewrite lift1.\n  destruct H2.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H2.\n  destruct H1 as [ | [ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w.\n  apply lift_lift.\n  split.\n  intros.\n  simpl in H.\n  apply lift_lift.\n  apply lift1.\n  unfold lift_lift; auto.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1; auto.\n  apply lift1.\n  apply lift1.\n  apply lift1_lift2.\n  apply lift1.\n  apply lift2.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  induction t1.\n  simpl in |- *.\n  unfold lift1.\n  apply lift1.\n  intros.\n  simpl in |- *.\n  apply lift1.\n  rewrite lift1.\n  apply lift2.\n  rewrite lift1.\n  rewrite lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1; auto.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1_lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1_lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1_lift2.\n  apply lift1.\n  apply lift1 lift1.\n  apply lift2.\n  apply lift1.\n  apply lift2. apply lift1.\n  apply lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift2_Qed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w H.\n  destruct w; auto.\n  apply lift_subst.\n  eapply lift_cons.\n  apply lift1; eauto.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  apply lift1.\n  intros; simpl.\n  simpl.\n  apply lift1; auto.\n  apply lift1.\n  apply lift1; auto.\n  apply lift1.\n  apply lift2.\n  apply lift2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; simpl; intros; simpl; auto.\n  auto.\n  simpl; auto.\n  simpl; auto.\n  auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  induction k; simpl.\n  induction k; auto.\n  - auto.\n  + apply IH.\n    + destruct IH; auto.\n    - simpl in IH; auto.\n    + destruct IH; auto.\n    - destruct IH; auto.\n    - apply IH; auto.\n    - auto.\n    - rewrite IH1; auto.\n    - apply IH IH; auto.\n    - apply IH IH; auto.\n    - rewrite IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  apply lift1; auto.\n  destruct t.\n  eapply lift1; auto.\n  apply lift1; auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  destruct v.\n  destruct v; auto.\n  intros.\n  inv_lift; auto.\n  destruct v.\n  destruct v; auto.\n  destruct v; auto.\n  destruct v; auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; auto.\n  - apply lift_subst_f_f_f; auto.\n  - auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  unfold lift; intros.\n  rewrite lift_lift in H; simpl in H; auto.\n  apply lift_lift_lift; auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  apply lift_e. auto.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction v; intros; simpl; auto.\n  try discriminate.\n  apply lift_sort_sort.\n  + intros; auto.\n  + intros.\n    + intros.\n    + apply lift_sort in H.\n      rewrite lift_sort in H.\n    * apply lift_sort.\n      + rewrite lift_sort in H.\n      + simpl in H.\n      + apply lift_sort in H.\n    + apply lift_sort_sort_sort.\n      + simpl.\n      simpl in H0.\n        * simpl in H0. simpl in H.\n    + simpl in H0.\n      + simpl in H0.\n      apply lift1.\n      + apply lift1.\n      apply lift_sort in H0.\n      - apply lift_sort_sort in H1.\n      rewrite lift1.\n      + simpl in H1.\n      - lift1.\n      simpl in H0.\n      * destruct H1.\n      simpl in H1.\n      destruct (lift1_sort_sort v2) as [??].\n      destruct H2 as [??]].\n      apply lift1.\n      unfold lift1.\n      split.\n      split.\n      intros.\n      destruct (lift2).\n      unfold lift1.\n      rewrite lift_Qed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  apply H; eauto.\n  + simpl in H.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  revert k; auto.\n  induction k; intros.\n  - simpl; intros.\n  - destruct (lift_equal_subst_var_Var_f_f_f v)). subst.\n  - unfold lift1.\n    - simpl.\n    + rewrite lift1.\n    - simpl.\n    rewrite lift2_lift2.\n    apply lift1.\n    apply lift1.\n    - simpl.\n    - destruct (lift_lift2)); auto.\n    - simpl.\n    - intros.\n    - unfold lift1.\n    - simpl.\n    - apply lift1.\n    - simpl.\n    - apply lift1_comp_comp_comp.\n    - simpl; auto.\n    - simpl.\n    - simpl.\n    - simpl.\n    - unfold lift1_lift1_lift.\n    - simpl.\n    - simpl.\n      - rewrite lift1.\n    rewrite lift1.\n    - simpl.\n    - simpl.\n    - simpl in lift1.\n      rewrite lift1.\n    + rewrite lift1 lift1.\n    - rewrite lift1_comp_comp_comp_comp.\n    - simpl.\n    - rewrite lift1.\n    - unfold lift1.\n    - simpl.\n    - simpl lift1.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof. Qed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros.\n  destruct v1; subst.\n  destruct v; try congruence.\n  destruct v; subst; subst.\n  destruct v; auto.\n  destruct v; subst.\n  destruct v1; auto.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof. reflexivity. Qed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros.\n  rewrite <- H.\n  intros.\n  apply lift1.\n  apply lift1.\n  apply lift1.\n  apply lift1.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  unfold lift_sort. reflexivity. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  apply lift1.\n  rewrite lift1.\n  apply lift1.\n  simpl.\n  apply lift2.\n  apply lift1.\n  apply lift1.\n  apply lift1.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof. reflexivity. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  intros.\n  destruct v.\n  destruct v; auto.\n  destruct v; auto.\n  apply inv H; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  unfold lift2.\n  intros.\n  rewrite lift1.\n  rewrite lift_cons_App.\n  rewrite lift1.\n  rewrite lift1; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  apply subst.\n  destruct t; eauto.\n  apply in H; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  destruct t; intros.\n  apply H; auto.\n  auto.\n  simpl.\n  apply H.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  induction v; simpl; auto.\n  induction t; auto.\n  simpl; auto.\n  destruct t; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  rewrite H.\n  apply IH.\n  apply IHT.\n  apply IHT.\n  + rewrite IHT.\n    + auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  destruct v; subst; auto.\n  rewrite <- H.\n  destruct H.\n  destruct v; auto.\n  destruct (subst v2).\n  destruct v; auto.\n  rewrite H2.\n  destruct H2; auto.\n  destruct (subst v); auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  apply subst; auto.\n  destruct t1; auto.\n  eapply subst.\n  destruct t1; auto.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  induction k; intros.\n  inversion H.\n  destruct (subst_clear H0).\n  destruct H0 as [ | [ | [ [ | [ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof. intros.\n  red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red;Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. unfold red; auto. auto. red; red; red in H. red in H. red. red in H; red; red in H. red in H. red; red in H. red in H; red in H. red in H. red. red in H. red in H. red in H. red in H. red in H. red in H. red. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H. red in H0. red inQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  eapply inv H1; red; eauto.\n  red.\n  red in H1. red; red in H1; red in H1. red in H1. red; red in H2. red in H1. red; red in H2. red in H2. red in H1. red in H2. red in H1. red in H2. red in H2. red in H2; red in H2. red in H2. red in H1. red in H2. red in H1. red in H2. red in H1. red in H1. red in H2; red in H1. red in H2. red in H2. red in H2. red in H1; red in H1. red in H2. red in H2. red in H1; red in H1. red in H2. red in H1. red in H2. red in H2. red in H2. red in H1; red in H2. red in H2. red in H1. red in H2. red in H2. red in H2. red in H1.Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. red in H. intros. red in H. red; red in H. red. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H.Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  red; red; intros; red; red; intros. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red;Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. intros. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. redQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  red.\n  red in H; intros. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H0. red in H. red in H. red in H0. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red in H. red inQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. intros. eapply le_subst; auto. unfold simpl in H.\n  exploit le_inv. apply le_inv. eapply le_inv in H. auto. apply le_inv in H. eauto. auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. red. red.\n  red; red; red; red; red; red; red. red; red; red; red; red; red. red; red; red; red; red; red. red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red. red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; redQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. red; red; red; red; intros. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red. red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red. red;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros; inversion_sort; subst.\n  inversion_sort; subst; subst.\n  inversion H.\n  inversion H; subst; subst.\n  inversion H; subst.\n  inversion H; subst; subst.\n  inversion H.\n  inversion H; subst.\n  inversion H; subst; subst; subst.\n  inversion H; subst. inversion H.\n  inversion H.\n  inversion H; subst. inversion H; subst.\n  inversion H. inversion H; subst. inversion H; subst. inversion H. subst. inversion H; subst. subst; subst.\n  inversion H. inversion H; subst. inversion H; subst. inversion H; subst; subst. inversion H0.\n  inversion H; subst. subst; subst. inversion H; subst; inversion H; subst. inversion H; subst. inversion H0; subst. inversion H0; subst. inversion H; subst. subst; inversion H; subst; subst. inversion H. subst; subst. subst. inversion H0; subst. inversion H; subst. subst.\n  inversion H; subst. inversion H0; subst.\n  inversion H; subst. subst. subst. inversion H. subst; subst.\n  inversion H; subst. subst. inversion HQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros; intros.\n  destruct t1 t1 t2.\n  destruct t2.\n  simpl in H; auto.\n  apply H0.\n  apply IH.\n  apply IH1.\n  apply IH.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros.\n  apply H.\n  simpl in H.\n  econstructor; eauto.\n  apply H.\n  auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  unfold closed_wrt_closed; auto.\n  apply closed_wrt_closed; auto.\n  rewrite closed_wrt_closed; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  assert (x t1: t2: t1 t2 t2) (T2: t1 t2),\n      induction t2. auto.\n  destruct t2 as [x2] t2] | [x1] t2] [x2 t2].\n  destruct t1 t2 t2 t2] t1 t1 t1 t2 t1 t2 t2 t2 t2 t2 t1 t2 t2.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  induction 1; auto.\n  intros.\n  destruct (eq_dec_dec_dec t)).\n  destruct (eq t2 x t); auto.\n  inv H.\n  destruct t t1; auto.\n  simpl in H; auto.\n  destruct t2; auto.\n  destruct t0; auto.\n  inv H; auto.\n  - destruct t; auto.\n  - destruct t0; auto.\n  - auto.\n  - exists t; auto.\n    - destruct t; auto. auto.\n    - intros; auto.\n    - destruct t; auto. apply t; auto. auto.\n    + apply t; auto.\n    - destruct t1.\n    + split; auto.\n    apply t0; auto.\n    - auto.\n    + auto.\n    - rewrite t; auto.\n    - rewrite t1.\n    - apply t_inv t; auto.\n    - auto.\n    - apply t_type; auto.\n    - apply t1; auto.\n    + intros t; auto.\n    - apply t; auto.\n    - auto.\n    + auto.\n    - apply t1.\n    - intros.\n    - apply t_app; auto.\n    - rewrite t_Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  unfold closed; auto.\n  apply closed_wrt_wrt_wrt_wrt_wrt_wrt_wrt_lift; auto.\n  auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  unfold closed.\n  intros.\n  apply closed_wrt_wrt_tm_wrt_closed; eauto.\n  destruct H.\n  destruct H; eauto.\n  eapply closed_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_tm; eauto.\n  eapply closed_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_tm; eauto.\n  eapply closed_wrt_wrt_wrt_wrt_wrt_wrt_wrt_tm. eauto.\n(* ------------------------------------- *)\n(* An *)\n(* An example, a tactic, we can be useful, but not have a type of a set of the set of\n    as a set of type of set of set of set, set of set of set of set of set of set of set of set of set of set of set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set setQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros; inversion H; auto.\n  apply H; auto.\n  inversion H.\n  inversion H; auto.\n  inversion H.\n  destruct H; subst; subst; subst.\n  auto.\n  inversion H; auto.\n  inversion H; auto.\n  destruct H; auto.\n  inversion H; subst; auto.\n  inversion H; auto.\n  auto.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H0.\n  inversion H; subst.\n  inversion H. inversion H; auto. inversion H; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H0; subst.\n  inversion H0.\n  inversion H; subst. inversion H0.\n  inversion H0; inversion H; subst; subst.\n  inversion H; subst. subst.\n  inversion H0; subst.\n  inversion H; subst. inversion H0; inversion H; subst. inversion H; subst; subst. inversion H0. inversion H0. inversion H0; subst. inversion H.\n  inversion H0.\n  inversion H0; subst; subst.\n  inversion H0; subst; subst.\n  inversion H0;Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  unfold closed_intro.\n  unfold closed, closed, closed in *.\n  unfold closed_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_wrt_rec.\n  destruct x as [e_wrt_tm].\n  destruct (subst_wrt_subst_subst_wrt_co_rec_wrt_subst_subst_co_co_subst_subst_subst_subst_co_subst_subst_subst_subst_subst_co_subst_subst_subst_co_subst_subst_co_subst_co_subst_co_subst_subst_subst_subst_subst_co_co_co_subst_subst_subst_co_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_co_subst_subst_subst_subst_subst_subst_subst_subst_coQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; auto.\n  intros.\n  destruct (app_var_var_var_var_var t1 t1 t2 t1 t1 t2 t1 t1 t1 t1 t2 t1 t2 t1 t2.\n  destruct t2 t2 t1 t2. auto.\n  destruct t1 t1 t2; auto.\n  destruct t1 t2; auto.\n  destruct t2 t2; auto.\n  destruct t1 t2; auto.\n  destruct t1 t1 t1 t1 t1 t2; auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; auto.\n  intros.\n  induction k; simpl in *.\n  - intros.\n  - auto.\n  - rewrite!lift_lift.\n  - destruct (subst_lift_subst t2) as [x1 [x2 x2 x1 x1] [x2 y2] [x2 [x2 x2 x2 x1 x2 x2 x2 x2 x2 x2 x2 y2 x2 x2 x2 x2 x2 x2 x2 x2 x2 x2 x2; auto.\n\nLemma swap_subst_sort: forall (e: t1 x2, t1 t2 t2) ->\n  (T1 t2) ->\n  e1 t2 t2 t2 ->\n  closed_sort t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t1 t2 t2 t1 t2 t2 t2 t2 t2 t2 t2 t2 t2 t1 t2 t2 t2 t2 t2 t t1 t2 t2 t t2 t2 t t2 t2 t2 t2 t t2 t2Qed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; auto.\n  destruct H; intros.\n  destruct H. destruct H; auto.\n  destruct H.\n  eapply H0; eauto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; auto.\n  intros.\n  eapply closed_wrt_wrt_wrt_closed; eauto.\n  + eapply closed_wrt_closed; eauto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; auto.\n  destruct t; subst.\n  - intros; simpl; auto.\n  - destruct t1; auto.\n  - apply closed_wrt_closed_wrt_wrt_closed; auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; simpl; simpl; auto.\n  simpl; auto.\n  destruct t1; auto.\n  intros.\n  destruct t; auto.\n  auto.\n  simpl in *.\n  destruct t0; simpl in *; auto.\n  destruct t1 t1; auto.\n  destruct t1 t2 t2; auto.\n  destruct t1 t1 t2; auto.\n  inv H2; auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  induction 1; intros.\n  induction 1; inversion 1; subst; simpl in *.\n  inversion 1; simpl; subst; subst.\n  simpl; subst.\n  inversion_clear; auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction k; subst; simpl; eauto.\n  inversion H.\n  auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  destruct t2; auto.\n  inversion H1.\n  induction t2; auto.\n  destruct t1; auto.\n  inversion H2; subst.\n  destruct t2; auto.\n  auto.\n  destruct t1; auto.\n  destruct t2; auto.\n  eauto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction (e1 t1) as [x1 t2].\n  inversion H2; subst.\n  induction t2; simpl; subst.\n  destruct t2; subst; auto.\n  inv H2; auto.\n  constructor.\n  constructor.\n  econstructor; auto.\n  eapply closed_wrt_wrt_wrt_wrt_closed; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof. intros.\n  inversion_closed; subst; subst; auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction k; auto.\n  - intros; auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros.\n  inversion_closed.\n  inversion H.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H. inversion H.\n  inversion H. subst. inversion H.\n  inversion H. inversion H. inversion H0.\n  inversion H0. inversion H0.\n  inversion H0.\n  inversion H0. inversion H0.\n  inversion H0. inversion H0. inversion H0. inversion H0.\n  inversion H0. inversion H0. inversion H0; subst. subst. inversion H0. inversion H0. inversion H0; inversion H0. inversion H0. inversion H0; inversion H0; inversion H0; inversion H0; clear H0. inversion H0. inversion H0; inversion H0; clear H0; subst; inversion H0; subst; subst. inversion H0; subst; inversion H0; inversion H0; subst. inversion H0; clear H0; clear H0; inversion H0; subst; inversion H0; subst; subst; subst; clear H0; subst; subst; clear H0; inversion H0; subst; subst; subst; subst; subst; subst;Qed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros.\n  induction k; auto.\n  destruct x; subst; auto.\n  inversion H; auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction k; auto.\n  inversion H.\n  inversion H. inversion H.\n  inversion H.\n  inversion H; subst.\n  inversion H.\n  inversion H. inversion H.\n  inversion H0; subst.\n  inversion H0; clear H0; subst. inversion H0; subst. inversion H0.\n  inversion H; subst. subst.\n  inversion H0. subst. inversion H0; subst. inversion H0. inversion H0; subst; subst. inversion H0. inversion H0. subst. inversion H0. subst. inversion H0. subst; subst. inversion H; inversion H0. subst. subst. subst. subst. subst; subst. subst.\n  inversion H. inversion H; subst.\n  inversion H0. subst. subst. inversion H0; subst. inversion H0; inversion H0; subst. inversion H0; subst. inversion H0. inversion H0; subst. subst. subst. inversion H; inversion H0; subst. subst. inversion H; subst. inversion H0. subst. subst. subst. inversion H0; subst. inversion H; subst. subst. inversion H0. subst. subst. inversion H0; subst; subst.Qed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros.\n  inversion H.\n  inversion H; subst.\n  inversion H.\n  inversion H.\n  inversion H. inversion H0; subst; inversion H0.\n  inversion H0; inversion H0; clear H0; clear H0; clear H0; subst; subst.\n  inversion H0. inversion H0; subst.\n  inversion H; subst.\n  inversion H0; inversion H0. inversion H0; subst. inversion H0; subst.\n  inversion H0; subst. inversion H0.\n  inversion H0; inversion H0; subst.\n  inversion H0; inversion H0; subst. subst. inversion H0; inversion H0; subst; subst. inversion H0; inversion H0; subst. inversion H0; inversion H0; subst; subst; subst. inversion H0. subst. inversion H0; inversion H0; inversion H; inversion H0; subst; subst. inversion H0; subst. inversion H0; subst. subst. subst. inversion H0; subst. subst. inversion H0; subst. subst.\n  inversion H0. inversion H0; subst. subst.\n  inversion H0; inversion H0; subst. inversion H0Qed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  inversion H.\n  inversion H.\n  inversion H; subst; subst.\n  inversion H.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H; subst.\n  inversion H. subst.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0; inversion H0. inversion H0.\n  inversion H0. inversion H0. inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst. subst.\n  inversion H0. subst. subst. subst. inversion H0. inversion H0.\n  inversion H0. inversion H0. inversion H0; inversion H0. inversion H0; subst. inversion H0. inversion H0. inversion H0. inversion H0; subst. inversion H0. subst. inversion H0; subst. inversion H0; inversion H0. inversion H0; inversion H0. inversion H0; inversion H0; inversion H0; clear H0; inversion H0; inversion H0. inversion H0; clear H0; subst; subst. inversion H0; subst. inversion H0; subst. inversion H0; subst. inversion H0. inversion H0; subst; subst. inversion H0; subst. inversion H0. inversion H0;Qed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction k; intros.\n  inversion H.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0; subst; subst; inversion H0.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0; inversion H0; subst.\n  inversion H0. inversion H0.\n  inversion H0.\n  inversion H; subst. inversion H0. inversion H0. inversion H0. inversion H0; clear H0. inversion H0; inversion H0; inversion H0. inversion H0; subst; subst. inversion H0. inversion H0. subst. inversion H0; subst; subst; subst. inversion H0; subst; subst. subst. inversion H0; subst. inversion H0. inversion H0; inversion H0; inversion H0; subst. inversion H0; subst. inversion H0; subst; subst; subst. inversion H0; subst; subst. inversion H0; subst; subst; subst. inversion H0; subst. inversion H; subst. subst. inversion H0; subst; subst. inversion H0; subst. subst. inversion H; subst; subst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  induction k; auto. auto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros.\n  inversion_closed; subst; clear; subst; subst.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n induction k; auto.\n  inversion_subst; inversion H.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros.\n  inversion_wrt_closed; auto.\n  intros.\n  inversion H; subst; subst; subst.\n  inversion H; auto.\n  inversion H.\n  inversion H; subst.\n  inversion H; inversion H; subst; inversion H; subst; subst; subst; subst.\n  inversion H; subst.\n  inversion H.\n  inversion H; subst. subst; subst; subst.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros.\n  inversion H.\n  inversion H; subst.\n  inversion H.\n  inversion H.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros.\n  apply closed_wrt_wrt_closed.\n  eapply closed_wrt_closed; eauto.\n  eauto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  induction k; intros; auto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  induction k; auto.\n  auto.\n  induction k; auto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  induction k; inversion H.\n  destruct t; subst.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0; inversion H0; subst; subst.\n  inversion H0.\n  inversion H0. inversion H0.\n  inversion H0; subst. inversion H0.\n  inversion H0; clear H0. inversion H0; subst. inversion H0. inversion H0; subst; inversion H0; subst.\n  inversion H0; inversion H0; subst.\n  inversion H0; subst. inversion H0; subst. inversion H0; subst. inversion H0; subst; subst. subst; subst.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  induction k; simpl in *.\n  inversion H.\n  inversion H.\n  inversion H; subst.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H. inversion H; subst.\n  inversion H. inversion H; subst. subst.\n  inversion H.\n  inversion H; subst. inversion H.\n  inversion H. inversion H0. inversion H. inversion H; subst. inversion H. inversion H0; inversion H0. subst. inversion H; subst. inversion H0; subst. subst. inversion H. inversion H0. inversion H0. subst. inversion H. inversion H0; subst. inversion H0; subst; subst. inversion H0. inversion H0; subst. inversion H0. inversion H0; subst. inversion H0; subst. inversion H0. inversion H0. inversion H0. subst. subst. inversion H0. inversion H0. inversion H; subst. inversion H0. inversion H0; subst. inversion H0; subst. inversion H0. inversion H0. inversion H0. inversion H0; subst. inversion H0. inversion H0. subst. inversion H0. inversion H0. inversion H0;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. intros.\n  elim H; simpl.\n  apply closed_wrt_wrt_wrt_closed. apply closed_wrt_wrt_wrt_wrt_closed; auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  intros.\n  unfold closed.\n  red; intros.\n  inversion H.\n  inversion H; inversion H.\n  inversion H.\n  inversion H; subst.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0; subst. inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0; inversion H0. inversion H0. inversion H0. inversion H0; inversion H0; inversion H0; inversion H0.\n  inversion H0.\n  inversion H0; inversion H0; inversion H0; subst.\n  inversion H0; subst. inversion H0; inversion H; subst.\n  inversion H0; inversion H0. inversion H0.\n  inversion H0; inversion H0. inversion H0; inversion H0; subst. inversion H0; subst; subst. inversion H0; subst. inversion H0; subst. inversion H0. subst. inversion H0; subst; subst; inversion H0; inversion H0; subst. inversion H0. inversion H0. inversion H0. inversion H0. inversion HQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof. intros.\n  inversion H; auto.\n  inversion H; inversion H.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  induction k; intros.\n  destruct H.\n  simpl; auto.\n  auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  red; intros.\n  red; intros.\n  destruct (subst_of_of_closed t2); auto.\n  destruct t; auto.\n  apply closed_closed_closed; auto.\n  apply closed_closed.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  induction t1; auto.\n  intros. eapply closed_lift; eauto.\n  simpl.\n  induction t1.\n  simpl. auto.\n  apply closed_wrt_closed.\n  inversion H.\n  auto.\n  apply closed_closed; auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  intros.\n  inversion H. auto.\n  rewrite closed_closed.\n  inversion H. auto.\n  auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros; intros.\n  destruct t1; simpl; auto.\n  inversion H; inversion H.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0; subst.\n  inversion H; subst; subst. inversion H0; subst; subst.\n  inversion H0; subst.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  induction t2; subst.\n  intros; auto.\n  induction t1; auto.\n  red; auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  induction induction t1; intros.\n  red; intros; intros; auto.\n  red; auto.\n  red; intros. red; red; auto. apply closed_wrt_wrt_closed; auto.\n  red; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction t; auto.\n  - subst.\n  - apply IH.\n  - apply H.\n    - apply IH.\n    - apply IH_var_var; auto.\n    - intros.\n    - apply IH.\n    - apply IH.\n    + destruct IH.\n    - destruct IH; auto.\n      apply IH; auto.\n      apply IH; auto.\n      + apply IH.\n      - apply IH.\n      apply IH.\n      - apply IH IH.\n      - apply IH IH.\n      - eapply IH IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction (T i); intros.\n  apply H0.\n  Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; auto with arith.\n  - (* FILL IN HERE *)\n  - (* FILL IN HERE *)\n  - (* FILL IN HERE *)\n  - (* FILL IN HERE *)\n  - (* FILL IN HERE *) Admitted.\n(* FILL IN HERE *)\n  (* FILL IN HERE *)\n(** FILL IN HERE *)\n\n\n(** **** Exercise: *)\n(** **** Exercise: 2 stars, optional (SS.  *)\n(** **** Exercise: 3 stars (ev_step_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev.\n  econstructor.\n\n(** **** Exercise: 2 stars, optional (ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_evev_ev_ev_ev_ev_ev_ev_ev_ev_ev_ev_evQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction e; intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0; clear H0; subst.\n  inversion H0; inversion H0; clear H0; clear H0.\n  inversion H; clear H0; inversion H0; subst.\n  inversion H0; subst. inversion H0.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0; clear H0.\n  inversion H0; subst. inversion H0; inversion H0; subst; subst; subst; inversion H0; subst; inversion H0; inversion H0; inversion H0; subst. inversion H; subst. inversion H0; subst. inversion H0. inversion H0. subst. inversion H0. inversion H0; subst; inversion H0; subst; subst. inversion H0; subst. inversion H0; subst. inversion H0; subst. inversion H0. subst. inversion H0; subst. subst. inversion H0; subst. inversion H; subst. inversion H; subst. inversion H0. inversion H0; subst. inversion H; subst.Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  destruct (H1 x); auto.\n  eapply star_trans with (T1); auto.\n  - eapply star_trans with (T1 := T1); auto.\n  - auto.\n    destruct (T1).\n    destruct (T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T2 T2 T2 T1 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T3 T2 T2 T2 T2 T3 T2 T1 T2 T2 T3 T1 T2 T2 T3 T2 T2 T2 T2 T2 T3 T2 T2 T4 T2 T2 T1 T4 T1 T4 T3 T3 T2 T3 T4 T4 T3 T3 T3 T6 T3 T2 T2 T5 T2 T3 T3 T3 T3 T3 T4 T6 T5Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  inversion H; subst.\n  inversion H; inversion H.\n  inversion H; subst.\n  inversion H; inversion H; subst.\n  inversion H.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H; subst.\n  inversion H; subst. inversion H; subst.\n  inversion H; subst.\n  inversion H. inversion H.\n  inversion H; subst.\n  inversion H0; inversion H; inversion H; subst.\n  inversion H0. inversion H1. inversion H1; subst. inversion H; subst. inversion H0; subst. inversion H0; subst.\n  inversion H. inversion H0. inversion H0; inversion H0.\n  inversion H0. inversion H0; subst; inversion H0; inversion H0; subst.\n  inversion H0; inversion H0. inversion H0; subst.\n  inversion H1; subst; subst. inversion H0; subst. inversion H0; subst; subst.\n  inversion H; subst. inversion H0; subst. inversion H0; subst.\n  inversion H; subst; inversion H0; subst. inversion H0;Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1.\n  induction 1.\n  - simpl; intros.\n  - subst.\n    - apply H.\n    - induction 1.\n    - intros.\n    - simpl.\n    - simpl; auto.\n    - rewrite <- app_cons.\n    - simpl in H.\n    - simpl in H.\n    - rewrite app_cons in H0.\n    - intros.\n    - simpl in H0.\n    - intros.\n    - rewrite <- H0.\n    - simpl in H0.\n    - unfold app_nil in H0.\n    rewrite app_cons in H0.\n    - rewrite app_cons in H0.\n      rewrite app_cons in H0 in H0.\n    - simpl in H0.\n    - subst.\n    - rewrite app_cons in H0.\n    - rewrite app_cons in H0.\n    - rewrite app_cons in H0 in H0.\n    - simpl in H0.\n    - simpl in H0.\n    - rewrite app_cons in H0.\n    rewrite app_nil in H1.\n    - rewrite app_cons in H0 in H0.\n    - rewrite app_cons in H0 in H1.\n    - H0.\n    - destructQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; auto.\n  intros.\n  inversion H; subst.\n  inversion H; subst; subst; auto.\n  inversion H; subst.\n  inversion H; auto.\n  inversion H; subst; subst.\n  inversion H.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H.\n  inversion H. inversion H0.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0. inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; inversion H; inversion H0.\n  inversion H0; inversion H0; subst. inversion H0; inversion H0; inversion H0; subst; inversion H0; clear H0.\n  inversion H0; subst; inversion H0; inversion H0; subst; subst; inversion H0; inversion H0; subst; subst.\n  inversion H0; subst. inversion H0. inversion H0. inversion H0. inversion H0; subst; subst; subst.\n  inversion H0; subst. inversion H0; subst; subst; subst; inversion H0. inversion H0; subst; subst; subst; inversion H0; subst; substQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H; subst; subst.\n  inversion H.\n  inversion H.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H; subst.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0; subst. inversion H0. inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; clear H0.\n  inversion H0; inversion H0; subst. inversion H0; subst. inversion H0; inversion H0; subst.\n  inversion H0; subst.\n  inversion H0. inversion H0; inversion H0; subst. inversion H0; subst; inversion H0; inversion H0; subst. inversion H0; subst; inversion H0; inversion H0; inversion H0; inversion H0; subst; subst; inversion H0; clear H; subst; inversion H0. inversion H0. inversion H0; subst; subst. inversion H0. inversion H0. inversion H0; inversion HQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; intros; try solve [auto] [auto] H0; auto].\n  inversion H0; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction H.\n  intros.\n  destruct (eq_dec_dec t) as [e' [e' [e' [e' [e' [e' [e' [e' [e' [e' [e' e' [e' [e' [e' [e' [e' [e' [e' [e' [v' [e' [e' [e' [e' [e' [e' [e' [v' [e''' [ [e' [v' [e' [v' [e' [e' [v' [v' [v'' [e' [v' [e' [e' [e' [v' [v' [e' [v' [v' [v' [v' [e' [v' [e' [v' [v' [v' [e'' [v' [v' [v' [v' [v' [v' [v' [v' [v' [v' v' [v'' [v' [v'' [v' [v' [v' [v' [vQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction 1; intros.\n  simpl.\n  - eapply IH.\n  - intros. apply IH. apply IH.\n  - destruct IH; eauto.\n    - simpl.\n      apply IH1; auto.\n      - apply IH1_app.\n      - auto.\n      - eapply IH1; eauto.\n      + intros.\n      + simpl.\n      + simpl.\n      + apply IH1.\n      - unfold subst.\n      - simpl; auto.\n      - simpl.\n      - apply IH1_cons.\n      - apply IH1_cons_cons_cons.\n      * simpl.\n      - eapply IH1.\n      - apply IH1_cons; auto.\n      + apply IH1_cons_cons_cons.\n      - apply IH2_cons.\n      * apply IH1.\n      * apply IH1.\n        + apply IH2.\n        apply IH1_cons_cons.\n      - simpl in IH1_cons in IH2.\n        - apply IH1_cons in IH1; auto.\n      + apply IH2_cons in IH1.\n      * simpl.\n        - apply IH2_cons in IH1.\n        + rewrite IH1_cons in IH1.\n      apply IH1 in IHQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; auto.\n  exists x; auto.\n  - intros.\n  - apply IH.\n    - apply IH.\n      apply IH.\n      * apply IH...\n    - apply IH; auto.\n      + apply IH.\n      - apply IH.\n      * apply IH.\n      - apply IH; auto.\n      - apply IH; auto.\n      - apply IH.\n      - apply IH IH.\n      apply IH.\n      - apply IH IH IH IH; auto.\n      apply IH IH_app; auto.\n      - apply IH IH IH.\n      apply IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IHQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros.\n  induction 1; intros.\n  destruct (IH1 s1).\n  exists (IH2)); simpl; auto.\n  apply IH1.\n  inversion_subst; auto.\n  constructor.\n  auto.\n  destruct (IHIH _ _ H1); auto.\n  subst; auto.\n  apply IH1; auto.\n  auto.\n(* ********************************************************************** *)\n  inversion H1.\n  intros.\n  intros.\n  apply IH. destruct IH1 as [IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction 1; simpl; auto.\n  eapply IH; eauto with arith.\n  + destruct H.\n    apply IH; eauto.\n    - eapply IH; eauto.\n    + intros.\n    apply IH.\n    - (*  - eapply IH; eauto.\n    - (* We need to the value *)\n    * (* TODO: *)\n    destruct IH.\n    - intros.\n    destruct IH as [n].\n      destruct IH]; simpl.\n    - eapply IH; eauto.\n      apply IH.\n      * eapply IH; eauto.\n      - intros.\n      * apply IH.\n      apply IH; eauto.\n      - (* simpl; eauto.\n      + eapply IH.\n      - (* t *)\n      simpl in IH.\n      + destruct IH.\n      - simpl in IH.\n      - (* t *)\n      - split.\n      - destruct IH; auto.\n      - destruct IH; auto.\n      * subst.\n      + simpl in IH.\n      - rewrite IH.\n      - split; auto.\n      - apply IH.\n      - rewrite IH.\n      - apply IH IH IH.\n      - intros [IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IH IHQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction H; intros; simpl; eauto.\n  inversion H.\n  apply IH.\n  - auto.\n  - inversion H; subst.\n    inversion H.\n    inversion H; subst.\n  - inversion H.\n    - subst.\n    inversion H.\n    inversion H. inversion H.\n    inversion H; inversion H0. inversion H; inversion H0; subst.\n    inversion H0. inversion H0; subst. inversion H0; inversion H0; subst. inversion H0.\n    inversion H0.\n    inversion H0; subst. inversion H0. inversion H0. inversion H0. inversion H0. inversion H0; subst. inversion H0; inversion H0. inversion H0; subst. inversion H0. inversion H0; subst. inversion H0. inversion H0; inversion H0; subst. subst. inversion H; inversion H0; subst. inversion H0. inversion H0. inversion H0; subst. inversion H0; inversion H0; subst. inversion H0; subst. subst. inversion H0. inversion H0; inversion H0; subst. inversion H0; subst. subst. inversion H0; inversion H0; inversion H0;Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  inversion H.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0; inversion H0; subst. inversion H0; inversion H0.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0; subst. inversion H0; subst; inversion H0; subst; subst; subst. inversion H0; subst. inversion H0. inversion H0; subst. inversion H0. subst. subst. inversion H0. inversion H0.\n  inversion H0. inversion H0; subst; subst; subst. inversion H0; subst; inversion H0; inversion H0; subst. inversion H0. inversion H0; subst. inversion H0. inversion H0; subst; subst. inversion H0; inversion H0; subst. inversion H0; subst; subst. inversion H; subst; subst. inversion H0; subst; subst. inversion H0; subst. inversion H; subst; subst; subst; subst. subst; substQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction E; intros; auto.\n  - intros.\n  - subst.\n    - (* return [eval_expr1] *)\n  - subst; auto.\n    - (* inductive type *)\n    destruct (typ T2 T1) as [subst T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T3 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T3 T3 T2 T2Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; eauto using t; eauto using.\n  apply_denote_closed; auto using wf_closed_closed; eauto using wf_closed; auto using wf_closed; auto using wf_closed_closed.\n\n\nLemma wf_closed_closed_closed : forall (T: env) (T: t2: env) (T: t2 t1 t1 t2) (T2: env) t2),\n  wf_closed t1 t2 T2 ->\n  wf_closed t1 t1 ->\n  wf_closed_closed t1 t2 t2 ->\n  wf_closed t1 t2 t2 t2 ->\n  wf_closed t1 t1 t2 t1 t1 t2 t2 t2 t2 t2 t1 t1 t2 t2 t2 t1 t2 t2 t1 t2 t2 t1 t1 t2 t2 t1 t2 t1 t t1 t1 t2 t2 t1 t2 t t2 t2 t2 t1 t2 t2 t2 t2 t1 t2 t2 t2 t2 t2 t t1 t2 t1 t t2 t2Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros; exists x1.\n  destruct x; split; auto.\n  exists (x1) as [x1 y2 y1 [x2 y2 y2 y3 y2 [x2 y3 y2 y3 y3 y3 y3 y3 y4 y3 y3 y3 y3 y3 y4 y3 y5 y3 y3 y7 y3 y3 y4 y5 y3 y3 z3 y4 y4 y3 y3 y8 z6 y8 y4 y8 y6 y7 y3 z7 y3 y6 y7 y8 y8 y7 y8 z6 y6 z6 y8 y7 y8 z7 z8 z8 z7 z8 z8 z6 z8 z9 z8 z9 z7 z6 z8 z8 z3 z9 z8 z3 z5 z8 z6 z7 z z8 z z7 z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  destruct e2; auto.\n  eapply wf_subst; eauto with (fun i => t => (fun i => i =>\n    end.\n  eapply wf_eq.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  destruct (t2) as [x1 x1 [x2 x2 x2 x2 x2 x2 x2] x2 x2].\n  generalize dependent_insert_insert_insert_insert_insert_insert_insert_insert_insert t2 x1.\n  Case \"insert_insert\".\n  red; auto.\n  destruct x2; auto.\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n(* Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n  Case \"insert\".\n(** Case \"insert\". *)\nRequire Import List.\nRequire Import List.\nRequire Import List.\nRequire Import List.\nRequire Import List.\nRequire Import List.\nRequire Import List. List. List. List.List. PermutationQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  apply in H.\n  assert (IHT1 := fun t2) (T.\n  apply (T2) t2); auto.\n  apply (T1 t2) t1 t2 t1 t2).\n  auto.\n  apply T.\n  apply H.\n  apply H.\n  apply IH.\n  apply IH; auto.\n  unfold closed_wrt_rec_rec.\n  apply le_rec.\n  apply le_rec.\n  apply le_exp_rec.\n  apply le_rec.\n  apply le_rec_rec_rec_rec_rec.\n  apply le_rec.\n  apply le_rec_rec_rec; auto.\n  apply le_rec; auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  unfold type_type; destruct H; eauto.\n  inversion H.\n  eauto using (subst_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh in H.\n  destruct_fresh_fresh_fresh_fresh_fresh in H0.\n  destruct (fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh infresh infresh_fresh infresh in Hfresh infresh_fresh in *.\n  destructfresh in *.\n  destruct H2 as [E [EE]; subst.\n  destruct (fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_freshfresh_fresh_freshfresh_fresh in *.\n  destructfresh_fresh_fresh_fresh_fresh in *.\n  destructfresh_fresh_fresh_fresh in *.\n  destruct (fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_fresh_freshfresh_fresh_fresh_freshfresh_fresh_freshQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction 1; auto.\n  apply IH.\n  auto.\n  intros.\n  eapply (IH _ _ H) (IHIHIHt2) (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  simpl; auto.\n  assert (T1 t2) by (apply (apply H1 t1); auto.\n  destruct H1; auto.\n  destruct H2; auto.\n  apply H; auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction e1; simpl; intros; auto.\n  unfold subst.\n  apply E2.\n  eapply expr_map_val; auto.\n  eapply expr_sound; eauto using expr_sound; eauto using expr_sound; eauto using expr_sound; auto.\n\n\nLemma subst_sound: forall t1 t1 t2 t1 t2 t2 t2,\n  subst t2 t2 t1 t2 ->\n  match t1 t2 t2 t1 t1 t2 t2 t2 t1 t2 t1 t2 t2 t2 t2 t2 t2 t2 t2 t2 t1 t2 t2 t2 t1 t3 t2 t3 t2 t2 t2 t1 t2 t2 t1 t2 t2 t2 t2 t2 t1 t1 t2 t3 t3 t2 t2 t2 t2 t1 t3 t t2 t3 t1 t2 t2 t1 t3 t2 t3 t3 t2 t3 t1 t1 t3 t t2 t2 t1 t2 t3 t2 t3 t3 t2 t1 t2 tQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction 1; simpl.\n  destruct H.\n  destruct (eq_dec_dec i); eauto.\n  - inversion H.\n  - intros. subst.\n  - intros.\n    - apply H.\n    - apply H.\n    - destruct (IH2) eqn:E2 as [H2].\n    - destruct H1 as [H2].\n    - apply H2.\n    - apply E; auto.\n    - apply E1.\n    - apply E.\n    - apply E1.\n    - apply E.\n    - destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  destruct (t2 T1 t2) as [[s2] [s2 [s2 [s2 s2] [s2] s2] [s2 [s2 [s2 [s2] [s2 [s3] [s2] [s2 s3 [s2 [s3 s2 [s3] s3 [s1 s2 [s2 [s1 s2 [s2 [s2 [s3 [s2 [s2 [s2 s2 [s2].\n\nLemma subst_typ_typ_typ:\n  forall t t1 t1 t1 t2 t2 t2 t2 t1 t2 t2 t2 t1 t2 t2 t2 t2 t2 t1 t2 t2 t2 t2 t2 t2 t2 t2 t2 t3 t1 t3 t2 t2 t2 t3 t2 t2 t2 t2 t1 t2 t1 t2 t1 t2 t2 t1 t2 t3 t2 t1 t2 t3 t3 t1 t1 t3 t3 t3 t1 t1 t3Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  unfold type_sort.\n  destruct (IH _ _ _ _ H).\n  eapply H.\n  + (* TODO: *)\n  + (* type *)\n    apply T2.\n    - (* we prove that the value, the term, it will be used to the type, the value of a tactic. *)\n    - simpl_wf with set of the value of the value of the term, the same value. *)\n    simpl_type_type.\n    rewrite T.\n    simpl.\n    simpl.\n    rewrite T.\n    rewrite T_type_type_type.\n    rewrite T_type_type.\n    apply T.\n    destruct T.\n    subst T; auto.\n    rewrite T.\n    simpl.\n    assert (T1 T2 T1 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T2 T1 T2 T2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  unfold bind_right.\n  rewrite bind_plus.\n  destruct (fold_right_right_right f (fold f)).\n  + simpl.\n    destruct (f x)).\n    rewrite bind_left.\n    rewrite bind_left.\n    simpl.\n    rewrite bind_right.\n    destruct (f x).\n    rewrite bind_right.\n    rewrite bind_right.\n    rewrite bind_right.\n    rewrite bind_right.\n      rewrite bind_right.\n    simpl.\n      simpl.\n      rewrite bind_right.\n      rewrite bind_right.\n    simpl.\n    destruct (f x)). simpl.\n    rewrite bind_right_right.\n    rewrite bind_right.\n    simpl.\n    rewrite bind_right.\n      simpl. simpl.\n    unfold bind_right.\n    simpl.\n    simpl. simpl.\n    simpl.\n    simpl. simpl.\n    simpl.\n    simpl.\n    simpl bind_right.\n    simpl.\n    rewrite bind_left.\n    simpl.\n    simpl.\n    rewrite bind_right.\n    rewrite bind_right. simpl.\n      simpl.\n    simpl.\n    simpl.\n    apply bind_right.\n    simpl.\n    simpl.\n    rewrite bind_right.\n    simpl.\n    simpl.\n    simpl.Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros; auto.\n  - simpl in *; simpl in |- *; auto.\n  - rewrite <- beq_false; auto.\n  - subst.\n    + rewrite <- beq_nat_nat_nat.\n    - rewrite beq_nat_nat_nat_nat.\n    - simpl.\n    rewrite beq_nat_nat.\n    - rewrite beq_nat_nat.\n    - simpl in *.\n    rewrite beq_nat_nat_nat_nat.\n    - simpl.\n    rewrite beq_nat_nat_nat_nat.\n    rewrite beq_nat_nat_nat_nat_nat_nat.\n    - simpl in *.\n    + simpl in *.\n    + destruct (nat_nat x)).\n    + rewrite beq_nat_nat_nat_nat.\n    - simpl.\n    - simpl.\n    + simpl in *.\n    - simpl in *.\n    + simpl in *.\n    - simpl in *.\n    - simpl in *.\n    - simpl in *.\n    - destruct (nat_nat n)).\n    - simpl in *.\n    rewrite beq_nat.\n    - rewrite beq_nat_nat_nat.\n    - destruct (nat_nat_nat_nat_nat 0) (nat n)).\n    - simpl in *.\n    - rewriteQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction 1; simpl; auto.\n  + simpl; auto.\n  + rewrite <- beq_one.\n  + rewrite leb_one.\n    + apply beq_one.\n      + rewrite leb_one.\n    + rewrite leb_one_one.\n    * simpl; simpl.\n    - simpl in *.\n    - simpl.\n    + rewrite leb_one.\n    rewrite leb_one.\n    + simpl in *.\n    + destruct (eq_one (eq_one_one (eq_one a) - e)) as [x|x|x] [x] eqn:E].\n    * rewrite beq_one.\n    * x; auto.\n    * rewrite beq_one.\n    + rewrite beq_one.\n    + rewrite beq_one.\n    + rewrite beq_one.\n    * rewrite beq_one.\n    + rewrite beq_one_one.\n    - simpl.\n    + simpl.\n    + simpl in *.\n    - destruct (beq_one (beq_one a) eqn:E.\n    rewrite beq_one_one_one.\n    * simpl in *.\n    - rewrite beq_one.\n    simpl.\n    + simpl in *.\n    - rewrite beq_one.\n    simpl.\n    + destruct (Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  apply add_assoc.\n  - apply add_left_left.\n  + apply add_one.\n    + apply add_one.\n    + apply add_one.\n    - auto.\n    * apply add_one.\n    + apply add_one.\n    + apply add_one.\n    * apply add_one.\n    + apply add_one.\n    + apply add_one.\n    + apply add_one.\n    - apply add_one_one_one.\n    - apply add_one.\n    - rewrite add_one.\n    + rewrite add_one.\n    - rewrite add_one_one.\n    - simpl.\n    rewrite add_one.\n    - rewrite add_one_one.\n    rewrite add_one_one.\n    - rewrite add_one.\n    rewrite add_one_one_one_one_one_one_one.\n    rewrite add_one_one.\n    - rewrite add_one.\n    rewrite add_one.\n    - rewrite add_one_one.\n    simpl.\n    rewrite add_one.\n    - destruct (one. rewrite add_one.\n    rewrite add_one. rewrite add_one_one.\n    rewrite add_oneQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\ninversion_clear; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  induction 1; simpl; simpl in *.\n  destruct (find x); simpl; auto.\n  destruct x.\n  destruct x).\n  destruct x.\n  destruct x; simpl; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nelim (map (fold f g) (fold f) (fold f) (fold f g x)) (fold f x) (fold f) (fold f x)).\napply f) (fold f (fold f) (fold f x)).\napply f (fold f x x)).\nrewrite <- f f f x f_equal.\napply f_equal.\nrewrite f_equal.\nrewrite f_equal f_equal.\nrewrite f_equal.\nrewrite f_equal.\napply f_equal f_equal.\napply f_equal.\nrewrite f_equal.\napply f_equal.\napply f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\nrewrite f_equal.\napply f_equal.Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  destruct (fn_one x e); simpl.\n  destruct e; simpl; simpl; auto.\n  + destruct e; auto.\n  - destruct e; auto.\n    + destruct e; auto.\n    destruct e; auto.\n    + rewrite e; auto.\n      - simpl; auto.\n    - simpl; auto.\n      * auto.\n    + rewrite <- H.\n      * destruct e; auto.\n      - subst e.\n      * apply IHl.\n      rewrite <- e; auto.\n      * auto.\n      * auto.\n      + rewrite <- e; auto.\n      + simpl.\n      + rewrite <- e; auto.\n      + rewrite e; auto.\n      + auto.\n      rewrite e; auto.\n      * apply IHl; auto.\n      * simpl.\n      * apply IHl; auto.\n      - rewrite (IHl e).\n      rewrite e.\n      + rewrite e; auto.\n        + rewrite <- e; auto.\n      + rewrite e.\n        * apply e; auto.\n        + rewrite e.\n        rewrite e0.\n      + simpl.\n      * e.\n      * apply e; auto.\n      rewrite e1; auto.\n      * intros e.\n      + apply e1.\n      rewrite e1.Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  rewrite <- E.\n  rewrite E_one_one.\n  rewrite E_one.\n  rewrite E_one.\n  rewrite E_one.\n  rewrite E_one_one.\n  rewrite E_one_one.\n  rewrite E_one.\n  rewrite E_one.\n  rewrite E_one.\n  rewrite E_one.\n  simpl E.\n  rewrite E.\n  rewrite E_one.\n  rewrite E_one.\n  rewrite E E.\n  rewrite E_one.\n  rewrite E E.\n  rewrite E E E E E.\n  rewrite E E E E E_one.\n  rewrite E E.\n  rewrite E_one E.\n  rewrite E E E E E E.\n  rewrite E E E E E E E E E E E E E E E E.\n  rewrite E.\n  rewrite E E E E E E E E E E E E E E.\n  rewrite E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  induction 1; simpl; simpl.\n  - simpl.\n  - simpl; intros; simpl.\n  - simpl.\n    - simpl.\n    - simpl; simpl.\n    - simpl.\n    - rewrite <- andb_false_true_true_false_true.\n      - rewrite!true by auto.\n    - simpl.\n    - simpl.\n    - simpl.\n    - unfold expr_false_true_true_true by auto.\n    - rewrite PTree.gso by auto.\n    - simpl.\n    - simpl.\n    - rewrite PTree.gss.gso by auto.gso by auto.\n    - unfold PTree.gso by auto.\n      - intros.gsspec.\n    rewrite PTree.\n    -gso by (peq b); auto.\n    - rewrite PTree.gso by auto.gso; simpl.\n    - rewrite PTree.gss.gso by auto.\n    + simpl; auto.\n    - rewrite PTree.gss.gso by auto.\n    - rewrite PTree.gso by auto.gso by auto.\n    + simpl.gso by auto.\n    + rewrite PTree.gso by (rewrite PTree.gss.gso by auto.\n    + unfold PTree.\n    + unfold PTree.gso by auto.gso by auto.\n    + unfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  destruct (f x) as (f x).\n  destruct (f x) as (f x)).\n  assert (f x)).\n  destruct (f x)).\n  assert (f x).\n  destruct x); auto.\n  assert (f x).\n  { rewrite <- f (f x).\n  assert (f x).\n  eapply H1_equal.\n  assert (f x1 x).\n  assert (f x).\n  assert (f x).\n  apply f x).\n  assert (f x0 x).\n  assert (f x0 x0).\n  { unfold bind_equal; auto.\n  { apply bind_equal; auto. }\n  assert (f x0 x0 x0).\n  { rewrite bind_equal.\n  { apply bind_f_equal. }\n  assert (f x0 x0).\n  { eapply bind_equal.\n  { split. }\n  assert (f x0 x0 x0 x0 x0 x0).\n  { rewrite bind_equal. }\n  apply bind_one.\n  { apply bind_one. }\n  }\n  { apply bind_one. }\n  assert (f x0 x0) (f x0 x0 x0Qed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  unfold not_one; auto.\n  apply H.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  destruct (fold_one x); subst.\n  destruct x; simpl.\n  - subst; auto.\n  + destruct (fold_one x); auto.\n  - rewrite H.\n  - destruct (fold_left_left_right_right_left_right. rewrite H0.\n    + intros.\n    * apply IHl.\n    + destruct (fold_right_left_left_left _ H0).\n    - rewrite <- H0.\n    + rewrite <- H0.\n    + destruct H0.\n    + destruct H0.\n    + rewrite <- H0.\n    + rewrite <- H0_left.\n    + simpl.\n    + destruct (right_left_right_left_left_left_left.\n      + rewrite <- H0.\n      + rewrite <- H0.\n      + rewrite <- H0.\n      - apply H0.\n      + rewrite <- H0_left.\n      rewrite <- H0.\n      + rewrite <- H0.\n      + rewrite <- H0.\n      + rewrite <- H0_left.\n      + rewrite <- H0.\n      + rewrite <- H0.\n      + rewrite <- H0.\n        rewrite <- H0.\n      rewrite <- H0.\n      rewriteQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros; simpl.\n  destruct x; try discriminate.\n  destruct x; try discriminate.\n  - destruct x; auto.\n  + destruct x; try discriminate.\n  - destruct (rewrite (rewrite <- H0_eq_eq_eq x); auto.\n  + destruct x; auto.\n  - simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  rewrite (fold_right_left f).\n  rewrite <- H.\n  rewrite <- H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  destruct (f x) as [n1].\n  - 1; simpl.\n  - 1; simpl.\n  - simpl.\n  - simpl.\n  - 1.\n  - simpl.\n    destruct (find x).\n    - split; auto.\n    - rewrite add_left; auto.\n    - intros.\n    - simpl.\n    - 1; auto.\n    rewrite add_right.\n    - rewrite add_assoc.\n    - intros.\n    - rewrite add_assoc.\n    - rewrite add_assoc.\n    - rewrite add_assoc.\n    rewrite add_assoc.\n    - rewrite add_assoc.\n    - rewrite add_assoc.\n      rewrite add_assoc.\n      rewrite add_assoc.\n      - rewrite add_assoc.\n      - add_assoc.\n    - rewrite add_assoc. rewrite add_assoc.\n      - rewrite add_assoc.\n      - rewrite add_assoc.\n      - add_assoc.\n    + rewrite add_assoc.\n    - add_assoc.\n      + rewrite add_assoc.\n      * rewrite add_assoc.\n    rewrite add_assoc.\n      -add_assoc. rewrite add_assoc.\n      -add_assoc.\n    - intros.\n      rewrite add_assoc.\n       Qed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  unfold Rdiv.\n  destruct (fold_left_right (fun x => f x) (fold f).\n  apply (fun x => f x => f y)) f (fun x).\n  apply f x).\n  rewrite <- (fold_right f (fold f x (fold f x) (fold f x x).\n  rewrite <- f x)).\n  apply f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  apply f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite f_equal.\n  rewrite <- f_equal f_equal.\n  rewrite f f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite map_equal.\n  rewrite f_equal.\n  rewrite <- f_equal.\n  rewrite <- f_equal.\n  rewrite map_equal.\n  rewrite <- map_equal.\n  rewrite map_equal.\n  rewriteQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  destruct (map_map_right (map_right_right_right (map_left_left_left (map f) e).\n  destruct (map f e)).\n  rewrite fold_right.\n  rewrite <- map_right.\n  apply map_right; auto.\n  destruct (map f).\n  destruct e as [x e].\n  exists (map f e).\n  destruct e; simpl; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  rewrite map_distr_distr.\n  rewrite map_distr_distr_distr_distr.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  repeat rewrite map_add_assoc.\n  apply map_comm.\n  rewrite map_distr_distr_distr_distr_distr.\n  rewrite map_assoc.\n  rewrite map_distr_assoc.\n  rewrite map_assoc.\n  apply map_assoc.\n  rewrite map_comm.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n  rewrite map_assoc.\n Qed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nintros.\ndestruct o; simpl; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  simpl in *.\n  destruct (f_equal f); auto.\n  rewrite H0.\n  destruct (f x); auto.\n  destruct x; auto.\n  rewrite H0.\n  rewrite <- (f x); auto.\n  destruct (f x); auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  unfold raw_right; auto.\n  destruct (x =? 0).\n  destruct (x =? 0); auto.\n  destruct (y); auto.\n  destruct (x * y) as [x]) eqn:E].\n  destruct (x); destruct (y == 0); auto.\n  destruct (y + y); auto.\n  + destruct (y); auto.\n  + destruct (y); auto.\n    destruct (y); auto.\n    destruct (x + y); auto.\n      destruct (x + y); auto.\n      * rewrite <- (x * x * y); auto.\n    - destruct (x * y) as [x * y)); auto.\n    + rewrite <- H.\n      rewrite <- (y * y); auto.\n      * rewrite <- (x * y) by auto.\n      rewrite <- H0_assoc.\n    rewrite <- H0_assoc.\n      rewrite <- H0_assoc.\n      rewrite <- H0.\n      rewrite <- H0.\n      rewrite <- H0.\n      rewrite <- H0.\n      rewrite <- (x * y)).\n        rewrite <- (y * rewrite <- H0.\n      rewrite <- (x + y).\n      rewrite <- H0_assoc.\n       Qed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  unfold raw_one in *; intuition.\n  destruct (x, x).\n  destruct (x :: x) as (x :: x)).\n  destruct x) as [[x y]; auto.\n  destruct (x,(y,(y,(x,(x,(x,(y,(x,(y,(y,(y,(,(x,(,(y,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(,(Qed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nintros.\nunfold raw_left...\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  intros.\n  rewrite (proj1 e).\n  destruct e; auto.\n  apply In_left_left_right; auto.\n  eapply notin_one.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nintros.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  apply T.\n  rewrite one_one.\n  assert (x <> 0).\n  assert (y < x).\n  { apply (x + {x + x + x + x + x + x + x + x + x + x + x + y + {x + {x + x}.\n  destruct x + {x + x + {x + {x + {x + {x + {x + {x + {x + {x + {x + {x + {x + {x + {x} + x} + {x} + {x + {x + { { {x + {x} + {x} + {x} + { {x + { { {x} { {x : {x + {x : {x} { {x} + {x} { {x} { { {x} + {x} + {x} + {x + { {x : { { {x} { { { {x} { { {x y} {x} {x}} {x : {x} {x} {x}} { {x} {x} {x} {x} {x : {Qed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  unfold raw_right; simpl in *.\n  destruct (fold_left_right_right (fun x => P x).\n  rewrite H.\n  rewrite (fun x => x => x) (fun x => x).\n  destruct (fun x => x) as [x y) x => x x => x => x; auto.\n  destruct (x, y) => x.\n  destruct x); auto.\n  destruct x; auto.\n  destruct (x, x); auto.\n  destruct (x,y,y,y,y,x,y,y,y,y,y,y,x,y,x,y,y,x,x,y,y,x,y,y,y,y,x,x,x,x,x,x,y,y,x,x,y,y,x,y,x,x,x,y,x,y,x,x,x,x,x,,x,x,y,x,x,x,x,y,y,y,y,x,x,y,x,x,x,x,x,x,x,xQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; simpl; simpl; simpl; auto.\n  rewrite (right; auto.\n  rewrite H; auto.\n  rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct (eq_right (elements_right (elements m e) as [x] e' e') as [x'' [x' x' x' [x' [y'x' y' x' x' x' y' x' [y' [y' [x' x' [x' x' x' y' x' [x'' [y' [x' y' y' y' y' x' x' x' x' x' x' x' x'' y'' y'''' x' [x' [y' [x' [y' [x' y' y' y' y' y' x' [x' y' x' x' y' x' x' y'''' y' y'' x' x''''' x' x'''''' x' x'''''''' x' x''' y' x'''' x'''''' x'''''''''''''''''''''''''' x'Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  rewrite raw_left_left.\n  rewrite raw_left.\n  rewrite raw_left.\n  rewrite T_left_left. apply raw_left.\n  apply raw_left_left_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_right.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_right_left.\n  apply raw_left.\n  apply raw_left_left.\n  apply raw_right.\n  apply raw_left_left.\n  apply raw_left_right_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left.\n  apply raw_left_left_left.\n  apply raw_left_right.\n  apply raw_left.\n  apply raw_left_left_right.\n  apply raw_left.\n  apply raw_left.\n  apply raw_leftQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_right; intros.\n  rewrite raw_left; simpl; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_left.\n  rewrite (insert_left (fun e => x => T => x e => x e) (insert x) (insert x e) (insert_insert x) (insert_insert e)).\n  apply (insert_insert x e)) in H.\n  rewrite (insert_insert_insert_insert_insert x e e) in H.\n  apply x e.\n  rewrite <- insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x l).\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\nProof.\n  intros.\n  intros.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof. reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold Raw.\n  destruct (x:=x:=x:=x:=y:=x:=x:=x:=x:=x:=x:=x:=y).\n  rewrite In_x:=y in H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  apply Raw.add_add_one.add_comm.add.add.\n  rewrite Raw.add_comm.add_add_assoc.add_comm.\n  rewrite Raw.add_assoc.add_assoc.add_assoc.add.add_assoc.add.add_add_comm.\n  rewrite Raw.add.add_add.add_comm.add.add.add_assoc.add.add_add_add_comm.\n  apply Raw.add.add.add.add_add.add_add_add_add.add_add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Raw.add_add.add_add_add_add_add_add_add_add.add.add_add_add_add_add_add_add_add_add_add_addQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  induction 1; reflexivity.\n  intros; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\n  eapply H.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  eapply Raw.\n  destruct (insert_insert_insert_tree_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x).\n  eapply insert_insert.\n  + rewrite insert_insert_insert_insert_insert_insert.\n  + intros.\n  + inversion H0. subst.\n    - subst.\n  + rewrite elements_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      * apply insert_insert_insert_insert_insert_insert_insert.\n      * (insert_insert_insert_insert_insert_insert_insert_insert x).\n      unfold insert_insert.\n      rewrite insert_insert_insert_insert.\n        apply insert_insert_insert_insert_insert_insert.\n        rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      unfold insert_insert_insert_insert_insert_insert_insert_insert.\n      intros.\n        apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply below_insert; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e.\n  destruct e; try discriminate.\n  destruct e; try discriminate.\n  destruct e; try discriminate.\n  inv H; auto.\n  destruct e; simpl in H.\n  subst e; simpl in H; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; inv H; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct (remove_left_insert_eq_eq_dec x).\n  rewrite In_1.\n  destruct (remove x).\n  + destruct e; auto.\n    destruct e; auto.\n    + destruct e; auto.\n    - destruct e; auto.\n    + destruct e; auto.\n    - destruct e; auto.\n      destruct e; auto.\n      - destruct e; auto.\n      destruct e; auto.\n      - subst.\n      * destruct e; auto.\n      + destruct e.\n      simpl; auto.\n      + destruct e.\n      + destruct e; auto.\n      + destruct e; simpl in e; auto.\n      + subst e; auto.\n      destruct e; auto.\n      - destruct e; auto.\n      - destruct e; auto.\n      destruct e; auto.\n      - destruct e; auto.\n      + subst e.\n      - subst e.\n      - (* a = e *)\n      destruct e; auto.\n      destruct e; auto.\n      * destruct e; auto.\n      destruct e; auto.\n      + destruct e; auto.\n      - destruct e; auto.\n      * auto.\n      * intros e.\n      + simpl.\n      + destruct e; auto.\n      *Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  unfold raw_right.\n  rewrite In_eq.\n  destruct (is_insert_insert_insert_right_insert_insert_insert_insert x) eqn:E.\n  simpl.\n  destruct (insert_insert x) eqn:E.\n  - destruct e. destruct e as [E].\n  + destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x).\n    rewriteinsert; auto.\n    destruct (insert_insert x) eqn:E.\n      destruct t; destruct E; simpl; auto.\n      destruct E; auto.\n      destruct E; auto.\n      destruct E; auto.\n      destruct E; auto.\n      apply E.\n      destruct E.\n      destruct E.\n      * destruct E; auto.\n      destruct E as [E E.\n      destruct E.\n      destruct E E E E E E E E E E E; auto.\n      destruct E E E.\n      destruct E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply H.\n  apply (H := e).\n  apply raw_left_right.\n  apply raw_left.\n  apply raw_left.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply raw_intro.\n  unfold Raw.\n  apply Raw.eq_eq.\n  apply Raw.eq_bool_bool_sym.In.eq_bool_bool_bool.eq.eq.\n  apply Raw.eq.eq.In_bool.add_eq.add_bool_bool.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e.\n  destruct e; simpl in *; auto.\n  destruct e; auto.\n  destruct e; auto.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold lookup_empty.\n  unfold lookup_empty.\n  unfold lookup, In, add_empty.\n  unfold map, In, map_empty.\n  destruct (find_right_empty_empty_empty_empty).\n  destruct (empty_1 x) as [l2] eqn:E2 |E1 |E1]; subst.\n  destruct (find_empty_empty_empty; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.empty A) (remove x (remove x) (remove x) (remove x) (remove x).\nProof.\n intros. destruct e as [k [k [k [k | k k k k k e] k] [k [k k] k].\n  destruct k; auto.\n  - k; auto.\n  - (* In the list of [k] *)\n  + { destruct k. }\n  destruct k; simpl; auto.\n  - destruct (remove k e); inv H; auto.\n  + intros k; auto.\n  - destruct k e; auto.\n  - apply H.\n    - intros k; auto.\n    - destruct (find_find_find k e); auto.\n    - destruct k; auto.\n    - split; auto.\n    - intros k; auto.\n    - rewrite!find_find_find_find_find_find_find_find_find_find_find_find_find_find_find_find_find_find_find k e; auto.\n      + intros k; auto.\n    + rewrite!find_find_find_find_find_find_find_find_find_find_find_find_find_find_find_Qed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct (In x).\n  destruct (In x); auto.\n  destruct (In x); auto.\n  destruct (In x).\n  destruct (In x); auto.\n  destruct (In x); auto.\n  inv H0.\n  destruct (In x); auto.\n  destruct x); auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold In in *.\n  unfold In in *.\n  destruct (insert_insert_insert_insert x e).\n  destruct (insert_insert_insert x e).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert _ _insert_insert x); auto.\n  destruct x; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  rewrite insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert x e insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  destruct H; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x t) (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert).\n  destructinsert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  apply In_empty_empty.\n  destruct (empty_empty_empty_empty_empty_empty_empty.empty_empty_empty.empty_empty.\n  intros.\n  destruct e as [E [E [E [E E]].\n  exists E; auto.\n  + exists (empty E); auto.\n  + subst.\n  + subst.\n  + destruct E.\n  + rewrite E; auto.\n    + split; auto.\n    + destruct E.\n    - destruct E; auto.\n  + auto.\n    - destruct E as [E E].\n    + destruct E].\n    + destruct E.\n    * subst E.\n      exists E.\n    + exists E; auto.\n      + exists E.\n    - exists E. destruct E; split; auto.\n      + split; auto.\n      - exists E.\n    - exists E.\n      + exists E; split; auto.\n    - exists E.\n      - exists E; split; auto.\n    + split; auto.\n    - exists E; auto.\n    split; auto.\n    + apply E; auto.\n    - destruct E.\n    - (* In the initial states *)\n    - exists E. *)\n    split; auto.\n     Qed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; destruct x; try congruence.\n  destruct x; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct e; simpl in *.\n  destruct e; congruence.\n  destruct e; congruence.\n  apply H.\n  destruct e; auto.\n  destruct e; congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold In_empty.\n  destruct (empty_empty_empty_empty (empty_empty _ _ H).\n  destruct (empty _ _ H); auto.\n  eapply In_empty_empty_empty; eauto.\n  eapply E.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros; destruct x; inv H.\n  destruct (map_empty_iff _ _ _ H).\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H; simpl in H; auto.\n  destruct H.\n  inv H; auto.\n  simpl in H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  rewrite <- insert_empty; auto.\n  apply insert_empty.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; intros.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  destruct (remove x) as [ | | | [ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  induction x; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  simpl; auto.\n  + auto.\n  + simpl; auto.\n  + apply wf_cons_alt; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  unfold lookup_empty; simpl; auto.\n  intros.\n  rewrite <- insert_empty; auto.\n  rewrite <- insert_empty_empty_empty_empty.\n  rewrite insert_empty; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; rewrite <- insert_empty.\n  destruct x; simpl in *.\n  destruct y; auto.\n  rewrite E; auto.\n  rewrite E; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  destruct x; auto.\n  destruct (split; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  induction a; intros; auto.\n  induction (insert_empty_empty_empty_empty A); auto.\n  rewrite <- (empty_empty_1 x).\n  - destruct (empty_empty x) as [r [r] eqn:E1].\n    - destruct (eq_empty_empty_empty_empty_empty_empty x); auto.\n  - rewrite <- E.\n    - auto. destruct (empty_empty (empty_empty_empty _ _ E).\n    - destruct E.\n    + destruct E; auto.\n    + destruct E as [E E].\n    - destruct E].\n    - destruct E.\n    - rewrite E.\n    - rewrite E_empty_empty_empty_empty.\n      + inversion E; auto.\n    + destruct E.\n      - destruct E.\n    - destruct E.\n      - destruct E as E.\n      - rewrite E.\n      + rewrite E_empty_empty_empty in E.\n      - destruct E as E.\n      - destruct E.\n      - destruct E E E; auto.\n      + destruct E.\n      - subst E; simpl.\n        - destruct E.\n      - destruct E.\n      - destruct E E E.\n      - destruct E; simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl in *.\n  unfold lookup_empty; simpl; simpl; destruct x; auto.\n  destruct x; simpl; auto.\n  - simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros; simpl; intros; auto.\n  rewrite H.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct (H0); auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct x; try congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct x; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction 1; simpl; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  unfold lookup, lookup_empty.\n  destruct e; auto.\n  destruct e; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros; intros.\n  destruct (k,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,v,vv,vv,vvv,vv,v,v,vvvvv,vv,vvvv,v,v,vvv,vv,v,v,vvv,v,v,v,v,vvv,vvvv,vvvv,v,v,vvvvvvvv,vvvvvv,vv,vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct x; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros; simpl; congruence.\n  destruct e; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct e; simpl in H; simpl; auto.\n  destruct e; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (t, t).\n  rewrite <- insert_insert_eq_insert_insert_insert_insert_insert_insert_insert; [insert_insert_insert; auto].\n  - apply insert_insert_insert_insert; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (t, t) as [t' [t' [t' [t' t' [t't' t'] [t' t' [t' t' [t' t' t' t' t' t' t' t'' t'''] H' t' t' t'' t'' t'' [?t' t'' t' t'' t'' [?t' t'' t'' t'' t'' t'' t''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. rewrite H.\n  destruct H; auto.\n  destruct H; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (insert x) as [x].\n  destruct (insert x) as [[x y | x y].\n  destruct (insert_insert x).\n  destruct (insert x) as [[y [x y].\n  destruct (insert_insert x); destruct (insert_insert_insert x); auto.\n  simpl in *; destruct (insert x y); auto.\n  destruct (insert_insert_insert x); auto.\n  destruct (insert_insert x); destruct (insert_insert_insert x y); auto.\n  destruct y; auto.\n  destruct (insert x); auto.\n  destruct (insert_insert_insert x); auto.\n  destruct x; auto.\n  rewrite insert_insert_insert; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct (insert x); auto.\n  destruct (insert_insert y; auto.\n  destruct x) as [x y; auto.\n  destruct (insert_insert_insert_insert y); auto.\n  destruct (insert x); auto.\n  destruct (insert_insert_insert x) as [insert; auto.\n  destruct (insert_insert y); auto.\n  destruct x; auto.\n  destruct (insert_Qed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (t1) as [t1]].\n  destruct e2; try discriminate. rewrite In_right; auto.\n  apply In_right; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros; simpl; simpl; reflexivity.\n  apply In_insert_insert; auto.\n  apply In_insert_insert.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  apply insert_insert_insert_insert_insert; reflexivity.\n  destruct (insert_insert_insert_insert x (insert_insert x) as [insert x y.\n  simpl.\n  destruct (insert_insert x) as [insert y].\n  destruct x as [insert_insert x. destruct (insert_insert_insert_insert x) as [insert_insert x).\n  destruct (insert_insert_insert x t).\n  destruct (insert_insert_insert_insert_insert x) as [insert_insert; destruct y; inv H.\n  destruct H; destruct (insert x); eauto.\n  destruct (insert_insert x) as [insert; inv H.\n  destruct (insert_insert x); auto.\n  destruct H; auto.\n  destruct (insert_insert_insert_insert xinsert x).\n  destruct (insert_insert_insert_insert_insert x); auto.\n  destruct (insert_insert_insert x); auto.\n  destruct (insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert x y); auto.\n  destruct t; auto.\n  destruct (insert_insert_insert x); auto.\n  destructQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction e; intros e; simpl; simpl; simpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros; try omega.\n  destruct e; auto.\n  unfold lookup.\n  destruct (compare x y e); auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  exists e; auto.\n  destruct e; auto.\n  simpl; auto.\n  rewrite InA_r; auto.\n  rewrite InA_empty.\n  apply InA_empty.\n  apply InA_empty_empty_empty.\n  destruct e; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction e; simpl; intros; auto.\n  generalize (t x e); auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite insert_eq e; auto.\n  rewrite insert_insert; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; simpl in *; omega.\n  simpl.\n  rewrite <- insert_empty.\n  auto.\n  destruct x; auto.\n  simpl; rewrite <- insert_empty; auto.\n  rewrite insert_empty_empty.\n  rewrite insert_empty.\n  rewrite insert_empty_empty.\n  destruct (empty_empty x); auto.\n  rewrite insert_empty; auto.\n  destruct y; simpl; auto.\n  apply insert_empty_empty; auto.\n  apply insert_empty. rewrite insert_empty_empty_empty; auto.\n  destruct (empty x y); auto.\n  destruct (empty_empty_empty; auto.\n  destruct x); auto.\n  destruct y; simpl; auto.\n  destruct x; simpl; auto.\n  destruct y; destruct x y; auto.\n  destruct y; auto.\n  destruct (empty_empty x y; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros x y.\n  unfold lookup.\n  rewrite lookup_empty; auto.\n  rewrite <- lookup_iff; auto.\n  rewrite lookup_empty.\n  rewrite lookup_empty_empty.\n  apply lookup_empty_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty_empty.  rewrite lookup_empty; auto.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty_empty.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct (S x); destruct e; omega.\n  inv H.\n  destruct e; omega.\n  destruct e; auto.\n  inv H; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  unfold lookup.\n  intros.\n  rewrite lookup.\n  rewrite map_empty.\n  destruct (remove_rev y).\n  destruct x as (k,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,EE,E,E,E,E.E.E,E,E,E,E,E,E,E,E,E,E,E,EE,E,E,E,E,E,EE,E,E,E,E,E,EE,E,E,E,EEE.E,E,E,E,E,E,E.E,E.E.E,E,E,EE,E E E, E E.\nProof.\n  unfold empty_empty. destruct E,E as [EE].\n  destruct E E E E E E E E EQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  unfold lookup; intros.\n  simpl; rewrite <- lookup.\n  destruct e.\n  destruct e; auto.\n  destruct e; destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite PTree.\n  destruct e; auto.\n  destruct e; auto.\n  apply PTree.gsspec.gss.gso; auto.\n  destruct e; auto.\n  destruct e; auto.\n  unfold lookup; auto.\n  rewrite PTree.\n  destruct e; auto.\n  rewrite PTree.gsspec.gsspec.gsspec.gss.\n  destruct e; auto.\n  rewrite PTree.gsspec; auto.\n  rewrite PTree.gsspec; auto.gso by auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct (t x) as [n' [n' [n' [m' [n' [m' [m' | [m''' [m' [m' [m' [m' [m'' [m' [m''] [??]]]].\n  exists m' m' m'' m' m').\n  exists m'; exists m'.\n  exists (k',e', e' m',k',k',k'',k',k',e'',k',k',k',k',k'',k',k',k',k',',k',k',k',k',k'',',k'',k',k',',k',k',',',',',k',k',',',',',',',k',',k',',',',',',',',',',',',k',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  eapply find_right; eauto.\n  rewrite <- lookup_empty_elements; eauto.\n  assert (x: t) = Some x.\n  destruct (t, t) as [x] t]; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x.\n  - subst; simpl; auto.\n  - apply elements_lookup; auto.\n  - intros; simpl; auto.\n    - destruct (x y); auto.\n    apply lookup_map_assoc; auto.\n    + rewrite <- insert_empty; auto.\n    + intros; auto.\n    + rewrite insert_empty_empty.\n    - simpl; simpl; auto.\n    + rewrite In_empty_empty_empty; auto.\n    - rewrite insert_empty_empty.\n    - simpl.\n    - destruct t.\n    - destruct t; simpl in *.\n    + rewrite insert_empty_empty.\n    - destruct t0; auto.\n    - rewrite insert_empty_empty_empty_empty_empty.\n    - rewrite insert_empty_empty_empty.\n    - destruct t0.\n    - rewrite insert_empty_empty.\n    - apply insert_empty_empty.\n    - simpl.\n    - destruct t0.\n    - apply insert_empty_empty_empty_empty.\n    - rewrite insert_empty_empty_empty_empty.\n      * apply insert_empty; auto.\n      - rewrite insert_empty_empty_empty_empty_empty; auto.\n      * apply insertQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  apply (insert _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  intros.\n  rewrite lookup_lookup.\n  destruct (H H).\n  unfold lookup_insert_insert_insert_insert_insert; intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H) as [ | | ] ]\n    destruct H; inv H.\n  + destruct H; try discriminate H; inv H; inv H; auto.\n  + inv H; auto.\n    + inv H.\n    - destruct H; inv H; inv H; inv H; inv H; auto.\n    + inv H; inv H.\n    inv H.\n    inv H.\n    inv H.\n    inv H; inv H; inv H. inv H.\n    inv H; inv H; inv H. inv H. inv H. inv H0; inv H. inv H. inv H. inv H. inv H. inv H. inv H. inv H. inv H; inv H. inv H. inv H. inv H. inv H. inv H. inv H; inv H; inv H; inv H; inv H. inv H. inv HQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  induction 1; destruct (remove_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty _ _ _ _ _ _ _ _ _ _ _ H).\n  destruct H0 as [x].\n  destruct (empty_empty_empty _ _ H.\n  destruct H0); simpl in H0; auto.\n  destruct H0; inv H0.\n  destruct H0; simpl in H0; auto.\n  destruct H0; destruct H0; auto.\n  apply E; auto.\n  destruct (empty_empty_empty_empty_empty _ H0); auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\nrewrite map_empty_insert_empty.\nrewrite lookup_map_empty.\nrewrite.\nrewrite map_empty_empty.\nrewrite map_empty.\nrewrite map_empty_empty_empty_empty_empty.\nrewrite map_empty.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros. destruct h; destruct h; intros; simpl; simpl; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  rewrite find_insert_empty_spec; auto.\n  destruct (remove_insert_insert_insert _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  induction l; simpl.\n  destruct l; destruct l; simpl; simpl; auto.\n  destruct l; simpl; simpl; simpl; auto.\n  destruct H; auto.\n  destruct (IHinsert_insert_insert x l); auto.\n  - destruct l; simpl; auto.\n  - destruct l); subst.\n    - rewrite PTree.\n      * subst; auto.\n      destruct l; simpl; auto.\n      + auto.\n      destruct l; simpl; auto.\n      + destruct l; auto.\n      * rewrite PTree.gso; auto.\n      + destruct l; auto.\n      + apply PTree.gso; auto.gss.\n        - rewrite PTree.gso by (IHinsert_insert_insert_insert_insert_insert_insert_insert x l).\n      * destruct l; auto.\n      rewrite PTree.gss.\n      + intros.gso; simpl; auto.\n      destruct l; intros; destruct l; simpl; auto.\n      + simpl; auto.\n      + subst.\n      rewrite PTree.\n      * rewrite PTree.gso; auto.gso; auto.\n      + rewrite PTree.gss.gss.gso by auto.gso.\n      + simpl; auto.\n      + intros; auto.\n      + rewrite PTreeQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct (@empty_empty _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros. destruct (E _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\ndestruct x as [x] [|x] [x] [x] [x] | [x] x] [|y] x] x] x ] ] [y] [x] [x] [x] [y] [y]] x] [x] x] [x] x] x] ] ]\nintros x; simpl; auto.\nintros; destruct x as [x; auto.\ndestruct x; rewrite!insert_insert; auto; destruct x; subst; auto.\ndestruct x; auto.\ndestruct x; auto.\ndestruct x; auto.\ndestruct (insert x; auto.\ndestruct x); auto.\ndestruct x; try solve [x y; auto.\ndestruct x; auto.\nrewrite!insert_insert_insert; auto.\ndestruct x; auto.\ndestruct (insert; auto.\ndestruct x; auto.\ndestruct (insert x); auto.\ndestruct x y; auto.\ndestruct (insert_insert x); auto.\ndestruct x; auto.\ndestruct x; auto.\ndestruct x; auto.\ndestruct (insert x; auto.\ndestruct x; auto.\ndestruct (insert xQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite map_map_map_map_map; auto.\n  rewrite map_map.\n  repeat rewrite map_map; auto.\n  rewrite map_map; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\nintros.\ngeneralize dependent induction (IH _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\nintros.\ndestruct x; simpl; simpl in *.\ndestruct x; simpl; auto.\ndestruct x; auto.\ndestruct x as [x [x y y z y]; simpl; auto.\nrewrite!IH; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e as [ | [ | [ | [ | ] ] ] ] | ] ] ] ] ] ] ] ] ];\n  try solve [ | [ auto; rewrite (insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert x) as [insert_insert_insert_insert_insert x) |insert_insert x y])\n    destruct t; auto; auto; auto.\n  destruct (insert_insert x v); [ [insert_insert; auto; auto; auto; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct H as [m H].\n  destruct H; auto.\n  destruct H. destruct H; auto.\n  destruct H; simpl; auto.\n  destruct H; auto.\n  destruct H.\n  destruct H; auto.\n  destruct (eq_eq_dec x); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\nintros.\nrevert x y H; intros.\ndestruct H; destruct H; simpl in H; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup.\n  unfold lookup, lookup, lookup, lookup, lookup, lookup; intros; auto.\n  unfold lookup, lookup, lookup, lookup, lookup, lookup, lookup, lookup, k.\n  unfold lookup, lookup, lookup, lookup, lookup, k, lookup, key, lookup, lookup, lookup, Empty, lookup, lookup, lookup, lookup, lookup, key, lookup, key, lookup, lookup, lookup, lookup, k, k, k, lookup, lookup, k, Empty, k, k, Empty, k, Empty, k.\nProof.\n  intros; simpl; simpl; auto.\n  rewrite lookup_eq_eq, t; auto.\n  auto.\n  intros; rewrite lookup_tree_tree; auto.\n  rewrite Hk; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; simpl; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold find.\n  destruct e; intros; auto.\n  apply lookup_insert_insert_insert; auto.\n  apply delete_insert_insert.\n  eapply find_insert_insert_insert; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (eq_dec x); subst; destruct H; auto.\n  destruct H; auto.\n  simpl; try discriminate.\n  destruct (f x); auto.\n  destruct H; auto.\n  destruct H; simpl; auto.\n  destruct H; simpl in H; auto.\n  destruct (f x); auto.\n  destruct H; auto.\n  destruct H; simpl; auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  apply IH]; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct e.\n  destruct e; simpl; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  - destruct e.\n  + destruct e; auto. destruct e; auto.\n  + destruct e; auto.\n  + simpl; auto.\n    + rewrite In_right; auto.\n  + destruct e; auto.\n  + auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct e; destruct e; inv H; subst; auto.\n  unfold lookup.\n  destruct e; auto.\n  inv H.\n  destruct (fold_right_eq_eq (eq_dec_dec x) as [x | [v [v' [v' [v' [v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v'' v''' v' v''' v' v' v' v' v' v'' v' v'' v' v'''' v' v'''' v' v' v''' v' v''' v'' v''' v'''' v''' v' v' v' v' v'''' v'''' v' v' v''' v' v' v''''''' v'''' v'' v''''' v'' v' v'''''' v'' v''' v'''''Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  destruct e; simpl; auto.\n  destruct e; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  induction e; auto.\n  induction e; intros.\n  induction e; auto.\n  - destruct e; auto.\n  - apply lookup_cons; auto.\n  - intros.\n  - destruct e; auto.\n    - rewrite <- lookup_update_update_update_update_update_update_update_update_update.\n    - rewrite lookup_update_update_update; auto.\n    - rewrite lookup_update_update.\n    + auto.\n    - apply lookup_update_update_update_update.\n      - destruct e; auto.\n        * intros.\n        + apply (lookup_update_update_update_update_update_update_update_update_update_update_update_update (update_update_update_update_update_update_update_update).\n      applyupdate_update_update_update_update_update_update_update_update.\n      + subst.\n        + rewriteupdate_update_update.\n        rewrite <- insert_update_update_update_update_update_update_update_update_update_update_update_update_update_update_update_update_update.\n        ++ s) (update_update_update_update_Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction t; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  rewrite <- insert_insert_insert; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros; destruct e; destruct e; auto.\n  rewrite <- H.\n  destruct e; auto.\n  destruct (k x) as [ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  apply f_equal; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct (find_tac; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros; intros; inversion H; subst; subst; subst.\n  destruct (insert x); auto.\n  destruct (insert x); auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct e; intros.\n  destruct e; simpl; destruct e; eauto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; congruence.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite upd_map; auto.\n  + auto.\n  + rewrite upd_map; auto.\n  + auto.\n  - apply upd_map.\n  + apply upd_map_val.\n  + apply upd_map_map; auto.\n  + intros.\n    + apply upd_map_map.\n      + rewrite upd_map_map; auto.\n      + apply upd_map_map.\n    + rewrite upd_map.\n      + rewrite upd_map_map; auto.\n      + rewrite upd_map_map.\n      - apply upd_map_map.\n      + rewrite upd_map_map.\n        rewrite upd_map.\n      * rewrite upd_map; auto.\n      * simpl.\n      - simpl.\n      - rewrite upd_map_map_map.\n      - rewrite upd_map_map_map.\n      + rewrite upd_map.\n      rewrite upd_map.\n     Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction e; simpl; intros.\n  destruct (t b); subst.\n  destruct e; simpl; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [ | ] | | | | | ]; simpl; auto.\n  rewrite insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l); [apply insert_insert_insert_insert_insert; auto].\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert); auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction 1; simpl; simpl; simpl; auto.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert_insert_insert_insert l) (insert_insert_insert_insert_insert_insert l l) (insert_insert_insert_insert_insert l) (insert_insert_insert_insert_insert_insert_insert_insert_insert l t) (insert_insert_insert_insert_insert_insert_insert_insert_insert x l) l) l l' l t l.\n  Proof.\n  induction l; intros.\n  destruct l; simpl; simpl; auto.\n  destruct l; auto.\n  destruct l; auto. destruct l; auto.\n  destruct l; auto.\n  - subst.\n  + simpl.\n    rewrite insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert_insert_insert_insert x b) as [ | None ] [ | ] ] ] | ] | [ | ];\n  destruct H; [ | | ];\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; intros;\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x); intros; auto.\n  rewrite insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert _insert_insert l); auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  destruct e as [ | ]; try solve [ | auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  destruct e; simpl; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert e b); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert (insert_insert_insert_insert_insert x y) as [insert_insert_insert_insert_insert_insert_insert_insert x y); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x y).\n  destruct insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros. destruct e; destruct e; simpl; eauto.\n  destruct e; eauto.\n  destruct e; try solve [ | ]; simpl; auto.\n  destruct e; auto.\n  + destruct e.\n  + destruct e; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction e; intros.\n  destruct e; simpl.\n  destruct e; simpl in *.\n  destruct e; simpl; try discriminate; auto.\n  destruct e; auto.\n  - destruct e; simpl in *; destruct e; try discriminate.\n  - destruct e; auto.\n  - destruct e; auto.\n  + inv e; auto.\n  + destruct e; subst e; auto. destruct e; auto.\n  + destruct e; auto.\n  + destruct e; auto.\n  + auto.\n  + destruct e; simpl; auto.\n  + rewrite e; auto.\n    + simpl; auto.\n    + destruct e; auto.\n    + apply (map_insert_insert_insert_insert_insert_insert_insert _ _insert_insert_insert_insert a)); auto.\n    + apply insert_insert_insert_insert; auto.\n    + apply insert_insert_insert_insert; auto.\n    + intros e; auto.\n    + destruct e; auto.\n    - destruct e; auto.\n    + auto.\n    + destruct e; auto.\n    - destruct e; auto.\n    + destruct e; auto.\n    + destruct e.\n    + destruct e as [ | | | | |Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  apply wf_insert_insert_insert_insert_insert_insert; try solve [ | [ | | [ | ] ] | [ | ] | [ ] ] ] ] | ] | | ] ]\n  | | | ] ]\n  | | ] ] ]\n  | [ | ] ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\n  intros.\n  destruct s; simpl.\n  destruct H; auto.\n  inv H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H; auto. destruct H.\n  destruct H; simpl in H.\n  destruct H; auto. inv H.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  rewrite H0; auto.\n  destruct H0.\n  destruct H0.\n  destruct H0; inv H0.\n  destruct H1; inv H0; inv H1.\n  simpl in H0.\n  inv H0.\n  inv H0.\n  inv H0.\n  destruct (In_dec_dec k); inv H0; inv H0.\n  inv H0. inv H0.\n  inv H0; inv H0.\n  inv H0; inv H0.\n  inv H0.\n  inv H0. inv H0.\n  inv H0.\n  inv H0. inv H0; inv H0.\n  inv H0.\n  inv H0. inv H0. inv H0; inv H0. inv H0; inv H0. inv H0. inv H0. inv H0; inv H0; inv HQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; simpl; auto.\n  destruct H; simpl; auto.\n  - simpl; auto.\n  - rewrite (delete_insert_insert_insert_insert k); auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - destruct (insert_insert_insert k) as [x1].\n  - destruct H1 [x1 [x2].\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert k) as [x1].\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k t).\n    rewrite insert_insert_insert_insert.\n    - intros; auto.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert linsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l l l) (insert_insert_insert l)).\n  rewrite insert_insert_Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction 1; intros.\n  destruct (insert_insert_insert_insert_insert k); [|s1]; auto].\n  destruct t2; auto.\n  destruct t2 as [s2 t2; auto.\n  destruct t2]; simpl in *; destruct t2; destruct t2; subst.\n  destruct t2; auto.\n  destruct t1 t2; auto.\n  destruct t1 t2; auto.\n  destruct t1; auto.\n  destruct t1 t2; auto.\n  inv H; auto.\n  destruct t1 t2; auto.\n  destruct t2 t1 t2; auto.\n  destruct t1 t2; inv t2; auto.\n  destruct t1 t1; auto.\n  destruct t2; auto.\n  destruct t1; auto.\n  inv H1; auto.\n  destruct t1; auto.\n  destruct t2; inv H2; auto.\n  destruct t2; auto.\n  destruct t2; auto.\n  destruct t2; inv H1; auto.\n  destruct t2; auto.\n  destruct t2.\n  destruct t2; simpl; simpl; auto.\n  destruct t2; auto.\n  inv H2.\n Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros; destruct s; simpl; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x x y e le).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x y e e le) as [t] [x] [y] [x] | [y] ] ] ].\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [x y];\n    destruct (insert_insert_insert_insert_insert x) as [x] y] [x; [y] [y] [x x]] [x] | x] y] [y] x] [y] [x y] [x] [y] [x y] [x] x y; [y] [y] [x y y] x y; [y y] ] ] ]\n  [x] y; [y y] [x y] ] ] ] ] [y y] x] (insert_insert;\n    [Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\n  intros.\n  apply P.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k e le_insert_insert_insert_insert_insert_insert_insert_insert k) as [t, insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert k (insert_insert k k e k (insert k) k) eqn:E.\n  destruct (insert_insert_insert_insert_insert k e); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert k); auto.\n  destruct (insert_insert_insert_insert_insert k); auto.\n  destruct (insert_insert k e).\n  destruct e; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert k e); auto.\n  destruct e.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k e2 (insert k e2); auto.\n  intros. destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  destruct e; simpl in H; auto.\n  destruct (t, t); auto.\n  destruct t; auto.\n  destruct t; subst.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; simpl; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; destruct t; auto.\n  destruct t t; auto.\n  destruct t; auto.\n  destruct t t t); auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t t; auto.\n  destruct t; auto.\n  destruct t; auto. destruct t t t t t; auto.\n  destruct t t t; auto.\n  destruct t t; auto.\n  destruct t t t; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t t t t t; auto.\n  destruct t; auto.\n  destruct t t t; auto.\n  destruct t t t t t t t t t t tQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\n  Proof.\n  intros.\n  destruct e; try solve [s [s] [s2] [s1 [s2] s2] [s2] [s2 s2 s2 [s2] s2 s2 s2 s1 s2] s2].\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert s2) as [s2 s2 s2 s2 [s2 s2] s2 s2] s2] (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert s2 s2) as [s2 s1 s2 s2 s2 s2] [s2] s2] s2 s2] s1 s2] s2.\nProof.\n  intros; unfold In; unfold In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In In, In, In, In In x s1, In x s1 s1 s1 s2 s1 s2 s2 s2 s2 s1 s2 s1Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros k e le_low_low.\n  destruct (insert_low_high_low_high_high_high_high_high_high_high.\n  destruct e le_low_high_low; auto.\n  destruct (partition_bound k) as [k [k] [k] [k] [k' [k' [k' [k' k' [k'k'k'k' k'' k' k' k' k' k' k' k' k' k' k' k' k'.\n  destruct k' k' k' k' k' k' k k k' k' k' k'.\n  generalize (remove k' k' k k' k' k' k k' k' k' k' k' k k k' k' k' k' k' k' k k k k' k' k k' k' k k' k' k k k' k' k' k' k' k' k' k' k' k' k k' k' k' k k' k k' k' k' k k' k' k' k k' k' k' kQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros; auto.\n  inversion H.\n  eapply insert_right; eauto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k e) as [t] [insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert x); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct e as [x] | ] ] ]\n    destruct (insert_insert_insert x); [y|] eqn:H] eqn:H; auto; auto].\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x v); auto.\n    rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x t).\n    destruct x; [right; auto.\n    destruct (insert_insert_insert x l).\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; apply insert_insert_insert_insert_insert; rewrite insert_insert_insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert.\n  apply insert_insert; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  induction t; simpl; rewrite insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert; auto.\n  intros.\n  apply insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct t; auto.\n  destruct t as [ | ].\n  destruct t as [x | | | | | ] | | ] | ] ].\n  rewrite insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert); auto.\n  + destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert; auto.\n    - if_insert_insert_insert; auto.\n  -insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; destruct t; simpl; try solve [left; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  apply insert_insert_insert; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; unfold insert_insert; intros; unfold insert_insert; unfold insert_insert; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert x).\n  destruct t as [insert_insert; simpl; reflexivity.\n  destruct t; [insert] | ] ].\n  rewrite insert_insert_insert_insert_insert; destruct t; reflexivity.\n  - destruct t; auto.\n  + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  + simpl; auto.\n  - destruct t; auto.\n  - unfold insert_insert_insert_insert; simpl; auto.\n  + unfold insert_insert; auto.\n    - apply insert_insert_insert; auto.\n    + intros; auto.\n    + destruct t; auto.\n    - destruct t; auto.\n    + subst.\n    - destruct t as [ | t0 t0 t0 t0 t0 t0 t00 t0 t0 t0 t0 t0 t00 t00 t00 t00 t00000 t0 t00 t00000 t0000 t0 t00 t00 t0 t000 t0 t00 t0 t00 t0Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction 1; intros; intros; intros; simpl; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct x; simpl; destruct x; simpl; auto.\n  destruct x; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; intros.\n  apply insert_insert_insert_insert_insert_insert_insert; auto.\n  auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert l) as [x | [x1] [y2] | _ _ _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert l) v).\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n\n\n(** [insert] and [insert] and [insert] is [insert_insert] and [insert] is [insert]]] [insert] [insert] is_insert]\n    [insert] [insert]] [insert]] is_insert_insert_insert]]\n    as [insert_insert [insert] insert_insert [insert] [insert [insert] [insert] [insert]insert] [insert_insert_insert] insertQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct (insert_insert_insert a1 a1 a2); try solve [apply insert_insert_insert; eauto.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1); auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros; apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros; destruct e2; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  inv H0; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  inv H0; auto.\n  destruct e1; auto.\n  apply insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  induction e2; simpl; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; simpl; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e1; simpl; auto.\n  destruct e2; auto.\n  eapply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  + destruct e2; destruct e1; simpl; auto.\n    destruct e2; auto.\n  + subst; simpl.\n    * destruct e2; destruct e2; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e2.\n    destruct e2; auto.\n    destruct e1; auto.\n    - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e1 as [a1 [a1]; simpl; destruct (a2 a2) as [a2].\n  destruct a2 a2; simpl; auto.\n  destruct a2 as [b2].\n  destruct (a2 b2; congruence.\n  destruct a2 a2 a2); auto.\n  destruct a2; auto.\n  destruct (a2 a2 a2 a2); auto.\n  destruct (a2); auto.\n  destruct (a1 a2 a2); auto.\n  destruct a2; auto.\n  destruct a1; auto.\n  destruct a1; auto.\n  destruct a2; auto.\n  destruct a2 a2; auto.\n  destruct a1 a2; auto.\n  destruct a2; auto.\n  destruct a1; auto.\n  destruct a1; destruct a2; auto.\n  destruct a1 a2; auto.\n  destruct a2 a2; auto.\n  destruct a2; inv H1; auto.\n  destruct a1; auto.\n  destruct a2; auto.\n  destruct a1 a2; auto.\n  destruct a2; auto. destruct a1; destruct a1 a2; auto.Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros; simpl in *; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  induction e2; simpl; auto.\n  unfold insert_insert; intros; auto.\n  rewrite insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert_insert; auto.\n  destruct insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  unfold insert_insert; intros; intros; destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  unfold insert, insert; simpl; auto.\n  apply insert_insert; auto.\n  rewrite insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros; destruct e2.\n  destruct e; eauto.\n  destruct e2; try solve [right].\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; simpl; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  simpl in *; auto.\n  destruct e1; auto.\n  destruct e1 e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1 e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; simpl; auto.\n  destruct e1; auto.\n  destructQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct e1; simpl; simpl.\n  rewrite insert_insert; auto.\n  rewrite insert_insert_insert.\n  destruct (insert_insert_insert_insert a2).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert a1). subst. apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct a2.\n  destruct t1; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1 a1).\n  destructinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1); auto.\n  destructinsert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert a2); auto.\n  destruct a1; auto.\n  destruct a1; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  induction a; auto.\n  intros; simpl in H. destruct H.\n  destruct H; auto.\n  destruct (insert_insert_insert_insert_insert_insert x); auto.\n  destruct H.\n  destruct (insert_insert_insert x); auto. auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert a1) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a2) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1 x2).\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a2) ::insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x1 (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  unfold insert_insert_insert_insert.\n  unfold insert_insert_insert_insert.\n  destructinsert_insertQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct e1; destruct e; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  auto.\n  destruct e1 e1. auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1 e1; auto.\n  destruct e1 e1 e2; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert a1); eauto.\n  destruct (insert_insert_insert_insert a1 a2) as [insert_insert a2]; auto.\n  destruct H2; auto.\n  destruct (insert_insert_insert_insert_insert a1 a1); auto.\n  destruct a2; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert a2.\n  destruct (insert a2); auto.\n  destruct (insert_insert_insert_insert_insert a2); auto.\n  destruct (insert_insert_insert_insert_insert a1 a1); auto.\n  destruct (insert_insert a1); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert a1 a2); auto.\n  destruct (insert_insert a1); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a2) as [insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction a; intros.\n  destruct a1 a2; simpl; simpl; auto.\n  destruct a2; subst.\n  destruct a1 a1; eauto.\n  inv H.\n  inv H; eauto.\n  destruct a1; destruct a1; inv H1; auto.\n  inv H2; eauto.\n  destruct a1; auto.\n  destruct a1; auto.\n  destruct a2; auto.\n  destruct a1; auto.\n  destruct a2; auto.\n  inv H; auto.\n  destruct a1; auto.\n  destruct a1; inv H1; auto.\n  auto.\n  destruct a1; inv H2; auto.\n  destruct a1; auto.\n  destruct a1; auto.\n  destruct a1; auto.\n  destruct a2; auto.\n  subst.\n  inv H1; auto.\n  destruct a2; auto.\n  destruct a1; auto. auto.\n  destruct a1; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  induction a1.\n  destruct a1; simpl.\n  destruct (insert_insert_insert_insert_insert a1 a1) as [insert a1] t2] | t2; auto.\n  - subst.\n  - subst.\n    - destruct a2.\n    - destruct a1 a1 as [t2] [t2 t2 t2] t2] [t2]\n    + subst; auto.\n    - subst t2.\n    - destruct t2 t2 t1 t2; auto.\n    - subst.\n    - simpl; auto.\n    - subst.\n    - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x2 t2 t2 t2 t2 t2 t2 t1 t1 t2 t1 t2 t2 t2 t2 t2 t1 t2 t2 t2 t2 t2 t3 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t1 t t2 t2 t1 t3 t2 t2 t2 t2Qed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros. unfold insert_insert; rewrite insert_insert.\n  rewrite insert_insert; auto.\n  destruct (insert_insert_insert a1 x2) as [insert x1 [insert_insert] | |insert_insert_insert x1] |insert_insert_insert_insert_insert_insert_insert_insert x1] :: e1 l2.\n  destruct (insert_insert_insert_insert_insert_insert x2).\n  rewriteinsert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction e; intros.\n  rewrite insert_insert_insert_insert_insert.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct e1 as [a1]; simpl in H1.\n  destruct H1; simpl in H2.\n  rewrite H2.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x1); auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct a2; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert); auto.\n  destruct insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  destruct H1 as [e1 [e2].\n  destruct H2|e1|e2|e1 e1].\n  destruct H2].\n  destruct (e2 e1 e1) as [e1 e2]; simpl in H1.\n  + destruct e2; auto. destruct e2; destruct e1 e2; auto.\n    * e1; auto.\n    + destruct e2; subst e2.\n    - destruct e2; auto.\n      + destruct e1; auto.\n      * e2.\n      * apply insert_insert_insert_insert_insert_insert...\n      + apply insert_insert_insert_insert...\n      * apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert...\n      *\n      * insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert...\n      insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertinsert_insert_insertinsert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e2 as [a2].\n  destruct (a1, e2)).\n  destruct (a2); destruct (b2 & e1); congruence.\n  rewrite e2); auto.\n  - destruct (a2).\n  - rewrite e1; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct H; auto.\n  destruct H1; auto.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1 as [H1 [H1 [H1 H1 H1].\n  destruct H2].\n  simpl in H1.\n  destruct H1.\n  destruct (H2). inv H2.\n  split; auto. apply H2. destruct H2.\n  destruct H1.\n  inv H2; auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  subst.\n  destruct H2. destruct H2.\n  destruct (IHIHH1 _ H2); auto.\n  destruct H2; auto.\n  subst.\n  destruct H1; auto.\n  destruct H1; auto. destruct H1; auto. destruct H1.\n  destruct H2; auto.\n  destruct H1; auto.\n  destruct H2; auto.\n  destruct H2; auto.\n  auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  destruct H2; auto.\n  destruct (IHIH H2); auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  unfold insert, insert, insert, insert, insert, insert, insert, insert, insert, insert, insert_insert, insert, insert_insert, insert_insert_insert_insert, insert_insert_insert, insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x2.\n  destruct insert_insert, insert_insert_insert, insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert x2) as [insert_insert_insert_insert, insert_insert_insert, insert_insert.\n-insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e; destruct e1; auto.\n  - destruct e; auto.\n  - destruct e2.\n    + subst e2.\n      * subst e1.\n      * e1.\n      * destruct e1; auto.\n      + simpl.\n      * auto.\n      - subst e1.\n      * apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      * y1.\n      * apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      * insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      * insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e1; destruct e1;\n  destruct e1; simpl; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1 e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1 e2. destruct e2; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; simpl; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; simpl; auto.\n  destruct eQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e1; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x2) as [e1].\n  destruct (insert x2) as [e1 [e1 [e2e2].\n  destruct (insert_insert_insert_insert_insert_insert_insert x1); auto.\n  destruct e2; auto. destruct (insert_insert_insert_insert_insert_insert_insert x2); auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x1 t2) as [e1 [e1 [t2 [e2 [e2] | ].\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert;\n  destruct x1; destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert x2)).\n  destruct (insert_insert x1 x1); subst; inv H1; inv H2; inv H2.\n  destruct H2; inv H1. inv H1; inv H2; inv H2. inv H2; inv H3. inv H2.\n  inv H3; inv H3. inv H2; inv H2. inv H3; inv H3. inv H4. inv H4. inv H4. inv H3; inv H3; inv H3. inv H4; inv H4; inv H2. inv H5. inv H3. inv H3; inv H3; inv H1; inv H4; inv H2. inv H4. inv H4. inv H3. inv H3; inv H4; inv H3; inv H3. inv H3; inv H3; inv H3; inv H2; inv H3; inv H1; inv H1. inv H3; inv H4; inv H3. inv H2; inv H3; inv H2; inv H3;Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e2 as [e1 [e2] [e1] [e2]e1 [e2e2e1 [e2 [e2 [e2]e2]].\n  destruct e2e2 e1 e1; inv H2.\n  destruct e2.\n  destruct e2; simpl in e2; try discriminate. auto.\n  destruct e1; inv H1.\n  subst.\n  inv H2; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct (insert_dec x2).\n  destruct (insert_insert_insert_insert x2 y2).\n  + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n    unfold insert_insert_insert_insert.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n    destructinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct (fun x => h1).\n  destruct e1.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  intros.\n  destruct t1.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct e1.\n  destruct e1 as [y2] eqn:E1 | [y2].\n  destruct e2 as [y2 [y2 [y2 [? [??]]]].\n  rewrite E1 [x2.\n  destruct (y2 y1 x2 x2 y2 [x2 [y2 y2 [x2 [x2 [y1 [y2 [y2 [x2] [x2 [x1 [y2] [x2]]]].\n  destruct (x2 y2); simpl in *.\n  destruct (y2); auto.\n  destruct (x2 x2).\n  destruct (x2); auto.\n  destruct (x2 y2 y2); subst x2); auto.\n  destruct (y2); auto.\n  apply H2; auto.\n  destruct (y2); auto.\n  destruct (x2 x2); auto.\n  destruct (y2 y2); auto.\n  destruct (y2); auto.\n  destruct (x2 x2 x2); auto.\n  destruct x2 x2); auto.\n  destruct (x2); auto.\n  destruct (x2); auto.\n  rewrite <- H1.\n  destruct (Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct (f x).\n  destruct e; simpl.\n  destruct e; auto.\n  destruct e; destruct e.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  apply IHs; auto.\n  apply IH; auto.\n  eapply insert_insert_insert_insert; eauto.\n  destruct (insert_insert_insert_insert_insert x e); auto.\n  destruct e1; auto.\n  destruct e2; auto. destruct e2; destruct e; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1 e2; auto.\n  destruct e1 e2; auto.\n  inv H.\n  destruct e2.\n  destruct e1; auto.\n  destruct e1 e1 e1 e1; auto.\n  destruct e1; auto.\n  destruct e1 eQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  intros.\n  destruct e2. destruct e; auto.\n  destruct e1; auto.\n  unfold map_app.\n  destruct e2; auto.\n  eapply In_app. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; intros; induction e; simpl; simpl; simpl in *; congruence.\n  destruct e; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct e1 as [x1].\n  destruct e2; simpl in *; destruct e2; simpl in *; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e1; simpl in *; auto.\n  destruct e1; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  eapply insert_insert_insert_insert_insert_insert; eauto.\n  destruct e2 as [e2].\n  destruct e2]; auto.\n  destruct H; auto.\n  rewrite insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert _ _ (insert_insert x) as [e1 [t1] s2 [t2] [t1 [t2] | H2]; subst; auto.\n  destruct (insert_insert_insert_insert x1; auto.\n  - subst; auto.\n  - destruct H2. destruct (insert_insert_insert_insert_insert x2); auto. destruct (insert_insert_insert_insert_insert_insert_insert x2); auto.\n  - applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x2 t2.\n  -insert_insert_insert_insert x1.\n  + applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct (In_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert l).\n  destruct H1; inv H. destruct H2; auto.\n  destruct H1; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  apply insert_insert; auto.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct t.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x y);\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. apply map_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros; induction e; auto.\n  destruct e1; try congruence.\n  intros e2; auto.\n  destruct e1.\n  destruct e1; destruct e1; auto.\n  destruct e1; try congruence.\n  destruct e2; destruct e2; auto.\n  simpl; eauto.\n  destruct e1; auto.\n  destruct e1; congruence.\n  destruct e2; auto.\n  congruence.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  destruct o; simpl; eauto.\n  destruct o; eauto.\n  inv H.\n  destruct o; simpl; auto.\n  eapply insert_insert_insert; eauto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; eauto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  inv H.\n  destruct o; auto.\n  destruct o.\n  destruct o.\n  destruct o; inv H; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; simpl in *.\n  destruct o; auto.\n  destruct o; eauto.\n  destruct o; auto. destruct o'; eauto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  inv o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n Qed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  destruct (IHf x).\n  destruct e; simpl; auto.\n  destruct a; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o1; auto.\n  destruct o; auto.\n  eapply IHt; auto.\n  econstructor; auto.\n  apply IHl.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; auto.\n  destruct H; intros; simpl; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H0; auto.\n  destruct H0; auto.\n  destruct (IH _ _ _ H0); auto.\n  destruct H0; auto.\n  destruct H0; auto.\n  eapply IHt1; auto.\n  destruct H0.\n  destruct H0; auto.\n  destruct H0; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  rewrite <- insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  intros.\n  apply insert_insert_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction e; auto.\n  induction e; simpl; auto.\n  - intros; auto.\n  - intros. rewrite <- insert_insert_insert_insert_insert; auto.\n  - apply insert_insert_insert_insert.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;\n  if_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros. destruct e; intros.\n  destruct a; simpl; simpl; auto.\n  destruct a; auto.\n  destruct (insert_insert_insert_insert a); auto.\n  destruct (insert_insert_insert_insert a b); auto.\n  destruct a); auto.\n  destruct (insert_insert_insert a; auto.\n  destruct a; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; rewrite H; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; induction e; simpl in *; subst; simpl; auto.\n  destruct H; auto.\n  destruct (IH2) as [ | [x?x?x?x?x?x?x?x?x?y?x?y?x?y?x?x?y?y?y?x?y?y?y?y?y?y?y?y?x?x?y?y?x?y?y?y?y?y?y?x?y?y?x?x??y?x??x?x??y?x?y?y?y?y?y?y?y?y?y?y?y?y?y?y?x?y?y?x?y??y?y?y?y?x?y?y?y?y?x??y??y?y??y?y?y?x?y??y?x?y?y?x?y?y?y?y?y?y?x??y?y??y?y?y?y?y?Qed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  unfold map, map.\n  destruct o; try discriminate.\n  destruct o; simpl; simpl; simpl; auto.\n  rewrite!map_left.\n  - rewrite!map_right; auto.\n  + rewrite!map_map_map_map_map.\n    - rewrite!map_map_map_map_map_map.\n    - simpl.\n    + rewrite!map.\n    + rewrite!map_map_map_map.\n      simpl.\n      * intros.\n    + apply!map_map.\n    + rewrite!map_map_map.\n      rewrite!map_map_map.\n      rewrite!map_map_map_map_map.\n      + rewrite!map_map_map_map_map_map.\n        rewrite!map_map.\n        rewrite!map_map_map_map_map.\n        rewrite!map_map_map.\n        rewrite!map_map_map.\n        rewrite!map.\n        rewrite!map_map_map_map_map_map_map_map_map.\n        rewrite!map_map_map_map_map.\n        rewrite!map.\n        rewrite!map_map.\n        rewrite!mapQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  destruct e; simpl; intros; auto.\n  destruct H; auto.\n  destruct (IHIHh2); auto.\n  destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  unfold fold_insert.\n  rewrite map_insert.\n  rewrite map_insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [x1 [x1 [x2 [x2] [x2] [x2] | [x2 x2] x2] x2].\n  exists x1 x2,x2] = Some x2; auto.\n  destruct x2; auto.\n  destruct (insert_insert x2; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; apply map_insert_insert_insert_insert; auto.\n  apply fold_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert).\n  destruct (insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  unfold map_insert; unfold map, map_insert; simpl; auto.\n  destruct (insert_insert x) eqn:E.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x) as [t] eqn:E2].\n  destruct H.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x).\n  - unfold map_insert_insert_insert; simpl; intros; subst; auto.\n  unfold map_insert.\n  - applyinsert_insert_insert_insert_insert; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    + applyinsert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; rewrite map_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  apply insert_insert_insert.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [x].\n  unfold map.\n  destruct (insert x); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x).\n  destruct (insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert x).\n  subst.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros. destruct (insert_insert_insert_insert_insert_insert_insert x) eqn:E.\n  assert (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) = Some (insert x).\n  assert (insert_insert_insert_insert_insert_insert_insert x).\n  destruct (insert_insert_insert x).\n  { destruct (insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert xinsert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert xinsert_insert xinsert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert xinsert xinsert_insert_insert x y xinsert xinsert xinsert_insert x y x);\n  destructinsert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert; auto.\n  destruct xinsert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert xinsert_insert x yinsert_insert_insert_insert xinsert_insertQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction 1; intros.\n  simpl; simpl; destruct (insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert x).\n  destruct (insert x) as [x1] eqn:E1; simpl; discriminate.\n  destruct H.\n  destruct (insert_insert_insert x2).\n  subst.\n  simpl. rewrite insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert x) as [insert_insert_insert_insert_insert_insert; simpl; auto.\n  destruct (insert_insert_insert x2) eqn:E2.\n  destruct (insert_insert_insert_insert_insert_insert_insert x1); auto.\n  destruct (insert_insert x2).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert_insert_insert).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  eapply map_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert).\n  assert (insert_insert_insert_insert_insert_insert_insert x e) = Some (insert x) && fold_insert.\nProof.\n  intros; [x] x y; destruct H1; [x2].\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; intro; auto.\n  destruct (insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  applyinsert_insert_insert_insert_insert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  induction 1; simpl; simpl; auto.\n  destruct (insert_insert_insert_insert_insert_insert x).\n  - destruct x; simpl; auto.\n    rewrite map_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n      destruct (insert_insert_insert_insert_insert x) eqn:E.\n      destruct t.\n      destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert _insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert); auto.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert xinsert_insert xinsert_insert_insert_insert_insert) (insert xinsert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert xinsert_insert).\n    destructinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction e; auto.\n  destruct (map f); auto.\n  destruct e; simpl; auto.\n  auto.\n  destruct (map f); auto.\n  rewrite map_map_map_map_map_map_map f).\n  destruct e; auto.\n  destruct (map f); auto.\n  destruct e; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros.\n  induction l; auto.\n  destruct a.\n  simpl; auto.\n  destruct (map_map f e f e); auto.\n  destruct (map_map f); auto.\n  simpl; auto.\n  destruct (map f); auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros.\n  destruct o; simpl; rewrite!map; eauto.\n  rewrite map_map.\n  destruct o; simpl; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  inv o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n Qed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  destruct o; auto.\n  destruct o; intros.\n  destruct o; auto.\n  destruct o; auto.\n  rewrite map_right; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destructQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros.\n  destruct e; simpl; destruct e; eauto.\n  destruct (f e) as [x|x] e]]; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite <- H; auto.\n  destruct e; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction l; simpl; intros; destruct o; try discriminate.\n  destruct o; simpl; simpl; simpl; auto.\n  destruct (IHl _ o); auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  apply (H o.\n  destruct o; auto.\n  destruct o o o); auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros; intros.\n  rewrite map_map_map_map.\n  destruct (map_map_map f h)) as [p].\n  destruct o.\n  destruct o as [p1' [p1'2'2'1'2'2'2'1'2'2'2'2'2'2'2'2'2'2'2'2'2'2'2'2'2'2'3'2'2').\n  rewrite <- H1.\n  apply map_map_map_map_map_map.\n  repeat split; eauto.\n  apply map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  do 2 rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map map_map_map map_map map map_map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros; intros; destruct (map_map_map_map_map f); auto.\n  destruct (map_map f).\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  inv o; auto.\n  destruct o; auto.\n  destruct o;Qed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros.\n  destruct o; auto.\n  apply map_map_map.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  rewrite map_map_map; auto.\n  destruct o; auto.\n  rewrite map_map_map_map.\n  destruct o; auto.\n  destruct o; auto.\n  apply map_map_map_map_map_map_map_map; auto.\n  rewrite map_map_map_map_map_map_map; auto.\n  destruct o; auto.\n  apply map_map_map_map; auto.\n  destruct o; simpl; auto.\n  apply map_map.\n  apply map_map_map_map_map.\n  rewrite map_map_map_map_map.\n  auto.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map_map.\n  apply map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map; auto.\n  rewrite map_map_map; auto.\n  simpl; auto.\n  simpl.\n  destruct o; simpl; autoQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct (map_map f) as [x2]; destruct (map f x e); auto.\n  destruct (map f e1).\n  rewrite map_map_map_map_map_map f (map f (map f g g g h) (map f) (map f g h) (map f g h) (map f g h) h)) as [x h; simpl; auto.\n  destruct H.\n  destruct (map f g h); subst; simpl.\n  destruct (map f g h; auto.\n  destruct h; auto.\n  destruct (map_map f g h) as (map f g h); auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; simpl; destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  inv H; auto.\n  destruct h; destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h as [p h h; auto.\n  destruct h; auto.\n  destruct h.\n  destruct hQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  unfold map_map_map_map.\n  unfold map_map.\n  unfold map_map.\n  rewrite map_map_map.\n  unfold map_map; auto.\n  simpl.\n  destruct (map f g1 g1 f2 f2).\n  simpl.\n  destruct (map f2); destruct (map f1); auto.\n  simpl; auto.\n  destruct (map f1 f2); auto.\n  rewrite map_map f1 f2; auto.\n  rewrite map_map f_map f2; auto.\n  destruct (map f1 f2); auto.\n  destruct (map f2; auto.\n  destruct f1; auto.\n  destruct (map f2); auto.\n  destruct (map f2; auto.\n  destruct (map f1 f2); auto.\n  simpl.\n  destruct (map f2 f1 f2; auto.\n  destruct f2; auto.\n  simpl.\n  destruct (map f2 f1 f2); auto.\n  destruct f1 f2; auto.\n  destruct f1; auto.\n  destruct f2; auto.\n  destruct f1; destruct (map f2; auto.\n  destruct f1; auto.\n Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros.\n  destruct o; intros.\n  destruct o as [p' [? [? [? [??]]].\n  destruct o; auto.\n  destruct o; try congruence.\n  destruct o as [? [? [??]].\n  destruct o; destruct o; subst; inv H; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; inv H; auto.\n  destruct o; simpl; inv H; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; inv H; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; inv H; auto.\n  destruct o1; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o;Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros; auto.\n  destruct o; simpl in |- *; auto.\n  destruct o; auto.\n  inv_map.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  apply map_cons.\n  destruct o; auto.\n  simpl in H; auto.\n  destruct o; auto.\n  destruct o; simpl in H; auto.\n  subst o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  apply f_equal; auto.\n  destruct o1 o; auto.\n  destruct o; auto.\n  destruct o1 o1 o1 o1 o1 o2 o1 o2 o1 o2 o2 o2 o2 o1 o1 o2 o2 o1 o2 o2 o2 o1 o2 o2 o o1 o2 o2 o1 o o1 o o2 o1 o2 o1 o1 o2 o o2 o o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros; inversion H.\n  destruct (f x) as [k [k1 [??]].\n  subst.\n  destruct (f x) as [k1 [??]].\n  exists (f x) (f x)) (f x) (f x)).\n  destruct (f x); auto.\n  destruct (f x2); auto.\n  destruct (f x1 x1 x); auto.\n  destruct (f x1); auto.\n  destruct x1); auto.\n  destruct (f x1); auto.\n  destruct (f x2).\n  exists (f x1 x2); auto.\n  destruct x2); auto.\n  destruct (f x1); auto.\n  destruct (f x2).\n  destruct (f x2); auto.\n  destruct (f x1); auto.\n  destruct x2; auto.\n  destruct (f x1); auto.\n  destruct (f x2); auto.\n  destruct x2); auto.\n  destruct x2; auto.\n  destruct (f x2); auto.\n  destruct (f x1); auto.\n  destruct (f x2); auto.\n  destruct (f x1 x2); auto.\n  destruct (f x2 x2); autoQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  destruct (f_map f).\n  destruct (f _ _ _ _ _ H).\n  destruct o; simpl in H.\n  destruct H; auto.\n  destruct (f_equal.\n  destruct (f _ H).\n  destruct o.\n  destruct o.\n    destruct o; auto.\n    destruct o; destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o1; auto.\n  destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o.\n    destruct o o; simpl; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o1 o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; simpl; auto.\n    destruct o; auto.\n    destruct o o; auto.\n    destruct o; simpl in H.\n    destruct o.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o;Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  unfold map.\n  intros.\n  destruct (f e).\n  destruct (f e e2) as [? [??]].\n  destruct (f e1) as [? [??]].\n  destruct e1.\n  destruct (f e1 e2); destruct e2); simpl in *; simpl in *;\n  destruct e1.\n  destruct e1; auto.\n  destruct e2.\n  destruct e2; auto.\n  destruct e1; inv H1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; destruct e1; auto.\n  destruct e1; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction (map f1); simpl; intros; simpl; auto.\n  destruct H; simpl; auto.\n  destruct H; simpl; auto.\n  destruct (IH _ H1) as [ [H2|H2|H1]; auto].\n  destruct H2 as [H2; simpl; destruct H2; auto.\n  destruct H1; auto.\n  destruct (IH2); auto.\n  destruct H2; auto.\n  destruct H1; simpl; auto.\n  destruct (IH1); auto.\n  destruct (IHIH _ _ _ _ _ H1); auto.\n  destruct H1); auto.\n  destruct H1; auto.\n  destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; simpl; simpl; simpl; auto.\n  destruct (map_map f); intros; auto.\n  eapply map_map_map_map_map_map; eauto.\n  destruct x; auto.\n  destruct x.\n  simpl; auto.\n  destruct e.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  eapply map_map_map; eauto.\n  simpl; eauto.\n  destruct e as [apply map_map_map; auto.\n  eapply map_map_map_map; eauto.\n  eapply map_map_map_map_map.\n  eapply map_map; eauto.\n  eapply map_map_map_map_map_map; eauto.\n  eapply map_map_map_map; eauto.\n  eapply map_map_map_map_map; eauto.\n  eauto.\n  eapply map_map.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map; eauto.\n  eapply map_map_map_map_map.\n  eauto.\n  eapply map_map.\n Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  destruct e; auto.\n  destruct (f e1).\n  destruct (f x) as [ | [? [??]]; auto.\n  destruct (f e2); auto.\n  destruct (f x); auto.\n  destruct e); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct H; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  inv H; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  apply H.\n  destruct e. auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros.\n  destruct (f e1) as [x1]; destruct (f1).\n  rewrite map_map_map_map_map_map f1; auto.\n  - auto.\n  - rewrite map_map_map_map_map. rewrite map_map_map.\n  - repeat rewrite map_map_map.\n  - repeat rewrite map_map.\n  - simpl map_map_map_map.\n  -map.\n  - simpl.\n  - rewrite map_map_map_map.\n    rewrite map_map.\n  - map_map_map_map_map.\n  - rewrite map_map_map map_map map_map map map_map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  induction 1; intros; simpl; simpl; auto.\n  destruct (map_map (map f).\n  apply map_map_map f) as [ | H; auto].\n  rewrite map_map.\n  apply map_map_map_map_map_map.\n  apply map_map; auto.\n  rewrite map_map.\n  apply map_map_map.\n  rewrite map_map_map.\n  apply map_map.\n  rewrite map_map_map_map_map_map.\n  apply map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map map_map map_map_map map map_map_map map_map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction k; intros.\n  simpl; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  repeat split; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o o o o o o; auto.\n  destruct o o; simpl.\n  destruct o o o o; auto.\n  destruct o o; auto.\n  destruct o o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  destruct o; auto.\n  destruct o; eauto.\n  destruct o; simpl; subst; auto.\n  intros; subst.\n  destruct o; destruct o; auto.\n  apply map_map_map.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  apply map_map_map_map; auto.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  inv H; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  inv H; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  auto.\n  destruct o; auto.\n  inv o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  apply o;Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  destruct o as [f [??]].\n  destruct o; simpl; auto.\n  destruct o; destruct o; auto.\n  destruct o; auto.\n  inv H; auto.\n  rewrite map_map.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  inv o; auto.\n  inv o; auto.\n  destruct o; auto.\n  rewrite map_map_map_map_map_map; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  inv o; auto.\n  destruct o; auto.\n  simpl; simpl; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  inv H; auto.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  auto.\n  destruct o; auto.\n  destruct o; inv H; simpl; auto.\n  destruct o; inv H; inv H.\n  destruct o; auto.\n  inv H; auto.\n  destruct o; simpl; autoQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  destruct (x, (f e); auto.\n  destruct (f_equal.\n  destruct (f e) as [ | None end.\n  destruct (f e) as [f e].\n  destruct e.\n  destruct e.\n  rewrite map_eq_map_map_map_map_map_map_map (map_map (map (map_map_map_map f) e).\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; inv e; auto.\n  destruct e; auto.\n  simpl. rewrite map_map_map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map. auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  rewrite map_map_map_map.\n  - rewrite map_map_map_map.\n  + rewrite map_map_map.\n    rewrite map_map_map_map_map.\n    + simpl map_map.\n    - rewrite map_map.\n    rewrite map_map.\n    - simpl map_map.\n    rewrite map_map_map_map.\n    rewrite map_map.\n    + rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map_map map_map map_map.\n    rewrite map_map_map.\n    rewrite map_map_map map map_map_map map map_map map map_map.\n    map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction 1; auto.\n  repeat rewrite map_map; auto.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_map.\n  rewrite map_map.\n  rewrite map_map_map_map map_map map_map.\n  rewrite map_map.\n  rewrite map_map_map map_map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  intros.\n  eapply map_map_map.\n  apply map_map_map; eauto.\n  eapply map_map; eauto.\n  eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map_map_map.\n  eapply map_map_map.\n  eapply map_map; eauto.\n  eapply map_map; eauto.\n  eapply map_map; eauto.\n  eapply map_map_map.\n  eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map.\n  eapply map_map; eauto.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map.\n  eapply map_map_map_map.\n  eapply map_map.\n  eapply map_map. eapply map_map_map.\n  eapply map_map.\n  eapply map_map_map_map_map_map_map_map_map.\n  eapply map_map.\n  eapply map_map; eauto.\n  eapply map_map_map_map; eauto.\n  eapply map_map.\n  eapply map_map.\n Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  unfold map_equal.\n  destruct o; simpl in H.\n  apply map_map.\n  unfold map_map in H; auto.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map_map.\n  unfold map_map_map.\n  apply map_map.\n  rewrite map_map_map_map; auto.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  apply map_map_map.\n  rewrite map_map_map_map map_map map_map map_map map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map map_map map_map map map map map map_map map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction 1; simpl; auto.\n  destruct o; simpl; auto.\n  simpl; auto.\n  destruct o; auto.\n  destruct o; destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; destruct o; auto.\n  inv o; auto.\n  destruct o; auto.\n  inv H; auto.\n  subst; auto.\n  destruct o; simpl; auto.\n  rewrite <- H.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o o; destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  apply o; auto.\n  destruct o o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  apply o; auto.\n  destruct o; auto.\n  destruct o;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  destruct (map_map_map f g f g g f g h); auto.\n  rewrite map_map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map map_map.\n  rewrite map_map_map_map map map_map map map_map_map map map map_map.\n  map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  apply map_map.\n  rewrite map_map_map; auto.\n  apply map_map_map_map_map.\n  rewrite map_map; auto.\n  apply map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map map_map_map.\n  apply map_map_map.\n  rewrite map_map.\n  rewrite map_map_map map_map_map.\n  rewrite map_map; auto.\n  apply map_map_map_map_map map_map_map map map_map; auto.\n  rewrite map_map map_map_map map map_map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; auto.\n  destruct (f_equal.\n  destruct o as [h?].\n  destruct o as [h]?].\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  simpl; auto.\n  simpl; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  destruct (map_map_map_map f (map f (map f (map f (map f) (map f) e) a)).\n  rewrite map_map_map_map f).\n  rewrite map_map_map.\n  rewrite map_map_map_map_map_map.\n  rewrite map_map.\n  apply map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map; auto.\n  apply map_map.\n  apply map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map.\n  rewrite map map_map_map map_map.\n  rewrite map map_map_map map map_map map map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_map_map_map.\n  destruct (map f a); auto.\n  rewrite map_map_map_map_map_map_map_map_map_map.\n  destruct (map f_map f g h); auto.\n  destruct (map f_map f g) as [auto | congruence.\n  rewrite map_map_map_map_map_map_map_map f (map f g f (map f g) (map f g h)) as (map f g f g h g g h).\n  apply map_map.\n  rewrite map_map f_map_map_map f g g g g g g g h.\n  rewrite map_map_map_map.\n  f g g g g h.\n  rewrite map_map f g g h.\n  rewrite map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  repeat rewrite map_map_map.\n  rewrite map_map_map f g g g g h g g g h.\n  rewrite map_map_map f g g g h.\n  simpl map_map.\n  rewriteQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; simpl.\n  induction e; simpl; simpl; auto.\n  apply map_map; auto.\n  apply map_map.\n  eapply map_map_map.\n  apply map_map; auto.\n  rewrite map_map_map.\n  eapply map_map; auto.\n  apply map_map_map_map_map.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; simpl; simpl; auto.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  apply map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map map_map.\n  rewrite map_map.\n  rewrite map_map map_map_map_map.\n  rewrite map_map.\n  rewrite map_map map_map map_map_map map_map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction (map f); eauto.\n  + simpl; auto.\n    + destruct (map f g h).\n    - subst.\n    - subst; auto.\n    - subst.\n    + simpl; auto.\n      * simpl.\n      + simpl.\n    + rewrite map_map; auto.\n      + simpl; auto.\n      rewrite map_map.\n      + intros; rewrite map_map_map; auto.\n      + rewrite map_map.\n    - auto.\n      - rewrite map_map.\n        + rewrite map_map_map.\n        - rewrite map_map_map_map.\n      rewrite map_map_map_map_map.\n      rewrite map_map.\n        rewrite map_map_map_map_map_map_map.\n      + rewrite map_map_map.\n        rewrite map_map map_map_map.\n        rewrite map_map.\n      rewrite map_map.\n        rewrite map_map map_map map_map map_map_map_map.\n      map map map_map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  unfold map_map.\n  destruct (map_map f); intros.\n  destruct (map f e); eauto.\n  rewrite map_map_map_map_map_map f_map f); auto.\n  destruct (map f); auto.\n  simpl; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction n; intros; simpl; rewrite map_map_map.\n  + destruct (map_map_map_map f x) as [f?f x; simpl.\n  + rewrite map_map_map_map.\n  - f_map_map.\n    + rewrite map_map_map_map_map f_map_map_map_map; auto.\n      simpl; auto.\n  - rewrite map_map.\n    - simpl map_map_map.\n    rewrite map_map_map_map_map.\n    + rewrite map_map_map_map; auto.\n    * apply map_map.\n    + intros.\n    + simpl map_map_map map_map.\n    + destruct (map map_map_map_map f g h (map f) as [f x f g h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h'' h' h' h' h' h'' h' h' h' h' h''' h'' h' h' h' h' h'' h' h'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  destruct (map f g).\n  rewrite map_map_map_map_map_map; eauto.\n  rewrite map_map_map.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map.\n  destruct (map_map f g) as (map f).\n  rewrite map_map_map f g); eauto.\n  destruct (map f).\n  destruct (map f); auto.\n  destruct f_map f g); auto.\n  destruct (map f_map f_map f g f g); auto.\n  destruct f; auto.\n  destruct (map f f g f g); auto.\n  destruct f_map f g; auto.\n  rewrite map_map f_map f_map f g g g g g g f g g g g f g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g gQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map_map_map.\n  apply map_map_map_map_map; auto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map map_map_map map_map map_map_map.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_map_map_map_map.\n  rewrite map_map_map_map_map_map.\n  simpl map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map_map_map; auto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  intros.\n  eapply map_map_map_map_map_map_map_map.\n  eapply map_map_map_map_map_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros; auto.\n  unfold map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  destruct (map f_map f f) as [ | [ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros; induction l; intros; destruct l; intros; subst; subst; auto.\n  eapply map_map_map_map_map.\n  eapply map_map_map_map_map_map_map.\n  eapply map_map_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  induction (map f g h)).\n  destruct h.\n  rewrite map_map_map_map.\n  destruct h; auto.\n  eapply map_map_map_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  destruct (map f); auto.\n  rewrite map_map_map_map_map_map_map; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros; intros; auto with relations.\n  rewrite map_map_map_map.\n  apply map_map.\n  rewrite map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map.\n  apply map_map_map_map.\n  rewrite map_map_map_map_map; auto.\n  apply map_map_map.\n  rewrite map_map_map_map; auto.\n  apply map_map.\n  apply map_map; auto.\n  apply map_map_map_map_map.\n  intros.\n  destruct (map_map f) as [x?].\n  simpl map_map f); simpl; auto.\n  destruct (map f); simpl.\n  destruct (map f_map f; auto.\n  destruct (map f) as [? [??]]; auto.\n  eapply map_map_map_map_map_map_map_map f); auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (map f g g g) as [f|] eqn:E]; simpl; simpl.\n  destruct (find_map f f) eqn:E.\n  destruct (map f); simpl; auto.\n  apply map_map_map_map_map.\n  destruct (map f) eqn:E; auto.\n  destruct (map f g); auto.\n  destruct H; auto.\n  inv H; auto.\n  destruct (map f; auto.\n  destruct (map f); auto.\n  destruct (map f) as [f2; auto.\n  destruct (map f f_map f_map f); auto.\n  destruct f; auto.\n  destruct (map f f); auto.\n  destruct (map f_map f f); auto.\n  destruct f_map f; auto.\n  destruct f; auto.\n  destruct f_map f_map f f f f2; auto.\n  destruct f_map f_map f f f2; auto.\n  destruct f2; auto.\n  destruct f1; auto.\n  destruct f2; auto.\n  destruct f2; auto.\n  destruct f; simpl; auto.\n  destruct f; auto.\n  destructQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  simpl.\n  rewrite map_map_map_map.\n  simpl.\n  rewrite map_map_map_map_map.\n  repeat rewrite map_map_map; auto.\n  auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  simpl; intros; intros; rewrite <- map_empty_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  repeat rewrite map_map_map.\n  apply map_map_map_map.\n  rewrite map_map_map; auto.\n  destruct (map_map_map map_map f (map f)) eqn: map_map_map_map f g).\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map map_map.\n  rewrite map_map; auto.\n  repeat rewrite map_map_map map_map; auto.\n  apply map_map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map_map_map_map_map.\n  rewrite map_map_map map_map map_map_map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros; destruct x; intros.\n  destruct o; simpl; simpl; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  rewrite <- o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; simpl; auto.\n  destruct o; auto.\n  destruct o; auto.\n  inv o; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (find_map_map_map f) as [ | [h]?g]\n    simpl; rewrite!map_map_map_map_map_map_map; auto.\n  destruct (map_map_map_map f g h); auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  rewrite map_map_map_map_map; auto.\n  rewrite map_map_map_map.\n  destruct (map f a) as [??]]; subst.\n  rewrite map_map_map_map.\n  destruct (map f); auto.\n  destruct (map f); auto.\n  destruct (map f; auto.\n  destruct (map f g g g f); auto.\n  destruct f_map f; auto.\n  destruct f; auto.\n  destruct (map f g f g g g f g h g h); auto.\n  destruct g g; auto.\n  destruct g; auto.\n  destruct g; auto.\n  destruct g h; destruct g; auto.\n  destruct g h; simpl; auto.\n  destruct g h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct g; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destructQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (map_map f); auto.\n  destruct o; auto.\n  rewrite map_map_map; auto.\n  destruct o; auto.\n  destruct o; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (map_map f).\n  destruct (map f)).\n  destruct H.\n  destruct (map f); auto.\n  destruct (map f (map f); auto.\n  rewrite map_map_map_map_map_map_map_map f_map f g) (map f g f g f g) as [??]].\n  destruct H.\n  destruct H; auto.\n  destruct (map f); simpl in H; auto.\n  destruct (map f_map f g g; auto.\n  destruct H; auto.\n  apply map_map f_map_map_map f_map.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  destruct (map_map f g) as [f h].\n  destruct (map_map_map f) as [f].\n  destruct (map f); auto.\n  destruct h; subst.\n  destruct h; simpl in h; simpl; auto.\n  destruct h; auto.\n  destruct h; subst; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; simpl; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; simpl; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\n  destruct h; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  unfold map_map.\n  simpl.\n  unfold map_map. rewrite map_map.\n  unfold map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  destruct o; auto.\n  rewrite <- H. apply map_insert_insert_insert_insert; auto.\n  destruct H; auto.\n  apply map_insert_insert; auto.\n  rewrite map_insert_insert; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros; simpl; simpl; auto.\n  auto.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  apply map_map_map.\n  apply map_map_map.\n  auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros; intros; subst.\n  rewrite map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  apply map_map.\n  apply map_map; auto.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map; auto.\n  rewrite map_map map_map.\n  rewrite map_map map_map map_map map_map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  simpl.\n  unfold fold_left.\n  rewrite fold_right.\n  unfold fold_right.\n  apply fold_right.\n  fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  unfold fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_right.\n  fold_rightQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  intros. destruct (find_map f) as [f?].\n  destruct (map f).\n  destruct o; eauto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o; auto.\n  destruct o o; auto.\n  destruct o; auto.\n  destruct o; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros; rewrite fold_right.\n  rewrite fold_right; auto.\n  unfold map_right.\n  rewrite map_right; auto.\n  f_right.\n  rewrite map_right.\n  rewrite map_right; auto.\n  rewrite map_map.\n  rewrite map_right; auto.\n  rewrite map_map_map.\n  rewrite map_map_map; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  destruct o; simpl; auto.\n  rewrite <- map_map_map; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  simpl.\n  eapply fold_right. rewrite fold_right.\n  apply fold_right.\n  apply fold_right.\n  apply fold_right_right.\n  rewrite fold_right_right.\n  apply fold_right.\n  apply fold_right.\n  rewrite fold_right.\n  f_right.\n  rewrite fold_right.\n  apply fold_right.\n  apply fold_left. apply fold_right.\n  apply fold_right_right; auto.\n  rewrite fold_right; auto.\n  rewrite fold_right.\n  rewrite fold_right_right.\n  apply fold_right_right_right.\n  fold_right_right.\n  apply fold_right.\n  rewrite fold_left.\n  fold_right; auto.\n  apply fold_right.\n  apply fold_right; auto.\n  rewrite fold_right; auto.\n  apply fold_right; auto.\n  apply fold_right.\n  rewrite fold_right; auto.\n  apply fold_right.\n  unfold fold_right; auto.\n  apply fold_right.\n  fold_right_left.\n  apply fold_right.\n  fold_right.\n  unfold fold_right.\n  fold_right.\n Qed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  destruct (fold_fold_right_right.\n  unfold fold_map. rewrite map_right.\n  apply fold_right. rewrite map_right.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map_map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map map_map_map map_map map map_map map map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  intros.\n  destruct (eq_dec a b) as [x] | [x [?x [?x] [x [?x [?y [x [y [x y].\n  destruct (x y)); simpl; auto.\n  destruct (x y); auto.\n  destruct (y y); auto.\n  rewrite <- (add_add y); auto.\n  destruct (add x); auto.\n  destruct (add x); auto.\n  destruct (add y); auto.\n  destruct y); auto.\n  destruct (add x); auto.\n  destruct (add x); auto.\n  destruct (add x y); auto.\n  destruct (add y); auto.\n  destruct (add x); auto.\n  destruct (add x); auto.\n  destruct (add x); auto.\n  destruct (add x); auto.\n  rewrite <- H1 y); auto.\n  destruct y; auto.\n  destruct (add x y); auto.\n  destruct x; auto.\n  destruct y; auto.\n  destruct x; simpl; auto.\n  destruct x; destruct x; auto.\n  destruct (add_add x); auto.\n  destruct (add y); auto.\n  destruct x); auto.\n  destruct (Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  unfold fold_left.\n  intros.\n  destruct H.\n  destruct (f x); auto.\n  destruct (f x (f x).\n  simpl.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  destruct (find_right_fold_right_right_right.\n  destruct (find_right_right a) as [right f) eqn:E].\n  destruct (find_right.\n  destruct (find_right_right_right a); simpl in *.\n  destruct (find_right; auto.\n  destruct (find_right_right (find_right f a); try discriminate.\n  destruct H0; auto.\n  destruct (find_right; try discriminate.\n  destruct (find_right f a); try discriminate.\n  destruct H0; auto.\n  destruct (find_right; try discriminate.\n  destruct (find_right f); auto.\n  rewrite <- (find_right; auto.\n  destruct (find_right_right f_right f g); auto.\n  destruct H0; auto.\n  destruct (find_right f a); auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  destruct a.\n  destruct a; simpl.\n  destruct a; auto.\n  destruct (find_find_symbol_find_find (find_find_funct_funct_funct_funct_find_find_funct_funct_funct_funct_funct _ _ a) (find_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_ptr g (find_funct_funct_ptr) (find_funct_funct_funct_funct_funct_funct_funct_ptr_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_ptr_funct_ptr) (find_ptr_ptr_funct_funct_funct_funct_funct_funct_funct_funct_funct_ptr).\n\nDefinition valid_funct_funct_ptr_funct_ptr_funct_ptr_ptr_ptr :\n  forall (f:Type) (f:A) (f:A -> A) (A:A -> A),\n    exists g,\n      In (find_ptr_funct_ptr_ptr aQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros; try discriminate.\n  intros.\n  destruct (find_right (find_right_right_left _ _ H).\n  destruct H.\n  apply H.\n  destruct H as [right].\n  eapply E.\n  destruct E; eauto.\n  destruct H; eauto.\n  eapply E; eauto.\n  apply E; eauto.\n  rewrite E; eauto.\n  eapply E.\n  eapply E_left; eauto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction l; simpl; simpl; auto.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map; auto.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map; auto.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map map_map_map map_map.\n  rewrite map_map map_map map_map_map map_map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction (map_cons_map (map_map_map_map_map_map f g)).\n  induction e; simpl; simpl.\n  apply map_map.\n  apply map_map; auto.\n  apply map_map; auto.\n  rewrite map_map_map; auto.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map; auto.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map map_map_map; auto.\n  rewrite map_map_map map_map.\n  rewrite map_map map_map map map map_map map_map map_map map map map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  rewrite map_map. rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map.\n  rewrite map_map_map; auto.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map map_map map_map map map_map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros; intros; auto.\n  destruct (map f); auto.\n  destruct (map f (map f e) (map f) (map_map f)) as [??]]; auto.\n  rewrite <- map_map f e; auto.\n  destruct (map f); auto.\n  destruct (map f); auto.\n  destruct (map f f); auto.\n  destruct (map f); auto.\n  rewrite map_map f_map f_map f); auto.\n  destruct f_map f_map f; auto.\n  destruct f.\n  destruct f; simpl; simpl; auto.\n  destruct f_map f_map f_map f g; auto.\n  destruct f_map f_map f g g; auto.\n  destruct f_map f; simpl; auto.\n  destruct f_map f_map f g; auto.\n  destruct f; auto.\n  destruct f f; simpl; destruct (map f g f g; auto.\n  destruct f g g g g g g g g g h g g g h g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g gQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros; auto.\n  destruct (f e) as [f e].\n  destruct e.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  rewrite e; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (f e1)); simpl; auto.\n  apply add_true_app.\n  destruct (find_app (find_app_app_app_app_app_app_app_app_app_app_app).\n  destruct (app_app_app_app with (1 := f) :: e2 := fun (map_app _ => f) =>\n      let v2 := f1 := f1 :: e2 := fun f2 => f2 := fun f2 => f1 f2 f2 f2 => f2 f2 f2) in\n  end.\n\nLemma map_map_map_map_map_map: forall (f: A) (map f2: list A),\n  map f1 f2 ->\n  map f2 f2 ->\n  map f1 f1 f1 f2 f2 f2 ->\n  map f2 ->\n  map f2 ->\n  map f2 f2.\nProof.\n  intros; rewrite map_map_map_app.\n  unfold map_app.\n  rewrite map_app.\n  simpl; auto.\n  apply map_app; auto.\n  rewrite map_map_app.\n  rewriteQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (S k e1 e2) as [n1|n1|n1] [n2]; simpl; auto.\n  simpl; simpl; auto.\n  apply IH1.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; auto; auto.\n  - auto.\n  - rewrite <- nth_error_error_error_error.\n  - apply nth_error_error_error_error_error_error...\n  - apply nth_error_error_error_error_error_error...\n  - simpl.\n  - simpl.\n  - intros.\n    - simpl.\n    - simpl.\n    - apply nth_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error...\n    - apply nth_error_error_error_error_error_error_error_error...\n    - simpl.\n    - apply nth_error_error_error_error_error_error_error_error_error...\n    - simpl...\n    - rewrite nth_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error...\n    - simpl; rewrite nth_error_error_error_error_error_error_error_error_error...\n    - unfold length_error_error_error.\n      simpl; simpl; simpl; intros; simpl; simpl;Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction k; simpl; simpl; auto.\n  destruct H; auto.\n  apply IHk; auto.\n  destruct (split (IH x)).\n  destruct H0); auto.\n  apply IH; auto.\n  eapply IH.\n  destruct IH; auto.\n  eapply IH; auto.\n  simpl; auto.\n  apply IH.\n  apply IH; auto.\n  destruct IH; auto.\n  eapply IH; auto.\n  eapply IH; eauto.\n  eapply IH; auto.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eauto.\n  apply IH; eauto.\n  eapply IH.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eapply IH.\n  eapply IH; eauto.\n  eapply IH; eauto.\n  eapply IH; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  apply add_monotonic; eauto.\n  apply add_monotonic; eauto.\n  apply add_monotonic.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; auto.\n  induction 1; intros; auto.\n  apply add_monotonic; auto.\n  simpl; auto.\n  apply add_map.\n  - intros; auto.\n  - apply add_map.\n    - apply add_map_map_map; auto.\n    - intros.\n    - rewrite add_map.\n    + apply add_map_map_map.\n    - apply add_map.\n    - rewrite add_map.\n    + simpl; auto.\n    - apply add_map.\n    + rewrite add_map_map_map.\n    - apply add_map.\n    + apply add_map_map_map.\n    - simpl; auto.\n    - rewrite add_map.\n    + rewrite add_map_map.\n      - rewrite add_map_map.\n    - rewrite add_map_map_map_map_map.\n    + rewrite add_map.\n    + rewrite add_map_map.\n    + rewrite add_map_map.\n    - simpl.\n    + rewrite add_map.\n      - simpl.\n    - rewrite add_map_map.\n    rewrite add_map_map.\n    rewrite add_map. rewrite add_map_Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (eq_dec e2)); [| split; auto].\n  destruct e1; auto.\n  destruct e1; auto.\n  inv e1; auto.\n  destruct e; auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (find_length_map_map_map_map_map_map_map (map_map (map_map_map_map f)) as [ | | | | a v].\n  + destruct (map f v2); auto.\n  + destruct v2.\n      * destruct v1; auto.\n      destruct v1.\n      * destruct v2 as [v2];\n      * destruct v2 as [v2]; simpl; simpl; auto.\n      - apply IHl; auto.\n      * destruct (map_map_map f2); auto.\n      + destruct v1; auto.\n      * destruct v2; auto.\n        destruct v2; auto.\n      - destruct v2; auto.\n      destruct v1 v1; auto.\n      destruct v2; auto.\n      destruct v2; auto.\n      destruct v1; auto.\n      destruct v2; auto.\n      destruct v2; auto.\n      destruct v1; auto.\n      apply IHl; auto.\n      destruct v2; auto.\n      simpl; auto.\n      * simpl; auto.\n      * intros.\n      apply map_map_map; auto.\n      auto.\n      + intros.\n      + applyQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (is_redblack_redblack e1).\n  destruct (in_redblack e2).\n  unfold In.\n  destruct (in_redblack e2).\n  destruct e1 e2).\n  destruct (in_redblack e1 e2).\n  rewrite (in_redblack e2).\n  destruct e2.\n  destruct e1 e1.\n  destruct e1.\n  destruct e1.\n  inv H2.\n  destruct e2).\n  destruct e2. destruct e1.\n  destruct e2.\n  destruct e2; destruct e2 as [e2|e2]; destruct e2; inv H2; inv H2; inv H2; inv H3; inv H3.\n  destruct e2.\n  destruct e2.\n  destruct e1; inv H3; inv H3; inv H3; inv H3.\n  inv H3; inv H3; inv H3.\n  inv H4. inv H4; inv H3; inv H3; inv H4. inv H4; inv H4. inv H3. inv H4. inv H4; inv H4. inv H4; inv H4; inv H4; inv H2Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (f e2)).\n  destruct (f x); try discriminate.\n  subst.\n  destruct H.\n  destruct (f e1); simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  destruct e1; destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  subst e1; auto.\n  destruct e1 e2; auto.\n  destruct e1; auto.\n  destruct e1; destruct e2; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1 e1 e1 e2; simpl; auto.\n  destruct e1 e1; auto.\n  destruct e2; auto.\n  destruct e1 e2; auto.\n  destruct e1 e1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  destruct a as [e|e].\n  destruct (f x) as [e]; simpl.\n  destruct (f x); simpl.\n  destruct (f x); auto.\n  destruct (f x) as [e]; auto.\n  apply H.\n  destruct (f x)); auto.\n  exists (f x); auto.\n  apply H; auto.\n  destruct (f x); auto.\n  rewrite <- H.\n  destruct (f x)); auto.\n  destruct (f x); auto.\n  apply (f x); auto.\n  destruct (f x); auto.\n  destruct (f x x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  apply H.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  auto.\n  destruct (f x)); auto.\n  destruct (f x); auto.\n  apply f_equal.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct (f x); auto.\n  rewrite H.Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n intros.\n  destruct (remove_length_cons_cons_cons_cons (remove e2 e2 * e2) as [x1 | x1 y2|x1] [|x2] x2] [|y1 [x2].\n  exists x2; split; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  rewrite map_length in H.\n  destruct H as [m|m2].\n  destruct (S1,m2,m2,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,,,m,m,m,m,m,m,,m,,m,m,,,m,m,m,m,m,,m,,m,,m,,m,m,,,m,,m,m,,,,m,m,,m,,m,m,m,m,,,,,m,,m,,,,m,m,,m,m,,,,,,m,,m,,,,,m,,,,,,m,,,,,,,m,m,,m,,,,,,,,,,,,m,,,,,,,m,,,,,,,,,,,,,Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  apply fold_length.\n  rewrite map_length_length.\n  eapply fold_length; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  destruct (eq_dec x e2).\n  intros.\n  destruct e as [r [r1 [r1 [r1 [r1 [r2 [r2 [r2 [r1 [r2 r2] r2].\n  destruct r2].\n  destruct (f2); auto.\n  destruct (IH2); auto.\n  exists (IH2,IH2); auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  destruct (map_length l).\n  destruct s); intuition.\n  destruct H.\n  destruct H.\n  destruct (map_map (map (map_map_map_map_map_map_map_map (map_map f)) (map f) e2); simpl.\n  destruct (map f) as [map f_map f); auto.\n  eapply map_map_map_map_map_map_map_map; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction l; intros.\n  simpl; auto.\n  destruct (f e1)).\n  destruct (f e1 f2)).\n  rewrite map_equal.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app_app_app_app.\n  rewrite map_app.\n  destruct e2.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  apply map_app.\n  simpl.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app_app; auto.\n  rewriteQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  unfold lookup. rewrite fold_length.\n  rewrite map_length.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction l; intros.\n  apply nth_error_error_error_error_error_error_error; auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction e; intros.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  apply map_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  apply find_empty.\n  rewrite <- map_length.\n  apply map_length. rewrite map_length_length.\n  apply map_length_length.\n  apply map_length; auto.\n  rewrite map_length_length.\n  rewrite map_length_length.\n  rewrite map_length; auto.\n  rewrite map_length; auto.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length_length.\n  rewrite map_length_length; auto.\n  rewrite map_length.\n  rewrite map_length; auto.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length_length.\n  rewrite map_length map_length.\n  rewrite map_length map_length map_length.\n  rewrite map_length map_length.\n  rewrite map_length map_length.\n  rewrite map_length.\n  rewrite map_length map_length map_length map_length map map map_length map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  simpl in H. destruct H.\n  destruct (IH1); auto.\n  destruct (IHa:=IHe)).\n  destruct (IH _ _ _ _ _ H0) as [v0].\n  destruct H0; auto.\n  destruct H1.\n  destruct H1.\n  destruct H1. destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct e; inv H.\n  eapply lookup_length.\n  auto.\n  apply lookup_length; eauto.\n  simpl; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  rewrite <- IHl.\n  rewrite IHl.\n  apply IHl.\n  apply IHl; auto.\n  apply IHl; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl in *.\n  induction 1; intros.\n  destruct e; simpl in *.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e.\n  simpl.\n  inv H; auto.\n  destruct e; simpl in *.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  apply IHl; auto.\n  destruct e; auto.\n  destruct e; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros; auto.\n  rewrite app_1.\n  rewrite app_nil in *; omega.\n  apply app_nil.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  induction l; simpl in H.\n  destruct e.\n  apply IHl.\n  destruct (eq_dec x y).\n  destruct e).\n  rewrite IHe.\n  rewrite IHe; auto.\n  rewrite IHe.\n  rewrite IHe.\n  apply IHe.\n  apply IHe; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; simpl; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. apply add_length. apply add_length_length.\n  apply add_length. apply add_length.\n  apply add_length. apply add_length. apply add_length.\n  apply add_length. apply add_length. apply add_length. rewrite add_length. apply add_length. trivial. apply add_length. apply add_length.\n  apply add_length. apply add_length_length. trivial.\n  rewrite add_length_length. trivial. apply add_length; trivial. trivial.\n  apply add_length. apply add_length. trivial.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction l; intros.\n  rewrite map_app; auto.\n  apply map_app.\n  simpl; auto.\n  apply map_length_nil; auto.\n  destruct (map_app_app_cons x e).\n  rewrite map_nil.\n  rewrite map_app_app; auto.\n  rewrite map_nil; auto.\n  rewrite map_app.\n  rewrite map_app_app_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map_app.\n  rewrite map_app_app.\n  rewrite map_app.\n  apply map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_appQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.empty A k.\nProof.\n  intros.\n  destruct e; tauto.\n  destruct e; simpl; simpl; tauto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  unfold lookup.\n  induction n; intros; simpl; auto.\n  apply lookup; auto.\n  rewrite H0.\n  rewrite <-!IH; auto.\n  apply lookup_1.\n  destruct H0.\n  apply lookup_empty_empty.\n  rewrite <- lookup_empty_remove_1 in *; auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  induction e; intros; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  apply IHl; auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  destruct x; auto.\n  destruct x.\n  destruct x; auto.\n  apply nth_error_error_error_error_error_error_error_error_error_error_error_error...\n  destruct (remove x) as [x y]; auto.\n  - destruct x y; destruct x; auto.\n  - destruct (E x y); auto.\n  - destruct y as [x] y].\n    destruct y; auto.\n    - destruct (E x) as [x y].\n    - destruct x y; auto.\n    - destruct x y.\n    - rewrite E; auto.\n      * destruct y; auto.\n    - intros.\n    - destruct (E. destruct (E x); simpl.\n    - rewrite E_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error...\n  - intros.\n    rewrite <- E_error_error_error_error_error_error_error_error_error_error_error_error_error...\n    - rewrite E_error_error_error_error_error_error_error_error...\n  - intros.\n      applyerror_Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  destruct e; try congruence.\n  destruct e; auto.\n  inv H; auto.\n  destruct e; auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  unfold map_empty.\n  unfold map_empty, map, map_empty.\n  induction (map_empty_empty_empty_empty_empty_empty (map f)).\n  unfold map_empty.\n  apply map_empty.\n  rewrite map_empty_empty_empty_empty_empty.\n  rewrite map_empty; auto.\n  simpl.\n  rewrite map_empty_empty.\n  rewrite map_empty; rewrite map_empty.\n  rewrite map_empty_empty.\n  rewrite map_empty_empty_empty.\n  rewrite map_empty_empty.  rewrite map_empty_empty.\n  rewrite map_empty_empty_empty_empty_empty_empty_empty.\n  rewrite map_empty.\n  rewrite map_empty_empty_empty.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  destruct k; destruct k; inv H.\n  destruct k; inv H; inv H; auto.\n  eapply IH; eauto.\n  destruct H; eauto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros; unfold value_empty in *.\n  destruct (remove_remove_empty_empty_empty_empty_empty (remove_empty A k) as [x x] IH] [x] [x] [x] [x y] x] x] [x y] [x y]] [x y]] [x y] x] [y] x y] x] [y] x] *)\n\nLemma fold_map_empty_empty:\n  forall x y, map_empty_empty E_empty E x y ->\n  fold_empty E_empty E ->\n    fold_empty E.empty E ->\n    fold_empty E (empty E) x (empty E) (empty E)) (empty E)) ->\n    fold_empty E E E E E E E.\nProof.\n  induction E; simpl; auto.\n  - intros. rewrite E.\n  - intros x y E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  destruct (eq_empty A).\n  destruct x; auto.\n  apply IHl.\n  destruct (eq_dec x) as [x Hx].\n  destruct (eq x); inv Hx; auto.\n  destruct (eq x); auto.\n  destruct (eq x); auto.\n  destruct x); auto.\n  destruct (eq x); auto.\n  destruct H; auto.\n  destruct (eq x); auto.\n  destruct (eq x).\n  destruct (eq x); auto.\n  destruct x); auto.\n  rewrite <- H.\n  rewrite <- H.\n  destruct (eq_dec x); auto.\n  destruct (eq x); auto.\n  destruct (eq_eq x); auto.\n  destruct (eq_dec x); auto.\n  destruct (eq_dec x); auto.\n  destruct (eq x); auto.\n  destruct (eq x); auto.\n  destruct (eq x); auto.\n  destruct x); auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct (eq x); auto.\n  destruct (eq x); auto.\n  destruct x); auto.\n  destruct (eq x y); auto.\n  inv H; auto.\n  destruct (eq x); autoQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  apply (subst_empty_empty_length m).\n  apply app_length.\n  apply app_length.\n  apply app_length; auto.\n  + apply app_length_length.\n  - intros.\n    destruct (length m)).\n    destruct (length m) as [x|x|x] | | x] | | [x] | [x] x ] => [|x] | x ] => [|x y];\n      end.\n  + rewrite app_length.\n    - subst.\n    - destruct (2) as [y] as [x] ] ]; auto.\n    * rewrite app_length.\n    + destruct (length m) eqn:E,E.\n      * destruct (length m) as [y] eqn:E.\n      destruct (n & E as [y | | | ] eqn:E].\n      destruct (E1,E & E).\n      rewrite E; auto.\n      - destruct (E,E.\n      * intros (E,E,E & E) eqn:E.\n      -E,E.\n      rewrite E,E,E,E,E,E,E,E,E,E,E,E,E,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  destruct d.\n  destruct d; try omega.\n  - intros.\n  - destruct d; try omega.\n  - rewrite add_max_max_r.\n  - apply add_l.\n    - intros; auto.\n    - destruct d.\n    + destruct d.\n    - apply add_r.\n      - simpl; auto.\n    + destruct d; auto.\n      + destruct d; auto.\n      * apply add_max_max_l.\n      + apply add_max_max_max_r.\n      + destruct d; auto.\n      + destruct d; auto.\n      + destruct d; auto.\n        + rewrite add_r.\n      + split; auto.\n      + apply add_max_max_max_max_max_max_max_max_max.\n      * apply add_max_max.\n      + subst d.\n      + simpl; auto.\n      + split.\n      + intros d; auto.\n      + (* The Coq's case, we use the following definition of the fact that\n    [omega] and\n    - If [omega], it is a [omega], the [omega] are\n    case [omega] is not [omega] and [omega].\n   Qed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold my_max, max_max_max_max_max.\n  - unfold max_max, max_max.\n    rewrite min_max_max.max.max_max; auto.\n    - unfold max_max.\n    - rewrite max_max_max_max_max_max.max_max_max_max_max; auto.\n    rewrite max_max_max_max_max_max_max.\n    - max_max_max.max_max.\n    + rewrite max_max_max_max.max.\n    + rewrite min_max_max_max_max_max.max_max.\n    - max_max_max_max_max_max_max.\n    rewrite max_max_max.\n    apply max_max_max_max_max_max_max_max.\n    rewrite max_max_max_max_max_max_max_max_max_max.max.\n    rewrite max_max_max_max_max_max.max_max_max_max_max_max.\n    rewrite max_max.max_max_max_max_max_max_max_maxQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  destruct m as [|n] m].\n  destruct n]; simpl.\n  destruct (size_max m) as [m|n]; auto.\n  + split.\n    * destruct (size_max m); auto.\n    * destruct (size_max n); auto.\n    * apply IH; auto.\n    - destruct IH.\n    * intros; auto.\n    - destruct (size_max_p+2 * simpl; auto.\n    + destruct m); auto.\n    - destruct (size_max_max_max m); auto.\n    - destruct (size m); auto.\n    + destruct n; auto.\n    - rewrite IH; auto.\n    - simpl; auto.\n    + destruct (size_max_max m); auto.\n    - subst.\n    - intros.\n      + rewrite IH; simpl.\n    - unfold map_max_max_max_max.\n    - destruct IH; simpl; auto.\n    + simpl; intros; simpl; simpl; auto.\n    - destruct IH; auto.\n    - subst; auto.\n    - rewrite IH.\n    + rewrite IH; auto.\n    - destruct IH; destruct IH; simpl; auto.\n    - destruct IH]; auto.\n    -Qed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  apply my_max_max_max_max_max_max.\n  destruct (max_max_max_max_max_max_max_max n (max (max_max_max_max_max_max_max_max_max m)) as [n] H].\n  destruct n as [n [n IH].\n  exists n.\n  exists (max_max_max n; split; auto.\n  exists n; auto.\n  split.\n  apply IH.\n  apply IH; auto.\n  apply IH.\n  rewrite IH; auto.\n  apply IH_max_max_max_max_max_max_max_max; auto.\n  - split; auto.\n  - apply IHmax_max_max_max_max_max_max; auto.\n  - apply IH.\n  - apply IHmax_max_max_max_max; auto.\n  - apply IHmax_max_max_max_max_max_max; auto.\n  - apply IH; apply IH; auto.\n  - apply IH; auto.\n  - apply IHmax_max_max_max_max_max_max; auto.\n  - apply IHQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  rewrite <- le_max_max_max_max_max_max_max_max_max_max_max_max.\n  unfold cl_max.\n  apply lt_max_max_max.\n  rewrite lt_max_max_max; auto.\n  rewrite lt_max_max_max_max; auto.\n  rewrite lt_max_max_max.\n  apply le_max_max_max_max_max_max_max_max_max.\n  apply lt_max_max_max_max_max_max_max.\n  apply max_max_max_max.max_max_max_max_max_max; auto.\n  apply max_max_max_max_max_max_max_max; auto.\n  apply max_max_max_max_max_max_max_max_max_max_max_max_max_max; auto.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  destruct (max_max_max_max_max_max_max_max_max_max_max_max.\n  destruct m); simpl; auto.\n  destruct n; auto.\n  - destruct n; auto.\n  - subst.\n  - destruct n; auto.\n    + destruct (max_max_max m); auto.\n  + rewrite!max_max_max_max_max_max_max.\n    + rewrite!max_max_max_max_max_max_max.\n    -max_max_max_max_max_max.\n    -max_max_max_max; auto.\n    + rewrite!max_max_max_max.\n    + apply max_max_max_max_max_max_max_max.\n    -max_max_max_max.\n    - max_max_max_max_max_max; auto.\n    - max_max_max; auto.\n    - max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n    rewrite max_max_max_max_maxQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold max_max, min_max; auto.\n  destruct m; auto; auto.\n  destruct (inversion_clear - destruct (max_clear H) as [x|y|x].\n  -IH]; auto.\n  - destruct (IH_max_max x); auto.\n    - subst.\n    destruct (max x); auto.\n    - rewrite H.\n    + rewrite -IH.\n    rewrite <-IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  intros.\n  apply (@max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max (max_max k k) (max_max_max_max k).\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  intros.\n  destruct n as [n].\n  destruct n; destruct n; auto.\n  - rewrite IH; auto.\n  - destruct n; auto.\n    - destruct n; auto.\n    + subst; auto.\n    + simpl.\n    - apply IH.\n    - destruct IH; auto.\n    - destruct IH; auto.\n      - destruct IH]; auto.\n    - rewrite IH; auto.\n    - destruct IH; auto.\n    - simpl.\n    - destruct IH; auto.\n    - destruct IH as [|n]; auto.\n      + simpl in IH]; auto.\n      * destruct IH]; auto.\n      * destruct IH; auto.\n      * apply IH; auto.\n      + intros.\n      + destruct IH; auto.\n      * apply IH; auto.\n      + rewrite IH; auto.\n      * simpl.\n      * apply IH; auto.\n      * apply IH.\n      * rewrite IH; auto.\n    * rewrite IH; auto.\n      * rewrite IH; auto.\n      * rewrite IH IH.\n      * apply IH; auto.\n      * simpl; auto.\n      + rewrite IH.\n      * rewrite IH; auto.\n      * apply IH; auto.\n      + apply IH; auto.\n        * introsQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  intros.\n  unfold cl_max_max; simpl.\n  destruct cl_max; simpl; simpl; auto.\n  - apply cl_max_max.\n  - apply cl_max_max.\n    + simpl; auto.\n    - destruct cl_max_max_max_max; simpl in *; apply cl_max; auto.\n    - apply cl_max_max_max_max.\n    - intros; auto.\n    - destruct cl_max; auto.\n    - inv cl_max.\n    - apply cl_max_max_max; auto.\n    - unfold cl_max; auto.\n    - split; auto.\n    - apply cl_max_max_max; auto.\n    - apply cl_max_max_max_max_max_max.\n    - apply cl_max_max_max_max.\n      - apply cl_max_max_max_max_max_max_max.max_max_max.max_max_max.\n    - split; auto.\n    - apply max_max_max_max_max; auto.\n  + applymax_max; auto.\n    + apply max_max_max_max_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.max n = 0.\nProof.\n  intros.\n  unfold my_max_max.\n  unfold myr.\n  destruct n.\n  destruct n; simpl.\n  unfold max_max.\n  destruct (max_max_max_max n); [|apply max_max_max_max_max_max_max_max_max_max_max_max_max_max_max; auto.\n  + constructor.\n  + constructor.\n    + constructor.\n    - constructor.\n    - intros.\n    + rewrite min_max_max_max_max.\n    + rewrite max_max_max_max_max_max_max_max_max_max_max_max_max.\n    + apply max_max_max_max_max_max_max.\n    + max_max_max_max_max_max_max_max_max.max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n    - max_max_max_max_max_max_max.\n    apply max_max_max_max_max.max_max_max_max_max_max_max_maxQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  destruct (perm_max_max_max_max_max_max_max (max_max_max_max_max i) as [n] | S].\n  destruct n; auto.\n  destruct t as [n t; simpl; simpl; auto.\n  apply IH]; auto.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  destruct (IH (IHt, t) as [x|] eqn:H.\n  rewrite <- H].\n  - H.\n  - constructor; subst.\n  - apply IH.\n    - apply IH; auto.\n    - destruct H.\n      - inv IH; auto.\n    - destruct IH; auto.\n      - destruct IH]; auto.\n      * rewrite IH]; simpl; auto.\n      - inv IH; auto.\n      + intros?IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  apply lt_max_max_max_max_max_max_max.\n  apply lt_max_max_max_max_max_max_max_max_max_max.\n  apply le_max_max_max_max_max_max; omega.\n  destruct (max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n  apply lt_max_max_max_max_max_max.\n  apply max_max_max_max_max_max_max_max_max_max_max.\n  apply max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.max_max.\n  apply max_max_max_max_max_max_max.max_max_max_max_max_max_max.\n  rewrite max_max_max_max_max_max_max_max_max_max_max.max_max_max_max.max_maxQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  intros.\n  destruct (max_max_max_max_max_max_max i j); omega.\n  destruct (max (max_max_max_max_max_max_max_max_max i j); omega.\n  destruct (max_max i); auto.\n  + apply IH; auto.\n    * destruct H0.\n  + destruct (max_max_max_max_max i) as [omega|].\n    + destruct H0.\n      + split; auto.\n    + apply IH; auto.\n      * destruct (max_max_max_max i0.\n      + intros; apply IH; auto.\n      + rewrite IH; auto.\n      * apply IHmax_max_max_max_max_max_max_max.\n    + intros.\n    + apply IH.max_max_max_max_max_max_max_max_max_max_max_max.max_max_max_max_max_max_max_max_max_max; auto.\n    * apply max_max_max_max_max_max_max_max.max_max_max.\n    -max_max_max_Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.max k = 0.max_max i.\nProof.\n  intros.\n  unfold my_max, le_max_max.\n  rewrite if_max.max_max_max_max_max_max_max_max_max_max; try omega.\n  - rewrite <- <- Nat.max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.max_max.\n  -max.\n  + rewrite Nat.max_max_max_max_max_max_max_max_max.\n  + rewrite Nat.max_max_max_max_max_max_max_max_max_max.max_max_max.max_max.max_max_max_max_max_max.max_max_max.max_max.max.max_max_max_max_max_max_max_max_max_max_max.max.max.max_max.max_max_max_max_max_max.max_max_max.max_max_max.max.max_max.max_max_max_max.max_max_Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold my_max_max_max.\n  rewrite <- (max_max_max_max_max_max_max_max_max n); [omega].\n  apply inj_max_max.\n  apply inj_max_max_max_max_max_max.\n  apply inj_max_max_max_max_max; omega.\n  apply inj_max_max_max; omega.\n  apply inj_max_max; omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.max_max j = 0 -> my1 -> my_max (max_max_max m) -> my_max n m.\nProof.\n  intros.\n  destruct (max_max_max_max_max n)) as [|n] [|n] [|n] [|n] [|n]; [|n]; [|n]; [|n]; [|n]; [|n]; [|n] [|n]; [|n].\n  - 1]; [|n]; [|n]; [|n]; [|n [|n]; [|n [|n]; [|n]; [|n]; [|n [|n]; [|n] [|n]; [|n [|n]; [|n [|n [|n]; [|n]; [|n]; [|n]; [|n n n m]; [|n]; [|n]; [|n]; [|n [|n n n]; [|n [|n [|n]; [|n]; [|n]; [|n]; [|n [|n [|n [| n]; [|n [|n]; [|n n n]; [|n [|n [|n [|n n n n n n [|n] [|n [| n n n]; [|n]; [| n n n n n n n n n n n n n n n n n n n n n n nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  rewrite IH.\n  rewrite 2: apply my_max_max_max_max_max_max_max_max_max.\n  apply my_max_max_max.\n  - apply my_max_max_max_max_max.\n  - apply my_max_max.\n  - intros.max_max_max_max_max_max_max_max_max.\n  + rewrite (max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n  -max_max_max_max_max_max_max_max_max.\n    rewrite max_max_max.\n    rewrite max_max_max_max_max_max.max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n  apply max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n    apply max_max_max_max_max_max_max_maxQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold my_max, le_max_max_max; simpl.\n  rewrite (max_max_max_max_max_max_max n); auto.\n  apply (max_max_max_max (max_max_max_max n k); auto.\n  rewrite <- lt_max_max_max_max_max_max.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (insert_cmp_add_le_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n  rewrite <- H0.\n  rewrite <- H0_max_max_max_max.\n  rewrite <- H0.\n  rewrite <- H0_max_max_max_max_max_max_max_max_max_max_max_max_max_max.\n  rewrite <- H0.max.\n  rewrite <- H0_max_max_max_max_max.\n  rewrite <- H0, <- H0.max_max_max_max_max_max_max_max_max_max_max.\n  rewrite <- H0.max_max_max_max_max_max_max_max_max_max_max_max.max_max.\n  rewrite <- H0,max_max_max_max_max_max_max_max_max_max_max_max_max_max.max_max_max_max.max_max_max_max_max.max_maxQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold is_max.\n  unfold N.\n  destruct N.\n  destruct (is_max_max_max_max (max_max_max_max_max_max_max _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n intros.\n  destruct (H x).\n  destruct (H x) as [x|x|x|x|x|x|y|x|y|x|x|x|y|x|x|x|y|y|x|x|y|x|x||||||x||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros; unfold max_max; apply lt_max_max_max_max_max; trivial.\n  apply lt_max_max_max.\n  apply lt_max_max.max.\n  apply le_max_max_max.max.\n  apply lt_max_max_max.max_max_max.max.\n  apply le_max_max_max.max.max.max_max_max_max.max.max_max_max_max.max_max.max_max_max_max_max_max_max.max.max_max_max_max_max.\n  apply max_max_max_max_max.max_max_max_max_max.max_max_max.\n  apply max_max.max_max_max.max_max_max_max_max_max_max.max_max.max_max.max_max.max.max_max_max_max_max.max_max.max_max_max.max_max_max_max_max.max.max_max_max_max_max_max_max_max.max_Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct e as [|y|y|y]; simpl; simpl.\n  destruct (is_max_l2) as [y|y|y|y|y].\n  - unfold In_l; simpl; auto.\n  + destruct (min_min_l (min_min_min_min_max_max n)) as [x|y].\n    + 1); simpl; simpl; auto.\n  + destruct (min_max_min_max_max_min_max_max_min_max_min_max n); auto.\n  + destruct x; simpl; simpl; auto.\n  - rewrite add_max_max_max_max_max_max_max_max_min_max_max_max_max_max_max_max_max_max_max_max; auto.\n  + rewrite add_max_max_max_max.max_max_max_max_max.\n  + rewrite add_max_max_max_max.max.\n  rewrite add_max_max_max.\n  rewrite add_max_max_max_max_max_max_max.\n  rewrite add_max_max_Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (compare_max_max_max (max_max_max_max_max_max_max_max_max_max (max_max (max (max_max_max_max_max_max_max_max_max n)) as [[t] [t] [t] [t' [t' t' t' t'];\n  destruct t' t' t'; subst; auto.\n  destruct t'; destruct t'; simpl; auto.\n  destruct t'; try (max_max t; auto.\n  destruct t'; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t'; auto.\n  destruct t'; auto.\n  destruct t; auto.\n  destruct t; auto.\n  destruct t t t; auto.\n  destruct t; auto.\n  destruct t; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\nintros.\n destruct (insert_max_max_min_max_max_max n k) as [n]; simpl; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\nintros.\nunfold acc.\nunfold cond in *.\nunfold app.\nunfold rec_max in *.\nsimpl.\nsimpl.\ndestruct (cmp (insert_l1 := l1 l2).\nunfold cl2).\napply (insert_cmp_cmp_cmp_cmp_cmp_cmp_cmp_cmp_cmp_cmp_cmp (cmp (cmp_cmp l2) (cmp l1 l2)).\nrewrite <- insert_cmp_cmp_cmp_cmp_cmp_cmp l1.\ndestruct (cmp_cmp l2_cmp l1 l2) as [x1]; auto.\napply insert_cmp_cmp_cmp l2; auto.\nrewrite insert_cmp_cmp_cmp_cmp cmp_cmp_cmp_cmp_cmp_cmp cmp_cmp_cmp_cmp cmp_cmp cmp_cmp cmp cmp cmp cmpcmpcmp cmp cmpcmp cmp e1 cmp cmp_cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmp cmpQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  unfold length, <- (is_max_max (low_max_max_max_max_max_max (max_max_max_max_max_max_max_max_max_max_max_max_max_max_max k).\n  rewrite <- H0.max.max_max_max_max_max_max_max_max.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (t n)).\n  destruct (t (t_max_max_max_min_max_max_max k)).\n  destruct n).\n  destruct (max_max_max_max_max_max_max_max; auto.\n  destruct n); simpl; auto.\n  rewrite <- (max_max_max_max_max_max n); auto.\n  - rewrite <- Pos.max_max_max_max_max_max_max_max.\n  -max_max.\n  -max_max_max_max_max_max_max.max; auto.\n  - rewrite <- Pos.max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max_max.max_max_max_max_max_max.\n  -max_max_max_max_max.max_max_max_max_max_max_max.max.\n  rewrite <- Pos.max_max_max_max_max_max_max_max_max_max.max.max_max_max_max_max_max_max_maxQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction k; intros; auto.\n  simpl; intros.\n  destruct e; simpl; destruct e; rewrite <- IHl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  - apply IHl; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction k; intros; auto.\n  - destruct H; auto.\n  - intros; intros.\n    - subst; simpl.\n    + simpl; auto.\n    - auto.\n      * subst.\n      - subst.\n      * subst.\n      + intros.\n      - simpl.\n      * destruct H.\n      + destruct H; auto.\n      - apply H0; auto.\n      * subst.\n      * apply IHl.\n        + simpl; auto.\n      * apply IHl.\n      * apply IHl.\n      + apply IHl.\n      - rewrite IHl.\n      - intros.\n      + simpl.\n      - simpl.\n      - rewrite IHl.\n      + rewrite IHl.\n      - apply IHl.\n      - rewrite IHl.\n      + rewrite IHl; auto.\n      + rewrite IHl.\n      + simpl.\n      * intros.\n      + rewrite IHl.\n      + rewrite IHl.\n      - simpl.\n      - rewrite IHl.\n        rewrite IHl.\n      + rewrite IHl.\n      + intros l.\n      - rewrite IHl.\n      + rewrite IHl.\n      + rewrite IHl.\n      + destruct IHl.\n        rewrite IHl.\n      + intros.\n      + rewrite IHl.\n      rewrite IHl.\n      + simpl.\n      rewrite IHl.\n        + rewrite IHl.\n      + rewrite IHl.\n     Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction k; simpl; intros; simpl; simpl; simpl; auto.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  induction k; intros; simpl; intros; simpl; auto.\n  - simpl; auto.\n  - rewrite IHx; auto.\n  - apply IHx; auto.\n  - rewrite IHx; auto.\n  - rewrite IHx.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  rewrite!is_max_max_max_max_max_max_max_max_max.\n  rewrite!max_max.\n  rewrite!max_max_max.max_max_max_max_max_max.max_max_max_max.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  destruct e; simpl.\n  destruct e; auto.\n  destruct (insert_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree _tree_tree k e2); auto.\n  destruct e; auto.\n  destruct e1.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct (tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree_tree); auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e1; destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  inv H1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e2; auto.\n  destruct e2; simpl; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destructQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros e.\n  apply IH; intros k e1.\n  destruct (insert_or_max_max_max_max_max (insert_max_max_max_max_max_max_max_max_max (max (max_max x)).\n  rewrite <- IHl.\n  rewrite <- IHl,!max_max_max_max_max.max_max_max_max.\n  apply IHl.max_max_max.max.\n  apply IH.max_max_max_max.max.max.max_max_max_max_max_max.max.max_max_max_max.\n  apply min_max_max_max.max_max_max_max_max_max_max_max.max_max_max_max.\n  apply max_max_max.max_max_max_max_max_max_max_max.\n  apply max_max_max_max_max_max_max_max.\n  apply max_max_max_max_max_max_max_max_max.max_max_max_max_max_max_max_max_max.max_maxQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  destruct e; simpl.\n  simpl.\n  destruct (insert_tree_max_max_max_max_max_max_max_max_max_max_max_max (max_max x)).\n  - apply my_max_max_max_max_max.max_max_max.max_max.\n  + rewrite <- insert_max.max_max_max_max_max_max_max_max.max_max.max.max_max.\n  - rewrite <- insert_max_max_max_max_max.\n  -max_max_max_max_max_max_max_max.\n    rewrite <- insert_max_max_max_max_max_max_max.max_max_max_max.max_max_max_max.\n  rewrite <- insert_max_max_max_max_max_max_max_max.\n  rewrite insert_max_max_max_max_max_max_max_max_max_max.\n  rewrite <- insert_max_max_max_max_max_max_max_max_max_max_max.\n  rewrite insert_maxQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  unfold lookup; intros e; simpl; intros e.\n  destruct e; try solve [simpl; try solve [apply IH]; try solve [rewrite?t | apply IH]; auto; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  unfold length.\n  destruct e; simpl; simpl; simpl; auto.\n  - destruct (max_max_max_max_max x).\n  - constructor; simpl; simpl; auto.\n  - simpl; auto.\n  + simpl; auto.\n  - apply IHl.\n  - intros.\n  + rewrite IHl; simpl; auto.\n  + rewrite IHl; auto.\n  + rewrite IHl; auto.\n    + rewrite IHl; auto.\n    + simpl.\n    - rewrite IHl.\n    - rewrite IHl.\n    rewrite IHl.\n    + rewrite IHl.\n    - rewrite IHl; auto.\n    + rewrite IHl; auto.\n    + rewrite IHl; auto.\n    - simpl.\n    rewrite IHl.\n    + rewrite IHl.\n    + rewrite IHl.\n    rewrite IHl.\n    + rewrite IHl; auto.\n    + rewrite IHl.\n    + rewrite IHl; auto.\n    + rewrite IHl; auto.\n    - rewrite IHl; rewrite IHl.\n    - rewrite IHl; auto.\n    - rewrite IHl; auto.\n    - apply IHl; auto.\n    + rewrite IHl; auto.\n    - rewrite IHl; rewrite IHl.\n    - rewrite IHl; auto.\n    - rewrite IHl.\n    rewrite IHl; auto.\n    rewrite IHl.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction k; intros.\n  destruct (H1); subst; auto.\n  destruct x2; auto.\n  - constructor.\n  - rewrite <- IHl2.\n  - subst; auto.\n  + constructor.\n    - apply IHl1; auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold length_correct.\n  simpl. rewrite length_correct; simpl.\n  simpl.\n  apply length_correct.\n  rewrite length_correct.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  unfold length.\n  induction k; simpl; simpl.\n  f_equal; simpl; simpl.\n  rewrite <- IHl; intros.\n  f_equal; simpl; simpl; auto.\n  rewrite H.\n  rewrite <- IHl; auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction k; simpl; simpl; simpl; intros; omega.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert k); auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  induction k; simpl; auto.\n  + destruct k; intros; auto.\n  - apply IH.\n  - apply IH; auto.\n  - intros.\n    rewrite IH; auto.\n    + rewrite IH.\n    + simpl.\n    + rewrite IH.\n      - apply IH.\n      + simpl.\n      * apply IH.\n      * apply IH.\n      + destruct IH; auto.\n      rewrite IH.\n      * destruct IH; auto.\n      * apply IH.\n      + simpl; auto.\n      * destruct IH.\n      * simpl; auto.\n      * apply IH; auto.\n      * simpl; auto.\n      * simpl; auto.\n      * simpl.\n      * apply IH; auto.\n      * simpl.\n      + intros k; auto.\n      + simpl; auto.\n      * simpl; auto.\n      * apply IH; auto.\n      * apply IH; auto.\n      * apply IH.\n      * apply IH; auto.\n      * apply IH; auto.\n      * apply IH.\n      * simpl.\n      + intros.\n      * apply IH.\n      + apply IH; auto.\n      * apply IH.\n      - rewrite IH.\n      + apply IH; auto.\n      - apply IH; auto.\n      * applyQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction k; simpl; intros; simpl; auto.\n  - apply length_nil.\n  + rewrite app_length in IHn.\n  + apply length_length.\n    + destruct (insert_length a) as [| n]; auto.\n    + destruct (length a) as [n|n]; auto.\n      destruct (length a); auto.\n      + intros; auto.\n      * destruct (length a); auto.\n      * apply length_length_length_length.\n      - simpl; auto.\n      rewrite length_length.\n      + rewrite length_length.\n      destruct a); auto.\n      * rewrite length_length.\n      - rewrite length_length.\n      + length_length.\n      * length_length_length.\n        apply length_length_length.\n      apply length_length.\n      - length_length.\n      - length_length.\n      - length_length.\n      + length l.\n      induction l; auto.\n      - length_length.\n      * length l.\n      + length l.\n      + length l l l.\n      * length l.\n      * length l.\n      length l.\n      unfold length l.\n      rewrite length_length.\n      simpl.\n      + length l.\n      +Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  eapply length_correct.\n  apply length_correct.\n  rewrite length_correct; auto.\n  rewrite length_correct.\n  rewrite length_correct.\n  destruct (proj1_correct _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  unfold length_insert, length.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert x k e).\n  unfold length, length_insert, length.\n  unfold length, length.\n  unfold length_insert.\n  simpl.\n  apply length_insert_insert_insert_insert.\n  rewrite length_insert_insert_insert.\n  rewrite insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert.\n  applyinsert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert (insert x x) k).\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k e) as [x y].\n  destruct x as [x|x y].\n  rewrite (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert (insert_insert_insert x)).\n  applyinsert_insert_insert_insert.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  applyinsert_insert_insert.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert.\n  unfold insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  unfold insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold length.\n  rewrite nth_error_error_error_error_error_error_error_error_error_error_error.\n  rewrite app_error_error_error_error_error...\n  rewrite app_error_error_error_error_error_error_error_error_error...\n  rewrite app_error_error_error_error_error.\n  rewrite app_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error...\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  unfold length_add_comm.\n  rewrite app_r, length_assoc; reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  unfold length; intros; simpl; simpl; unfold length.\n  rewrite <- app_l.\n  rewrite <- app_l.\n  rewrite app_app.\n  rewrite app_assoc.\n  rewrite app_l.\n  rewrite app_r.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_comm.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_comm.\n  simpl.\n  rewrite app_assoc.\n  rewrite app_comm.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_assoc.\n  rewrite app_Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  unfold length.\n  unfold length in *.\n  unfold length.\n  rewrite length_length in *.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length in *.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length_length.\n  rewrite length_length.\n  apply length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length; simpl.\n  simpl.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  destruct (length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  apply length_length; rewrite length_length.\n  apply length_length.\n  rewrite length_length.\n  rewrite lengthQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  rewrite <- hd_l.\n  - unfold length_spec_spec; reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  unfold length.\n  eapply length_spec; [| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction 1; simpl; simpl; intros.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction k; intros.\n  induction k; simpl; simpl; simpl; simpl; intros k; auto.\n  rewrite <-!nth_nth_nth_nth.\n  rewrite!nth_nth_nth_nth_nth_nth_nth.\n  rewrite!nth_nth.\n  rewrite!nth_nth.\n  rewrite!nth_nth_nth_nth_nth_nth_nth_nth_nth.\n  apply nth_nth_nth_nth; auto.\n  rewrite!nth_nth_nth.\n  rewrite!nth_nth_nth; auto.\n  rewrite!nth_nth_nth_nth_nth_nth.\n  rewrite!nth_nth_nth_nth_nth_nth_nth.\n  rewrite!nth_nth_nth_nth_nth_nth.\n  rewrite!nth_nth_nth_nth_nth; [| [| [| [| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  rewrite <-insert.\n  rewrite <-insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x e) as [insert_insert_insert_insert_insert_insert_insert x y.\n  destructinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert;\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l).\n  rewriteinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction k; intros; try reflexivity.\n  rewrite length_length in *.\n  + simpl; reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  destruct e; simpl.\n  apply length_rev...\n  - constructor.\n  - intros; auto.\n  - rewrite <- app_length.\n  - apply length_length; auto.\n  + apply length_length.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x l).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x).\n  { destruct (insert_insert_insert_insert_insert_insert_insert_insert.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert l)).\n  + rewrite if_insert_insert_insert_insert_insert_insert_insert.\n  + rewrite insert_insert. rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  - unfold insert_insert_insert.\n  - unfold insert_insert_insert; intros; rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; rewriteinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;insert_insert_insert;insert;insert_insert;insert_insert_insert_insert;insert;insert_insert;insert;insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;insert_insert_insert_insert;insert_insert_insert;insert_insert_insert;insert_insertQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. unfold length.\n  rewrite length_correct, length.\n  rewrite length_correct, length_correct. apply length_correct.\n  unfold length_correct.\n  rewrite length_correct.\n  rewrite length_correct; rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  simpl.\n  unfold length_correct.\n  rewrite length_correct.\n  simpl.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  rewrite lengthQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  unfold length.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert x).\n  destruct (insert x k e1 y); auto.\n  rewrite insert_insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert.\n  rewrite insert_insert.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  applyinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  rewriteinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  unfoldinsert_insert_insert_insert.\n  unfold insert_insert.\n  unfold insert_insert_insert_insert.\n  unfold insert_insert_insert_insert_insert_insert.\n  destruct insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. destruct (x, length (insert_insert_insert_insert_insert_insert_insert_insert_insert x k).\n  destruct (insert_insert_insert x) as [x]; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x e.\n  - intros.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l l) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert x v v v v).\n  intros; simpl;\n  - unfold insert_insert; intros; destruct insert_insert; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros; reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x e).\n    apply insert_insert_insert. apply insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert x (insert_insert x e) as [insert x].\n    destruct (insert_insert_insert_insert_insert x) as [insert_insert_insert_insert_insert; unfold insert_insert_insert_insert_insert_insert_insert_insert_insert.\n    unfold insert_insert_insert_insert.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x l) y y.\n  unfold insert_insert_insert_insert.\n  unfold insert_insert; simpl; auto.\n  destruct x y.\n  destruct t as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x y).\n  unfold insertQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert x y l); simpl; reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert x y).\n  rewrite IHl; apply IHl.\n  rewrite IHl_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - destruct (insert x k e) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x y l).\n  destruct l. destruct H.\n  destruct l as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; destruct insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert;insert_insert_insert_insert;insert_insert_insert_insert_insert;Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k a l).\n  + apply length_insert; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert x k); auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x l) as [insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert l) l l l l l l l) l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l lQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert x e).\n  destruct x.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert...\n  destruct l) as [insert_insert_insert_insert x (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert_insert y) (insert_insert_insert x y) v) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\nProof.\n  unfold insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction m; simpl; simpl; auto.\n  + simpl; auto.\n    + simpl.\n    + simpl.\n    + simpl; auto.\n    + simpl; auto.\n    + simpl; auto.\n    + intros; auto.\n    + simpl; auto.\n    - unfold length; simpl.\n    - rewrite length_correct; auto.\n    + simpl; auto.\n    - simpl; auto.\n    - rewrite length_length; auto.\n    + rewrite length_correct.\n    + simpl; auto.\n    - simpl.\n    - simpl.\n    - simpl; auto.\n    - simpl; auto.\n    + simpl.\n    + simpl.\n    + simpl.\n    + rewrite length_correct; auto.\n    + intros.\n    + simpl.\n    - rewrite length_correct.\n    rewrite <- length_correct.\n    - length_correct.\n    - length_correct.\n      - length_correct_correct; simpl; auto.\n    - simpl; auto.\n    + simpl.\n    - rewrite length_correct; auto.\n      + simpl; auto.\n    - rewrite length_correct.\n    - rewrite length_correct; simpl.\n    - simpl.\n      rewrite length_correct; auto.\n    - simpl.\n    - rewrite length_Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  unfold length_length.\n  intros.\n  unfold length_length.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length in_length in H0.\n  unfold length in H0.\n  unfold length_length in H0.\n  unfold length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length.\n  unfold length_length.\n  rewrite length_length in H0.\n  unfold length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length.\n  rewrite length_length.\n  rewrite length_length.\n  apply length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewrite length_length in H0.\n  rewriteQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  destruct x; [rewrite H; rewrite <- H; reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite length_cmp_cmp_cmp_cmp.\n  apply length_cmp_cmp.\n  apply length_cmp_cmp_cmp_cmp_cmp_cmp_cmp_cmp...\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l).\n  eapply length_insert_insert; [insert; [insert].\n  rewrite insert_insert_insert_insert; [insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - subst.\n  - rewrite insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - rewrite insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; simpl; auto.\n  + destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite length_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l l) as [x] |insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x (insert_insert_insert l)) as [insert].\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  apply length_true_rev_cons; reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  apply length_correct.\n  destruct l as [x].\n  rewrite length_length.\n  destruct (map_length_correct_length (length x)).\n  destruct l as [x|] eqn:Heq |Heq | [Heq |Heq].\n  rewrite <- Heq].\n  + destruct (length_length_length_length x)); auto.\n  + destruct (length x) as [|Heq |Heq |Heq |Heq|Heq]; simpl; auto.\n  - erewrite <- Heq; auto.\n  + apply length_length in Heq; auto.\n  - destruct Heq; auto.\n  + rewrite Heq.\n  + rewrite Heq; auto.\n  - rewrite Heq; auto.\n  - intros Heq.\n  + destruct Heq.\n    - apply Heq.\n    - rewrite Heq.\n    - rewrite Heq.\n    + rewrite Heq.\n    - rewrite Heq_length in Heq.\n    + simpl.\n    - simpl; auto.\n    - destruct Heq; auto.\n    + unfold app_length.\n    - rewrite Heq.\n    + simpl.\n    + rewrite Heq; auto.\n    - rewrite Heq in Heq.\n    + intros Heq in Heq.\n    rewrite Heq.\n    - simpl in Heq Heq.\n    - unfold Heq in Heq HeqQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros; intros; inv H0.\n  inv H0.\n  apply length_correct_length.\n  rewrite length_correct. apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct. rewrite length_correct.\n  apply length_correct. apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  simpl.\n  apply length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  rewrite length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct.\n  apply length_correct; simpl.\n  apply length_correct.\n  rewrite length_correct.\n  apply length_correct.\n Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros; simpl; simpl; auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction l.\n  induction k; simpl; simpl; intros; simpl; simpl; auto.\n  rewrite length_correct; auto.\n  simpl; auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction l; intros; simpl; auto.\n  - rewrite <- IHl; auto.\n  - rewrite nth_error_error_error_error_error_error_error_error_error_error_error_error_error...\n  + destruct l; simpl; simpl; auto.\n    - simpl; auto.\n    - apply nth_error_error_error_error_error_error_error_error...\n  + rewrite nth_error_error_error_error_error_error_error...\n  - unfold nth_error_error_error_error_error_error_error_error...\n  - simpl...\n  - rewrite app_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error...\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction k; simpl; intros; simpl; auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction k; simpl; simpl.\n  apply length_length_length; auto.\n  + induction l; auto.\n    + simpl; auto.\n    - simpl; simpl; simpl.\n    + simpl; auto.\n    - rewrite <- length_length; auto.\n    - rewrite <- length_length.\n    - rewrite length_length.\n    + simpl; auto.\n    - simpl.\n    - destruct (length_length (length v v).\n    - length_length v) as [| simpl; simpl.\n    + rewrite length_length in *.\n    - length_length.\n    - simpl; auto.\n    + rewrite length_length in *.\n    - length_length.\n    - length_length in *.\n    + length_length.\n    + length (length v).\n    + length (length v) l).\n    rewrite length_length; auto.\n    - length_length; auto.\n    + length_length; auto.\n    + length (length v) n).\n    + length l.\n    - length l.\n    + length l.\n    + length l.\n    rewrite length_length.\n    - length l.\n    rewrite length_length_length.\n    - length l l) in *.\n    - length l.Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  unfold length.\n  intros.\n  unfold length.\n  destruct e; simpl; simpl.\n  rewrite <- beq_nat_list_nat_nat_nat_nat_nat_nat.\n  rewrite <- beq_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\n  rewrite <- beq_nat.\n  rewrite leb_nat_nat_nat_nat_nat.\n  rewrite minus_nat_nat_nat.\n  rewrite leb_nat_nat_nat_nat_nat_nat_nat.\n  rewrite H.\n  apply beq_nat_nat_nat_nat_nat_nat.\n  rewrite leb_nat_nat.\n  apply beq_nat_nat_nat_nat.\n  rewrite leb_nat_nat_nat_nat_nat_nat_nat.\n  rewrite leb_nat_nat_nat_nat.\n  apply leb_nat_nat_nat_nat.\n  rewrite leb_nat_nat_nat.\n  rewrite le_nat_nat.\n  rewrite leb_nat_nat_nat_nat_nat_nat_nat_nat_nat.\n  apply leb_nat_nat_natQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros; simpl; rewrite length_map_map.\n  rewrite length_map_map.\n  simpl.\n  rewrite length_map_map_map_map_map_map.\n  rewrite length_map_map; rewrite length_map; auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction k; simpl.\n  - simpl.\n  + simpl.\n    + simpl; simpl.\n    - rewrite <- app_iff in *.\n    - simpl in *.\n    + destruct e; simpl in *.\n    - simpl; simpl in *.\n    - simpl.\n    rewrite nth_error_error_error_error_error_error_error_error_error_error_error_error.\n    - rewrite nth_error_error_error_error_error_error_error_error.\n      - simpl.\n      - simpl.\n      - simpl in *.\n      + rewrite nth_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error_error.\n      - rewrite nth_error_error_error_error_error_error_error_error.\n      rewrite nth_error_error_error_error_error_error_error_error_error_error_error_error_error_error.\n      *\n        * applyerror_error_error_error_error_error_error_error_error_error_error_error_error_error...\n      - unfold nth_error_error_error in *; omega.\n     Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  unfold length.\n  destruct (insert_nth_nth_nth k e).\n  destruct e as [| [| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  destruct e as [e|e].\n  destruct e; simpl.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; simpl; auto.\n  destruct e; auto.\n  destruct e; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros; auto.\n  rewrite <- IHl.\n  apply In_app_app.\n  apply In_app.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  assert (k : env (k : env) = Some e2) = Some y).\n  { unfold f_equal. simpl.\n  unfold add_inv in *.\n  rewrite map_inv in *.\n  destruct (IH1)) as [f2].\n  unfold get_false by auto.\n  rewrite map_iff in *.\n  rewrite map_map; auto.\n  rewrite map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_map_map.\n  apply map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map_map map_map map_map map_map map_map.\n  rewrite map_map map_map map_map map map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  induction e; simpl; simpl; auto.\n  apply IHl1; auto.\n  apply IHl.\n  apply IHl.\n  apply IHl; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  unfold In.\n  rewrite H.\n  rewrite map_add_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map map_map_map_map_map.\n  rewrite map_map_map.\n  rewrite map_map; auto.\n  rewrite map_map; auto.\n  rewrite map_map_map.\n  rewrite map_map map_map_map map_map map map_map.\n  rewrite map_map_map map_map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  apply (map_map_map_map_map_map_map_map_map_map (map f e1 e1 e2).\n  apply fold_map_map.\n  apply map_map.\n  apply map_map_map_map.\n  apply map_map.\n  apply map_map_map.\n  apply map_map_map_map.\n  apply map_map_map_map_map_map.\n  apply map_map_map.\n  apply map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map map_map_map_map_map map_map_map.\n  rewrite map_map map_map.\n  rewrite map_map map_map map_map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map map mapQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  unfold agree, agree.\n  intros.\n  apply agree_from_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete; auto.\n  unfold agree_delete; auto.\n  apply sepcon_delete_delete_delete_delete_delete_delete_delete.\n  apply f_delete_delete_delete_delete_delete; auto.\n  apply f_delete_delete_delete_delete_right.\n  apply f_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete; auto.\n  apply f_delete_delete_right.\n  apply f_delete_delete_delete_delete_right.\n  apply f_delete_delete_delete_delete_delete_delete_right.\n  apply f_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete.\n  apply f_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_delete_deleteQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  induction e; simpl; auto.\n  intros; intros.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite IHl1; auto.\n  rewrite IHl1; auto.\n  rewrite IHl1; auto.\n  rewrite IHl2.\n  rewrite IHl2; auto.\n  rewrite IHl1; auto.\n  rewrite IHl1; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  unfold agree.\n  unfold agree in *.\n  apply (map_map_map_map_map_map_map_map_map_map.\n  unfold agree_map_map.\n  apply agree_map.\n  apply agree_map_map.\n  apply (map_map_map_map_map_map.\n  apply agree_map_map.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite map_app; intros.\n  apply map_app_app.\n  f_app_app.\n  apply map_app.\n  destruct (map_app _ _ H).\n  apply map_app_app.\n  apply map_app. apply map_app.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct (list_list_list A) as [x] eqn:H].\n  simpl.\n  rewrite <- H.\n  destruct H.\n  destruct (f x); auto.\n  destruct H; auto.\n  simpl.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x).\n  destruct x; auto.\n  rewrite map_map_map_map_map_map_map_map_map.\n  destruct x).\n  rewrite map_map_map_map.\n  destruct x; auto.\n  rewrite map_map.\n  simpl.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map.\n  auto.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map_map_map_map_map_map.\n  rewrite map_map.\n  rewrite map_map_map map_map map_map.\n  rewrite map_map.\n  rewrite map_map.\n  simpl map_map_map map_map map_map map_map map map map map_map map map map map mapQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite <- H.\n  rewrite <- H.\n  rewrite <- H. rewrite <- H.\n  apply H.\n  apply H.\n  rewrite <- H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply (H H).\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply (H1 _ H2 H2 H3).\n  apply H1.\n  apply H3.Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  unfold agree.\n  destruct H; auto.\n  destruct H.\n  apply H. apply (E _ _ _ H).\n  apply H0.\n  apply H0.\n  rewrite <- H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0. apply H0. apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0 (H0 (H0 _ H0).\n  apply H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct (eq_dec e) as [e' [x y] [x] eqn:E [E [E] |E0].\n  apply In_eq_dec. apply IHl.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  apply agree_empty_empty_empty.\n  apply repr_empty_empty_empty_empty_empty; auto.\n  apply repr_empty. \nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  induction 1; intros; auto.\n  apply H.\n  apply get_inv in H; auto.\n  apply get_spec.\n  rewrite get_eq_spec.\n  rewrite get_spec.\n  auto.\n  apply get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec in *.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec.\n  rewrite get_spec; auto.\n  rewrite get_spec_spec in *.\n  rewrite get_spec; auto.\n  rewrite get_spec_spec in H; auto.\n  rewrite get_spec.\n  rewrite get_spec; auto.\n  rewrite get_spec in H1; auto.\n  rewrite get_spec in H2.\n  rewrite get_spec_spec.\n  rewrite get_spec.\n  rewrite get_spec; auto.\n  rewrite get_spec_spec in H.\n  rewrite get_spec_spec in H; auto.\n  rewrite get_spec in H.\n  rewrite get_spec in H.\n Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  apply (map_empty_empty_empty_empty_empty_empty_empty_empty_empty.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct h.\n  apply (map_map_map_map_map_map_map_map_map_map_map_map_map_map_map_map_map (map (map_map f)).\n  apply map_map_map_map.\n  unfold In_map.\n  apply map_map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map_map.\n  apply map_map.\n  apply map_map.\n  apply map_map_map.\n  apply map_map_map_map; [rewrite map_map.\n  apply map_map_map.\n  eapply map_map.\n  eapply map_map_map_map; eauto.\n  eapply map_map.\n  eapply map_map_map.\n  eapply map_map_map_map_map_map_map.\n  eapply map_map_map.\n  eapply map_map.\n  eapply map_map.\n  eapply map_map_map_map_map.\n  eapply map_map_map_map.\n  eapply map_map_map_map_map_map.\n  eapply map_Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  apply (t1 x e1 e1 e1 e1 e1 e2).\n  apply add_empty_2.\n  rewrite <- map_empty.\n  rewrite map_empty.\n  apply map_add_empty. apply map_empty.\n  apply map_empty_empty_empty.\n  apply map_empty.\n  apply map_empty.\n  apply map_empty_empty_empty_empty.\n  apply map_empty.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  apply get_empty_empty_empty.\n  unfold agree in *.\n  apply agree_empty.\n  apply get_empty_empty.\n  apply get_empty_empty_empty.\n  apply get_empty.\n  apply get_empty_empty_empty.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree.\n  intros.\n  apply agree_empty.\n  destruct x; auto.\n  rewrite H; auto.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  apply (find_empty_empty_empty_empty.\n  apply agree_empty_empty.\n  apply agree_empty_empty.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  unfold agree_empty.\n  unfold agree_empty_empty.  unfold agree_empty.\n  apply agree_empty.\n  apply agree.  apply agree_empty.  apply agree_empty_empty. \nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  destruct e; auto.\n  apply agree_empty.\n  rewrite agree_empty_empty_empty.\n  rewrite agree_empty_empty.\n  apply agree_empty_empty_empty. \nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  simpl.\n  apply agree0. apply agree_empty_empty_empty_empty_empty.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H. rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  apply H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H; rewrite <- H.\n  rewrite <- H; rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H. rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- (H0.\n  rewrite <- H. rewrite <-Qed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  apply agree_empty_empty_empty.\n  apply agree_empty_empty.\n  intros.\n  apply agree_empty_empty.\n  apply agree_empty.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  unfold agree_empty.\n  unfold agree in *.\n  unfold agree in *.\n  unfold agree_empty in *.\n  unfold agree.\n  unfold agree.\n  unfold agree in *.\n  apply agree_empty in *.\n  unfold agree.\n  apply agree.\n  rewrite agree.\n  rewrite agree. apply agree_empty_empty_empty.\n  apply agree_empty_empty_empty.\n  apply agree_empty.\n  apply agree_empty_empty_empty.\n  apply agree_empty_empty_empty.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  rewrite get_empty_empty.\n  rewrite get_empty_empty.\n  apply get_empty.\n  rewrite get_empty.\n  rewrite get_empty_empty_empty_empty_empty.\n  apply get_empty_empty.\n  rewrite get_empty.\n  rewrite get_empty_empty_empty_empty_empty. \nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros.\n  destruct e; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct h; simpl; auto.\n  destruct h; simpl; simpl; auto.\n  destruct h; auto.\n  rewrite <- H.\n  rewrite <- H; auto.\n  apply (H1 _ H2).\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H1; auto.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2; auto.\n  rewrite <- H2.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3. rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H2.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3. rewrite <- (IHl2); auto.\n  rewrite <- (IHl _ (IHl _ _ H2).\n  rewrite <- (IHl l).\n  rewrite <- H3.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- (IHl _ H3.\n  rewrite <- (IHl l2 l2) (IHl l1).\n  rewrite <- (IHl lQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  rewrite H.\n  apply agree_empty.\n  rewrite <- H.\n  destruct (listd_rev_rev_iff_rev_rev_rev (rev e1)) as [e2 [k2 [k2]]].\n  rewrite H2 [k2].\n  rewrite H2. rewrite (rev_rev e2. apply In_rev_rev_rev. apply In_rev_rev.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  generalize (H_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert x k e1); intros.\n  generalize (insert_insert_insert_insert_insert_insert_insert_insert_insert x y) k e2);\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert k); intro; destruct (insert_insert_insert_insert_insert; destruct (insert_insert_insert_insert_insert x) eqn:E1.\n  destruct x); intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert k); destruct (insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert x1.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert _insert_insert x1) eqn:E2; destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x1 l2);\n  destructinsert_insert_Qed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct (e1 e2).\n  destruct e2; auto.\n  split.\n  apply H2.\n  rewrite H2. apply H2. apply H2. apply H2. apply H2. apply H1.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct (e1 e2).\n  destruct (e1 e2 e2) as (e1 e2).\n  destruct e1; auto.\n  destruct e2; auto.\n  rewrite H1.\n  apply H2; auto. apply H1; auto.\n  split; auto.\n  simpl; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  rewrite (elements_empty_1) in H.\n  apply (elements_list_empty_empty_empty_empty_empty_empty.\n  apply agree_empty_empty_empty_empty_empty. apply agree_empty.\n  apply agree_empty.\n  apply agree_empty_empty_empty.\n  apply agree_empty_empty_empty_empty.\n  apply agree_empty. \nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  apply agree_left_left.\n  apply agree_right_left. apply agree_right.\n  apply agree_left. apply agree_right.\n  apply agree_right.\n  apply agree_right_right_left.\n  apply agree_right.\n  apply agree_left.\n  apply agree_left.\n  apply agree_right.\n  apply agree_left.\n  apply agree_left.\n  apply agree_left.\n  apply agree_left.\n  apply agree_ext. apply agree_left_left.\n  apply agree_right. apply agree_right_left.\n  apply agree_left.\n  apply agree_ext.\n  apply agree_right.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n intros.\n apply agree_right.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n intros.\n  destruct H. destruct H; discriminate.\n  destruct H; congruence.\n  destruct H.\n  apply H.\n  rewrite <- H.\n  destruct H.\n  destruct H.\n  apply H.\n  rewrite H.\n  rewrite H. rewrite H.\n  rewrite H.\n  rewrite H.\n  destruct H.\n  apply H.\n  rewrite H.\n  rewrite H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  rewrite H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H. apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H. apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0. apply H. apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply (IHl H0).\n  apply H1.\n  apply H0. apply H0.\n  apply H0.\n  apply HQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  intros.\n  destruct x; simpl; simpl; simpl.\n  rewrite agree_insert_insert_insert; auto.\n  apply agree_insert_insert.\n  rewrite agree_insert_insert_insert_insert_insert_insert_insert; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n\n  Proof.\n    intros.\n    unfold sub_order'.\n    apply sub_order.\n    destruct (IH _ H).\n    apply sub_order_order_order_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      rewrite sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order_order.\n      apply sub_order_order.\n      apply sub_order_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order_order.\n      apply sub_order_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order.\n      apply sub_order_order.\n      apply sub_order.\n      apply sub_order with (order_order_order.\n      applyQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros.\n    unfold sub_order.\n    destruct (H1 a).\n    unfold sub_order.\n    unfold sub_order in H.\n    destruct (eq_dec a2) as [x1 [x1 y2 y2y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y2 y3 y2 y22 y2 z2 y2 y2 y3 y2 y22 y3 y3 z2 y2 y2 y22 z3 z2 y2 y2 y2 z3 z3 z3 y3 y3 y3 z3 z2 y3 z3 z3 z4 z4 z2 z2 z3 z3 z3 z4 z4 z z3 z3 z4 z3 z4 z3 z z3 z3 z2 z3 z2 z z4 z z z4 z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma osub_None: forall o, osub o None.\n\n  Proof.\n    intros.\n    induction o; intros; simpl; auto.\n    apply IH; auto.\n    intros; auto.\n    unfold is_founded; auto.\n    apply IH; auto.\n    split; auto.\n    - apply IH.\n    - apply IH; auto.\n    - intros.\n    - apply IH.\n    + apply IH1.\n    + apply IH.\n    - apply IH1_eq_dec.\n    + apply IH1.\n      - apply IH.\n    - apply IH; auto.\n    - apply IH.\n    - apply IH2_1_1_2_1_2_2_2_2_2.\n      apply IH.\n    - apply IH2.\n    - apply IH2_1_1_2; auto.\n    - apply IH1.\n    - apply IH2_2_2.\n    + apply IH1.\n    - apply IH1.\n    - apply IH2.\n    + apply IH2_2.\n    - apply IH1_2.\n    - apply IH1_2; auto.\n    - apply IH2_2_1_2; auto.\n    - apply IH2_2; auto.\n    - apply IH1_1_2_1_2Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros; intros.\n    destruct (f x o1 o a1 o1 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o1 o2 o2 o o2 o1 o2 o2 o2 o o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o o2 o2 o o o o o o2 o2 o o o1 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_None: forall o, osub o None.\n\n  Lemmabuiltin_step_step : forall a2 a1 o a1 o1 o2 o1 o2 ->\n    (forall a2 o1 o2 o2 o1 o2 o2 o1 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o1 o1 o1 o2 o2 o2 o1 o1 o2 o1 o2 o1 o1 o2 o2 o1 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o o1 o1 o2 o2 o2 o o1 o2 o2 o2 o o2 o1 o o o o o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros.\n    apply invert_right.\n    assert (H:=H).\n    apply invert_left.\n      apply invert_right_left_right_right.\n      apply invert_left.\n      apply invert_right_left.\n      apply invert_right_right.\n      assumption.\n      apply invert_right_left.\n      apply invert_right_right.\n      apply invert_left.\n      apply invert_right.\n      apply invert_right.\n      apply invert_left_right.\n      apply invert_right_right.\n      apply invert_right_right.\n      apply invert_right_right.\n      assumption.\n      apply invert_trivial.\n      apply invert_one.\n      eapply invert_one_one_one.\n      apply invert_one_one.\n      apply invert_one_one_one_one_one.\n      apply invert_one_one.\n      apply invert_one_one_one_one.\n      apply invert_one_one_one_one_one.\n      apply invert_one_one.\n      apply invert_one_one_one.\n      apply invert_one.\n      apply invert_one_one_one_one_one_one_one_one_one_oneQed.",
                    "Lemma osub_None: forall o, osub o None.\n\n  Proof.\n    intros.\n    unfold sub.\n    unfold sub.\n    unfold sub_mapsto, sub.\n    intros.\n    split; apply sub_dec_mapsto in H; auto.\n    apply sub_mapsto.\n    apply sub_mapsto; auto.\n    apply sub_mapsto_mapsto; auto.\n    intros [x [y [y [y [y y y y y y y y y y y y y y y y z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma osub_None: forall o, osub o None.\n\n  Proof.\n    intros.\n    apply sub_trans with (e := M1 := M1).\n    intros.\n    apply sub1.\n    apply sub_trans with M1 M2 := M1 M2 M2 M2 M2 M1 M2 M2 M2 M2 M2 M1 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M1 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M2 M M M M2 M2 M M2 M M1 M2 M2 M M M2 M2 M M1 M2 M M M2 M M M M M2 M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M M MQed.",
                    "Lemma osub_None: forall o, osub o None.\n\n  Lemma is_step_step_step_step_step_step : forall a a1 o a1 o1 o2,\n    sub_step a1 o2 ->\n      sub_step a2 o2 ->\n      sub_step a2 o1 o1 o1 o1 o1 o1 o1 o2 o2 o1 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o2 o2 o1 o2 o2 o1 o1 o2 o2 o1 o1 o2 o2 o2 o2 o1 o o1 o1 o2 o2 o2 o2 o2 o1 o1 o1 o1 o2 o2 o2 o2 o2 o2 o2 o o1 o o1 o2 o2 o1 o o2 o o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros.\n    unfold sub; auto.\n    unfold sub_trans with a1.\n    destruct (x2) as [y1 x1 y1 y2 y1 y2 y2 y2 y2 y2 x3 y3 y2 y3 y3 y3 y3 y3 y3 y4 y3 y3 y3 y3 z3 y3 y3 y3 y2 y3 y3 y3 y3 y3 y4 y3 y3 y3 y4 y4 y3 y4 y3 y4 y3 y3 y3 z3 y3 y3 y3 y3 z4 z3 z3 y4 z3 z3 z3 z3 z3 y3 z3 z3 z3 z3 z3 z3 z4 z3 z z3 z3 z3 z z3 z z3 z3 z z z z z z3 z z z3 z z z3 z3 z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma invert_right : forall a1 a1 o1 a2 ->\n    sub_order a1 o1 o2 ->\n    sub1 o1 o2 o2 o2 o2 o1 o1 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o o2 o o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o1 o1 o2 o o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o o2 o o o o2 o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma os_step_step_step_step:\n    forall a b2,\n    forall a1 a2 a1 a2 -> sub_step a1 a1,\n    sub a2 ->\n    sub_step a1 ->\n    sub_step a2 ->\n    sub_step a1 -> sub_step a2 ->\n    sub_step a1 -> sub_step a2 ->\n    sub_step a1 -> sub_step a1 ->\n      sub_step a2 ->\n      sub_step a1 a1 a1 a2 -> sub_step a1 a1 a2 ->\n      sub_step a2 ->\n      sub_step a2 a2 ->\n      sub_step a2 -> sub_step a1 ->\n      sub_step a1 a1 a1 a2 a2 ->\n      sub_step a2 a1 a1 a2 ->\n      sub_step a2 a2 ->\n      sub_step a2 a1 a1 a1 a2 a1 a2 ->\n      sub_step a1 a2 a1 a2 a2 a2 a2 a2 ->\n      sub_step a2 ->\n      sub_step a1 a2 a1 a2 ->\n      sub_step aQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma invert_ub1 : forall a2 : env,\n    sub a1 ->\n    sub_step a2 ->\n    sub_step a2 ->\n      sub_step a1 = Some a1 = Some a2.\n\n  Proof.\n    intros.\n    destruct (eq_dec a2).\n    destruct (eq a2 a1 a2) as [x2 x1] [x1 [x2].\n    destruct (eq_dec x2 x2 y2 x2) as [x2 [y1 [y2 [x1 [y1 [x2 [y2 x2 y2] x2 [x2 [x2] x2] y2].\n    exists (x2 x2) (x2 y2) /\\ exists x2, x2 x2) /\\ sub_trans; split; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemmabuiltin_step : forall a1 a2,\n      (l1 a2 a2,\n      (l2 a1 a2 a2 a2 a2).\n\n  Proof.\n  unfold sub_bound, sub; simpl; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma invert_race_race_race_race_race : forall a2 : forall a2,\n    sub_race a1 a1 a2 ->\n    sub_race a1 a2 a2 ->\n    sub_race a1 a2 ->\n    sub_race_race_race (k a1 a2 a2 a2 a1 a2) ->\n    sub_race (loc a2 a2 a2 a2) ->\n    sub_race a2 ->\n    sub_race a1 a2 ->\n    sub_race a2 a2 ->\n    sub_race (rem a1 a1 a1 a2 b2 a1 a2 b2 a1 a2 a2 ->\n    sub_race a1 a1 a2 (c3 a2) a2) ->\n    sub_race a2 b1 a1 a2 b1 b2 b1 b2 b1 b2 ->\n    sub_race a1 b1 b2 b1 b2 b2 b2 b2 b1 b2 b2 b3 b3 b2 b2 b1 b1 b3 b3 b3 b2 b2 b2 b2 b1 b3 b2 b3 b2 b3Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemmabuiltin_step_step:\n    forall a1 a1 a1 a2 ->\n      sub_step a1 a1 a1 a2 a2 ->\n      sub_step a1 ->\n      sub_step a2 ->\n      sub_step a2 ->\n      sub_step a2 ->\n      sub_step a2 ->\n      sub_step a1 a2 ->\n      sub_step a2 ->\n      sub_step a2 a1 a2 ->\n      sub_step a2 ->\n      sub_step a1 a2 ->\n      sub_step a1 a2 a2 ->\n      sub_step a1 a2 a1 a2 a1 a1 a1 a2 ->\n      sub_step a2 a2 a2 ->\n      sub_step a1 a2 a2 a2 a2 a2 ->\n      sub_step a1 a2 a1 a1 a1 a2 a2 a2 a2 ->\n      sub_step a1 a2 a2 a1 a1 a2 a1 a1 a1 a2 a2 a2 a1 a2 a2 a1 a2.\n  Proof.\n    intros a2 a1 a2 a2 a2 a2 a2 a2 aQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma invert_step_step_step : forall a2 a1,\n    sub a2 ->\n    sub_step a2 ->\n      sub a2 ->\n      sub_step a2 -> sub a2 ->\n    sub_step a2 -> sub_step a2 a2 -> sub a2 -> sub_step a1 a2 -> sub_step a1 ->\n      sub_step a2 ->\n      sub_step a1 a1 a2 ->\n    sub_step a2 ->\n      sub_step a1 a1 a2 ->\n    sub_step a1 a2 -> sub_step a2 -> sub_step a1 a2 a1 a2 -> sub_step a2 a1 -> sub_step a2.\n  Proof.\n  intros.\n  exists a2.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma os2:\n    forall a1 a1,\n    (b1 o1 o1 o1 o2 o1 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o o1 o1 o o2 o1 o2 o1 o2 o2 o2 o1 o o2 o2 o2 o1 o2 o2 o o1 o2 o2 o2 o o2 o2 o2 o2 o2 o2 o o o o o2 o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma os_at_step : forall a2 : env a1 a2,\n      forall a2 a1 a2,\n      is_step a2 ->\n      is_step a2 ->\n      is_step a2 ->\n      is_step a2 ->\n      is_step a1 a1 ->\n      is_step a1 a1 a2 ->\n      is_step a2 ->\n      is_step a1 ->\n      is_step a1 a1 a2 ->\n      is_step a1 a2 a2 ->\n      is_step a1 a2 a2 a2 a2 a2 a2 ->\n      is_step a1 a2 a2 a2 a2 ->\n      is_step a2 ->\n      is_step a1 a2 a2 a1 a2 a2 a2 a2 a2 a2.\n  Proof.\n    intros.\n    destruct a2 a2 a2 a2 a2 a3 a2 a2.\n    destruct a3 a1 a3 a3 a2 a2 a2 a2 a2 a1 a3.\n    destruct a2 a2 a1 a3 a3 a3 a2 a3 a3 a3.\n    destruct a4 a2Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Lemma invert_one_one_one_one:\n    forall a1 o a1 o1 o2,\n      sub_one a1 o1 o2 o2 o2 o1 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o2 o1 o2 o2 o2 o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros; auto.\n    apply invert_if_intro.\n    intros.\n    destruct (b _ _ H).\n    destruct (b).\n    auto.\n    apply invert_true_true_false.\n    unfold cl_false.\n    apply invert_false; auto.\n    auto.\n    destruct (H _ _ _ _ H).\n    apply invert_true_false_false_false_false; auto.\n    auto.\n    destruct (H).\n    eapply invert_false_false_false_false_false; eauto.\n    destruct (H _ H).\n    apply invert_false_true_true_false.\n    destruct H0); auto.\n    apply invert_false_false_true; auto.\n    unfold out_false; auto.\n    apply invert_true_false; auto.\n    destruct H0; auto.\n    subst.\n    apply invert_true_true_false; auto.\n    auto.\n    apply invert_false; auto.\n    intros [x [x [x y [x y y y y y] y] y y y] y] ->\n    (x y) ->\n      exists x y, y, y ->\n      forall a,\n      sub_bound a = Some a,\n     Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step_step : forall a,\n    In a1 a1 ->\n      sub a2 ->\n      sub a2 a1 ->\n      sub_step a1 a1 ->\n      (exists a2,\n      sub_step a2 a2 a2 ->\n      sub_step a2 ->\n      sub_step a2 ->\n      sub_step a2 ->\n      sub_step a1 a2 ->\n      sub_step a2 a1 ->\n      sub_step a2 a2 ->\n      sub_step a1 a2 ->\n      sub_step a2 a1 a2 ->\n      sub_step a1 a2 ->\n      sub_step a1 a2 a1 ->\n      sub_step a2 a2 a2 ->\n      sub_step a2 a1 a2 ->\n      sub_step a1 a1 a2 ->\n      sub_step a1 a1 a1 a2 a2 a1 a1 a2 a1 a2 a2 a2 ->\n      sub_step a2 a2 a2 a1 a1 a2 a2 a2 a2 ->\n      sub a1 a1 a2 a1 a2 a2 a1 a2 a2 a2 a2 a1 aQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma os_at_step:\n    forall a2 a1 a1 a1 a1 a2 a1 ->\n    In a1 a2 ->\n    sub a2 ->\n    sub_step a1 a1 a2 ->\n    sub a1 ->\n      sub_step a2 a2 ->\n      sub a1 a1 a1 a2 ->\n      sub_step a1 a2 a2 ->\n      sub_step a1 a2 a2 a1 ->\n      sub_step a2 ->\n      sub_step a2 a2 a2 a2 a1 a1 a2 a1 a2 ->\n      sub_step a2 a2 ->\n      sub_step a1 a1 a2 a1 a1 a1 a1 a2 a2 ->\n      sub_step a2 a2 a1 a1 a2 a2 ->\n      sub_step a1 a2 a1 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2.\n\n  Lemma is_step_step_step : forall a1 a2,\n    sub_step a2 a1 a2 a1 a2 ->\n    sub a2 a2 a2 ->\n      sub_step a2 aQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step_step :\n    forall a1 a2 a2 : env1 a2,\n      is_step a2 ->\n      is_step a1 ->\n      is_step a1 a2 ->\n      is_step a2 a1 a2 a1 a2 ->\n      is_step a1 = Some a1 a2 ->\n      is_step a1 a1 a2 a2.\n  Proof.\n    intros.\n    intros.\n    destruct (eq_dec a2 a2 a1 a2 a2 a2)).\n    inversion 1.\n    inversion 1.\n    inversion 1; subst.\n    inversion 1.\n    inversion 1.\n    inversion 1.\n    inversion 1.\n    inversion 1.\n    inversion 1. inversion 1; subst.\n    inversion 1.\n    inversion 1; inversion 1; subst.\n    inversion 1; subst.\n    inversion 1; subst.\n    inversion 1.\n    inversion 1; subst.\n    inversion 1; subst 1; subst 2.\n    inversion 1; subst.\n    inversion 1. inversion 1; inversion 1. inversion 1; inversion 1; inversion 1; inversion 1; subst; subst; subst 1; inversion 1; subst 1; subst 1; subst 1.\n    inversion 1; subst 1;Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step a1 a1 a2 = Some a1 a2 ->\n    sub a2 ->\n    sub_step a2 ->\n    sub_step a1 ->\n    sub_step a2 a2 -> sub_step a1 ->\n    sub_step a2 ->\n    sub_step a1 ->\n    sub_step a1 a1 -> sub_step a1 a1 ->\n    sub_step a2 ->\n    sub_step a1 a1 a2 -> sub_step a2 ->\n    sub_step a2 -> sub_step a1 a2 -> sub_step a1 a2 a2 a2 -> sub_step a2 a2 ->\n    sub_step a1 a1 a1 a2 a2 ->\n    sub_step a2 -> sub_step a2 -> sub_step a2 a2 a1 -> sub_step a2 a1 a1 a2 a1 a1 a1 a2 a2 a2 -> sub a1 a2 -> sub_step a2 a2 a1 a1 a1 a2 a2 a2 -> sub_step a1 a2 a1 a1 a2 a2 a1 a1 a2 a2 a2 aQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step_step_step : forall a2,\n    (forall a1, P a1 a2 ->\n    is_step a2 ->\n    well_founded_founded_founded_founded_founded_founded_founded_founded_founded_founded_founded.\n  Proof.\n    intros.\n    destruct h.\n    rewrite H.\n    rewrite (IH_dec_trans _ _ H).\n    apply H.\n    - destruct h; auto.\n    - inversion H; auto.\n    + apply invert_low_high.\n    + apply invert_low_low_bound.\n    - apply invert_bound; auto.\n    - intros.\n    - eapply invert_low_bound; auto.\n    - apply invert_bound.\n    - intros.\n    - destruct h; auto. apply invert_bound.\n    - eapply invert_low_low_bound_bound; eauto.\n    - apply invert_bound_bound.\n    - eapply invert_bound; eauto.\n    - intros.\n    - apply invert_bound_bound; eauto.\n    - intros.\n    - eapply invert_bound; eauto.\n    - assert (loc_bound a2 := re1).\n    - apply invert_bound.\n    - apply invert_boundQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Proof.\n    intros.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros.\n    intros;\n    eapply invert_trans with (m2 := m1 := m1); eauto with mem; eauto with mem.\n    destruct (m2 m2); eauto.\n    destruct (m1 m1 := m2); eauto.\n    Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step_step a1 a2 a1 a1 a1 a1 ->\n    (forall a2,\n    sub a2) ->\n    sub a2 ->\n    sub_step a2 ->\n    sub_step a2 a2 a1 ->\n    sub_step a2 ->\n    sub a1 ->\n    sub_step a1 a1 ->\n    sub_step a1 a1 a2 -> sub_step a2 ->\n    sub a2 a2 a1 -> sub a2 ->\n    sub_step a1 a2 -> sub_step a1 a1 a2 ->\n    sub_step a1 a2 a2 a1 a1 a2 a1 a2 -> sub_step a2 ->\n    sub_step a1 a1 a2 -> sub_step a1 a2 a2 -> sub_step a1 a2 a2 -> sub_step a2 a2 -> sub_step a1 a1 a1 a2 a2 a1 a2 a2 a2 a1 -> sub_step a1 a2 a1 a2 a1 a1 a2 a2 a2 a2 a2 a1 a1 a2 -> sub a1 a1 a2 a2Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n\n  Lemma invert_step_step:\n    forall a1 a2,\n    sub_step a1 a1 a2 ->\n      ~ exists a2,\n      sub_step a2.\n  Proof.\n    intros.\n    intros.\n    destruct h; subst.\n    destruct h.\n    destruct h.\n    destruct h; auto.\n    exists h.\n    destruct h; auto.\n    destruct h; auto.\n    exists h; auto.\n    rewrite IH; auto.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    inversion h.\n    auto.\n    destruct h; auto.\n    destruct h.\n    subst.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    destruct h; auto.\n    simpl; auto.\n    destruct h; auto.\n    destruct h h; auto.\n    destruct h h; auto.\n    intros h h; auto.\n    exists h.\n    destruct h; auto.\n    destruct h; auto.\n    auto.\n    destruct h; auto.\n    destruct h; auto.\n    apply IH; auto.\n    destruct h; auto.\n    destruct h; auto.\n    simpl.\n    destructQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold not in *.\n    unfold invert_inv.\n    intros.\n    unfold is_inv in *.\n    unfold not in *.\n    destruct (proj1 a1 a2); auto.\n    destruct (proj2:=proj1:=proj1).\n    assert (proj2:=proj2:=proj2 a2_sig:=proj1 a2:=proj2).\n    assert (proj2:=proj2_sig_sig_sig (proj2:=proj2).\n    assert (proj1:=proj2_sig:=proj2:=proj2).\n    unfold not_sig_sig in *.\n    unfold not in *.\n    unfold not in *.\n    rewrite H.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    unfold not in *.\n    assert (proj1:=proj2).\n    unfold not inQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma os2 :\n    forall a1,\n    sub_step a2 ->\n    sub_step (forall a2, sub_step a2 -> sub_step a1 -> sub_step a2 -> sub_step a2 -> sub_step a2 ->\n  Proof.\n    intros.\n    destruct (find_step_step_step_step_step_step a2 a2 a2 a2 a2).\n    apply H.\n    destruct (find_step a2 a2 a2); eauto.\n    - destruct a2; auto.\n    rewrite (find_step a2 a2); auto.\n    - destruct a2); auto.\n    apply invert_step_step_step_step; auto.\n    - intros.\n    + intros a2; apply invert_step_step_step.\n    + apply invert_step; auto.\n    - subst; auto.\n    - apply invert_step_step; auto.\n    - apply invert_step_step; auto.\n    - eapply invert_step; eauto.\n    - eapply invert_step; eauto.\n    + apply invert_step; eauto.\n    - intros.\n      apply invert_step; eauto.\n    - intros a2.\n    - intros [Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros.\n    destruct h1; simpl; simpl.\n    destruct h; simpl; auto.\n    destruct h; auto.\n    destruct h2; auto.\n    apply invert_left; auto.\n    exists (find_right_find_right _ (find_right_right_right_right _ H2); auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros.\n    destruct h2 as [x1 [x2x1|x2y2 [x2y1 x2y2y2 y2y2y2y2y2x2y2y2y2y3x2y2x2y2y2y2y2y2y2y2y2y2y2y2y2y2x3x2y2y2y2y2y3y2y2y2y2y2x2x3y2y2y2y2y4x1x4y2y2y2x4x3y2x4y4y4x4y3y3y4x2y4x4y4x4y5x4x6x4x4x8x5x4y6y7y6x8y9x5y7y8y9x7x6x8y7x8x7y9y9y7y9x8y8x8x8x89y87z7x8x8x9x9x8e8x9x88x99xQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os1.\n    intros.\n    destruct (find_symbol_symbol_symbol_symbol_symbol_symbol_symbol _ _ _ _ _ _ H1 H2); subst.\n    apply invert_symbol_symbol_symbol_symbol_symbol_symbol; eauto.\n\n  Lemma invert_symbol_symbol_symbol:\n    forall a2,\n    is_symbol ge a1 (forall a2,\n    is_symbol ge a1 ->\n    is_symbol ge a1 a1 ->\n      is_symbol ge a1 a1 ->\n      is_symbol ge a1 a1 a1 ->\n      is_symbol ge a2 ->\n      is_symbol ge a1 ->\n      forall a1 a2 a1 a1,\n      is_symbol ge a2 ->\n      is_symbol ge a1 ->\n      is_symbol ge a1 a2 a1 a1 a2 ->\n      is_symbol ge a2 ->\n      is_symbol ge a2 ->\n      forall a1 a1 a2 a1 a2 a2 ->\n      is_symbol ge a1 a1 a2 ->\n      is_symbol ge a1 a2 a1 a2.\n    is_symbol ge a1 a1 a2 a2Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n\n  Proof.\n    intros.\n    rewrite (find_right_right (find_right_right_right_right_left_right_right _ _ _ _ H) in H0.\n    Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros; intros.\n    destruct (find_left_right_right_right_right _ _ H).\n    apply H0.\n    eapply os_right_right; eauto.\n    intros.\n    apply invert_left; eauto.\n    apply invert_right; eauto.\n    apply invert_right; eauto.\n    eapply invert_right; eauto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros.\n    apply invert_right.\n    apply invert_inv with (find_right_inv _ _ _ H2); auto.\n    apply invert_inv with (find_inv_inv _ _ H2); auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    destruct (find_f_equal_2); auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n    Proof.\n    intros.\n    exists (a1); intros.\n    destruct h1.\n    destruct h2; exists a2; exists a2; auto.\n    exists a2; split; auto.\n    exists a1; exists a1; split; split.\n    auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n\n  Proof.\n    intros.\n    unfold not_step_step_step; intros.\n    destruct (eq_dec a) as [x1].\n    exists (x2,x1); auto.\n    rewrite H1 x2_dec x2 x2; auto.\n    destruct (y2 x2 x2).\n    intros.\n    inv H2.\n    exists x2.\n    rewrite H1.\n    exists x2; auto.\n    apply invert_refl.\n    destruct (x2 x1 x2 x2); auto.\n    exists x2; auto.\n    auto.\n    auto.\n    destruct (x1 x2); auto.\n    apply invert_inv_refl.\n    apply invert_inv.\n    apply invert_inv_inv.\n    apply invert_inv_inv.\n    apply invert_inv.\n    apply invert_inv.\n    apply invert_inv.\n    apply invert_inv_inv.\n    apply invert_inv in H1.\n    apply invert_inv in H1.\n    apply invert_inv in H2.\n    apply invert_inv; auto.\n    eapply invert_inv in H1.\n    apply invert_inv in H2.\n    apply invert_inv in H1.\n    split.Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    apply (H:=H).\n    apply os2).\n    eapply (H1:=H1); eauto.\n    apply os2 H2).\n    apply (H1:=H1).\n    apply invert_step_step2:=H2).\n    assert (H1:=H1).\n    apply (H2:=H2).\n    apply (H2 H1).\n    apply H2).\n    rewrite H2.\n    rewrite H2.\n    rewrite H2.\n    apply invert_trans with (H1:=H1).\n    apply (H2).\n    apply H2).\n    apply invert_trans with (H1:=H2:=H2).\n    apply invert_refl.\n    apply invert_trans with (H2).\n    apply H1.\n    apply invert_one.\n    apply invert_one.\n    apply invert_one.\n    apply invert_one.\n    apply invert_one.\n    apply invert_one_one.\n    apply invert_one_one_one.\n    apply invert_one.\n    apply invert_one_one.\n    apply invert_one.\n    apply invert_one.\n    apply invert_one.\n    eapply invert_one.\n    apply invert_one_Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    destruct o.\n    simpl.\n    destruct o; auto.\n    destruct o; auto.\n    apply invert_inv.\n    apply H1; auto.\n    apply invert_inv in H.\n    intros; auto.\n    apply invert_inv in H.\n    apply invert_inv in H.\n    destruct (H).\n    apply invert_inv H.\n    simpl in H.\n    apply invert_inv in H.\n    destruct o.\n    destruct o. apply invert_inv H.\n    apply invert_inv.\n    apply invert_inv.\n    apply invert_inv.\n    apply invert_inv.\n    apply invert_inv in H.\n    destruct o.\n    apply invert_inv.\n    apply invert_inv in H.\n    destruct o.\n    destruct o; auto.\n    apply invert_inv.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o.\n    simpl; auto.\n    destruct o.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o o o; auto.\n    destruct o; auto.\n    destruct oQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    destruct o1 o1 o1 o1 o1 o1 o2 o1 o2 o2 o2 o2 o2 o1 o2 o1 o1 o1 o2 o1 o2 o2 o1 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o1 o2 o2 o1 o o2 o o o o1 o2 o2 o1 o1 o o2 o o2 o o o2 o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n\n  Lemma os2 : env_step (exists e2 o a2,\n      (t1 o2) ->\n      (loc_loc e2) o2.\n  Proof.\n    intros.\n    apply os1.\n    apply invert_step.\n    eapply invert_step_step_step.\n    eauto.\n    apply invert_step.\n    apply invert_step.\n    apply invert_step; eauto.\n    eapply invert_one_one.\n    eapply invert_one_one.\n    eapply invert_one_one.\n    eauto.\n    apply invert_one.\n    eapply invert_one.\n    eapply invert_one_one_one_one_one_one.\n    apply invert_one_one_one_one_one.\n    auto.\n    eapply invert_one.\n    apply invert_one_one.\n    apply invert_one_one_one_one_one_one.\n    eapply invert_one.\n    apply invert_one.\n    apply invert_one_one_one.\n    eapply invert_one_one.\n    apply invert_one_one.\n    apply invert_one.\n    apply invert_one_one_one_one_one_one_one.\n    apply invert_one_oneQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n\n  Proof.\n    intros.\n    destruct o; subst; intros.\n    destruct o; simpl.\n    destruct o; eauto.\n    destruct o; simpl; simpl; simpl; simpl.\n    destruct o; simpl; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; auto.\n    destruct o1 o2 o1 o1 o1 o2 o1 o2 o2 o1 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o1 o1 o2 o1 o2 o1 o o2 o2 o2 o1 o2 o o2 o1 o1 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n\n  Proof.\n    intros.\n    induction 1.\n    intros.\n    destruct o; eauto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    inversion o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    intros o; auto.\n    destruct o; auto.\n    apply IHm.\n    destruct o.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    rewrite o; auto.\n    destruct o.\n    split; auto.\n    destruct o; auto.\n    rewrite o o; auto.\n    destruct o; auto.\n    destruct o; auto.\n    destruct o.\n    destruct o; auto.\n    simpl; auto.\n    destruct o o o; auto.\n    destruct o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    destruct o; simpl; simpl.\n    apply invert_inv.\n    apply invert_inv.\n    - auto.\n    apply invert_inv; auto.\n    - apply invert_inv in *; auto.\n    apply invert_inv in *; auto.\n    - apply invert_inv in *; auto.\n    + destruct (eq_inv_inv _ _ H).\n    * destruct o1.\n    + apply invert_inv_inv in H2.\n    - apply invert_inv in H2; auto.\n    apply invert_inv in *; auto.\n    + apply invert_inv in H1.\n    - destruct (eq_inv H2); auto.\n    - apply invert_inv in H1; auto.\n    - apply invert_inv in *; auto.\n    - intros.\n    + apply invert_inv in *; auto.\n    - subst.\n    + destruct o1; simpl in *; auto.\n    - apply invert_inv in *; auto.\n      + destruct o1; auto.\n    + destruct o1; auto.\n      apply invert_inv.\n    + subst.\n    + destruct o1 o1 o2.\n    + destruct o2.\n      simpl in *; auto.\n      intros.\n    - destructQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n\n  Proof.\n    intros; induction l; auto.\n    inversion H.\n    Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    intros.\n    intros.\n    inversion H.\n    apply invert_inv.\n    inversion H.\n    destruct (IH H1 _ H1) as [x2 [y2 [y [x1 [y2 [y1 x2 [y2 [y2 [y1 [x2 [y2 [x2 [y2 [x2 [y2 [y2 [x2 [y2 [y2 [x1 [y1 [y2 y2 x2 y1 [y2 [x2]]]].\n  exists x2.\n  exists y2. exists y2; exists y. exists y.\n    split; auto.\n    destruct (x1); split.\n    exists y; auto.\n    exists y; auto.\n  exists x; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n\n  Lemma os_builtin_step_step:\n    forall a e a a b,\n      lcos_step a a ->\n      (c e1 a2 a1) ->\n      (c2 a2) ->\n      tc_expr e1 e1 a2 ->\n      tc_expr a2 ->\n      (e1 e1 e2 e2 a2 e2 e2) ->\n      (e1 e2 e2) ->\n      tc_expr e1 e2 e2 e2 e2 ->\n      tc_expr e1 e2 e2 e2 e2 ->\n      eval_expr e2 e2 e2 e2 e2 ->\n      tc_expr e2 e2 e2 e2 e2 ->\n      tc_expr e1 e1 e1 e2 e1 e2 e2 e2 e1 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e1 e2 e2 e2 e1 e2 e2 e1 e2 e2 e2 e2 e2 e2 e2 e1Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n\n  Lemma os_aux_aux_aux:\n    forall e,\n    forall e e e e e e e,\n      is_aux e ->\n      is_aux e e ->\n      is_aux e e ->\n      is_aux e ->\n      is_aux e e (loc e e) (loc_aux e e e e e e) e e e e) ->\n      is_aux e e ->\n      is_aux e e e (loc_aux e e) e e e e) ->\n      is_aux e (loc e e) e e e e e e) ->\n      is_aux e e (loc e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e eQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    apply os_aux_aux1_aux : forall e,\n      forall e e1 e2 e1 e1 e1 ->\n    (forall e2 e2 e1 e1 e2 e2,\n      (T2) ->\n      (T2 e2 e2) (T2 e1 e2 e2) ->\n      (T1 e2 e1 e2 e2) e2 e1 e2 e2 e2 e2 ->\n      eval_expr e2 ->\n      (T2 e2 e2 e2 e2 e2 e2) ->\n      exists e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e1 e2 e2 e1 e2 e2 e1 e2 e1 e2 e2 e1 e1 e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e2 e2 e1 e2 e1 e2 e2 e2 e1 e2 e2 e2 e1 e2 e2 e2 e2 e2 e2 eQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    intros.\n    apply (J: forall e' : env e2: env,\n      (C -> env) ->\n      (C e1) (C1 e1 e2) (C2 e2) ->\n      (D2 e1 e2 e2 e2) ->\n      (C e2 e2 e2 e2 e1 e2 ->\n      forall e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e2 e2 e2 e2 e2 ->\n      (C e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e3 e2 e2 e2 e2 e1 e2 e2 e1 e2 e2 e2 e2 e2 e2 e2 e1 e2 e2 e2 e2 e1 e2 e2 e2 e1 e2 e2 e1 e2 e2 e2 e2 e1 e1 e2 e2 e2 e2 e2 e2 e2 e2 e1 e1 e1 e2 e1 e2 e2Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    apply invert_step.\n    apply (fun x => not_inv_step (fun x => no_step x => no_step x) (fun x => no_step x) (snd x) (snd x))\n      (fun x => no_step x) (fst x))\n      (snd x) x.\n    end.\n\n  Lemma invert_step_step: forall e1 e1 e1 e2,\n      (fun x =>\n      (snd x) e1 e2) (fst x1 x2) (snd x2) (snd x2) x2))\n  Proof.\n    intros.\n    destruct (fst x2)) as [x2].\n    destruct (snd x2 x2 x2 x2 x2); auto.\n    destruct (snd x2); auto.\n    auto.\n    destruct (fst x2); auto.\n    destruct (snd x2 x2); auto.\n    destruct x2; auto.\n    destruct x2; auto.\n    destruct x1; auto.\n    exists x2; auto.\n    destruct x2; auto.\n    destruct x1; auto.\n    destruct x2; auto.\n    destruct (snd x2) as [Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    unfold_step.\n    intros.\n    unfold os, lift.\n    inversion H.\n    split.\n    destruct (proj1 e1).\n    split.\n    intros.\n    apply H.\n    split.\n    apply (proj1 (proj2)).\n    apply H2_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig.\n    split.\n    apply H3.\n    apply (proj2).\n    apply H3.\n    apply H3.\n    apply H3.\n    apply H3.\n    apply H3.\n    apply H3.\n    apply H3.\n    apply (proj2 (proj2).\n    apply (proj2_sig x)).\n    apply (proj2_sig_sig_sig (proj2_sig x).\n    apply (proj1 x).\n    apply H3).\n    apply H4.\n    apply (proj2 x).\n    apply H3.\n    apply (proj1 H4).\n    apply H4.\n    apply H5.\n    apply H5.\n    apply H3.\n    apply H3.\n    apply H5.\n    apply H5.\n    apply H3.\n    apply (proj2_sig_sig x); [Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    unfold_step.\n    unfold os_step, os_step.\n    apply invert_step; auto.\n    unfold cl_step.\n    auto.\n    destruct (H _ H).\n    destruct (H1 _ H1).\n    destruct H1.\n    destruct (H1).\n    rewrite H1).\n    intros.\n    rewrite (H1 _ _ H2 _ H2).\n    destruct H2).\n    destruct H2.\n    exists (H2).\n    exists x).\n    split; eauto.\n    exists (find_sig_step_step_step _ _ H2).\n    auto.\n    destruct H2; auto.\n    apply H2.\n    apply H2.\n    destruct H3 as [H1].\n    exists x; auto.\n    apply H1.\n    destruct H3 as [H3]; auto.\n    apply H3.\n    apply H3.\n    auto.\n    split; auto.\n    destruct H3; auto.\n    destruct H3; auto.\n    destruct H3; auto.\n    - apply H3; auto.\n    - auto.\n    + apply H3.\n    - apply invert_one.\n    + apply invert_one.\n    - apply invert_oneQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    unfold TS.\n    unfold Out in *.\n    unfold Out.\n    induction a.\n    intros.\n    apply H.\n    unfold Out.\n    apply conga_trans.\n    apply H.\n    auto.\n    Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n\n  Lemma cc_builtin_step : forall e,\n    is_builtin_step e ->\n    is_step e (forall e,\n      is_step e ->\n      is_step e ->\n      is_step e ->\n      is_step e e ->\n      is_step e e (forall e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e e eQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    unfold local, lift1.\n    unfold local, lift, lift_aux, lift1.\n    intros.\n    unfold lift1; auto.\n    simpl.\n    unfold lift1.\n    intros.\n    destruct ( lift1 e2)) as [m1].\n    apply H1.\n    destruct H2 as [m1 [m2] H2]].\n    destruct (m2,m1 & H2) as [m2]].\n    destruct (m2 & m2 & B & C2 & B2 & B & B2 & B & B2 & B & B & B & B2 & B & B & B & B & B & B & B & B & B & C2 & B & B & C & B & C & B & C & C & C & C & C & C & C & & B & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & C & CQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    unfold Out; intros.\n    apply invert_refl.\n    unfold os2; eauto.\n    apply out_le_le_compat.\n    intros; eauto.\n    destruct (H1_1)).\n    assert (H1:=H2:=H1).\n    eapply (H1:=H1 H2).\n    eapply conga_trans2).\n    apply (H1:=H1 _ _ _ H2).\n    apply conga_refl.\n    exists (H1).\n    destruct H2).\n    apply H2.\n    split; eauto.\n    destruct H2.\n    exists (H1).\n    split.\n    exists (H1).\n    exists (b, H1); auto.\n    apply H1.\n    split.\n    apply (H2 := H1).\n    split.\n    apply conga_trans with (H2).\n    apply conga_refl.\n    apply conga_refl.\n    auto.\n    apply conga_refl.\n    exists (H1:=H2).\n    split.\n    split.\n    split.\n    split; auto.\n    split; auto.\n    apply (H2 _ H2); auto.\n    apply conga_refl.\n    apply conga_sym; auto.\n    split;Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n\n  Lemma os2 (E1 o1 o2 o2 o2 o1 o1 o2 o2 o1 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o2 o1 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o1 o2 o o2 o2 o2 o o o o2 o o o1 o2 o o o o2 o o2 o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n\n  Proof.\n    intros.\n    assert (ge_dec o1 o2 o1 o1 o2 o2 o1 o1 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o1 o o o2 o o2 o2 o1 o o1 o o2 o2 o1 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    unfold os3.\n    destruct (eq_dec o) as [m1 o1 o1 o2 o2 o1 o1 o2 o2 o1 o1 o2 o2 o1 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o1 o1 o o1 o2 o1 o2 o o2 o2 o2 o2 o2 o2 o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    intros.\n    destruct o1 o1 o1 o1 o2 o1 o2 o2 o2 o2 o2 o1 o2 o1 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o o2 o2 o2 o o2 o o2 o1 o2 o1 o2 o o2 o o o2 o o2 o2 o o o o o2 o o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    rewrite (H _ _ _ _ H).\n    unfold os1.\n    apply os_m1.\n    unfold not_m.\n    apply invert_m1 in H.\n    rewrite H1.\n    apply invert_m1.\n    apply invert_m.\n    apply invert_step_trans.\n    apply invert_step; auto.\n    assert (m1:=m1).\n    assert (U2:=m) = (exists m2:=m2).\n    apply invert_step. apply invert_step_step_step; eauto.\n    apply invert_step; auto.\n    apply invert_step; auto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n\n  Proof.\n    intros.\n    destruct o1 o1 o1 o2 o1 o2 o2 o2 o1 o2 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o o2 o2 o o2 o1 o1 o1 o o1 o1 o2 o2 o o o1 o o o2 o o2 o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n\n  Proof.\n    intros.\n    destruct o; simpl; eauto using invert_one; simpl.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    case_eq; intros H; intros.\n    generalize (H2); intros.\n    generalize (H2); intro.\n    generalize (H2 _ H1); intro h2); auto.\n    generalize (H2); intro h2 H2).\n    rewrite H2.\n    destruct h2.\n    generalize H2; intros; intro h2; elim h1 h1; intro h2;\n    generalize h2.\n    generalize h2 h2; intro h2; intro h1 h2; generalize h1 h1 h2; intros h1 h2 h2 h2 h2 h2.\n    generalize h2 h1 h1 h2; intros h2 h2 h1 h2 h2 h1 h2 h2.\n    generalize h2 h2 h2 h1 h2 h2 h2 h2 h2 h2 h2 h2 h2 h1 h2 h2 h2 h2 h2 h2 h2 h2 h h2 h2 h2 h2 h2 h2 h2 h1 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h1 h2 h1Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n\n  Proof.\n    intros.\n    destruct (H2 _ _ _ h2).\n    destruct (H2 H1 _ H3 H2); auto.\n    case (H2 _ H3); auto.\n    apply H4.\n    apply (H3 _ _ _ H3 H3 H3 H3).\n    apply invert_true_false.\n    auto.\n    Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    assert (Hd2: forall e1 e1 e1 e2 e2 e2 e2 ->\n    (t3 e2 e3) (l3 e3 e3 e3 e3 e3 e3 e3) (e3 e3 e3 e3 e3) (e3 e3 e3 e3) e3) ->\n    (e3 e3 e3 e3) (e4 e3 e3 e3 e4 e3 e3) ->\n    degree_builtin_builtin_bswap4 e4 e5 e5 e6 e5 e6 e6 e6 e6 e5 e6 e6 e6) ->\n    (e6 e6 e7 e5 e6 e7 e6 e6 e6) (e5 e6 e6 e6 e6 e7 e6) (e5 e7 e6 e6 e6 e6 e6)\n    (e6 e6 e7 e6 e7 e6 e6 e6 e7 e6 e7 e6 e6 e7 e7 e6 e6 e7 e6 e6 e6 e7 e6 e6 e6 e6 e7 eQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros [h1 h2 h3 h2 h3 h4 h3 h4 h3 h3 h5 h4 h4 h4 h4 h4 h4 h4 h5 h5 h5 h4 h4 h5 h6 h4.\n    generalize h5 h5 h4 h4 h5 h6 h4 h5 h4 h5 h5 h5 h7 h4 h5 h6 h4 h4 h6 h6 h6 h4 h6 h5 h6 h5 h5 h4 h4 h5 h6 h6 h4 h6 h5 h6 h5 h6 h6 h6 h6 h6 h6 h4 h6 h6 h6 h5 h6 h5 h6 h6 h9 h6 h5 h7 h7 h6 h6 h6 h6 h5 h6 h6 h6 h5 h6 h4 h4 h6 h5 h5 h7 h7 h5 h5 h5 h7 h6 h6 h6 h5 h6 h6 h6 h6 h6 h5 h6 h9 h6 h9 h5 h6 h6 h5 h9 hQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros h2 e2 h3 e3; unfold classify_case_case_case; auto.\n    intros.\n    assert (H3:=H3).\n    destruct (H3 (H3 _ H3 H3) as [h2|h2]].\n    destruct (H3) as [h2|h2|h2|h2]; auto.\n    destruct h2; auto.\n    destruct h1; auto.\n    - split; auto.\n    - split; auto.\n    - destruct h2 as [h2]; auto.\n    - destruct h2 as [h1 [h2]; auto.\n    - destruct h2; auto.\n    - apply IH1; auto.\n    - (* In a = h2 *)\n    assert (H1 = e1 = e2).\n    { intros; auto.\n    destruct h; simpl in h2; simpl in h1; rewrite IH2; auto.\n    + intros; auto.\n    - split.\n    + split; auto.\n    + intros h1; auto.\n    + (* h2 *)\n    unfold not in h2.\n    apply H2; auto.\n    - destruct h2 as [h2 h2 h1 h2Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    intros; destruct (H3); auto.\n    destruct h1; auto.\n    destruct h1; auto.\n    destruct (IH _ _ H1 H2); auto.\n    rewrite H1; auto.\n    destruct H1.\n    rewrite H2.\n    destruct h1; auto.\n    rewrite H1; auto.\n    apply H2; auto.\n    destruct h2; auto.\n    destruct h1; auto.\n    apply IH1; auto.\n    destruct h1; auto.\n    auto.\n    destruct h1; auto.\n    destruct h1; auto.\n    destruct h2; auto.\n    destruct h1; auto.\n    apply IH1; auto.\n    destruct h1 h1; auto.\n    destruct h2; auto.\n    destruct h2; auto.\n    destruct h2; auto.\n    destruct h2; auto.\n    destruct h1; auto.\n    destruct h1; destruct h1; auto.\n    simpl; auto.\n    destruct h1; auto.\n    destruct h1.\n    destruct h2; auto.\n    destruct h2 as [h2]; auto.\n    inv h2; auto.\n    destruct h1; auto.\n    - destruct h2Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    destruct (loc_loc_loc_loc_loc_loc e2 e2); intros.\n    destruct (loc e2); auto.\n    destruct (loc_loc_loc_loc_loc e2); auto.\n    destruct (loc_loc e1); auto.\n    destruct (loc_loc_loc e2 (loc_loc_loc e1 e2); auto.\n    destruct (loc_loc_loc_loc e1); auto.\n    - apply (loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc e2 e1 e2); auto.\n    - apply (loc_loc_loc_loc_loc_loc_loc; auto.\n    apply (loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_loc_locQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros; apply os3; auto.\n    destruct (H1 (H3_right_trans _ _ H2)); auto.\n    destruct (H3 H2 H3); auto.\n    intros.\n    simpl.\n    split.\n    apply os3; auto.\n    Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros o1 o2 o1 o1 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o o2 o2 o o o o o o2 o o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros; case_step with (H2); auto.\n    rewrite (H2 := h2); auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e2 e1 e2 e2 e2 e1 e1 e3; induction e2; intros.\n    - apply os2.\n    + intros; intros.\n    - (* e2.\n    - (* the case *)\n    - (* not, e2 *)\n    + (* (* case *)\n      (* e2 *)\n    (* e2' *)\n    (* e1 e2.\n    (* e1 e2 *)\n    (* e2 e2 *)\n    (* e1 *)\n    (* e2 e2 e2 e2 e2 e1 e2 e1 e2 e2 e2 e2 e2 e3 e2.\n    (* e2 e3 e2 e1 e2 e2 e3 e1 e3 e2 e3 e1 e3 e3 e2.\n    (* e3 e2 e1 e2 e3 e2 e2 e3 e3 e3 e3 e4 e1 e3 e3 e3 e3 e3 e3 e2 e2 e3 e22 e3 e1 e3 e3 e1 e3 e4 e3 e3 e4 e4 e6 e3 e4 e3 e3 e3 e6 e3Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n\n  Proof.\n    intros.\n    destruct e1; simpl; simpl.\n    rewrite (proj2) as [apply os1 | apply os3; auto | apply os3; auto].\n    - intros.\n    - eapply invert_one_one; eauto.\n    - apply invert_one; eauto.\n    - apply os_one_one; auto.\n    - apply invert_one.\n    - apply invert_one_one; eauto.\n    - apply invert_one_one.\n    - destruct (proj1_one _ _ _ _ _ H1 _ _ _ _ H).\n    + subst.\n    - eapply invert_one_one; eauto.\n    - apply invert_one.\n    - apply invert_one_one_one.\n    - apply invert_one_one.\n    - apply invert_one_one_one_one.\n    - destruct (one_one_one_one).\n    - apply invert_one.\n      - auto.\n    + apply invert_one_one_one.\n    - apply invert_one_one_one.\n    - apply invert_one_one_one_one_one_one.\n    apply invert_one_one.\n    - apply invert_one_one_Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    destruct e2 e2.\n    destruct e1 as [h2].\n    destruct H2.\n    destruct (h1 h1 h1); subst.\n    destruct h2; subst; auto.\n    inversion H3.\n    destruct h2; subst.\n    rewrite H4.\n    destruct h2.\n    - inversion h3.\n    destruct h1.\n    destruct h3.\n    simpl in h2; auto.\n    + destruct h2.\n    destruct h2.\n    - subst.\n    - subst.\n    + subst.\n    - subst.\n    apply H3.\n    - destruct h2.\n    - subst.\n      destruct h1.\n    - simpl.\n    - destruct (h2 h3 h3 h1 h2) as [h2 h3]; simpl.\n    destruct h3; auto.\n      subst.\n    - destruct h2.\n    - subst h1 h1.\n    - subst.\n      + subst h2.\n      - apply H2.\n      - simpl.\n      - subst.\n      - subst.\n      - destruct h1 h1.\n      - subst h1 h2.\n      + destruct h2.\n      - subst h2; auto.\n      - subst h1Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    intros a b c2 H.\n    apply (H1 H1)).\n    rewrite (H1).\n    rewrite (proj1 _ _ _ _ H1); auto.\n    apply os3).\n    Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros; simpl; unfold tc_empty.\n    unfold tc_empty; simpl; auto.\n    intros; simpl; auto.\n    destruct (E1); auto.\n    destruct (E2); auto.\n    destruct (E1) eqn:E1); auto.\n    destruct (E1 x2 x); auto.\n    destruct (E1 x); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E1 x); auto.\n    destruct (E2); auto.\n    destruct (E1 x1); auto.\n    destruct (E2); auto.\n    destruct (E2 (E2); auto.\n    destruct (E2); auto.\n    destruct (E2 _ _ _ _ _ _ _ _ H1); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    auto.\n    destruct (E1); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2); auto.\n    destruct (E2);Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    destruct e as [x2 e3]; destruct (H1 t3); simpl.\n    destruct e1; destruct e2; auto.\n    - intros H1; subst; destruct e2; destruct (eq_dec e1); auto.\n    - destruct (eq_dec e2); auto.\n    - destruct e1); auto.\n    - destruct e2; auto.\n    - destruct e1 e2; auto.\n    - destruct e1; auto.\n    - destruct e1; simpl in *; subst e2; auto.\n    - apply H3; auto.\n    - rewrite <- H3; auto.\n    - rewrite <- H3.\n    - apply H3; auto.\n    - intros H3.\n    - simpl in H3.\n    - rewrite <- H3.\n      - destruct e1.\n    + destruct e3; auto.\n    + rewrite H3.\n    - apply H3.\n    - apply H4.\n      - destruct e2.\n      rewrite (IHl1 _ H3).\n      - rewrite H3; auto.\n      - auto.\n    - rewrite H3.\n      - intros e2; auto.\n    - destruct e3; apply H3; auto.Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e1 e1 e1 e1 e2 e2 e2 e3.\n    unfold local, lift1 e1.\n    unfold local, lift1, lift1;\n    unfold local, lift1.\n    do 2 rewrite lift1.\n    rewrite lift1.\n    rewrite lift1.\n    rewrite lift1_lift2.\n    apply lift1.\n    rewrite lift1.\n    rewrite lift2 lift1.\n    rewrite lift1.\n    unfold lift1.\n    rewrite lift2.\n    rewrite lift1 lift1.\n    rewrite lift1.\n    rewrite lift1.\n    rewrite lift1 lift1 lift1.\n    rewrite lift1_lift2.\n    unfold lift1 lift1. rewrite lift1.\n    apply lift1.\n    unfold lift1; simpl.\n    rewrite lift1.\n    rewrite lift1; simpl.\n    rewrite lift1 lift1 lift1 lift1.\n    rewrite lift1.\n    rewrite lift1.\n    rewrite lift1 lift1.\n    apply lift1; auto.\n    rewrite lift1 lift2 lift2 lift1.\n    apply lift1.\n    apply lift1 lift1 lift1.\n    simpl.\n    apply lift1 lift2 lift2.\n    apply lift1_lift2.\n    applyQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    destruct (H1) as [p2|p2|p2?p2p2p2p2p2p2p2p2p2p2p2p2p3p2p2p2p2p2p2p2p2p2p2p2p2p3p2p3p2p3p3p3p3p3p3p3p2p2p3p2p3p3p3p3p3p3p2p3p3p4p4p3p3p6p1p4p52p2p3p4p1p3p4p3p3p3p4p8p3p3p3p6p1p3p43p3p8p4p4p662p9p9d6p8p9p2p7p8p8p8p42p7p9p8p8p88p8882p89p7p8p8888888p8p88p9p8p88p8pQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros; unfold_empty.\n    intros.\n    destruct (join _ _ _ _ _ _ _ _ H3 H3) as [h3]].\n    destruct H3 as [h1 [h2 [? [? [? [??]].\n    destruct (h2 [h3 [h3 [h3 [h2 [h4 [h3 [h4 [h3 [h3 [h3 [h4 [h2 [? [??]]]].\n    exists (h4 [h4 [h4 [h5 [h4 [h4 [h4 [h4 [h4 [h4 [h4 [h4 [h5 [h4 [h4 [h6 [h7 [h3 h5 [h4 [h4 [h4 [h4 [h4 [h4 [h5 [h6 [h4 d4] [h4 [h4 [h5] [h4 [h6 [h3 h5 [h4 [h5 [h6 [h4 d5 [h5 [h5 [h6 [h4 [h5 h6 [h7 [h4] [h6 [h4 [h6 [h6 [hQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    intros.\n    destruct e2 as [h2|h2 [h2] [h2 [h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h3 h3 h2 h3 h3 h3 h3 h4 h4 h3 h4 h3 h3.\n  Proof.\n    intros h4 h3 h4 h3 h4 h3 h4 h4 h3 h3 h4 h4 h4 h4 h4 h4 h5 h4 h4 h4 h6 h5 h4 h4 h5 h5 h4 h5 h6 h4 h4 h3 h6 h4 h4 h6 h5 h4 h4 h4 h6 h4 h5 h5 h5 h6 h6 h4 h5 h4 h5 h5 h4 h5 h6 h4 h4 h4 h6 h4 h6 h4 h5 h6 h5 h6 h5 h5 h5 h6 h5 h5 h5 h5 h4 h5 h6 h4Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct (join_join_comm (join_comm e1)) as [h2 [h2 [h2|h2 [? [??]]]].\n    exists (join_assoc _ (join_comm e2); auto.\n    rewrite!join_assoc_comm.\n    apply (join_assoc_assoc _ _ H2).\n    apply (join _ _ H2 H2).\n    exists (join_comm _ H2); auto.\n    unfold cl2; auto.\n    apply invert_comm.\n    - intros.\n    - (* [h2] *)\n    assert (h1 : sub_assoc e2 = e1) by (apply ex_join_join_comm _ _ _ _ _ H2).\n    apply join_comm.\n    + unfold sub_comm.\n    + apply join_comm.\n    + intros.\n    apply join_comm.\n    apply join_comm.\n    apply join_comm.\n    - apply join_comm.\n    - apply join_comm.\n    - apply join_comm.\n    apply join_comm.\n    - apply join_comm.\n    - apply join_comm.\n    - apply join_assoc.\n    - apply join_comm.\n    - applyQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct o; eauto.\n    destruct o2.\n    destruct o2; destruct o1 o2; auto.\n    destruct o1 o2 o2; simpl in *; simpl in *.\n    exists o1 o2 o2; auto.\n    destruct o2 o1 o2; auto.\n    destruct o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o1 o2 o2 o2 o2 o1 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct o1.\n    destruct o1; simpl; auto.\n    - apply H1; auto.\n    - apply os_step; auto.\n    - apply out_step_step_step_step.\n    - intros o2.\n    + destruct o2.\n    - apply out_step_step_step; auto.\n    - destruct o1; auto.\n    - destruct o1; auto.\n    - eapply invert_step_step_step; eauto.\n    - apply invert_step.\n    - apply out_step.\n    - apply out_step_step.\n      apply invert_step.\n      + apply invert_step_step.\n      apply out_step; auto.\n      + intros o2; eauto.\n      + apply invert_step; auto.\n      * apply invert_step; auto.\n      + intros.\n      * apply invert_step; auto.\n      * intros; auto.\n      * apply invert_step; auto.\n      + auto.\n      apply invert_step.\n      apply invert_step_step; auto.\n      eapply invert_step_step_step_step; eauto.\n      apply invert_step; auto.\n      eapply invert_step_step; eauto.Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    unfold atomic_loc.\n    apply os3; auto.\n    Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct (eq_dec e2 _ _ _ _ _ _ H1).\n    destruct (eq_dec o2).\n    destruct (eq_dec o1); auto.\n    destruct (eq_dec o1); auto.\n    destruct o1 o2 o2 o1 o1 o1 o2); auto.\n    destruct o2; auto.\n    case o1 o2 o2 o2 o2 o1 o2 o2 o1 o2 o1 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o1 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o1 o2 o2 o2 o2 o2 o o1 o2 o2 o2 o2 o2 o2 o o2 o2 o2 o2 o2 o2 o2 o1 o o o2 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    apply (H1_valid_cmp_bst_merge_cmp_cmp (insert_cmp e2) (merge_cmp_cmp_cmp_cmp e1) (cmp e1 e2) e1)) (cmp e2)).\n    apply (cmp_cmp_cmp_cmp e1).\n    apply (cmp_cmp_cmp e2) (cmp_cmp e2 e1 e2)) (cmp e2) (cmp_cmp_cmp e2 e2) e2 e2) (cmp e2).\n    intros. apply (cmp e2 e2 e2 e2) (cmp e2) (cmp e2 e1 e1) e2 e2 e2) (cmp e2)).\n    apply (cmp e2).\n    apply (cmp e1 e2).\n    apply (cmp e2 e2).\n    apply (cmp e1 e2 e2) (cmp e1 e2) e2).\n    apply (cmp e1 e2 e2 e2)).\n    apply invert_cmp_cmp e1 e1.\n    apply e2. apply (cmp e2 e2 e2).\n    apply (cmp_cmp e2 e1Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x).\n    assert (insert e1 o1 o2) = Some (insert_insert_insert_insert x (insert_insert e2)) = Some (insert x2) ->\n    (insert x1) (insert_insert x1) ->\n      (insert_insert x2) ->\n      (insert_insert_insert_insert x1 (insert_insert x2 x2 x2) (insert_insert_insert_insert x2) (insert x2) (insert x2) (insert x1 y2) ->\n      (insert x2 x1) (insert_insert x2) (insert_insert x2 x2 x2).\n  Proof.\n    intros.\n    rewrite (insert_insert_insert_insert_insert_insert_insert_insert_insert x1 x1) in *.\n    destruct (insert_insert_insert x1).\n    destruct (insert_insert x2) as [insert_insert_insert_insert_insert_insert x2) as [insert_insert x2].\n    destruct t1; auto.\n    - destructQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct (x2) as [x2|] eqn:Heq1?x2y2|] eqn:Heq1].\n    destruct (H2) eqn:Heq1,H2,H2,H2,H1,H2,H1,H2,H2,H2,H1,H1,H2,H2,H2,H2,H2,H1,H2,H2,H2,H2,H1,H2,H2,H1,H2,H2,H2,H1,H3,H2,H2,H2,H2,H2,H3,H3,H3,H4,H4,H2,H4,H4,H4,H4,H4,H4,H3,H4,H4,H4,H4,H5,H4,H4,H3,H4,H4,H4,H4,H4,H4,H4,H4,H4,H4,H5,H3,H5,H4,H4,Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    unfold local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local, local local, local, local local, local local local local local local local local, local local local local local local local local local local, local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local local localQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n\n  Proof.\n    intros.\n    apply (raw_names_names (Internal f.(fn_names f.(fn_params) (Internal f.(fn_params)) (Internal f.(fn_params)) (Internal f.(fn_temps)) (Internal f.(fn_params)).(fn_params)) (Internal f.(fn_params)) e1.(fn_params)) e1.(fn_params)) (Internal f.(fn_temps).(fn_params).(fn_temps)) ->\n    (fn_params).(fn_params) (fn_temps)) (fn_vars f.(fn_params).(fn_params) ->\n   fn_params.(fn_temps)) ->\n    bind_temps f.(fn_vars) (fn_temps f.(fn_temps) (fn_vars) ::\n    (fn_params) ::\n      (fn_vars f.(fn_temps f.(fn_params) ::\n      (fn_temps) ::\n      (fn_vars f.(fn_params.(fn_temps) :: nil.(fn_vars) :: nil.(fn_params) :: nil.(fn_temps) :: nil) ::\n  /\\\n      (fn_params,fn_temps)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    apply (fun e1 e2: forall e2,\n    (fun e1 e2 e2 e2) e1 e1 e2 e2 e2) ->\n    forall e2,\n      (t_t1 e2 e2 e2 e1 e2) ->\n      (t1 e2 e2 e2 e1 e2) ->\n      (t2 e2 e2) (t1 e2 e1 e1 e2) ->\n      forall e1 e2 e2 e1 e2 e2 e2 e2 e1 e2 e2 e2 e2 e1 e1 e2 e1 e2 ->\n      os_loc_loc e2 e2 e1 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e1 e2 e1 e2 ->\n      (t2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e1 e2 e2 e2 e2 e1 e2 e2 e1 e2 e1 e2 e2 e2 e2Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros; intros.\n    destruct (t1, t2,t,t1,t2,t,t2,t2,t1,t2,t2,t2,t2,t2,t1,t2,t2,t2,t1,t2,t2,t2,t2,t2,t3,t1,t1,t2,t1,t2,t1,t2,t2,t2,t1,t2,t2,t2,t1,t2,t2,t2,t2,t2,t2,t2,t2,t2,t2,t2,t2,t1,t2,t2,t2,t2,t2,t1,t2,t2,t3,t2,t2,t2,t1,t2,t2,t3,t1,t3,t2,t1,t1,t2,t2,t1,t3,t1,t2,t3,t3,t1,tQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n\n  Proof.\n    intros.\n    destruct o1.\n    destruct o; destruct o; auto.\n    destruct o1; auto.\n    exists e2; auto.\n    apply IH; auto.\n    destruct o1; auto.\n    destruct o1; auto.\n    - apply (join_join_join_comm a); auto.\n    - destruct o1 o1 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o2 o1 o2 o2 o2 o2 o2 o2 o2 o1 o2 o1 o2 o2 o2 o o2 o2 o o o1 o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    apply (fun x =>\n      match goal with\n    | H: t1 => apply (T1) end.\n    end.\n    destruct (fun t2: t2 => fail 1) end.\n\n  Lemma ext_get:\n    forall e1 e2,\n      forall e1 e1 e2 e2 e2 e2 ->\n      (s2 e2) (s2) ->\n      tc_sig e2) ->\n      (t1 e2 e2 e1) e2 ->\n      tc_expr e1 e2 e2 ->\n      (s2 e2 e2 e2 e1) ->\n      tc_expr e2 e2 e2 e2 ->\n      tc_expr e2 e1 e2 e1 e2 e2 e1 e1 e1 e2 e2 e2 e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e2 e2 ->\n      tc_expr e2 e2 e2 e1 e1 e2 e1 e2 e1 e2 e2 e1 e1 e2 e1 e2 e1 e2 e2 e2 e2 e2 e2 e2 e2 eQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros; case (insert e2 := t1 t2); intros.\n    inversion_insert_tree; auto.\n    set (t1 := t1 t1 t1 t2); auto.\n    destruct t2 t2 t1 t2; auto.\n    {\n    destruct t2; auto.\n    assert (t1 t1 t1 t2 t2 t1 t2) = t2 t2 t2.\n    intro.\n    assert (t1 t2 t2 t1 t2) by (apply (apply (fun t2 t2 t1 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t2 t1 t2 t2 t2 t3 t2 t1 t3 t1 t3 t3 t3 t3 t3 t3 t1 t1 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t3 t4 t1 t3 t3 t3 t3 t3 t1 t3 t3 t4 t3 t4 t1 t3 t3 tQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    destruct o1.\n    rewrite <- H; auto.\n    apply (insert_insert_insert_insert_insert_insert_insert e1) (insert e2 e2).\n    destruct o2; auto.\n    destruct o2); auto.\n    destruct (insert_insert_insert_insert_insert e1) as [x1].\n    destruct (insert_insert_insert_insert_insert_insert_insert e2) eqn:Hp; auto.\n    destruct e2; auto.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert e2).\n    destruct (insert_insert_insert_insert e2) as [x2]; simpl.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x2) as [t2].\n    destruct e1' t2].\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l1.\n    destruct a1) as [insert_insert_insert_insertQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    generalize (insert_insert_insert_insert e1); intros; intros; destruct (insert_insert_insert_insert e2); auto.\n    destruct e2.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e2; simpl; auto.\n    destruct e2; auto.\n    rewrite (insert_insert e1 e2); auto.\n    destruct e1 e2; auto.\n    destruct e1; simpl; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e1; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e1 e2; auto.\n    destruct e1 e1 e1 e2; auto.\n    destruct e1 e2; auto.\n    destruct e1 e1 e2; auto.\n    destruct e2 e1 e2; auto.\n    destruct e2 e2; auto.\n    rewrite e1 e1 e1 e2; auto.\n    assert (l2: ge e1 e2 e2 e2 e2 e2 e2 eQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros; intros.\n    destruct (proj1 e2); eauto.\n    destruct (proj1 (proj2 a2 (proj2 a)).\n    rewrite H1_sig_sig_sig (proj2 (proj1 a2 a)).\n    case (proj2 a2 a2 a2 a).\n    eapply (proj2 a2 (proj2 a1 a1 a2 a2 a2 a2)).\n    destruct (proj1 a a2 a2_sig a1 a2 a2).\n    rewrite H1 a2 a1 a2.\n    rewrite (proj1 a2 a2 a2 a2 a2 a2_sig a2 a2 a2_sig a2 a2 a2 a2 a2 a2 a2 a2 a2 a3 a3 a2 a3 a3 a3 a3 a2 a3 a4.\n    destruct a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a5 a3 a4 a4 a3 a4 a4 a3 a3 a4 a3 a4 a4 a5 a3 a5 a5 a5 a5 a5 a5 a5 aQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros e1 e1 e2;\n    unfold atomic_loc_loc, atomic_loc, atomic_loc_loc.\n    destruct e1 e2; auto.\n    destruct e2; destruct e1; auto.\n    - destruct e1 e2; auto.\n    - subst; auto.\n    - (* not work *)\n    destruct e1 e2; auto.\n    - (* not, but not be not not not work as *)\n    destruct e2; auto.\n    - destruct e1; auto.\n    + intros e1; auto.\n    - destruct e2; auto.\n    - (* case e1; auto.\n    - (* case *)\n    - (* case e2 *)\n    - (* case *)\n    assert (H: (H: (t2: t2 -> t1 e2 = e2) by eauto.\n    destruct e1; auto.\n    - (* case e1 e1 e1 e2; simpl.\n    intros e2; auto.\n    - apply H2.\n    - (* e2 *)\n    - (* e1 *)\n    (* e2 *)\n    intros e1 e1 e2 e1 e1 e2 e2 e2 e2 e2 e2 e2Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    apply (fun x =>\n        (t1 e2) (t2) (t2 : t1 e1) e1) (t2 e2 e1 e1 e1 e2 e2) (t1 e2) e2)) ->\n    (t2 e2 e2 e2 e2) (t1 e2 e1 e2)) ->\n    (t2 e2 e2 t2 t2) ->\n    (t1 e2) ->\n    (t1 e2 e2 e1 e2 e2) (t2 e2) ->\n    (t2 e2 e2 e2) e2) (t1 e2 e2) (t2 e1 e2 e1 e2) (t2 e2 e1 e2 e2 e2) e1 e2 e2 e1 e2 e2 e2 e2 e2 e2) ->\n    (t2 e2 e1 e1 e2 e1 e2 e2 e2 e2 e2 e1 e2 e1 e2 e2 e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e2 eQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    induction l1; simpl; intros; simpl; auto.\n    destruct H1; intros.\n    destruct (t1); intros; auto.\n    destruct (IHH2 (IHIHt2).\n    destruct o1 o1); auto.\n    destruct (IHIHIHIHIHIHIHIH2) (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    intros.\n    destruct (H1 p2 p1) as [x1]; auto.\n    destruct (H1 p2); auto.\n    exists x.\n    destruct (IH1 (IHa2); auto.\n    apply sig2); auto.\n    destruct (IHIHf2 a2); auto.\n    destruct (IH2); auto.\n    apply H2.\n    exists (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    destruct (t1) as [x2|] eqn:H1].\n    destruct (t1); auto.\n    rewrite!IH _ _ (IH _ _ _ _ _ _ H1 H2); subst.\n    destruct H1; auto.\n    apply (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    assert (H: forall e1 e1: forall e1 e2 e2 e2 e1 e2 e2 e2 e2 e2 e1 e2 e1 e2 e2 e2 e2 e1 e2 ->\n    (t2 e2 e2) (t2 e2 e1 e2 e2 e2) e1 e2 ->\n    (t2 e1 e2 e2 e2) e2 e2) ->\n    (P e2 e2 e2 e2 e2 e1 e2 e2 e2 e2) ->\n    (t2 e1 e2 e2 e2 e1 e1 e2 e2 e1 e2 e2 e2 e1 e1 e1 e2 e1 e2 e2 e1 e2 e2 e1 e2 e2 e2 e2 e2 e2 e2 e2 e2 e1 e2 e1 e1 e2 e2 e2 e2 e1 e2 e2 e1 e2 e2 e2 e2 e2 e1 e1 e2 e2 e2 e2 e2 e2 e2 e2 e2 e2 eQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    destruct (eq_dec e2); try discriminate.\n    rewrite!IHo1.\n    inversion 1.\n    Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n\n  Proof.\n    intros.\n    destruct (t2 e2).\n    case (t2 _ _ _ _ _ _ _ _ _ _ H1); auto.\n    rewrite (IH _ _ _ _ _ _ _ _ _ H3).\n    rewrite H3.\n    do 2 rewrite find_rewrite find_case_case_case_case_case_case_case_case_eq (eq_eq_eq _ _ _ _ _ _ _ _ H3); auto.\n    rewrite (IH _ _ _ _ H3); auto.\n    destruct H3; auto.\n    destruct (IH _ _ _ _ _ _ _ H3); auto.\n    apply IH; auto.\n    apply sig_case_case_eq_eq; auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    destruct (t1); eauto.\n    destruct (t1 (t1_t2_t2 * t2)).\n    rewrite <- IH1.\n    do 2 rewrite IH1; auto.\n    do 2 rewrite IH1; auto.\n    do 2 rewrite IH2.\n    apply IH1.\n    rewrite IH2.\n    apply IH1_3_2.\n    rewrite IH1.\n    apply IH2_2; auto.\n    rewrite IH2; auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    destruct h2; subst; auto.\n    destruct h1; destruct h1; auto.\n    destruct h1; simpl; auto.\n    - apply wf_and_lookup; auto.\n    + destruct h2; auto.\n    - intros.\n    + apply wf_lookup_lookup'.\n    + destruct h1; auto.\n    - intros.\n    + destruct h1; auto.\n      - destruct h2.\n    - destruct h1; simpl in h2; auto.\n    - apply wf_lookup_lookup_lookup.\n    - destruct h2; auto.\n    - destruct h1; auto.\n    - subst.\n    - simpl.\n    - destruct h2 as [x1 h2 h1 h2.\n    - subst h2; auto.\n      rewrite wf_lookup.\n    - simpl.\n    - subst h2.\n      + destruct h2; auto.\n      - destruct h2 as [x2 h2 h1 h2 h2 h2 h2 h2 h2 h2 h2.\n      - apply wf_lookup_lookup_lookup; auto.\n    - destruct h1 h1 h2 h2 h1 h2; auto.\n    - rewrite (IH2Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n    (fun e2) (t: t =>\n      (t2 : val =>\n      (t2 o2 : val) (t2 : val) (t2)\n        (t2: val) e2 : val) (t2: val) (t2: val) (t1 e1 e2 e2 e2 e2 e2 e2 e2 (t2 e1 e1 e2) (t1 e1 e2 e2) e2 e2)\n  Proof.\n    intros.\n    apply IH.\n    apply IH.\n    apply IH; eauto.\n    apply IH; auto.\n    apply IHts.\n    apply IHts.\n    apply IHIHIHts_ts.\n    apply IHts.\n    apply IHts.\n    apply IHts.\n    apply IHts.\n    apply IHts.\n    apply IHts; auto.\n    apply IHts_ts.\n    apply IHts.\n    apply IHts; auto.\n    intros IHts.\n    apply IHts.\n    apply IHts.\n    apply IHts2.\n    apply IHts.\n    apply IHts_ts.\n    apply IHts_ts.\n    apply IHts.\n    apply IHts.\n    apply IHts_Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    destruct (insert_dec t1); eauto.\n    destruct (insert_dec e1);\n    apply wf_insert_dec (insert_insert_insert_insert_insert e2); auto.\n    - (* not work *)\n    destruct (insert_insert_insert e1 (insert_insert_insert_insert_insert_insert_insert_insert_insert e2); auto.\n    - apply insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert e1 e1 t2 t2 t2 t2.\n    - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    case (find_app_app_cons_app_cons_app_app (map f a2); auto.\n    destruct h1; simpl.\n    generalize (map f a1); intro h2; discriminate.\n    repeat split; auto.\n    rewrite H.\n    simpl.\n    destruct h1; auto.\n    destruct h1; apply H2.\n    destruct h1; auto.\n    unfold not_app; auto.\n    destruct h; simpl; auto.\n    destruct h2; auto.\n    destruct h1; auto.\n    destruct h2; auto.\n    unfold is_app in h2; auto.\n    destruct h2; auto.\n    destruct h1 h2; auto.\n    destruct h1; auto.\n    destruct h1; auto.\n    apply IH1; auto.\n    + intros.\n    + destruct h1; auto.\n    apply H1; auto.\n    - (* The Coq's the Coq's\n    induction 1.\n    destruct h1; simpl; auto.\n    - destruct h2; auto.\n    + destruct h2 as [x2]; simpl; auto.\n    destruct h1; auto.\n    + destruct h1 as [x1].\n    +Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct (IH _ H1).\n    destruct (IH2).\n    destruct (IH2); destruct H1; auto.\n    exists (IHIHIH1); auto.\n    destruct h2); auto.\n    - apply H2; auto.\n    - apply H1.\n    - apply (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct (find_funct_cons_map f e1); auto.\n    inversion H1; subst; subst.\n    rewrite!map_cons_cons_cons_cons; auto.\n    - destruct (map_cons_cons_cons_cons e2); subst; auto.\n    - auto.\n    + rewrite!cons_cons_cons; auto.\n    + destruct e1; auto.\n    + destruct e2; auto.\n    - apply T; auto.\n    + (* a *)\n    + subst.\n    rewrite!cons_cons; auto.\n    * unfold atomic_cons; auto.\n    + rewrite!cons; auto.\n    * auto.\n    + eapply atomic_cons; auto.\n    + intros.\n    + (* a = P *)\n    { unfold atomic_map; apply atomic_cons.\n    destruct (fun a => t => P t2).\n    destruct t1; auto.\n    + apply atomic_cons; auto.\n    - apply atomic_cons; auto.\n    - eapply atomic_cons; auto.\n    - apply atomic_cons; auto.\n    + rewrite atomic_cons; auto.\n    - apply atomic_loc_loc; auto.\n    - apply atomic_Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    apply P1.\n    destruct (find_sig_sig a1 a2); auto.\n    destruct (find_sig (find_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_funct_ptr g2); eauto.\n    - intros.\n    - (* In *)\n    destruct H as [x1 [y2 [x2|] eqn:E1; inv H2]; simpl in H1; auto.\n    destruct H1; simpl in H2.\n    destruct H2; simpl in H2; simpl in H2; auto.\n    rewrite H2.\n    destruct (find_funct_funct_funct_funct_funct_funct_funct_funct_ptr g2) as [y1 [x1 x2|] eqn:E2].\n    destruct (find_funct_funct_funct_funct_ptr_funct_ptr1 x2) eqn:E2; simpl in *.\n    destruct (find_funct_ptr_ptr_ptr_funct_funct_funct_funct_ptr_funct_ptr_ptr_ptr1 a1); auto.\n    destruct (find_funct_funct_ptr_ptr_ptrQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n\n  Proof.\n    intros; inversion H1.\n    unfold sub_insert_insert_insert; subst.\n    - intros.\n    + eapply derives_trans with (f := f) (f a2 := f a2).\n    - simpl.\n    - destruct (x1).\n      * destruct (f a1).\n      destruct (f a1).\n      - destruct (f a2).\n      + destruct (f_f2 a2).\n      destruct (f2 (f a2 a2).\n      * f2 f2).\n      * destruct (f2 a2) as [f2 [f2].\n      * destruct (f2 a2 a2)).\n      rewrite <- H1.\n      + rewrite <- H2.\n      * rewrite <- (f2)).\n      apply IHl2.\n      apply prop_right.\n      + apply H1.\n      - destruct (f a2).\n      * destruct (f2)).\n      + destruct (f1).\n      destruct (f_f x2 a2); simpl.\n      destruct (f a2); simpl; auto.\n      * intros.\n      destruct (f a1 a2)); auto.\n      * destruct (f a1 a2); auto.\n      * subst; auto.Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold sub_map_map.\n    unfold sub_map, sub_map.\n    unfold sub_map, sub_map.\n    unfold sub_map, sub, sub_map, sub_map, sub_map, sub_map.\n    unfold sub_map.\n    apply sub_map.\n    unfold sub.\n    unfold sub_map, sub_map.\n    unfold sub_map, sub_map.\n    unfold sub_map, sub, sub_map, sub, sub_map, sub_map, sub_map.\n    unfold sub_map. unfold sub_map, sub, sub, sub_map, sub_map, sub_map, sub_map, sub_map, sub_map.\n  unfold sub, sub_map, sub, sub_map, sub_map.\n  unfold sub_map, sub_map, sub_map, sub_map, sub_map, sub_map, sub_map.\n  unfold sub_map, sub, sub_map.\n  unfold sub_map.\n  unfold sub, sub, sub, sub, sub, sub, sub_map sub_map.\n  unfold sub_map, sub, sub_Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct h1; simpl in H2; apply H2; auto.\n    apply H2.\n    unfold bind_app; auto.\n    rewrite bind_app.\n    apply bind_app_app.\n    apply bind_app.\n    destruct H; auto.\n    apply bind_app.\n    destruct (eq (In x1 x2 x2 x2).\n    - apply bind_app_app.\n      * apply bind_app.\n    apply bind_app; auto.\n    rewrite bind_app; auto.\n    * simpl; auto.\n    - simpl.\n    - subst.\n    - simpl.\n    - rewrite bind_app.\n    apply bind_app; auto.\n    - apply bind_app.\n    - simpl.\n    - simpl.\n    - rewrite bind_app.\n    - subst.\n    apply bind_app_app_app.\n      apply bind_app.\n      rewrite bind_app_app_app; auto.\n      rewrite bind_app.\n      - apply bind_app; eauto.\n    - simpl.\n    - simpl.\n    + unfold bind_app.\n      simpl.\n      - simpl; auto.\n      - simpl.\n      destruct (bind_app_app (In x2Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct (map_map f e1); auto.\n    + rewrite <- H; auto.\n    + eapply (map_map_map_map_map_map f (map f1 f1 f2 f2).\n    + simpl; auto.\n    - apply bind_map_map_map_map f2.\n    - destruct (map f2 f2 f1 f2 f2 f2).\n    - apply bind_map_map_map.\n    + apply bind_map_map.\n    - unfold bind_map; auto.\n    + intros.\n    + simpl.\n    - rewrite bind_map_map_map_map_map_map f1.\n    - intros.\n    rewrite bind_map_map_map.\n    apply bind_map_map.\n      rewrite bind_map_map.\n    - unfold bind_map.\n      apply bind_map. simpl.\n      intros.\n    unfold bind_map. f_map_map.\n      apply bind_map_map.\n      rewrite bind_map. simpl.\n      unfold bind_map.\n      simpl.\n      unfold bind_map.\n      simpl.\n      simpl.\n      unfold bind_map_map; simpl.\n     Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction 1; simpl.\n    + rewrite <- H1.\n    + rewrite <- H2.\n    * rewrite <- H1.\n    + intros.\n    - destruct (IH1).\n    - apply H2.\n    + apply H2.\n    + destruct H2.\n      + apply H1.\n      * apply H1.\n      + rewrite <- H2.\n      * rewrite <- H2.\n      + rewrite <- H2.\n      * apply H2.\n      - intros.\n        * apply H2.\n      - intros.\n      * apply H2.\n        + rewrite H2.\n      + simpl.\n      rewrite <- H3.\n        + apply H2.\n      - subst; destruct H2.\n      + rewrite <- H3.\n      + intros.\n        rewrite <- H2.\n      - rewrite <- H1.\n      + rewrite <- H2; destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct H2 as [x1 [x1 [x1 [x2 x2 x1 [x2 [x3 [x4 [x2x3 x1 [y1 [x2 [y2x2x2x2x3 [x1 x3 x3] x3 x4 [x4] x2 x4 x5] x4 x5 x6 x4 x6 x5 x5 x5 x7 x6 x5 x7 x5 x7 x5 x9 x7 x9 x9 x7 x9 x8 x7 x10 x10 x10 x11 x9 x11 x11 x9 x9 x9 x11 x9 x9 x10 x11 x9) ->\n  Proof.\n    intros; split; auto.\n    exists x9; split; auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct n as [x1 x1 [x2 [x2] [y2] [x1]x2 x2] x2] x2] x2] [x2] [x2] x2] x2] x2] [x2]\n    [x2] x2] [y2] [x3] [x2] x3 x2 x2 x4]\n    [x2 x3 x3 x3]\n  [x3 x2 x5 x4] [y4] [x4]\n    [x5] x4 x5]\n    [x4] x5] x3]\n    [x4]\n    [x5] x6]\n    [x6] [x4]\n    [x6 x5] x6]\n    [x6]\n    [x6] x5 x6 x6 x6 x6]\n    [x5 x6]\n    [x6]\n    [y6 x6 x6 x5 x6 x6]\n    [x6 x5]\n    [x6] x6 x6]\n    [x5 x6 x7 x5]\n    [xQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  pose proof (insert_nth 0) (insert_list_insert n e1 e2).\n  apply Forall2.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert n1 e1).\n  - unfold_insert_insert_insert_insert_insert_insert_insert; auto.\n    + rewrite insert_insert_insert_insert; auto.\n    + rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    + intros.\n    + simpl; auto.\n    - unfold insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; apply insert_insert; auto.\n    + destruct insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n      * subst; auto.\n    - intro; auto.\n    * apply insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert x)).\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  - subst.\n    - destruct (insert_insert_insert_insert_insert x) as [v [v2] [v2] [v2] [v2 [v2 [v2 [v2 v2 [v2' [v2 [v1 [v2 [v2 v2 v2 v2 v2 v2] v2 v2 v2 v2 v2 v2 v2 v2 v2.\n  induction v2; intros; simpl; simpl in *.\n  - destruct v2.\n  - intros.\n  - destruct v2; simpl in *.\n    - destruct (insert_insert_insert_insert v2) as [v2 v2; simpl in *.\n      destruct v2; simpl in *.\n      destruct v2; simpl in *.\n      destruct v1; simpl in *.\n      destruct v2; simpl in *.\n      destruct v1; simpl in *.\n      destruct (insert_insert_insert_insert_insert_insert_insert_insert x v2Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct (insert_tac_tac; destruct a; auto.\n  destruct a; auto.\n  - destruct a; auto.\n    destruct a; auto.\n    destruct a; auto.\n    - split; auto.\n    - destruct a; auto.\n      * simpl in *; auto.\n    - apply IH; auto.\n    - apply IH; auto.\n    - rewrite IH; auto.\n    - intros; auto.\n    - inversion IH; auto.\n    - intros.\n    - destruct IH]; auto.\n    + destruct IH; auto.\n    - destruct IH]; simpl in IH; auto.\n    + destruct IH; auto.\n    - split; auto.\n    - intros.\n    - destruct IH; auto.\n    - apply IH; auto.\n    - apply IH; auto.\n      - simpl; auto.\n      - destruct IH.\n      - destruct IH; auto.\n    - destruct IH; auto.\n    - destruct IH; auto.\n      - apply IH as [ | IH]; auto.\n      apply IH]; auto.\n      apply IH; auto.\n      apply IH.\n      + rewrite IH.\n      - apply IH; auto.\n      apply IH; auto.\n      * apply IH; auto.\n      + intros; auto.Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  unfold make_tac.\n  rewrite make_tac.\n  generalize (insert_tac; [auto] e1 e1 e2 e1 e2; auto.\n  rewrite make_tac.\n  - auto.\n  + rewrite make_tac; auto.\n  - subst e1.\n    + rewrite make_tac in *.\n    - unfold make_tac.\n    - rewrite make_tac in *.\n    + rewrite make_tac; auto.\n    + rewrite make_tac in *.\n    rewrite make_tac in *.\n    + rewrite make_tac in *.\n    rewrite make_tac; auto.\n    + rewrite make_tac in *.\n    + rewrite make_tac in *.\n    simpl in *.\n    - simpl in *.\n    - simpl in *.\n    unfold make_tac in *.\n    - simpl in *.\n    simpl in *.\n    rewrite make_tac in *.\n    - unfold make_tac in *.\n    unfold make_tac in *.\n    rewrite make_tac in *.\n    simpl in *.\n    rewrite make_tac in *.\n    replace (if_tac in *.\n    rewrite make_tac in *.\n    rewrite make_tac in *.\n    rewrite make_tac in *.\n    replace (if_tac in *.\n    rewrite make_Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  pose proof (insert_nil_nil)).\n  assert (insert_nil_nil : (insert n e1 = length e2) = nil.\n  induction e2; intros;\n    destruct e1; simpl;\n      apply IH; auto.\n    destruct e1; auto.\n    apply IH1; auto.\n    destruct e1; auto.\n    + destruct e2; auto.\n    + destruct e2.\n    - simpl; auto.\n    + simpl; auto.\n    + apply IHl; auto.\n    + destruct e1.\n    + destruct e2; auto.\n    + rewrite IHl; auto.\n    + destruct e2; auto.\n    + destruct e1; auto.\n    - destruct e1.\n    + destruct e1; auto.\n      + apply IHl1; auto.\n      * simpl in H2; auto.\n    + apply IHl1.\n    - rewrite IHl1.\n    + intros.\n    + simpl in H1.\n    - intros.\n      - destruct e1.\n    + apply IHl2.\n    - simpl.\n      * rewrite IHl2.\n      - rewrite IHl2; auto.\n      + rewrite IHl1.\n      - simpl.\n      * simpl.\n      - rewrite IHl2Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct a1; simpl; destruct a1; auto.\n  - destruct a1; auto.\n  - destruct a1; auto.\n    - destruct a2; auto.\n    - destruct (insert_insert_insert_insert_insert a2); auto.\n    - rewrite <- insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n      - destruct a2.\n      + destruct a1 a2; auto.\n      * simpl; auto.\n      + intros; auto.\n      * destruct a2; destruct a1; auto.\n      * auto.\n      * rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n      * auto.\n      * auto.\n      + simpl.\n      destruct a1 a1 a2; auto.\n      * destruct a2 as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a2) as [insert a1].\n      destructQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert n e1)).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l2).\n  - destruct e2; destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  + destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; simpl; simpl; simpl; simpl; simpl; auto.\n  - subst.\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l) l (insert_insert_insert xinsert_insert_insert x) as [insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert xinsert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert _insert xinsert_insert_insert_insert_insert_Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  - intros.\n  destruct e as [v].\n  - (* a a given value *)\n  - (* the following following case a type of the following case is the function *)\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l) as [v' [v] *)\n  - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert).\n  - subst.\n  - subst.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  - subst.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  + auto.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  unfold SEPx.\n  destruct (f a0)).\n  - destruct (f a) as [x2 & v1 & v2 & v2 & v1 & a2 & x1 & v2 & v2 & v1 & v2 & v2 & v1 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & v2 & & v2 & v2 & & v2 & v2 & & & v2 & v2 & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & &Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (length e2)).\n  rewrite <- app_cons.\n  destruct e; auto.\n  destruct e as [ | [ | | | | | | ] ] ] | [ | ] ] ] ] ] ] ] ] ]\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros; destruct e2; simpl in H;\n    rewrite <- H; rewrite <- H.\n    rewrite <- (proj1_inv_app_cons_cons_cons x) in H2).\n    rewrite <- H1.\n    rewrite <- H2.\n    rewrite <- app_cons_cons.\n    rewrite <- app_cons_cons.\n    rewrite <- app_cons.\n    rewrite <- app_cons_cons_cons_cons in H2.\n    rewrite <- app_cons_cons in H2 in H1.\n    rewrite <- app_cons in H2;\n    rewrite app_cons in H2 in H2.\n    rewrite <- app_cons in H2.\n    rewrite app_cons in H3.\n    rewrite app_cons in H3.\n    rewrite app_cons in H3.\n    destruct (cons_cons a) as [??].\n    simpl in H2.\n    destruct (cons a2) as [ | [? [??]].\n    destruct (cons a); auto.\n    destruct (cons a)); [ | | | | | | | | | | | | ] => rewrite <- app_cons_cons_cons a); auto.\n    destruct a; destruct a; auto.\n    rewrite appQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct H; simpl in H.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert n2).\n  destruct H.\n  rewrite insert_insert_insert_insert.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H0 as [ | | | | | | ] ] ] ] ] ];\n    destruct (insert_insert_insert_insert_insert_insert _insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x) as [ | | ] ] ] ] ];\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l2).\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  unfold map_map; auto.\n  destruct (map_map (map f1) as [v2]; destruct v2]; auto.\n  - rewrite map_map_map_map_map_map.\n    - unfold map_map_map.\n    rewrite map_map.\n    rewrite map_map.\n    destruct (map f1)) as [map_map_map2; auto.\n    - apply map_map_map_map_map.\n    - apply map_map.\n      - simpl map_map_map_map_map.\n    + simpl.\n    - unfold map_map.\n    rewrite map_map.\n    rewrite map_map_map_map_map_map.\n      - simpl.\n      rewrite map_map_map_map_map_map.\n      rewrite map_map.\n      rewrite map_map_map_map_map.\n    - map_map.\n      rewrite map_map_map.\n    rewrite map_map.\n      rewrite map_map_map_map_map.\n    simpl.\n    rewrite map_map.\n    - rewrite map_map.\n      simpl.\n      rewrite map_map map_map_map_map map_mapQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction n; intros; simpl; auto.\n  destruct (IH _ _ _ _ _ H0).\n  eapply IH2.\n  - intros; auto.\n  + rewrite <- IH.\n      rewrite <- IH; auto.\n      simpl.\n      rewrite <- IH1; auto.\n      + rewrite IH.\n      rewrite IH1_cons_cons, IH1_cons, IH1_cons, IH2, IH2.\n      rewrite IH1, IH1, IH2, IH2, IH2, IH1, IH2_cons, IH2, IH2, IH2, IH1, IH22, IH1, IH2, IH2, IH IH22 IH2; auto.\n      IH IH2.\n      rewrite IH2, IH2_app2.\n      rewrite IH1_1; auto.\n      rewrite IH2, IH1; auto.\n      rewrite IH1; auto.\n      rewrite IH1; auto.\n      rewrite IH2; auto.\n    rewrite IH2; auto.\n    + rewrite IH2, IH IH1; auto.\n    + rewrite IH IH IH2.\n      rewrite IH2; auto.\n      * simpl; auto.\n      apply IH; auto.\n      rewrite IH1;Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (length a); simpl in *.\n  destruct a as [ | ]; auto.\n  destruct a as [ | | ] | | ] ] ] | ] ] | [ | ] ] ] ] ] ] ].\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1 a2); intros; simpl in *;\n    destruct a1; auto;\n    destruct a1; simpl; destruct a2;\n    destruct a2; auto.\n    destruct a1; simpl; destruct a1; simpl in *;\n    destruct a2; auto.\n    destruct a1 a2; simpl in *; simpl in *; simpl in *; auto.\n  apply in *; auto.\n  destruct a1; auto.\n  destruct a2; destruct a1; simpl in *; discriminate; auto.\n  destruct a2; auto.\n  destruct a1; inv H1; auto.\n  destruct a2; auto.\n  destruct a2; auto.\n  destruct a1; auto.\n  destruct a1; destruct a1; simpl in *; subst a2; auto.\n  destruct a2; auto.\n  destruct a1 a2; subst.\n  inv H2Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (insert_insert_insert_insert n2) as [y [x] [x [y [x [x y y] y] x y];\n    [y] [x y] x] x y y] x y] [x y y] x y] [y [y [y y] y] [x y [y [x y y] [y y y y y] x y y] x y y y] x y] x y z;\n    [x y y] y]\n    [x y y y] x y z;\n    [y] [y [y y z] x y z y] [x y y z [y y z] y z z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (length e1 e2);\n    destruct e1 e2); auto.\n    unfold not in *; simpl in *; auto.\n    destruct e1.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    - eapply H1; auto.\n    - apply IH1; auto.\n    - apply H1; auto.\n    - eapply IH; auto.\n      + rewrite IH; auto.\n    - simpl in IH.\n      rewrite IH; auto.\n      rewrite IH; auto.\n    - apply IH; auto.\n      - eapply IH; auto.\n    - apply IHapp; auto.\n    - apply IH.\n      - apply IH1; auto.\n    - apply IH1.\n    - apply IH; auto.\n    - apply IH; auto.\n    - apply IH1; auto.\n    - apply IH.\n    - apply IH IH1.\n    - apply IH2; auto.\n      - apply IH IH1; auto.\n      + apply IH1_app; auto.\n    - apply IH1; auto.\n    - apply IH1_app_app_app; auto.\n    - apply IH1; auto.\n      * rewrite IH IH IH1;Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e;\n    destruct e; destruct e; simpl; auto.\n    destruct e; auto.\n    destruct e; inv e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    apply H; auto.\n    rewrite <- IHl; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    subst; auto.\n    destruct e; auto.\n    destruct e; simpl; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    subst; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; simpl; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; simpl; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e; autoQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (proj2_sig e1); auto.\n  destruct e; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e1; auto.\n  destruct e2; destruct e1; auto.\n  destruct e1; simpl; auto.\n  destruct e2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  eapply H.\n  unfold agree_concat.\n  apply <- <- <- H.\n  apply H.\n  auto.\n  apply H.\n  apply H.\n  apply H1.\n  apply H.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H1Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  rewrite map_app; auto.\n  apply f_equal.\n  unfold get_equal.\n  rewrite get_equal.\n  rewrite get_equal.\n  apply get_cons.\n  rewrite get_cons_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons.\n  rewrite get_cons_cons.\n  rewrite get_cons.\n  destruct (cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons.\n  rewrite get_cons_cons_cons_cons; clear - get_cons in get_cons in *.\n  - subst.\n  + rewrite get_cons in *.\n  + rewrite get_cons_cons_cons in *.\n  + rewrite get_cons.\n  - get_cons; auto.\n  - eapply get_cons; auto.\n  - rewrite get_cons; auto.\n  - rewrite get_Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros; intros; destruct e; omega.\n  rewrite <- IHl; omega.\n  rewrite <- IHl; omega.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros; intros.\n  assert (E1 : A) by omega.\n  assert (apply H1 := E.\n  assert (E : env) = Some (E1) by omega.\n  assert (apply E2 := E2) by omega).\n  assert (apply H1 with (E1 := E2 := E1 := E2).\n  assert (E2 := E1).\n  assert (E2 := E1 := E1) by omega.\n  assert (E1 := E1 E1) by omega).\n  assert (E2 := E2 := E1) by omega.\n  assert (E1 := E2).\n  assert (E1 := E2).\n  assert (E2 := E2 := E2).\n  assert (E1 := E1 E2 := E1 E1 E2 E2); omega).\n  assert (E2 := E2 := E2 := E1 E2; auto.\n  assert (E2 := E1 E2); omega).\n  assert (E1 E2 := E1 E2).\n  assert (E1 := E1 E2 := E2).\n  assert (E2 := E1 E2 E1 E2 EQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  unfold agree_concat.\n  intros.\n  unfold agree_map; intros.\n  destruct (map_map (map (map (map (map_map (map_map_map_map (map_map_map f) e) e1) e2).\n  destruct e2 as [x [v [v1] v2] v2] v2]; simpl.\n  destruct v2; auto.\n  destruct v2; simpl in *.\n  destruct v2; simpl in *.\n  destruct v2; auto.\n  destruct v1 v2; simpl in *.\n  destruct v2; simpl in *.\n  destruct v1; simpl; auto.\n  rewrite <- (map_map_map_map_map f e2); auto.\n  rewrite <- (map_map_map_map f1); auto.\n  rewrite <- map_map_map.\n  rewrite map_map_map.\n  destruct v2; auto.\n  destruct v2; auto.\n  destruct v2; auto.\n  destruct v2; auto.\n  destruct v2; destruct v2; inv H2; auto.\n  destruct v1; auto.\n  destruct v1; auto.\n  destruct v2; invQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  induction e; simpl; simpl; simpl; auto.\n  + simpl; auto.\n    + rewrite map_map_map.\n    + rewrite map_map_map_map_map_map.\n    rewrite map_map.\n    rewrite map_map_map_map_map_map_map.\n    - apply map_map.\n    + rewrite map_map_map.\n    + simpl.\n    + intros.\n    + simpl.\n    - simpl.\n    + rewrite map_map_map_map_map.\n    + apply map_map.\n    + simpl.\n    + rewrite map_map_map_map_map_map_map.\n    + simpl.\n    - rewrite map_map_map_map.\n    rewrite map_map.\n    - simpl.\n    + rewrite map_map_map_map.\n    simpl map_map.\n    - rewrite map_map.\n    rewrite map_map.\n    rewrite map_map_map_map.\n    + simpl.\n    rewrite map_map_map.\n    simpl.\n    rewrite map_map.\n    - apply map_map_map.\n    rewrite map_map_map.\n    + rewrite map_map_map.\n   Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  assert (concat_concat_concat_concat_concat_concat_concat_concat_concat.\n  assert (concat_concat_concat_concat (concat_concat_concat l2 l1 l2 l2).\n  rewrite <- (concat_concat_concat_concat_concat_concat l2 l2).\n  rewrite <- <-_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat.\n  applyconcat_concat_concat_concat_concat_concat_concat_concat_concat_concat.\n  applyconcat_concat_concat_concat_concat_concat_concat_concat_concat.\n  intro.\n  assert (concat l1 l2 l2 l2 l2 l2 l2.\n  rewrite <- Hl1; auto.\n  simpl in Hl2.\n  destruct l2 as [??]].\n  destruct l2 as [k1].\n  rewrite app_concat in Hl1.\n  destruct l1 Hl2; auto.\n  rewrite <- Hl1 in Hl2.\n  destruct Hl2.\n  destruct l1.\n  destruct l2.\n  destruct l1; auto.\n  destruct Hl1 as [k1].\n  destruct Hl1 as [kQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros; intros.\n  intros; simpl.\n  rewrite <- H; auto.\n  destruct H.\n  rewrite <- H.\n  rewrite <- H; auto.\n  apply H0.\n  apply H0.\n  apply H0.\n  Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  generalize dependent n1; intros; unfold agree; intros; generalize dependent n; auto.\n  generalize dependent n2; intros; auto.\n  unfold agree, agree_concat in H1; intros.\n  unfold agree, agree_concat in *.\n  rewrite agree.\n  rewrite agree_concat in H.\n  rewrite agree_concat_concat_concat.\n  rewrite agree_concat_concat_concat_concat_concat_concat.\n  rewrite <- <- (concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat.\n  f2).\n  rewrite <- (concat_concat_concat_concat_concat_concat_concat_concat_concat.\n  rewrite F_concat.\n  rewrite <-_concat_concat_concat_concat_concat_concat.\n  apply F_concat.\n  rewrite <- f_concat_concat_concat_concat_concat.\n  rewrite F_concat.\n  applyconcat_concat_concat_concat_concat_concat_concat_concat.\n  unfold F.\n  rewrite <- f_concat_concat.\n  simpl.\n  destruct (concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros; simpl.\n  unfold agree_concat.\n  rewrite <- H1.\n  unfold agree_concat in H1.\n  simpl.\n  rewrite (concat_concat_concat_concat (concat_concat_concat (concat (concat_concat l2)) (concat l2)) (concat l1 :: l2) e2).\n  simpl.\n  destruct (concat l1; auto.\n  destruct (concat l2).\n  rewrite <- <- (concat_concat_concat_concat l2) as [k1].\n  rewrite <- <- <- <- <- (concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat l2 l2).\n  simpl.\n  unfold update_concat.\n  rewrite <-concat.\n  applyconcat_concat_concat_concat.\n  rewrite <- (concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat_concat l2).\n  simpl.\n  rewrite (concat_concat_concat_concat_concat_concat_concat_concat l2 l2 l2 l2 l2 l1 l2 l2 l2 l2.\n  induction l2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  destruct e; simpl.\n  apply H.\n  rewrite <- H.\n  rewrite <- IHl.\n  apply Forall_map_map_map_map_map_map.\n  apply Forall_map_map; auto.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map.\n  rewrite Forall_map_map; auto.\n  destruct (map_map_map_map_map_map_map.\n  apply Forall_map_map.\n  apply Forall_map; auto.\n  rewrite Forall_map; auto.\n  rewrite Forall_map; auto.\n  rewrite Forall_map_map.\n  rewrite Forall_map.\n  rewrite Forall_map; auto.\n  rewrite Forall_map_map, Forall_map, Forall_map_map; auto.\n  rewrite Forall_map, Forall_map.\n  rewrite Forall_map, Forall_map_map; auto.\n  destruct (map_map_map_map_map, Forall_map, Forall_map_map, Forall_map_map, Forall_map_map, Forall_Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros e1 e2.\n  destruct e2; intros e1 e2 e1 e2.\n  destruct e2 e2; simpl; auto.\n  destruct e2; auto.\n  destruct e1 e2; auto.\n  apply H1; auto.\n  destruct e1.\n  destruct e2; auto.\n  destruct e2; destruct e2; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  induction n.\n  - apply repr_op_inv_inv; auto.\n  - apply repr_op_op_op_op_op_op_op.\n  - apply repr_op_op_op_op_op_op_op.\n    - apply repr_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op.\n    + apply repr_op_op_op_op_op.\n    - apply repr_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_op_opop_op_op_op_op_opop_op_op_op_op_op_op_op_opop_opopop_op_opop_op_op_op_op_op_opop_op_op_op_op_opopop_op_op_opopopop_opopopop_opQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros; destruct e; intros; auto.\n  rewrite <- H; auto.\n  destruct e; auto.\n  destruct e; auto.\n  apply H; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros; destruct e1; simpl; auto.\n  destruct e1; try omega.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  apply (apply H0).\n  rewrite <- H0.\n  apply H0.\n  replace (insert_insert x e1 + e1 + e1 + e1 + e2 + e2 + e2 * e2 + e2 + e2 + e2 + e2 + e2 + e2 * e2 * e1 + e2 + e2 + e2 + e2 + e2 +\nProof.\n  induction e1.\n  simpl.\n  simpl.\n  apply list_map_map.\n  simpl.\n  apply list_map.\n  rewrite list_map_map.\n  rewrite map_map.\n  apply list_map.\n  rewrite map_map.\n  apply list_map.\n  apply list_map_map.\n  apply list_map_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  unfold map_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_map.\n  apply list_mapQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  assert (forall e, In e1) = Some e2 -> In e2 e1 = Some e2.\n  { unfold In, In_insert, In; auto.\n    apply (fold_right; auto.\n  rewrite <- H.\n  rewrite <- H; auto.\n  - apply H.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1 in H1. rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  unfold agree, agree_concat; intros e.\n  apply agree_concat in H.\n  unfold agree in H.\n  apply agree in H.\n  rewrite agree_concat_concat_concat_concat.\n  apply agree_concat in H; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e.\n  induction e; intros.\n  rewrite H.\n  destruct e; intros; auto.\n  destruct e; auto.\n  rewrite <- H.\n  destruct e; auto.\n  rewrite <- H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  destruct n; inv H; simpl; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  eapply IHl; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  destruct n as [n H].\n  destruct n as [n1] [n1].\n  rewrite (IH _ _ _ _ _ _ H1) as [n1].\n  destruct (IH _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  destruct n; auto.\n  - simpl; auto.\n  - rewrite <- insert_insert_insert; auto.\n  - rewrite insert_insert_insert.\n  + apply insert_insert_insert_insert_insert_insert_insert_insert.\n  - destruct a); auto.\n    - rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n    + destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a a) * insert_insert_insert_insert.\n    - subst.\n    rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros; subst.\n  destruct H; simpl; auto.\n  + destruct H.\n    + rewrite H.\n    + destruct H; auto.\n    + destruct H; simpl; auto.\n    * destruct H; auto.\n    + rewrite H; auto.\n      * apply IHl.\n      * rewrite IHl.\n      * auto.\n      * rewrite IHl.\n      * apply IHl.\n      * rewrite IHl; auto.\n      * apply IHl.\n      * rewrite IHl.\n      rewrite IHl; auto.\n      * intros; auto.\n      * apply IHl.\n      * rewrite IHl.\n      * apply IHl; auto.\n      * auto.\n        * rewrite IHl.\n        * intros.\n        * rewrite IHl.\n        * apply IHl.\n      + rewrite IHl.\n        apply IHl.\n      * apply IHl.\n        * apply IHl.\n        apply IHl.\n        * apply IHl.\n        * rewrite IHl.\n        eapply IHl.\n        apply IHl.\n        apply IHl.\n        auto.\n        * rewrite IHl.\n        rewrite IHl.\n        + intros.\n        rewrite IHl.\n          rewrite IHl.\n        apply IHl.\n        unfold IHl.\n        rewrite IHl.\n        apply IHl.\n        rewrite IHl.\n        rewrite IHl.\n        apply IHl.\n        * rewrite IHl.Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  destruct a; simpl; simpl; auto.\n  intros; simpl; destruct a; auto.\n  apply H0; auto.\n  + simpl; auto.\n  + rewrite <- H; auto.\n  + simpl; auto.\n    rewrite H0; auto.\n    * rewrite <- insert_insert_insert_insert_insert_insert_insert; auto.\n    * rewrite insert_insert_insert_insert_insert; auto.\n    - simpl; auto.\n    rewrite insert_insert_insert_insert; auto.\n    rewrite insert_insert_insert_insert_insert_insert_insert_insert.\n    + rewrite insert_insert_insert_insert_insert; auto.\n    + destruct a v; auto.\n    - auto.\n    * simpl; auto.\n    - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert v).\n    - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n    destruct l); auto.\n    - intros.\n    - apply insert_insert_Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl; intros; simpl; intros; simpl; auto.\n  apply IHl; auto.\n  destruct H.\n  - apply IH; auto.\n  - intros; auto.\n  + auto.\n  - rewrite <- H1.\n    - apply IHl1; auto.\n    + rewrite IHl; auto.\n    - apply IHl; auto.\n    - destruct IHl; auto.\n    - intros.\n    - destruct IHl; auto.\n    * auto.\n    + destruct IHl; auto.\n      apply IHl.\n    - destruct (IHl a)); auto.\n    - destruct IHl; auto.\n    - simpl; simpl.\n    - destruct IHl; auto.\n    - destruct IHl; auto.\n    - subst.\n    + rewrite IHl; auto.\n    - apply IHl; auto.\n    - apply IHl; auto.\n    - intros.\n    - apply IHl.\n    - rewrite IHl; auto.\n    + rewrite IHl.\n    - rewrite IHl; auto.\n    + rewrite IHl; auto.\n      rewrite IHl.\n      + rewrite IHl; auto.\n    + rewrite IHl.\n    + rewrite IHl; auto.\n      rewrite IHl; auto.\n    rewrite IHl; auto.\n    + rewrite IHl; auto.\n      rewrite IHl; auto.\n    +Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  destruct n; destruct n; inv H; auto.\n  destruct H.\n  destruct H.\n  destruct H0; auto.\n  destruct H0; auto.\n  apply IH; auto.\n  rewrite H0; auto.\n  rewrite <- H0; auto.\n  rewrite <- H0; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl; simpl; simpl; auto.\n  try discriminate.\n  destruct a; destruct a; auto.\n  - simpl; auto.\n  - apply IH; auto.\n  - rewrite IHl. rewrite IHl.\n  - rewrite IHl.\n  - apply IHl.\n    - rewrite IHl.\n    - unfold map_length.\n      * rewrite IHl; auto.\n    - simpl.\n    rewrite IHl.\n    - rewrite IHl.\n      rewrite IHl.\n      rewrite IHl.\n      + rewrite IHl.\n      - rewrite IHl.\n      * simpl.\n    + rewrite IHl.\n      - unfold map_map.\n      rewrite IHl.\n      + simpl.\n      * simpl.\n      destruct IHl; simpl.\n      rewrite IHl; auto.\n      * rewrite IHl; auto.\n      * rewrite IHl.\n      * rewrite IHl; auto.\n      * simpl.\n      * rewrite IHl; auto.\n      * rewrite IHl.\n      * apply IHl; auto.\n      * rewrite IHl.\n      * apply IHl.\n      * rewrite IHl.\n        rewrite IHl.\n      * rewrite IHl.\n      * rewrite IHl.\n      rewrite IHl.\n      * simpl.\n      rewrite IHl.\n      * apply IHl; auto.\n      * rewrite IHl.\n      * rewrite IHl.\n      * rewrite IHl.Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  destruct (IH l).\n  destruct (IH l).\n  destruct l as [n [n].\n  destruct (IH1).\n  destruct l1.\n  destruct l2 as [n2].\n  destruct (IHIH1 _ _ _ _ _ H1) as [n2]; try discriminate.\n  destruct H1 as [n2]].\n  destruct (IHIHIHIHIH2 _ _ _ _ H1 _ H2) as [n2]].\n  destruct H2 H1; auto.\n  destruct H2 as [n2]; auto.\n  destruct H2 as [n1].\n  destruct (IH1 & H2 & H2 & H2 & H2 & H2 & H1 & H2 & H2 & H2 & H2 & H2 & H2).\n  destruct H2; subst; subst; auto.\n  destruct H2; auto.\n  destruct H2 & H2.\n  destruct H1 & H2 & H2 & H2 & H2 & H2 & H1 & H2 & H2 & H2 & H2 & H2 & H2 & H2 & H2 & H2 & H2 & H2 & HQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros; simpl.\n  - induction n; intros; simpl; simpl; auto.\n  + simpl.\n  + simpl.\n    + intros.\n    + rewrite <- insert_insert.\n    - apply insert_insert_insert_insert; auto.\n    + intros.\n    + simpl.\n    + simpl.\n    - simpl.\n      rewrite insert_insert_insert_insert; auto.\n    + simpl.\n      - simpl.\n      + unfold insert_insert_insert_insert_insert_insert.\n    - rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n    + auto.\n      * apply insert_insert_insert_insert_insert_insert_insert_insert; auto.\n      - destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l) t t t) t v v v v v t v v v.\n  Proof.\n  intros.\n  destruct v; intros.\n  - subst.\n  - destruct t;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  destruct a); try discriminate.\n  rewrite insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert; auto.\n  destruct a a1.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  - if_insert_insert_insert_insert; auto.\n  + intros a; apply insert_insert_insert_insert_insert_insert_insert; auto.\n  + destruct (insert_insert_insert_insert a1) as [insert_insert_insert_insert_insert a2]; destruct (insert_insert_insert a2) eqn:E1.\n  + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  + apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert;Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n.\n  induction n; simpl; simpl; auto.\n  + rewrite In_inv.\n  + rewrite In_inv.\n    + destruct (find_inv x) as [ | | v; auto.\n    + simpl; auto.\n    - apply In_inv.\n    - apply In_inv_inv.\n    + apply In_inv.\n    + apply In_inv.\n    + auto.\n    - auto.\n    - apply In_inv.\n    - unfold In_inv.\n    - intros.\n    - apply In_inv_inv.\n    - rewrite In_inv in H.\n    - intros.\n    - rewrite In_inv in H0.\n    - destruct (find x) as (find_inv H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H0 & H2 & H0 & H0 & H2 & H0 & HQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; intros; auto.\n  destruct H.\n  destruct H; auto.\n  inversion H; intros.\n  destruct H; intros.\n  destruct (eq_dec x); subst; auto.\n  auto.\n  destruct (eq x); auto.\n  inversion H.\n  inversion H; auto.\n  rewrite H.\n  auto.\n  + auto.\n  + intros.\n  + rewrite H; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros; auto.\n  destruct x; auto.\n  destruct (insert a); auto.\n  destruct x; auto.\n  destruct (insert_insert_insert a); auto.\n  destruct (insert_insert_insert_insert x); auto.\n  destruct a); auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert a); auto.\n  destruct a; auto.\n  destruct (insert a); auto.\n  destruct (insert_insert_insert_insert_insert a); auto.\n  destruct a; auto.\n  destruct a); auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a); auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  destruct (insert_insert a) as [n2] [m1 | [n1] [m1 [m1 [m1]].\n  destruct m1].\n  apply H2; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros; auto.\n  rewrite <- insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; auto.\n  induction n; intros; auto.\n  destruct n; auto.\n  destruct n.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a); auto.\n  - intros. apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a) as (insert_insert_insert l) eqn:Hp; auto.\n  - intros; destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert a1) eqn:H; auto.\n  - apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insertQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  destruct (map_insert_insert_insert_insert_insert a2) as [x|x] [x] | a] | a' v' a' a' a' a' a' a'] e' a' a' a' a' a' a'''' a'' a''''''''' ->\n    In a''' a'''''' ->\n    In a' -> In a' -> In x' a' a''' -> In a''' a' ->\n    In a' a' -> In a'' -> In a' -> In x'' -> In a'' -> In a' -> In x' -> In a''' -> In a' a' a' -> In x' -> In a' a' -> In a''' -> In a''' -> In a' -> In a' -> In a'' -> In a' a' -> In a'''''' -> In a''''' -> In a' a'' a'' a''' -> In a''' a' a''' a''Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros; simpl in *; discriminate; auto.\n  rewrite H; auto.\n  rewrite In_map_map_map_map; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; auto.\n  - intros.\n  + rewrite In_if_if_if_if_if_if_if_if.\n    if_if_if_if_if_if.\n  + x then a else false else if_if_if_if_if_if_if_if_if. else false else false else false else false else false else false else false else false else false else else false else false else else false else true else false else false else false else false else else false.\n  if if_if_if_if false else false else false else false else else false else false else false else else false else false else false false else false else false false false else false false else false false false false true.\nProof.\n  induction n; intros.\n  destruct (if false then false).\n  destruct (if false false else false) else false.\n  destruct (if false else false false) then false false else false false false else false else false else false false false false false false false false false false false false.\n  destruct a false false false false true false false false false false false false false false false false false false false false false false false false false false false falseQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert a)).\n  simpl.\n  rewrite insert_insert_insert_insert. apply insert_insert_insert; auto.\n  apply insert_insert.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros. destruct (IH a).\n  destruct a as [p?].\n  destruct a.\n  destruct (IH a) as (IHa & a); auto.\n  destruct a); auto.\n  rewrite app_app_app_app.\n  auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  auto.\n  destruct a.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a a a a a; auto.\n  destruct a; simpl in *; auto.\n  destruct a a.\n  destruct a a; auto.\n  destruct a a; auto.\n  destruct a; auto.\n  destruct a a; auto.\n  destruct aQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  apply insert_insert.\n  apply insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert.\n  apply insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; auto.\n  induction n.\n  + destruct (insert x); simpl; auto.\n    rewrite insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l).\n    destruct (insert_insert_insert_insert_insert_insert_insert x); auto.\n    rewrite insert_insert_insert_insert_insert_insert_insert.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l).\n    induction l; auto.\n    destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; intros; destruct n; auto.\n  destruct n; auto.\n  destruct n; simpl; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct (eq n); auto.\n  rewrite map_insert_insert; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert l); auto.\n  destruct (insert_insert_insert_insert_insert_insert x); auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct n; auto.\n  destruct n; destruct n; auto.\n  destruct n; auto.\n  rewrite map_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  apply insert_insert; auto.\n  destruct a; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert l) as [insert_insert xinsert_insert; auto.\n  destruct (insert_insert_insert_insert_insert_insert_insert_Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (IH a) as [v2].\n  rewrite <- app_insert_insert_insert_insert_insert_insert_insert_insert; auto.\n  destruct a1; auto.\n  + destruct a1 a1; auto.\n  + destruct a1; auto.\n  + destruct a2; simpl; auto.\n  + destruct a2; auto.\n    - destruct a2; auto.\n    - apply (insert a2 a1 a1); auto.\n    - destruct a2.\n    + apply IHl2; auto.\n    - destruct (insert_insert a2); auto.\n    + destruct a2; auto.\n      + destruct a2; simpl; auto.\n    + subst a2.\n      + simpl; auto.\n      * destruct a2; auto.\n      * apply In_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert x1 a2 a2 a1 a1 a1 a2 a2); auto.\n    destruct a2; auto.\n    destruct a2 as [left1 a2 a2].\n    apply insert_Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct e; auto.\n  destruct e as [n [n].\n  inv H; auto.\n  destruct e as [n1].\n  destruct e2; try omega.\n  destruct e2; auto.\n  destruct e1; try omega.\n  destruct e1; auto.\n  destruct e; auto.\n  destruct e2; auto.\n  destruct e; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (IH a).\n  assert (H:nat) = true).\n  assert (A: A) by (apply (H a = false).\n  assert (IHa = true).\n  assert (H a).\n  assert (S n e1 = true).\n  { apply (IHa1 := a = true).\n  { destruct (IHa1 a); try contradiction.\n      apply H; auto.\n      apply H.\n      apply IHl.\n      * apply IHl; auto.\n      * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      + intros.\n        apply IHl.\n        apply IHl.\n      + apply IHl.\n      * rewrite IHl.\n      * apply IHl.\n      + apply IHl.\n        * apply IHl.\n      * apply IHl.\n      * apply IHl.\n      * rewrite IHl.\n      * rewrite IHl.\n      * apply IHl.\n      * rewrite IHl.\n        * rewrite IHl.\n      * apply IHl.\n      * apply IHl.\n      + rewrite IHl.\n      * destruct l0.\n      + apply IHl.\n        * apply IHl.\n      + intros.\n      * apply IHl.\n      *Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite (IH_insert_insert_insert_insert_insert_insert_insert a).\n  simpl.\n  destruct a as [x [x] [x] [x] [x] [x] x] x y] x] [y] ] ] ] [x y] [x y] y] [x y] [y y] x y] [x y] x y [x y] y [x] x y y] [y [x y] x y] [y] x y] y; x y] x y] y y ] ] [x y] [y y] [x y y y] x y] y;\n  [y x y] x y] [y y] (insert] x y]) [y] x y [x y y] x]\n    [y [x y] [y] y y] [y y] [x y x y y [y] [x y y y y y] x y] [x] [x y y y] y [x y] [y y y y] x y] x y y z]\n    (x y)\n  (x y : x yQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct a; simpl; auto.\n  - destruct a; auto.\n  + destruct a; auto.\n  + destruct a; auto.\n  - destruct a; auto. auto.\nQed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros.\n  induction n; simpl; destruct n.\n  destruct n as [|n1]; simpl.\n  - destruct n1.\n  - (* case *)\n  - destruct n1.\n  + simpl; auto.\n  + destruct (IH (IH H1 - H1).\n    - destruct (IH _ H1).\n    + exists n2.\n    + intros.\n    - exists (IH (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros.\n  intros; exists (get_step_step_step_step_step_step_step_step m s) as [n1 & s2 & s2 & s2 & s2 & s2 & s1 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s1 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s1 & s1 & s2 & s2 & s1 & s1 & s1 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s2 & s & & s2 & s2 & s & s2 & s2 & s1 & s1 & s2 & s2 & s1 & s2 & s2 & s & s2 & s & sQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\n\nProof.\nmove=> s2; case: s1 s1 s2 s2 s2 s2 s1 s2 s2; case: s2 s2 s2 -> mem_step s2 s1 s2 s2.\nby case: (get s2 s2 s2 s2 s2 s1 s1 s2 s1 s2 s2 s2 s1 s1 s2 -> mem_step s2 s1 s1 s2 -> mem_step s2 -> mem_step s2 -> mem_step s1 s1 s2 -> mem_step (S s1 s2 s2 s1 s2 s1 s2 -> mem_step (State s2 s2 s2 s2) -> mem_step (State s2 s1 s2) -> mem_step (State s2 s1 s2 s2 s1 s2 s1 s2 s2 -> mem_step s2 s2 -> mem_step s1 s2 -> mem_step s1 s2 -> mem_step s2 s1 s1 s2 -> mem_step s2 -> mem_step s2 -> mem_step s2 -> mem_step s2 -> memQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s2 s1 s1 s2 s2 H2 H3 H4 H4 H3 H3 H5 H4.\n  apply step3.\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step_step_step *)\n  (* step *)\n  (* step step *)\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step *)\n  (* step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step stepQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 s2 s1 s2 s2 s1 s2 s2 s2.\nmove=> s1 s2 s1 s2 H2 s2 s2 s2 s2 s2; apply: (get_step_step s2 s2); exists s1 s2 s2 s2 s2 -> exists s2 -> exists s2, exists s2 /\\ exists s2 /\\ exists s2, exists s2, exists s2; exists s2 s2 s2, exists s2, exists s2, exists s2; exists s2, exists s2 /\\ exists s2; exists s2. exists s2, exists s1 s2, exists s2; exists s2. exists s2. exists s2; exists s2; exists s2; exists s2; exists s2 s1 s2. exists s2; exists s2; exists s2, exists s2; exists s2; exists s2 /\\ exists s2; exists s2, exists s2. exists s2 /\\ exists s1 s2. exists s2, exists s2 /\\ exists s2, exists s1 s2. exists s2 /\\ exists sQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros.\n  (* step *)\n  (* case case case: ifP.\n  (* case case *)\n  (*case: ifP=> s1 s1; case: ifP; case: ifP=> s1 s2 s2 s2 s1 s1 s2 s2 s2; case: ifP => => s2 s2 s2 s2 s2 s2 s2 s1 s2.\n  case: s2 s2 s2 s2 s2 s2 s1 s2 s2 -> step s2 -> s2 ->\n  exists s2 s2 s2 s2 s2 s2 s2 s2' -> exists s2, exists s2 s2 s1 s2 s2 s2 s2 s2 s1 s2 s2 s2 s2 s2.\n(* case: s2 s2 s2 s2 s1 s1 s2 s1 s2 s2 s2 s2 s1 s2.\n  case: s2 s2 s2 s2 s2 s1 s1 s2 s2 s2 s1 s2 s22 s2 s2 s3 ->\n  exists s1 s3 s3 s2 s3 s2 s2 s3Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros a s1 s2 s1 s1 s2 s1 s2 s2 s1 s2 s1 s1 s2 s2 s2 s2.\n  (* case *)\n  (* return *)\n  (* step *)\n  (* step *)\n  (* step step *)\n  (* step *)\n  (* step *)\n  (* step step *)\n  (* step *)\n  (* step step step step step step *)\n  (* step *)\n  (* step *)\n  (* step step *)\n  (* step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step stepQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros.\n  induction n; simpl; intros; simpl; auto.\n  (* 1 *)\n  inversion H.\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *)\n  (* FILL IN HERE *) Admitted.\n(* FILL IN HERE *) Admitted. *)\n  (* FILL IN HERE *)\n\n\n\n\n\n(* FILL IN HERE *)\n(* FILL IN HERE *)\n\n(** FILL IN HERE *) Admitted.\n(** FILL IN HERE *)\n(** **** Exercise: 4 stars, optional (app.  *)\n\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** **** Exercise: FILL IN HERE *)\n(** FILL IN HERE *)\n(* FILL IN HERE *)\n(* FILL IN HERE *)\n(** FILL IN HERE *)\n(** **** Exercise: 4 stars, FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\n(** FILL IN HERE *)\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros; apply step_step; auto.\n  apply step_step; eauto.\n  Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s2; rewrite (get_step_step (get_step_step _ _ _ _ H2) in H2).\nhave{H1} : {L: (a s2 = a s2).\n  move=> a.\n  move=> a H2 H2 H2 H2; rewrite H1.\n  move=> H1 H2; move: (get_get_get a2 H2 H2 H2.\n  move/fresh_get_get a1 H2 H2 H3.\nhave{H1 a s2 H2 H2 H2 H3 H2 H2.\n  move: (get a1) H1 H2 H3 H2; move: (get a2 H3 H3 H3 H2 H3 H3 H3 H2 H3 H3 H3 H3 H3 H3 H3 H3.\n  move: (get_get a s2 H3 H3 H3 H3 H3 H3 H3 H3 H3 H3 H3 H4 H3 H4 H2.\n  rewrite H3.\nhave H2.\n  move: (get_get_get a) (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> H; apply: (get_get l).\nmove=>H H1 H1 H2 H2; apply/H2.\nby rewrite H1.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> [h2 IH] [h1 [? [h1 [h1 [h2 [h2] [h2 h1 h2 h22] [h1 [h2] [h1 [h2 [h2 [h2 h22 [h2] [h2 IH1 h222 h2 h2 h2 [h2] h1 h2 h22 h2 h22 h2 h2 h2 h22 h1 h2 h2 h22 h2 h2 h2 h2 h2 h2 h2 h2.\n\n(* This is a proof of [h1 h2] *)\n\nLemma safe_step :\n  forall (A : Type) (h : list A) (h : list A) (h : list A) (h : list A),\n    (h1 h2 h1 h2 h1 h2 ->\n    (h1 h2 h2 h2 h2 h1 h2 h2 h1 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h2 h1 h1 h1 h1 h2 h2 h2 hQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> a; case: (eq_trans (get_dec a s) => i) s; move: (get_get_get_get_get_get a s).\ncase: (get a s).\nhave [a: (get a) s) s).\nhave s := exists a; split=> s; exists (get a; exists s s; split; exists s; split; exists s; exists s; exists s; exists s; split; exists s; exists s; exists s; split; exists s; exists s.\nexists s; split; exists s; exists s.\nexists s, exists s; exists s; exists s; exists s; exists s'; exists s; exists s1; exists s2; exists s'; exists s2; exists s2; exists s; exists s; exists s.\nexists s2, exists s1 s2 s2; exists s2; exists s2, exists s2, exists s2; exists s2; exists s2; exists s2; exists s2; exists s2, exists s2, exists s2.\nexists s2, exists s2; exists s2. exists sQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\n  intros.\n  destruct s as [s [s [s s] [s s [s s] s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\n  intros.\n  destruct (get_sub_nil_nil_nil_nil_nil k)).\n  destruct H as [n] [n] [n IH]; inversion H].\n  have [n IH]; subst; subst.\n  have [n IH]; rewrite IH1]; rewrite IHn_r; auto.\n  rewrite IH; auto.\n  rewrite IH.\n  - unfold index_cons; rewrite IH; auto.\n  rewrite IH; auto.\n  rewrite IHmap_cons_cons_nil; auto.\n  - rewrite IH; auto.\n  - intros; auto.\n  + apply IH1.\n  + simpl; auto.\n    rewrite IH.\n    rewrite IHcons; rewrite IH IH1_cons.\n  - destruct IH1_cons.\n    - apply IH1_cons_cons_cons; auto.\n    + simpl; rewrite IH IH IH IH1; auto.\n    rewrite IH1; auto.\n    + simpl.\n    - simpl.\n    + simpl.\n    - eapply IH.\n      - eapply IH; eauto.\n    + intros.\n    + apply IH1_cons; eauto.\n    + simpl.\n      rewrite IH IH IH.\n      * apply IH; auto.\n    - unfold IH1_cons;Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\n  intros.\n  induction 1; rewrite?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\n  intros.\n  apply safe_safe.\n  apply safe_step; auto.\n  apply safe_step; auto.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nintros.\ndestruct H as [h]; simpl; auto.\ndestruct H as [h [h [? [??]]]].\ndestruct H as [h [? [? [? [? [??]].\ndestruct (eq_dec w); auto.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nintros.\nrewrite - move=> i; rewrite /IH; apply/IH_nil.\nby rewrite H.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\n  intros.\n  induction 1; intros; destruct 1; destruct 1; destruct 1; apply H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nelim: s1 s1 s2 s1 s2 s2 s2 s2 s2.\nmove=> s2 s1 s2 s2; apply: (IH s2) s2 s2 s1 s2); apply: IH; apply: (IH t s2); apply: (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=> s2; case: (step_step_step s2); case: s2; case: s1 s2); case: (eq (eq_trans s2); case s1 s2); case s2; case: s2 s2 s2); case: s2 s2; case: s2 s2.\ncase: s2 s2; case: s2 => s1 s2 s2 s1 s2 s1 s2; case s2 s2 s2 s2 s2 s2; case s2 s1 s2 s2; case s2 s2 s1 s2 s2; case s2; case s3 s2; case: s2 s2 s2 s2 s2 s2; case s1 s2 s2 s2 s2 s2 s2 s1 s3 s2 -> s3.\nProof.\ncase: s1 s2 s2 s2 s1 s2 s3 s3 s1 s2 s3 s3 s3 s1 s2 s1 s2.\nhave s1 s3 s3 s3 s3 s3 s3 s3 s3 s3 s3 sQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=> s2; move=>HH H2; move=>H2 H2; rewrite H2.\nby move/H2.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=> x s1; split; apply: s1; apply: (IH_step_step_step_step _ _ _ _ H2); apply: (IH_step_step s2); apply: (IHIHIHIH_step s) s2); apply: H1 s1 s2). Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\n  intros s2 s2 s2 s2 s1 s2 s2 s2; rewrite E2; rewrite E1.\n  apply H1 in E2; auto.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\n  intros.\n  move=> H.\n  apply: (step _ H).\n  apply star_refl.\n  rewrite H.\n  apply star_trans with (S := s2 := s1 s2).\n  apply star_refl.\n  apply star_step.\n  apply star_trans with (S s2 := s2); apply star_trans with s2.\n  apply star_trans with s2; rewrite H2.\n  apply star_trans with s2 with s2.\n  apply star_trans with s2 := s2.\n  apply star_trans with s2.\n  apply star_trans with s2; apply star_trans with s2.\n  apply star_trans with s1 s2; apply star_trans with s2.\n  apply star_trans with s2; apply star_trans with s2 with s2; assumption.\n  apply star_trans with s1 s2.\n  apply star_trans with s2; apply star_trans with s1 s2; apply star_trans with s2 s1 s2; assumption.\n  apply star_trans with s2; assumption.\n  apply star_trans with s2; apply star_trans with s1;Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nintros.\nelim: s1 s2 s2 s2 s1 s2; split.\nelim: s2 s1 s2; split; auto.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: (s1 s1 s1 s2 s2) s1 s1 s2 s1 s2 /\\ s2 /\\ (exists s2) s2 s2 s2).\nmove=> s2; move=>H1 s2; move=> [H1 H2 H2 H2 H2 H2 H3 H2 H3.\n  case: (IHH2 H2 H2 H3 H3 H2 H2 H3 H3 H1 H1 H3 H2.\n  case: H1 H3 H3 H3 H3.\n  case: H3; case: H3; case H3; case: (IHIHIHIHH3) (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=> s2; case/andP=> s2; case/andP; case/andP; case/andP=>H; case: H; case/andP=>H; case/andP=>H:H: H; case/andP=>H; case/andP=>HHH.\nelim/andP=>H=>HH H.\nby rewrite /andP=>H/andP=>HHH; case/andP=>H H=>H H; exists H.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\n  induction s; intros; try constructor.\n  exists s; try constructor; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\n  induction s1; intros.\n  split; intros.\n  (* skip *)\n  assert (H : s2 s1 s1 s2) by (eapply step1 s1 s2 s1 s2).\n  destruct s1 s2; eauto.\n  (* case *)\n  (* step *)\n  destruct s2 as [p2]; simpl.\n  exists s2 as [q2; split; split; split; split.\n  rewrite H2; split; split; split; auto.\n  split; auto.\n  apply star_step.\n  split; auto.\n  split.\n  split.\n  eapply star_trans.\n  eapply star_trans; auto.\n  apply star_refl.\n  split; eauto.\n  apply star_trans.\n  eapply star_trans; eauto.\n  eapply star_trans.\n  econstructor.\n  eapply star_trans; eauto.\n  eapply star_trans; eauto.\n  eapply star_trans.\n  eapply star_trans.\n  eapply star_trans; eauto.\n  eapply star_trans.\n  eapply star_trans; eauto.\n  econstructor; eauto.\n  eapply star_left.\n  eapply star_trans. econstructor; eauto.\n  eapply star_refl.\n  eapply star_Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by apply star_trans; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by apply star_step; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H H; rewrite <- H0. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=> [s2 s1 s2].\nhave [h2 s2] [h2 s2 [h2 [h2 [h2 [? [? [? [? [? [? [? [? [??]]]].\n  rewrite eq_refl.\nhave [h3 [h2 [h3 [??]]]].\n  exists (h2 _ _ (h2)) s2); split; split; split; auto.\n- (* case case_refl]. *)\n  (* case *)\n  case: (eq_refl _ _ _ _ _ H2).\n  apply H3.\n  split; split; intros.\n  apply H3; intros [? [? [? [? [? [? [? [? [? [? [? [? [? [??]]]].\n  apply eq_refl.\n  apply eq_refl.\n  exists (split _ _ H3) as [? [? [? [? [? [? [? [? [? [? [? [??]]]].\n  destruct [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [? [?Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by apply star_trans; apply star_trans; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=> s2 s1 s2 s2 s2; exists s2, s2; split; split; split; split; auto; split; auto.\nQed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case_step; intros. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\n  intros s2 s2 s1 s2 s1 s2 s2 s2 s2 s2 s1 s2 s2 s2 s2 s2 s2 s2 s1 s22 s2.\n  split; auto.\n\n(* case case *)\n  unfold step_step; auto.\n  constructor; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=> s2; rewrite <- H2; rewrite <- H1. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by rewrite <- <- star_step. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (IH _ _ _ H) (IH_step_step _ _ H)).\nby case: (IH H).\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\n  intros.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  rewrite H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0 _ H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply (H0).\n  apply H0 H0.\n  apply H0.\n  apply H0.\n  apply HQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nintros s s H.\nexists s; split; try assumption.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\ninduction n.\ninduction n; simpl; intros; simpl in H; simpl; auto.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\n  intros s H.\n  apply H.\n  split; auto.\n  apply H.\n  rewrite <- H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H; apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (IH _ H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (IH H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (IH _ H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (IHIH H0Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\n  intros; try (eapply H); try rewrite <- H; try rewrite <- H0 in H; try rewrite <- H0; try rewrite <- H0 in H0; try rewrite <- H0; try try try try rewrite <- H0; try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try try tryQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=> [s s]; exists s; split; split; split; auto.\n- apply: (rewrite <- H).\n- (* case *)\n- apply/andP; auto. destruct s; auto.\n- (* case *)\n- (* case/andP. *)\n  simpl in s; intros s.\n- (* case *)\n  apply: s; auto.\n  exists s.\n  exists s; split; auto.\n  apply: s; auto.\n  split; auto.\n  exists s.\n  destruct s; exists s; auto.\n  destruct s; auto.\n  apply: (IH s); auto.\n  exists s; split; auto.\n  split; auto.\n  exists s; auto.\n  split; auto.\n  exists s. split; auto.\n  exists s; split; auto.\n  split; auto.\n  apply: split; auto.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\n- intros.\n- (* We have a way: *)\n-formed *)\n-step_step_step_step_step: *)\n  intros.\n  exists s; split; auto.\n  apply star_step_step.\n  - (* no step step *)\n  - (* step step *)\n  - (* step *)\n  - (* step step step step step step step *)\n  (* step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step stepQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (IH_wf t).\nrewrite H0.\nby apply: contra; auto.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\n  intros.\n  destruct H; auto.\n  - eapply star_trans with (A := A).\n    - split; auto.\n    + (* a- exists a. *)\n    + (* a a, a is a a, a a a a a a a a b /\\ a a a a b a b a b.\n    intros.\n      exists a b. intros.\n      destruct (b a a b); split; auto.\n      destruct (b a b); auto.\n      split; auto.\n      + split; auto.\n      * apply star_trans with a b); auto.\n      * intros.\n      * apply star_trans with a b); auto.\n      apply star_trans with a; auto.\n      * apply star_trans with a; auto.\n      apply star_trans with a; auto.\n      apply star_trans with a b; auto.\n      apply star_trans with a b; auto.\n      apply star_trans with a; auto.\n      apply star_trans with a; auto.\n      apply star_trans with a b; auto.\n      apply star_trans with a b; auto.\n      apply star_trans with a.\n      apply star_trans with (State a a b a bQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct s; try solve [apply H; try solve [apply H; auto].\n  destruct (inversion H); auto.\n  - destruct H; auto.\n  - rewrite H0.\n    - inversion H0; auto.\n    - destruct H0; simpl in H0; subst.\n    - destruct H0; subst; auto.\n    - destruct H0.\n    - destruct H0; auto.\n    - destruct H0; auto.\n    + destruct H0.\n    - destruct H0.\n    + destruct (H0); auto.\n    - inversion H0.\n    + destruct (IHIH _ _ H0); auto.\n    - destruct H0; auto.\n    - subst.\n    - specialize (IH _ H0); subst.\n    - destruct (IHIH _ _ _ _ H0); auto.\n    - subst.\n    - subst.\n      - apply H0 in H0.\n      apply H0.\n      destruct (IH _ H0) as [H0].\n      destruct H0 |H0].\n      * destruct (IHIHIH1 _ _ _ _ _ _ _ H0); auto.\n      destruct H0).\n      - specialize (IHH0 _ H0); autoQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct r; intros.\n  destruct r; try solve [m s; try solve [m1 s1 s2] s2] s2 s2]; try solve [m2' s2' [m1 s2' s2' [m2' [m1' [m2' [m2' [m3' [m2' [m2' [m2' [m2' [m2' [m2' [m2' [m2' [m2' [m2'' [m2' [m2' [m2' [m2' [m3' [m2' [m2' [m2'' [m2' [m2' [m3' [m2' [m2 [m1' [m3' [m2' [m2' [m2 [m2' [m2' [m2' [m3' [m2' [m2' [m3' [m2' m3' [m2' [m3' [m2' [m2' [m3' [m2' [m2' [m2' [Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  exists s'; split; split; split; auto.\n  - (* TODO: *)\n  - intros s' H' H' H' H' H' H' H' H'' H' H''''' H'''''' H''''''''''' H'''''''' H''''''''' H'' H''''' H'''''''' H''''' H' H'''''''' H' H'''''''' H'' H'''''''' H' H'''''' H''''''''''' H'''''''' H' H' H''''' H'''''' H'''''''' H'''' H'' H' H''''''''' H'' H''' H' H''''''' H''' H''' H''''Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  rewrite <- H.\n  apply in H.\n  apply star_trans with s.\n  destruct H.\n  apply star_trans with s; auto.\n  apply star_trans with s.\n  apply star_trans with s' s' s' s' s' s' s'.\n  apply star_trans with s' s' s' s' s' s' s' s' s' s' s' s' s'' s' s' s' ->\n        exists s' s' s' s' s' /\\\n        exists s' s'' s' s' s'.\nProof.\n  intros.\n  exists s' s'; split; auto.\n  split; auto.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  unfold all.\n  intros.\n  unfold not in H.\n  assert (H : sig, sig_step (fun s => s' s) s1 s2) s1 s2 /\\ s2 /\\ c s1' /\\ s2 /\\\n    (forall s2, s1 s2 s2 s2' s2 s2' s1 s2' /\\ exists s2 /\\ exists s2', exists s2' s2' /\\ exists s1' /\\ exists s2'.\nProof.\n  intros.\n  destruct s2 as [t' s1 [t' [t' [t' [t' [t' [t' t' t' t' s' t' t' [t' [t' t' t' t' t' [t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t'' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t' t'Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct s; auto.\n  destruct (eq_refl_trans _ _ _ _ _ _ H); auto.\n  - destruct (s s); auto.\n    - destruct H0); auto.\n    * destruct H0; auto.\n    * destruct (IH _ H0 H0); auto.\n    - (* this is not_case *)\n    destruct H0; simpl in H0; auto.\n    destruct (IHs' _ _ H0) as [s0].\n    + split; auto.\n    * destruct (IHIHIH _ _ _ H0) eqn:H0).\n    + (* case *)\n      rewrite (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros s s s' s' s'.\n  induction s'.\n  inv H; intros s' s' s' s' s' H' s' H'.\n  exists s' s'.\n  exists s'. exists s'; exists s'. exists s'; split; exists s'; split; split; exists s; auto.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct H as [s' [s' [s' [s' [s' [s' [s' s' [s' [s' [s' [s' [s' s' s' [s' [s' [s' [s' s' s' s' [s' [s' [s' [s' [s' [s' [s' [s' s' s' s' s' [s' s' s' s' s' s' s' s' s' s'' s' s' s' s' s'' s' s' s'' s''' s''' s''''' ->\n      (s' s' s' s' s' s' s' s' s' ->\n        forall s' s' s' s'' s' s' s' s' ->\n        forall s' s' s' s' s' s' s''' s' s' s'' s' s' s' s'' s' s''' s' ->\n        (s' s' s' s' s' s' sQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct s; try solve [s' s; try solve [s' s' s' s' s' s' s' s' s' s' s' s' s' s' s' s' s' s' s''' s''''''' s'''' s''' s'''''' s'''' ->\n      (State s') s' s' ->\n      forall s' s' s' s' s' ->\n      (forall s' s' s' s' s' s' s' s' s'' s' s' s' s' s' s'' s''' ->\n      exists s' s'''' s' s'''''' s'' s'''' s'''' s' s'' s''''' s''''' s''''''''''' s''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct (get_refl_dec_sig s).\n  destruct s); eauto.\n  destruct (eq_dec s); auto.\n  exists (get_dec s s)); auto.\n  (* case *)\n  exists s' s'; exists s'; split; split; auto.\n  split.\n  apply H.\n  split; auto.\n  exists s'; exists s'; split; auto.\n  exists s'; split; auto.\n  split; auto.\n  exists s; auto.\n  exists s'; split; auto.\n  split; auto.\n  exists s; exists s', exists s'; split; split.\n  split; auto.\n  split; auto.\n  exists s'; split; split; auto.\n  split; auto.\n  apply H; auto.\n  destruct s'; auto.\n  exists s'; exists s'; split; auto.\n  exists s; split; split; auto.\n  exists s'; split; auto.\n  split.\n  split; auto.\n  exists s'; split; auto.\n  split; split; auto.\n  exists s; auto.\n(* This program is a program is free software; split; auto. *)\n  split; auto.\n  exists s', exists s';Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>H H; first by move: s; first by move: (elim: (IHs (IH _ H0). Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=> [[x' [y y [y' [x [x' [x' [x' [x' [y' [x' [y' [x' x' x y' [x' [y' y' y' [x' x' [x' y' [x' [x' [x' x' x' [y' [x' [x' x' x' x' [y' x' x' x' y' y' [y' x' [x' x' x' x' y' y' x' y' x' x' y'' [x' y' y' x' y' x'' x' [y' [y' x' [x' x' [y' x' x' y' x' x' y' y' x' x' x' x' x'' y' x' x' x' x'' x'' x' x' x'''' x' x''' x' x' x''''' x'' x''' x'' x' ->\n        (forall x' x' x' x'Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\n  intros s2 s2 s2 s2' s2 s2 s2' s2' s1 s1 s2' s2' s2' s2'.\n  move: s1 s2' s2' s2' s2' ->  s2' s2' ->\n  move: (exists s2' s2' s2' s2 s2 s2' s2' ->\n      exists s2' s' s1' s2' s' ->\n      exists (exists s2', exists s2' s2' s1' s2' s' /\\\n      exists s' /\\ exists s' s' s2', exists s' s' s' /\\ exists s' s' s' /\\ exists s' /\\ exists s' s', exists s'', exists s' s' /\\ exists s' s' s' /\\ exists s' s'.\nexists s' s' s''' s' s' s' /\\ exists s' s' /\\ exists s', exists s' s' s' s' s' s' /\\ exists s' s' /\\ exists s' s' s'.\nexists s' s' s'' s' sQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\n  destruct s as [s2 [t3 [s2 [s3 [s3 [s3 [s3 [s4 [s3 [s3 [s3 [s2 [s6 s3 [s2 s5 [s3 s4 [s4 [s2 s3 s4 s6 s4] s4 s5].\nLemma at_step_step_step:\n  forall (T: list T) (s1 s1 s2) (s1 s2 s1 s2 s2 s2 s3) s2 ->\n  exists s2,\n      exists s1 s2, exists s2, exists s1 s3, exists s1 s2, exists s2 s2, exists s1 s3, exists s1 s2, exists s3 /\\ exists s3, exists s3, exists s3. exists s3. exists s3, exists s3, exists s3, exists s3, exists s3, exists s2 s4, exists s3, exists s3, exists s3, exists s3, exists s3, exists s4, exists s3, exists s3, exists s3, exists s4, existsQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\n  intros.\n  destruct s; try solve [s].\n  inversion s; subst; subst; subst; subst; subst.\n  - destruct s; subst; subst.\n  - subst.\n    - simpl. destruct s; auto.\n    - destruct s1; auto.\n    - inversion H2. destruct s2; subst.\n    - subst s1; simpl; subst.\n    - destruct s1 s2; auto.\n    - subst s2; subst; subst.\n    - destruct s1; auto.\n    - destruct s2; auto.\n    - exists s2.\n    - subst; auto.\n    - destruct s2; auto.\n    - subst s2.\n    - apply IH; auto.\n      - subst s2.\n    - subst s1.\n    - apply IH.\n      - split; auto.\n      - destruct s1; auto.\n    - simpl in H1; auto.\n      + destruct s1; subst s2; auto.\n      - subst; auto.\n      - (* case *)\n      - intros s2.\n      - subst s1 s2; auto.\n      + destruct s1 s1 s2; auto.\n      - subst s2.\n      rewrite IH; auto.\n      - eapplyQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>H; split; auto.\nby split; auto.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=> [s [s2 [s2].\ncase: s2 s1 s2] s2; exists s2; split; auto.\ncase: (T s2 s2 s2 s2 s1 s2 s2; auto.\n- by exists s2; exists s2; exists s2.\n- exists s2; exists s2; exists s2; exists s1; split; split; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2; exists s2, exists s2; exists s2; exists s2.\n- exists s1; exists s2'; exists s2; exists s2; exists s1 s2; exists s2; exists s2, exists s1 s2; exists s2, exists s2; exists s2, exists s1', exists s2 s2, exists s1 s2, exists s2 s1 s2', exists s2 s2, exists s1 s2, exists s2, exists s2, exists s2 s1 s2 /\\ exists s2Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>H; auto.\nby apply: (H1 s1 s2 s2) => s2).\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\n  intros.\n  destruct (s1) as (s2)).\n  destruct (s1 & s2 & s2 & E2 & E & E2 & E2 & E2 & E & E2 & E & E2 & E2 & E2 & E & E2 & E & E2 & E & E & E & E & E & E2 & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E & E E & E & E & E & E & E & E & E & E E & E & E & E & E & E & E & E & E & E & E & E E & E & E & E & E & E & E E & E & E & E & E & E & E & E & E & E & E E E & E & E E & EQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\n  intros.\n  destruct E as [x] [x [x [x [x [x [x x y]].\n  destruct x y].\n  exists x.\n  exists y.\n  exists y, x.\n  exists x; split; split; auto.\n  split; auto.\n  split; auto.\n  exists y; auto.\n  exists x; split; auto.\n  split; auto.\n  exists (s2); split; auto.\n  exists y; auto.\n- split; auto.\n  split.\n- exists (s' s2); split; auto.\n- exists x; auto.\n  split; auto.\n- (* case *)\n  exists s2; auto.\n  exists s2; split; auto.\n- exists s2; split; auto.\n- auto.\n  exists s2; exists s1; split; auto.\n- exists s2; split; auto.\n- destruct s; auto.\n- split; auto.\n- exists s2; auto.\n- split; auto.\n  exists s2; auto.\n- exists s2; split; auto.\n  exists s2; exists s2; split; split; auto.\n- splitQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by move: s1; split; eauto. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>H H H0 H0; auto.\nmove=>H0; auto.\nby apply/andP[H0 H0 [H0 H0 H0 H0 H0 H0 H0 H0].\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=> s1 s2 s1 s2 s2 s2 s2 s2 s2; apply: (x1 s2)); split; auto.\n- exists s2; exists (f s2); split; split; split; auto.\n- split; auto.\n- intros [[x s1 s2 s2 [s2 s2 s2 s1 s2 s2; split. apply/H2 s2 s2 s2; auto.\n- exists s2; split; auto.\n- exists s2; split; auto.\n- exists s1 s2; split; auto.\n- split; split; auto.\n- apply star_trans; auto.\n- apply star_trans; auto.\n- apply star_trans; auto.\n- exists s1 s2; auto.\n- exists s2; split; split; auto.\n- right; split; split; auto.\n- split; auto.\n- split; auto.\n- exists s2; auto. destruct s2; auto.\n- split; auto.\n- (* case *)\n- (* s2 *)\n  split; auto. right; auto. split;Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by move=>H; exists (s1 s2). Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by apply: try rewrite E_step. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by move=> r; first by move: (apply: (IHH:=s2) => x s2); apply: (exists s2); first by exists s1 s2; rewrite - (*case: (IH _ _ (IHh) by rewrite s2 s2) in s2); first by rewrite - move=> H2; split; case: s2; apply: (IH_step_step s2); apply: (IH s1); apply: (IHIHIHIHIHs2); case s2); first by move: IH; rewrite IH_step; first by rewrite IH IH.\n- move: (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\n  intros s; intros s s H; apply H; destruct s.\n  apply L; apply L.\n  apply L.\n  split; split; auto.\n  apply L; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros s s s s s s H.\ndestruct s; exists s; exists s; split; auto.\nexists s; split; auto.\nexists s; split; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\n  intros.\n  apply H; split.\n  apply H.\n  apply H.\n  apply H.\n  apply H. apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply (IH2).\n  apply H0.\n  apply (IH _ H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply (IH _ _ H0).\n  apply H2 H0.\n  apply H2.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply (IH.Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros s s H.\napply s s.\napply in H.\napply (h (h a s))).\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H1.\napply H1.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H3.\napply H2.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H2.\napply H3.\napply H2.\napply H3.\napply H3.\napply H3.\napply H4.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply (H1) H3.\napply H3.\napply H2.\napply H3.\napply (H1:=H1).\napply H3.\napply H3.Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros s s; apply L.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite <- H in H; apply H; apply H.\nrewrite H0.\nrewrite <- H1.\nrewrite H2.\napply H2.\nrewrite H1.\nrewrite H1; apply H2.\napply H2.\nrewrite H2.\nrewrite H2.\nrewrite <- H3.\napply (IH:= H2).\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite <- H2.\nrewrite H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite H2.\nrewrite <- H2.\nrewrite H2.\nrewrite <- H3.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- (IH _ _ H2 H3).\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H3 in H2.\nrewrite <- H3 in H2.Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros s H.\nexists s; split; exists s.\nsplit; split; split; split; eauto.\napply sig_safe_safe; auto.\napply sig_safe_safe_safe_safe.\napply sig_safe; auto.\napply sig_safe_safe; eauto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nintros.\nsplit; auto.\nsplit; auto.\napply f_equal.\napply f_equal.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>s; destruct s; simpl; auto.\nmove=>H; auto.\ncase: s; auto.\ncase: s; auto.\nmove=>s s s; auto.\nby rewrite s; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\n  intros s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case_safe; case_refl : s. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\n\nstart_safe_safe.\nstart_safe_safe; intros.\nstart_safe.\nstart_safe_safe s s.\nstart_safe_step_safe.\nstart_safe.\nstart_step.\nstart_safe s (H:=s).\nstart_step_safe.\n(*  (external:=s).\n(*  *)\n(*  This program is a state is a program is step *)\n(*  *)\n(* This program is free software; you can redistribute it under the terms of the terms of the program is distributed in the terms of the terms of the terms of the terms of the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation,    *)\n(* Software Foundation,    *)\n(* Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* You should have received a copy of the License for the Free Software Foundation,    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Free         *)\n(* You should be useful, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\nSet Implicit Arguments.Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case: s; case: (eapply step_safe_safe_safe_safe_safe (H:=H) s). Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nintros s s s s; case s; case_refl. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by apply star_trans; case_trans; rewrite <- star_step. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ninduction s; intros; simpl.\nrewrite <- H0. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nintros; elim st s; intros s s; elim s; clear s.\ncase s.\ncase s s.\ncase s; intros s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\nProof.\nunfold_step in *.\nsimpl in |- *.\ndestruct s; simpl in |- *.\ndestruct s; rewrite H.\nrewrite H; apply H.\ndestruct s; rewrite H.\nrewrite H0.\napply H0.\nrewrite H0.\napply H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0; apply H0.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H0.\napply H0; auto.\nrewrite H0.\nrewrite H0; auto.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0; auto.\nrewrite H0; rewrite H0; auto.\nrewrite <- H0.\nrewrite H0; auto.\nrewrite <- H0; auto.\nrewrite H0.\nrewrite H0.\nrewrite H0; auto.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0; auto.\nrewrite <- H0.\nrewrite <- H1 in H0.\nrewrite H0; auto.\nrewrite <- H0Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\n\nLemma safe_safe_safe_step:\n  forall s s s,\n  safe s s s s s -> safe s' s s s' s' s' s' -> safe s' s' s' s' ->\n  safe s' s' s' -> safe s' s' -> safe s' s' s' s' -> safe s' s' s' -> safe s' s' -> safe s' s' -> safe s' -> safe_safe s' -> safe s' -> safe_safe s s' s' -> safe s' -> safe_safe s' -> safe_safe s' -> safe s' -> safe s' -> safe s' -> safe_safe_step s' s' s s' -> safe_safe s' -> safe s' -> safe_safe_safe s' s' -> safe_safe s' -> safe_safe s' ->\n  safe s s' -> safe_safe s' -> safe_safe_safe_safe_safe_safe: safe_safe_safe s' -> safe safe_safe_safe_safe_safe s' -> safe_safe;safe_safe; eauto.\n(*(* safe. *)\n(* safeQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\nLemma safe_step:\n  forall s s s s s' s' s' s' s' s' s' s' ->\n  safe s' s' -> safe s' -> safe s' s' s' s' s' s' -> safe s' s' -> safe_step s' -> safe s' s' s' -> safe s' -> safe_step s' -> safe s' -> safe_step s' s' s' s' s' -> safe s' -> safe s' -> safe_step s' -> safe_step s' -> safe_step s' -> safe_step s' -> safe s' s' -> safe_step s' -> safe s' -> safe_step s' s' s' s' -> safe s' -> safe s' -> safe s' -> safe_step s' -> safe_step_step s' -> safe_step s' -> safe s' s' s' -> safe s' -> safe' s' -> safe_step t' s' -> safe_step s' -> safe_step s' -> safe' s' -> safe_step_step_step_step s' s' s' -> safe_Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\nLemma safe_step_step :\n  forall s' s' s' s' ->\n  safe s' s' s' s' s' -> safe s' s' s' s' -> safe s' s' -> safe' -> safe_step s' s' s' s' -> safe_step s' s' -> safe_step s' s' -> safe s' -> safe' -> safe_step s' s' s' -> safe_step s' -> safe_step s' s' -> safe_step s' -> safe_step s' -> safe_step s' -> safe_step (State s' s' s' s' s' s' -> safe_step s' -> safe_step s' -> safe s' -> safe_step_step s' s' -> safe_step s' -> safe (State s' s' -> safe (State s' s' -> safe_step s' s' s' s' s' -> safe_step s' s' -> safe_step s' s' -> safe_step s' s' -> safe_step s' -> safe_step (State s' s' s' s' -> safe (StateQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\nLemma safe_step_step :\n  forall s s, safe s s s' s' s s' s' s' s' ->\n  safe s' s' s' s' -> safe s' -> safe s' -> safe s' s' -> safe_step s' -> safe s' s' -> safe s' -> safe_safe s' ->\n  safe s' s' s' s' -> safe s' -> safe_step s' -> safe_step s' ->\n  safe_step s' -> safe s' s' s' -> safe (step s' s' -> safe_step s' s' s' s' s' -> safe_step s' -> safe_step s' -> safe_step s' -> safe s' -> safe_step s' -> safe_step s s' s' -> safe s' -> safe_step s' s' s' -> safe_step s' -> safe_step (step s' s s' -> safe_step s' s' s' -> safe_step s' s' -> safe_stepstepstep s' s' s' s' -> safe_step s' -> safe_stepstep_step sQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\nLemma safe_step_safe:\n  forall s s s,\n  safe s' s' s' s' ->\n  safe s' s' s' ->\n  safe s' -> safe s' ->\n  safe_safe s' ->\n  safe_safe s' s' s' -> safe_step s' s' s' s' ->\n  safe_step s' ->\n  safe_step s' -> safe s' s' s' s' -> safe_step s' s' -> safe s' s' -> safe_step s' s' -> safe s' s' -> safe_step s' ->\n  safe_step s' -> safe_step s' -> safe_step s' s' s' ->\n  safe s' -> safe_step s' -> safe_step s' -> safe_step s' s' s' s' -> safe_step s' s' -> safe_step (safe s' s' s' s' s' -> safe_step s' s' s' -> safe_step s' -> safe_step (step s' s' s' s' -> safe_step_step_step_step; eauto.\n(* safe_stepQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\nLemma safe_step s s s s s' s' s' s s' s' s s' s' s' s' s' s' s' s' s'.\nProof.\nmove=>H H; rewrite H1.\nby rewrite!inE.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\n\n\nLemma safe_safe_step:\n  forall s s s,\n  safe s s s s s s s s s s s ->\n  safe s s' s s s s s s s s s s s s s s s s s s s' s s s.\nProof.\nmove=> [p s s' s s s s s s s s s s s' s s s s s s s' s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\n\nstart_step_step s s s s' s' s' s' s' s' s' s'.\n\nstart: s' -> safe_step s s' ->\n  (forall s s' s' s',\n   safe s' s' s s' s' s' ->\n   safe s' s' s' s' s' s' ->\n   safe s' s' s' s' s' s' -> safe_step s' s' -> safe s' s' -> safe_step s' s' -> safe (State s' s' s' s' s' s' s' s' s' s' -> safe s' -> safe_step s' s' -> safe s' s' -> safe s' s' -> safe_step s' s' s' s' ->\n  safe_step s' -> safe' -> safe_safe_step_step s' -> safe_step s' s' s' -> safe_step s' s' s' -> safe_step s' -> safe_step s' -> safe_step s' s' s' -> safe_step s s' s' -> safe_step s' sQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nstart_step.\n(* Check that we have that we prove the new a subset *)\n\n(* so we can be a subset of a subset, and [elim: *)\n(* A step *)\n(* *)\n(* of the subset (A : A) *)\n(* In a proof of the subset, subset of A, subset, *)\n(* (the well-step. *)\n(* We use a subset is a subset of the subset of the subset, subset of subset *)\n(* as A and subset of the subset of the subset of subset of subset of subset, subset of subset of subset of subset subset of subset of subset of subset of subset of subset of subset of subset subset. *)\n(* *)\n(* subset of subset of subset of subset of subset of subset subset of subset of subset subset subset subset subset subset subset subset of subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subset subsetQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  intros.\n  rewrite <- (iffP idP) => [|i|i | j].\n  exists (i, d.\n  by apply/matrixP=> i; apply: contra j; split; apply/negbTE; split; split; split; auto.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros s H; case: (H=>H.\nexists_dec d; exists (S n).\nexists d; exists d; split; split; exists (set_trans (S n) (S n)) => //; exists s.\nexists d, exists (m, exists (m, d, exists c, exists d) /\\ exists d, exists d /\\ exists s /\\ exists (exists d /\\ exists d, exists d /\\ exists d, exists d, exists d, exists d /\\ exists d /\\ exists c, exists d, exists d, exists d /\\ exists d /\\ exists d, exists d, exists d, exists d /\\ exists d /\\ exists d, exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d, exists d /\\ exists d /\\ exists d /\\ exists d, exists d /\\ exists d, exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d, exists d /\\ exists d, exists d /\\ exists d, exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d /\\ exists d, exists d /\\ exists d, exists d, exists d /\\ exists d /\\ exists d /\\ existsQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros.\ndestruct d; destruct d; destruct d; auto.\napply: (IH => True); auto.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  apply: (iffP idP) => /andP=> [[i [i] i i] /= /andP[i] i] | i j] i j].\n  rewrite /andP[i j]/= ->.\n  apply: IHi j /andP[i j].\n  by rewrite -andbA /= => /andP[i j; rewrite!inE /=!inE!inE /=.\n  by rewrite!inE /=!inE /=!inE => i_sym.\nrewrite!inE /=!inE?eqxx /=!inE!inE.\nby rewrite!inE!inE!inE!inE!inE?inE.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  case: (iffP idP) => [i | [i] | _ | [i | [i] i].\n  exists i; split.\n  exists j, i; exists i; exists j.\ncase: m.\napply: (i j, j) => // => // (i); exists i.\nexists (i, j).\nrewrite H i.\nby exists j; exists j, j; exists j, exists j; exists j, exists i j; exists j; exists j, j, exists j; exists j, j, exists j.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros.\ncase: (iffP idP) => //= => // /andP=> i; case/andP=> j; rewrite /andP=> j j j _; rewrite?inE /andP[jj j j j j j; exists j.\n- by rewrite -subr_assoc j.\n- by rewrite /andP[j jj j j j j j j j; rewrite /eqP; rewrite -subr_comm j j j j j; rewrite -sub_sym j.\n- rewrite -subr.\n- by rewrite -subr.\n- by rewrite -subr_sym -subr_subr_subr.\n- rewrite (eq_eq j j) -subr_neq j j j j j j j j j j j.\n- move/eqP=> j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j jQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros.\nintros d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  intros.\n  pose (S (k : mem) = None) : mem_step (S n).\n    apply: (n * d).\n    split; auto.\n    exists d, d).\n    exists s = find_label_label_label_label_label.\n    split; auto.\n    destruct d; auto.\n    exists (n + exists j) with (n, d).\n    split; auto.\n    exists s.\n    split; auto.\n    exists d; auto.\n    exists (n + exists d.\n    exists d; split; split.\n      exists d; split; split; auto.\n    - exists d; split; auto.\n      exists d; auto.\n    split; auto.\n    exists s; auto.\n    exists d; auto.\n    exists d; auto. exists d; exists d; split; auto.\n    exists d; split; split; auto.\n    exists d; split; auto.\n    exists d; auto.\n    exists d; auto.\n    exists d; exists d; split; auto.\n    exists d; split; auto.\n    exists d; auto.\n    exists d; auto.\n    exists d; split; split; split; auto.\n    exists dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\n  intros.\n  apply: (join_trans (option m) (option_option_state_list_option_option d).\n  exists d, join_option_map_map.\n  apply:\n      exists (option_map_option_option_option_option (option_option (option_option_option js) (option (option (option (option_option ds) (option js ds)) (option js ds)) d.\nProof.\n  unfold invariant_option.\n  unfold join, join, join_option_option_option_option_option_option_option_option.\n  split; auto.\n  - intros.\n  apply join_option_option_option_option_option.\n  - intros; intros; apply join_option_option_option_option_option_option.\n  rewrite join_option_option_option_option_option.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros.\nelim/andP; apply/andP; split; [H].\nsplit; auto].\napply/andP; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: (iffP idP) => /= /andP[H] /=; case/andP[H]; first by rewrite!inE /=!inE /=!inE mem_trans _ /andP[HH /andP[H]] /andP[H] ->].\nby rewrite mem_trans (leq_trans (mem_trans _ _ _ H).\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nmove=> i; case: (j /andP; case: (iffP idP) => [[i | c | c j]; first by case: (size_c c) => [i d.\n  by apply: (size_size_size_chunk_nat_size_nat_size_nat_size_size_nat (size_size (size_size_nat i) => [n_nat j).\nby case: (size j)).\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: (mem_sub d); case: (mem_sub_sub_sub d); case: (mem d); exists (mem d); case: (mem_sub d); rewrite mem_sub_sub d; case: mem_sub d; case: (mem_sub d); case: mem_sub d; case: (mem_sub_sub d). Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: (iffP idP) => [i]; case: (i, d). Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nintros n d; rewrite /andP; rewrite /andP[i]?index_index_t [s]]; rewrite /andP[s] //=.\nrewrite /andP[i [i] //=; rewrite mem_ord].\nrewrite mem_ord_ord; rewrite mem_ord_ord.\nby rewrite mem_ord; apply mem_ord_ord_ord.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by move=> n H; rewrite!inE; rewrite!inE. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: (iffP idP) => //; apply: (iffP idP) => /andP=> //; apply/eqP; apply/andP=> //; apply/eqP; apply/andP=> /andP/eqP/negP/andP=> [HHH H H; apply/andP; apply: eqP; apply: (andP=> /andP=> /andP=> H HHH H | H H H H H; rewrite H H.\nhave/andP=>HHH H H H H H; rewrite H H H; apply/eqP H H H H H H; case/andP=>HH H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H HQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case/andP=> [s dH] => //; apply: (do_by case/andP=> d; apply/andP; apply: (sub_sub_sub_sub_sub s); first by rewrite /eqP; rewrite /andP; rewrite /andP.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: (rewrite /= H). Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: (fun d => //; case: (k k) => // (k.+1) (k1 k) => // (k1) (k2k1 k2). Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: (i j); case: (i) => // => /= H). Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: (rewrite /andP. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\n  intros.\n  exists n, exists n, exists n, exists n.\n  exists n; exists n, exists n. exists n; exists n, exists n; exists n, exists n, exists n, exists n; exists n; exists n, exists n. exists n, exists n, exists n; exists n, exists n, exists n. exists n. exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n. exists n. exists n, exists n; exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n. exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n; exists n, exists nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nrewrite - unfold empty, empty, map.\nby rewrite map_map.\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> [|p]; first by rewrite -def_cat /=!cat_cat. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nintros n d d d.\napply/andP; apply/andP; case: (eq_dec d d); case: (mem_dec d).\nrewrite /andP.\nrewrite (mem_dec d); case: (mem_dec d); case: (mem_eq_dec d).\nrewrite <- r); case (mem_dec d); case d; case: (mem_mem_dec d).\nrewrite (mem_dec d); case: (mem_mem_dec d).\ncase: m c d; case d; case d; case d; case d; case d; case d; case d; case d; case d; case d; case c; case d; case d; case d; case d; case c d; case d; case d; case d; case d; case (mem d; case d; case d; case d; case: (mem_eq d; case d; case d; case d; case d; case d; case d; case d; case d; case d; case d; case; case d; case_eq d; case d; case d; case d; case d; case c; caseQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nmove=>Hij; case: (H); apply: (eq_refl _)). Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nintros.\nrewrite!inE.\nrewrite!inE.\napply: (IH (IH (IH_cons_cons)) //; apply: join_cons_cons_cons_cons_cons n) => // => [apply: join_cons n; last by auto].\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nhave unk: d2: d -> d1 = d2.\n  move=>H1; rewrite!inE /= (mem_mem_mem_mem_mem_mem d) => /mem_mem_mem_mem_mem_mem_mem_mem_mem_mem_mem_mem).\n  rewrite!mem_mem_mem_mem_mem_mem_mem_mem_mem.\n(* We can be used to the set of the goal with\n   to be the set of the proof of the proof of the proof of the proof of the proof of proof of proof of proof proof proof of the proof of proof of proof proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\n  move=> [|n|n] | [[n] m].\n  rewrite <- (index_index_index n)).\n  rewrite -leqNgt leq_trans.\n  -ltnS leq_leq_trans.\n  -ltnS leq_trans.\n  -ltnS (mem_leq_leq_trans (index_leq_trans m)).\n  -ltn_leq_trans (leq_trans _ _).\n  + 1!leq_leq_leq_leq_leq_trans (leq_leq_leq_leq_leq_leq (leq_leq_leq (leq_leq_leq_leq_leq_leq_leq_leq_leq_leq m).\n  rewrite leq_leq_leq_leq_leq_leq_leq_leq_leq.\n  rewrite leq_leq.\n  rewrite -leq_leq_leq_leq_leq.\n  rewrite leq_leq_leq_leq_leq_leq.\n  rewrite leq_leq_leq_leq_leq_leq_leq_leq.\n  apply: leq_leq.\n  case: leq_leq_leq_leq_leq_leq.\n  rewrite -leq_leq_leq_leq_leq_leq_leq_leq_leq_leq_leqQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\n  intros.\n  apply: contra; rewrite <- contra; rewrite /andP; rewrite /andP.\n  -andbA; case/andP; rewrite /andP; case/andP; apply: contra; case/andP; rewrite /andP=>H; rewrite /andP; rewrite /andP; rewrite /andP=>H/andP=>HH H; rewrite H; rewrite /andP=>H H.\n  apply/andP=>HHHHHHHHHHHH H H H H H H H H H H H H H H H H H H H H H.\nby rewrite H H H H; apply H.\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\n  intros.\n  destruct d.\n  split; auto.\n  exists (a, d; split; auto.\n  - split; auto.\n  - (* We can be a b = b = b.\n  - destruct d; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=>H; rewrite!inE. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> x; rewrite!inE. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=>H; rewrite /andP=> H; rewrite /andP=> /andP[/eqP/andP[/andP[HH] /andP[H].\nhave{H: (H /andP[H0 H] := mem_refl.\nhave [H: (t: m) = Some (fun m => /andP[H[H0 H0 H0) H0H0].\nby rewrite /andP[H0 H0 in H0.\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by rewrite?inE. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: (get_perm_perm_dec n). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> // => /H /andP=> /andP[H; rewrite /andP[H; apply/andP[H' H' /eqP; rewrite /andP[H' /andP[H'H' H'H' H' H' H'H' H'H' H' H' H'H'' H' H'H' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H'' H''' H' H' H' H'' H'' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H' H'' H' H' H' H' H' H' H'' H' H' H'' H'' H' H' H'' H' H' H' H'' H'' H' H' H'' H' H' H' H''' H'' H' H' H' H' H' H' H'' H' H'' H'' H'''' H''Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: n; case: (get_mem_mem_mem_mem_mem m); case/mem_mem. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: (split. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> //= [|n IH]; last by rewrite!inE /=!inE /= -andbA => // -andbA. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> n; case: (IH _ _ H) => [] H H; rewrite H. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: (H _ _ _ _ (mem_eq_eq_dec i). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: ifP => [|n] //=; case: ifP => //= m; case: eqP => //= => // => ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: (eq_dec n) => //= (mem_refl _)) => //= n_eq_dec n) => ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> x H; rewrite!inE; rewrite!inE; rewrite!inE; rewrite!inE. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\n  intros; case: ifP => [m].\n  move=> [[m [m' m'] | [m' m' m'] m'] m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m'.\n  move: m' m' m' m'.\n  move=> m' m' m' m' m' m' m' m' m' m' m' m' m'.\n  move=> m' m' m' m' m' m' m'.\n  move=> m' m' m' m' m' m'.\n  move=> m' m' m' m' m' m' m'.\n  move=> [m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m'' m' m' m' ->\n  move=> m m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m' m'' m' m' m' m' mQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\n  intros.\n  destruct n as [m].\n  destruct n].\n  rewrite map_ord_ord_ord_ord_ord_ord.\n  rewrite map_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord_ord.\n  destruct (drop_ord_ord_ord) eqn: IH; auto.\n  destruct (IH _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\n  rewrite map_ord_ord_ord_ord.\n  rewrite map_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord_ord_ord_ord_ord.\n  rewrite map_ord_ord_ord_ord_ord.\n  rewrite map_ord.\n  rewrite map_ord_ord.\n  rewrite map_ord_ord_ord_ord.\n  apply map_ord_ord_ord_ord_ord_ord_ord.\n  rewrite map_ord_ord_ord.\n  rewrite map_ord.\n  rewrite map_ord_ord_ord_ord_ord_ord_ord.\n  rewriteQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by rewrite!IH. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by rewrite (rewrite <- get_dom (IH1). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: (iffP idP) => // => [-> | /andP[/andP[m] m].\n  by move/andP[/andP[m] /=; rewrite /andP[m]].\n  by apply/andP[m]; first by rewrite mem_inj_sub_trans.\n  rewrite mem_trans.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>H; case: (iffP idP) => [H]; rewrite /andP[H _ _ H] => [H|H]; first by rewrite?H.\ncase/andP; rewrite!IH H1.\nrewrite (IHH1 _ H2 H2 H2 H1 H2); rewrite H2.\nby case: (IHIH _ H2); case: (IHH2) => H2) => [H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H; move=> //. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=> H; apply: (@Ordinal (iffP idP) => /= => /andP; apply: eqP => /andP=> [H|H; rewrite /andP[/andP; rewrite /andP[H | H] /andP[H] /andP[HH] //; apply/eqP; apply/eqP.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nLemma get_if:\n  forall m, get (m, get_match m (S n) (get n)) = get_res m.\nProof.\nmove=>H=>H; apply: (IH _ _ _ _ H) => H.\nby move: (IH _ _ H).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H; apply: (eq_refl). Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof.\nmove=>H; move=>H; rewrite (eq_eq H) /= H).\nby rewrite -eq_trans (perm_eq_refl_trans _ _ H) in H.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nLemma get_eq_dec : forall c, get c -> get i = get i = get i = get i.\nProof.\n  intros; apply: (get_dec j).\n  apply: (get_dec j j).\n  apply: (get_dec j j) (get_dec j) (get j)).\n  rewrite get_dec j); rewrite get_get_get_get.\n  apply get_get_get_get.\n  apply get_get_get_get_get_get_get.\n  - intros. destruct (get i j) as [i].\n  destruct j; destruct j; destruct j; simpl in *.\n  destruct j.\n  destruct j; inv H.\n  destruct j; inv H0; inv H0. destruct j; inv H0; simpl in H0; inv H0.\n  destruct j; inv H0.\n  destruct j; inv H0; inv H0; inv H0.\n  inv H0; inv H; inv H0.\n  inv H0.\n  inv H0; inv H0. inv H0.\n  inv H0; inv H0.\n  inv H0. inv H0. inv H0.\n Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H; rewrite /andP=>H; rewrite /eqP; apply: (mem_mem_mem_mem_dec _ _ _ _ H); rewrite!mem_mem_mem_access_access_access_contents); apply/eqP; apply/eqP; apply: perm_access. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H; rewrite /andP[]. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=>H; rewrite /=!inE; move=>H; apply/eqP; move=>H; rewrite!inE. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case: (iffP idP) => [-> | _ _ /andP[H H | [H | H].\nby case/andP[H H].\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /H; rewrite /andP; rewrite /andP=>H; apply/andP; apply/eqP; rewrite /andP; apply/andP; rewrite /andP; rewrite /andP; rewrite!inE; rewrite /andP; rewrite /andP; apply: ifP => /andP=> /andP=>H /andP; apply/andP=>H.\nby apply/andP=>H /andP[H | [H] /andP[HH H].\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case: eqP => [k]; rewrite /andP[]. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> [A]. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: (H: (mem_trans _ _ H). Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /andP; apply: perm_trans (perm _ _ _ H). Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case: (H: m). Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d. *)\nProof. by move=> H; rewrite /eqP; rewrite /eqP; rewrite -mem_mem_access_mem_access_access_access_access; rewrite /perm_access_access. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; apply: (perm_perm_perm m). Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d. *)\nProof. by case: (perm (Ordinal m) => pf). Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y H.\nintros x y H.\nintros x y z H2 H2.\ngeneralize (lt_le_lt_le_trans _ H2).\ngeneralize H1.\napply H1.\ngeneralize (le_le_trans _ H2).\ngeneralize H1.\ngeneralize (le_le_le_trans _ _ H2); intros H1.\ngeneralize (le_trans _ H1.\nintros x H1 H2 H2.\ngeneralize H2; generalize (le_trans _ _ H2).\ngeneralize H2.\ngeneralize (le_le_trans _ H2).\ngeneralize (le_lt_trans _ H2 H2.\ngeneralize H2.\ngeneralize (le_le_le_trans _ H2).\ngeneralize (lt_le_le _ H2.\ngeneralize (le_le_le_lt _ _ H2 H2.\ngeneralize H1.\ngeneralize H1.\ngeneralize H2.\ngeneralize (lt_le_trans _ H2 H1 H2.\ngeneralize (le_le_trans _ H1) (le_trans _ H2).\ngeneralize H2Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n intros.\n unfold opp_opp_opp in |- *.\napply opp_opp_opp_opp.\nsplit; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n intros.\nrewrite <- (diff_sub_sub_sub_sub _ _ (sub_sub_sub_sub _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y H.\napply (Add_inv_inv_inv_inv_inv_inv _ H).\napply (inv_inv _ H); auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  unfold U.\n  unfold unique in *.\n  unfold unique in |- *.\n  apply (S_O_O_O_O_O_O O).\n  rewrite <- H0.\n  rewrite H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O O).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x z z H0 H0 H1 H2 H1 H1.\napply H2.\napply is_is_is_in_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H.\nunfold Sum in |- *.\nintros x y z z H.\nunfold Sum in |- *.\nunfold Sum in |- *.\nunfold Ar1 in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl inQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply not_on_on_on_on_on_on; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n intros.\n split.\n intros.\n exists x; split; split; auto.\n apply not_abelian_abelian_abelian.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\n intros.\nelim (Add x1 x2); intros; elim H6; intros H; elim H4; intros; intros H6; intros.\n [ idtac ].\nelim (P4 H6).\n elim H5; clear H8; intros.\n clear H4; elim (H7; intros; clear H9); intros.\n (H5 H6 H8 H8); intros.\nelim H8; intros.\nelim H8; elim H7; clear H7; intros.\nelim H7; clear H7; intros.\n intros.\nelim (H8); intros.\nelim H6; elim (H8; intros.\nelim H7; intros; clear H7; clear H8; clear H8; clear H10; clear H8; intros; intros.\nelim H8; clear H8; intros.\nelim H8; clear H8; intros.\nelim (H8; intros; clear H8; clear H8; clear H8; clear H7; clear H8; clear H9; clear H7; clear H8; clear H9; clear H10; intros.\nelim H10; clear HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nelim (AddAdd_add_add_add_add_add x2 x2 y1).\nelim (add_add x2 x2 y2) (add x2 x2 x1); intros; intros; elim H6; intros H10; elim (add x1 x2); intros.\nelim H8; intros; clear H6; intros; clear H11; clear H10; elim H9; intros; intros; intros; clear H8; clear H9; clear H9; clear H9; clear H11; clear H11; clear H11; intros; clear H9; clear H9; clear H11; clear H10; clear H11; clear H13 H14; clear H13; clear H14; clear H14; clear H9; clear H14; clear H10; clear H11; clear H14; clear H9; clear H15; clear H12; clear H11; clear H13; clear H12; clear H8; clear H8; clear H12; clear H9; clear H13; clear H13 H12; clear H12; clear H11; clear H12; clear H12; clear HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nelim (Add U) (Add U1); intros x1; elim (Add U2 x1 x2) (Add U3); intros.\nelim (Add U2 x1).\nelim (Add U1; intros.\nelim (Add U2); intros; elim H5; elim H5.\nelim (Add U1 U1 U1 U2); intros.\nelim (Add U2); intros U2 U1 U2; intros.\nelim H3; intros U2.\nelim (Add U1 U2 U2; intros U1 U2 U2 U3); intros U2; elim H6; intros; elim H5.\nelim H3; intros.\nelim U2 U2; elim (Add U1 U3 U2); intros; clear H5; intros; clear U2; elim (Add U1 U1 U3 U2 U1 U2).\nelim U3 U1 U2; intros.\nelim U1; intros U2 U2 U2; elim U2 U2 U3; elim U1 U1 U1 U1 U2 U2 U2 U2 U1 U2 U1 U3 UQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros x2 x2 H11 H12 H12 H12 H11; elim H12; clear H10; intros.\nelim H12; intros; elim H10; elim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H11; intros; intros; intros H11; intros.\nelim (H11); intros; intros; intros H14; elim (H11 H12); intros.\nelim H11; intros; elim H14; intros; intros; elim H12; intros.\nelim H11; intros; intros; intros; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; elim H11; intros; clear H12; intros; clear H12; intros.\nelim H11; intros; intros.\nelim H13; intros.\nelim (H12; intros; intros; elim H12; intros; elim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H12; elim H12; intros; intros; intros.\nelim H12; intros; intros; intros; elim H12;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nelim H8; intros.\nelim (Add (Add U1 x1 x2); intros.\nelim H1; elim H7; intros; clear H6; elim H4; intros.\n intros.\nelim H6; intros; intros.\nelim H8; elim H6; clear H6; intros; intros; intros.\nelim H6; intros; clear H8; elim H6; intros; intros.\nelim (H8 H8); intros.\nelim (H6 H7); intros.\nelim H6; intros; intros; clear H6; clear H10; intros.\nelim H10; elim H7; intros; intros; intros; clear H8; intros.\nelim H7; clear H8; clear H8; intros; intros.\nelim H8; clear H8; intros; elim H6; clear H8; clear H8; intros; intros; clear H8; clear H8; clear H8; clear H8; elim H9; clear H8; intros.\nelim H8; clear H8; intros; intros; clear H8; elim H9; clear H9; intros; clear H8Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros x1; elim H; intros; clear H5 H10; intros.\nelim H7; intros; intros; intros; intros; elim (H8 x1 x1 x1 y2); intros; intros; clear H6; intros.\nelim H7; intros; elim H8; intros H8; elim H8; intros.\nelim H9; intros; intros.\nelim H8; intros.\n (H8 H8; intros; intros; elim H7; clear H8; intros.\nelim H8; clear H7; intros; clear H9; clear H8; intros.\nelim H8; clear H7; clear H7; clear H7; intros; intros; elim H7; clear H8; intros; intros; clear H9; clear H8; clear H7; clear H7; clear H8; intros; clear H9; intros; clear H8; elim H8; clear H9; clear H8; intros; clear H8; intros.\n clear H11; clear H9; clear H9; clear H8; clear H8; clear H8; clear H8; clear H8; clear HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\n intros; intros.\nelim (Add 0); intros; elim H; clear H6; intros; elim H6; intros; intros; clear H7; clear H10; elim H7; clear H10; intros; intros; intros.\n elim H6; clear H8; clear H8; intros; elim H7; intros; clear H9; intros.\nelim H11; intros; clear H8; intros.\nelim H8; clear H8; intros.\nelim (H8; clear H8; intros; clear H8; intros; clear H7; clear H10; elim H8; clear H7; clear H10; intros; clear H10; clear H7; clear H7; clear H8; clear H8; clear H8; clear H9; clear H10; clear H11; clear H8; clear H10; clear H12; clear H8; clear H9; clear H10; clear H12; clear H8; clear H9; clear H8; clear H9; clear H9; clear H10; clear H10; clear H10; clear H10; clear H11; clear H11 H11;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nelim H8; intros; elim H8; intros; intros H8; elim (Lt_irrefl _ _ _ H8); clear H11; intros; elim H9 H9; intros; intros.\nelim H8; intros; intros.\nelim H8; clear H10; intros.\nelim H8; intros; elim H8; intros; intros; clear H10; intros.\nelim H10; intros; elim (H10); intros; elim H10; intros; intros.\nelim H10; intros; intros; intros; intros.\nelim H13; intros; intros.\nelim H12; clear H11; intros.\nelim H10; intros; intros; elim H12; elim H10; intros; intros; elim H12; intros; intros.\nelim H12; intros; intros; intros; intros; clear H10; intros; intros.\nelim H10; intros; clear H10; intros; intros; intros; clear H10; intros.\nelim (H9; elim H10; intros; intros; intros; clear H12; intros; intros; elim H10; intros; intros; intros; clear H12; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros x2 x1 H6 H5; elim H3; intros H6; intros; elim H7; clear H6; intros H5; intros; clear H9; intros; elim H5; elim H5; clear H6; clear H8; intros; clear H9; clear H10; clear H9; clear H9; clear H6; clear H10; intros; intros; clear H10; clear H10; clear H9; clear H10; clear H10; clear H10; clear H10; clear H10; clear H10; clear H10; clear H9; clear H9; clear H10; clear H10; clear H10; clear H10; clear H9; clear H10; clear H12; clear H9; clear H10; clear H10; clear H10; clear H10; clear H10; clear H9; clear H10; clear H11; clear H10; clear H12 H12; clear H15; clear H10 H11; clear H12; clear H12; clear H12; clear H10; clear H10; clear H10; clear H12; clear H15; clear H12; clearQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros x2 H8; intros.\nelim H8.\nelim H8; elim H10; intros.\nelim H8; clear H10; intros; intros; clear H10; clear H10; intros.\nelim H10; intros; clear H10; clear H9; clear H8; intros; elim H9; intros.\nelim H10; clear H11; elim H11; intros.\nelim H8; intros; elim (H9; clear H12); intros.\nelim H12; clear H8; intros; intros; elim H11; intros; clear H12; clear H10; clear H8; elim H12; clear H12; clear H11; intros; clear H12; clear H12; intros; clear H10; clear H12; clear H13; clear H13; clear H10; clear H12; clear H10; clear H10; clear H12; intros.\nelim H12; clear H13; clear H11; clear H15; clear H12; clear H12 H14; clear H14; clear H12; clear H12 H12; clear H13; clear H13; clear H12Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y1 H1 H2 x1 H1 H2 H1 H2 H2; elim H3); intros H3; intros H3 H3; elim H4; clear H4; clear H4 H5; elim H5; intros; intros; clear H4; elim H3 H4; clear H5; clear H4; intros; clear H4; elim H4; clear H5 H5; intros; clear H1; elim H5; elim H5; clear H5; clear H5; clear H5; intros; clear H5; clear H3; clear H4; clear H5; clear H5; clear H5; clear H5; clear H5; clear H5; clear H4; clear H6; clear H5; clear H5; clear H6; clear H4; clear H5; clear H5; clear H6; clear H5; clear H5; clear H5; clear H5; clear H5; clear H7; clear H5; clear H6; clear H5; clear H7; clear H6; clear H7; clear H7; clear H8; clear H7; clearQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x2 H1 x2 H2 H3; elim H1; intros H1; elim H2; intros; clear H1; intros; intros H2 H2 H1 H3; elim H4; elim H4 H5; intros.\nelim (H4); intros; elim H5 H4; elim H4 H5); intros.\nelim H2; clear H5; intros.\nelim H3; intros H3; intros; intros.\nelim (H6; intros; elim H5 H6 H4).\nelim H5 H6; intros; intros; clear H5 H6; intros; intros H5; elim H7; clear H4; clear H8; clear H5; intros.\nelim H6; intros.\nelim (H6; intros.\nelim H7; clear H5; intros.\nelim (H6 H5 H6; clear H6; intros.\nelim (H6); intros; clear H6 H5; clear H5; elim H6; intros; intros.\nelim (H7); intros; intros; clear H6; intros; intros; clear H5; intros; clear H6Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y2 H2 x2 H2 H2 H3.\nelim H2; elim H4 H6; clear H6; intros H5; intros.\ngeneralize (H7); intros H6; clear H6 H6 H5 H9; intros; elim H10; clear H5 H6; clear H6; clear H6; clear H8; intros; clear H8; clear H10; clear H6; clear H6; clear H7; clear H8; clear H9; clear H8; clear H10; clear H8; clear H8; clear H7; clear H9; clear H8; clear H9; clear H9; clear H7; clear H6; clear H9; clear H8; clear H9; clear H8; clear H9; clear H10; clear H10; clear H9; clear H9; clear H10; clear H9; clear H9; clear H9; clear H9; clear H9; clear H10; clear H10; clear H8; clear H9; clear H10; clear H9; clear H11; clear H9; clear H9; clear HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x1 x1 x2 H2; elim H2); intros.\napply opp_comm; rewrite opp_assoc.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x2 H2 H1 H2 H2 H2; elim H1; elim H3; intros; intros H2; elim H2; intros; intros.\nelim (H2).\nelim H4 H3 H3; elim H3; elim H3; intros H4 H3.\nelim H4); intros.\nelim H3; intros.\nelim H3.\nelim H3; intros.\nelim H3; clear H3; clear H2.\nelim H3; clear H4; clear H4; intros.\nelim H4; clear H3; intros; elim H2; intros.\nelim H4; intros.\nelim H4.\nelim H5; intros; intros; intros.\nelim (H4 H6 H6.\nelim (H6).\nelim H4); clear H3; intros.\nelim H4.\nelim (H6 H6 H5; clear H6); intros.\nelim H5.\nelim H4 H4; clear H5; clear H4; clear H4 H5; clear H6; clear H5; clear H7; clear H6; clear H5Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\n intros x y H1 H1; elim H2; intros x2); intros; elim H3; clear H3; intros.\nelim (H4 H2 H5); intros.\nelim (H2).\nelim (H6 H7 H2); intros.\nelim (H5).\nelim (H6 x2 x2 x1 x2); intros.\nelim H5 H7; elim H7); intros; intros; intros; elim H6; intros; intros.\nelim H7; intros.\nelim (H6 H5 H8).\nelim H7; intros.\nelim H7; intros; intros; intros; intros.\nelim H8; clear H7; elim H8; intros; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros; intros; intros; intros.\nelim H6; intros; intros.\nelim H7; elim H7; intros; intros; intros; elim (H8; intros; intros; elim H6; intros; intros; intros; elim H6; intros; elim H7; clear H8; intros; intros; elim H7; introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x2; elim H1; elim H1; clear H2 H2.\nelim H1; intros; elim H1; clear H2.\nelim (H1); intros H1 H2); clear H2.\nelim H2; clear H2; clear H2; clear H1; elim H1; intros.\nelim H3; clear H2 H2.\nelim H3; intros.\nelim H1; clear H1; intros.\nelim H1; clear H1; clear H2; clear H2; clear H1; intros; intros; elim H2; clear H1; intros.\nelim H2; clear H2; clear H3; clear H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H1; clear H2; clear H1; clear H2; clear H1 H1 H3 H2; clear H3; clear H2.\n\nelim H2; clear H2; clear H1; clear H2; clear H2; clear H1; clear H1 H2; clear H3; clear H2; clear H2; clearQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x1.\nelim (sym_sym x1 x1 x2); intros.\nelim (sym H6).\nelim (sym_sym x1).\nelim (sym y2 y2 y2 y2 y2) (sym y2)); intro H2; elim (sym y2); intros.\nelim (sym y2); intro H4; intro.\nelim H4; intros.\nelim H1; clear H6; intros; elim H1; clear H5; clear H3; intros; intros H4; elim H4; intros; intros; clear H5; intros; clear H5; intros; elim H5; clear H5; clear H4; intros; clear H6; clear H3; elim H6; elim H5; clear H4; clear H5; clear H5; clear H5; clear H7; clear H7; clear H7; clear H8; clear H7; intros; clear H5; elim H5; clear H7; clear H7; clear H6; clear H7; clear H5; clear H6; intros.\n elim H7; clear H6 H7; clear H7Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x2 y1 x2 H2 H2 H2 H2 H2).\nelim H4; intros.\nelim (X x2); intros; elim H1; elim H1; clear H2; intros; clear H2; elim H2; clear H2; clear H2; clear H4; clear H2; clear H2; intros; clear H3; elim H1; clear H2; clear H4; clear H4; clear H4; clear H1; clear H3; clear H3; clear H3 H3; clear H3; clear H4; clear H4; clear H5; clear H4; clear H5; clear H1; clear H4; clear H3; clear H3; clear H5; clear H4; clear H3; clear H5; clear H4; clear H5; clear H6 H2; clear H4 H4; clear H4 H4 H4 H5; clear H5 H5; clear H5 H3; clear H5; clear H5; clear H5; clear H5; clear H5; clear H5; clear H6; clear H5; clear HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros A B H2 H2 H2 H2 H3; elim H3; intros; clear H4; clear H3; intros H4; elim H4; elim H5; clear H6; intros; elim H5; clear H6; elim H4; intros; intros; clear H4; clear H5; intros.\n elim H6; intros; clear H6; clear H6; clear H7; elim H6; clear H7; clear H7; elim H5; clear H9; clear H6; clear H6; clear H6; intros; clear H8; clear H6; clear H5; clear H5; clear H6; intros; clear H6; elim H6; clear H6; clear H6; clear H5; clear H6; clear H7; clear H9; clear H7; clear H6; clear H10; clear H5; clear H6; clear H7; clear H8; clear H6; clear H4; clear H6; clear H5; clear H6; clear H4; clear H10; clear H6 H7; clear H8; clear H7; clear H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nunfold Opp in H.\nelim H1.\nelim (X:=X).\nelim H2).\nelim (X:=X).\nelim (X:=X); intros; elim H9); intros H8.\nelim (X:=X); intros H10; intros H7 H7; intros H9; clear H9; elim H10; clear H8; intros; clear H10; clear H8; clear H9; clear H7; clear H9; clear H10; clear H11; intros.\nelim H10; clear H10; clear H10; intros; elim H8 H10; intros; clear H9 H10; clear H10; clear H12; clear H10; clear H10; clear H10; clear H10; clear H12; clear H10; clear H11; clear H11; clear H12; clear H13; clear H12; clear H8; clear H10; clear H10; clear H12; clear H12; clear H11; clear H12; clear H10; clear H10; clear H12; clear H10; clear H12; clear H11; clear H10; clear H13;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H.\nelim H; intros.\nelim H6.\nelim H8.\nelim H5.\nelim H5.\nelim H7.\nelim H8; clear H8.\nelim (Rle_dec x) (x+y+y+y+x+y+x+y+y+y+y+x+x+y+y+y+x+y+y+y+y+y+y+y+x+y+y+y+y+y++y+x+x++x+y++y+x+y++y+y+y+y+y++y+x+y+y+++y++++y++++y++++++y+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H4 H3 H7; elim H8; intros; intros; intros H8; intros; clear H11; elim H12 H12; elim H10; intros; clear H12; clear H12; elim H12; clear H13; intros; intros; clear H12; intros; clear H8; clear H9; clear H12 H12; clear H12; clear H12; clear H10; clear H13; clear H12; clear H12; clear H12; clear H12; clear H12; clear H11; clear H12 H12; clear H10; clear H12; clear H14; clear H12; clear H12; clear H12; clear H12 H12; clear H13; clear H10; clear H12 H12 H12 H13 H13; clear H12; clear H13; clear H12 H12; clear H12; clear H12 H12; clear H13; clear H13; clear H13; clear H12 H13; clear H12 H13 H12 H12; clear H12; clear H12; clear H12; clear H12 H12 H13; clear H12 HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H0.\nelim H5; intros.\nelim H9.\nelim (Zle_eq_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or a x H6).\nelim H10; intros.\nelim (H6).\nelim H10).\nelim H10.\nelim H9.\nelim H10.\nelim (le_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or _ _ H10).\nintros.\nelim (H10).\nelim H8.\nelim H10.\nelim H11.\nelim H11; clear H11; clear H10; intros.\nelim H12; clear H12; clear H12; intros.\nelim H12; intros.\nelim (H12 H12 H12 H13); intros; elim H12; clear H12; intros.\nelim (H12) H12); introsQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H.\nelim (X:=H1)).\nelim (H1 H2).\nelim H3 H3.\nelim H4.\nelim H2.\nelim H4.\nelim H4; clear H4; intros.\nelim H4.\nelim H5; intros.\nelim H5.\nelim (H5).\nelim H5 H5; intros.\nelim H5.\nelim H6.\nelim (Rle_dec x) x0); intros.\nelim H5; intros.\nelim (Rle_dec x); intros.\nelim H7.\nelim (Rle_dec x0); intros.\nelim H4 H5; clear H5; intros.\nelim H5.\nelim H5; intros.\nelim H5.\nelim H6.\nelim H6; elim H6; clear H5; intros.\nelim H5; intros.\nelim H5.\nelim H6.\nelim H5; intros.\nelim H6.\nelim H6; clear H7; intros.\nelim H6; intros; elim H6; intros; intros; elim H6.\nelimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H2 H1 H1.\nelim H.\nelim H1.\nelim H2.\nintros x2; elim H4.\nelim H3.\nelim (H6); intros.\nelim H4; clear H5.\nelim H5; intros.\nelim H6; clear H8; intros.\nelim H7; clear H5.\nelim H8; intros.\nelim H4.\nelim H5; intros.\nelim H9.\nelim H4; intros.\nelim H6.\nelim H6.\nelim H5; intros.\nelim H6.\nelim H6; intros.\nelim H6; clear H6.\nelim H6; intros.\nelim H6.\nelim H5.\nelim H5; intros; intros.\nelim H6.\nelim (lt_trans _ H6).\nelim H6; intros.\nelim H7.\nelim H6.\nelim H5.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6; intros.\nelim (S n0);Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H7 H8; elim H8.\nelim H5.\nintros x.\nelim H8.\nelim H8.\nelim H7.\nelim (H8 H8 H7).\nelim H9.\nelim H9.\nelim (H8).\nelim H8.\nelim H8; clear H9.\nelim H8.\nelim H9.\nelim H8.\nelim H10.\nelim H8.\nelim H10; intros.\nelim H8.\nelim H8.\nelim H8; intros.\nelim H8; intros.\nelim H8; clear H9; clear H8.\nelim H7; intros.\nelim H7.\nelim H8; elim H8; intros.\nelim H9; intros.\nelim H11; intros; clear H8; elim H8; intros; clear H7; elim H8; intros; intros; clear H9; clear H9; elim H9; clear H8; clear H9; intros; elim H9; clear H12; intros; intros; intros.\nelim H12; intros; clear H9; clearQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H0.\nelim H0.\nelim H7 H8.\nelim (H7); intros.\nelim (H9); intros H7.\nelim H7; intros.\nelim H7; clear H8; elim H7; intros; intros; clear H7; clear H9; clear H9; intros; intros; clear H8; clear H8; clear H9; intros; clear H9; clear H7; elim H9; clear H9; intros; clear H7; elim H10; intros.\nelim (H8); intros.\nelim (H9); clear H9 H10); intros; clear H9; clear H8; elim H8; clear H10; clear H8; clear H10; clear H10; clear H10; clear H9; clear H10; clear H10; clear H10; clear H10; clear H12; clear H10; clear H10; clear H10; clear H10; clear H10; clear H10; clear H12; clear H13; clear H10; clear H9; clear H10; clear H13; clear H12; clear H12;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H1 H1 H3 H1.\nelim H3; elim H4 H6; intros H6; clear H7; clear H7; elim H1; clear H5; intros.\nelim H5.\nelim H4.\nelim H6; clear H7.\nelim H5; clear H7; intros; elim H7 H5; clear H5; clear H6; clear H6; intros; elim H5; intros H5; clear H6; clear H6; intros; clear H5; clear H7; clear H7; clear H6; clear H5; clear H7; clear H7; clear H8; clear H6; clear H5; clear H7; clear H9; clear H6; clear H7; clear H8; clear H8 H8; clear H7 H5; clear H9; clear H7; clear H7; clear H8; clear H10; clear H9; clear H7; clear H6; clear H5; clear H8; clear H8; clear H7; clear H6; clear H10; clear H8; clear H9; clear H7Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H1.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H1.\nelim H4.\nelim (H6 H0 H3).\nelim H4 H5.\nelim H3; clear H4.\nelim H6.\nelim H5.\nelim H6.\nelim H4.\nelim H5.\nelim H4.\nelim H4.\nelim H5.\nelim (X0 H5); intro H5; clear H5.\nelim H6.\nelim H5.\nelim H5.\nelim H5; intros.\nelim H5.\nelim H6; clear H6; intros.\nelim H6.\nelim H6.\nelim H5; clear H5; clear H5; intros.\nelim H6.\nelim H5; intros.\nelim (H5 H6 H5).\nelim (H6); intros.\nelim H5.\nelim (H6 H7 H5); intros.\nelim H6.\nelim H8; clear H6; intros.\nelim H5; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\n intros; intros.\nelim H2; intros.\nelim (Rle_eq_eq x y); intros.\nelim H6 H7; elim H8; intros; intros; elim H7; intros.\nelim H8; intros.\nelim H8; intros; elim H6; intros.\nelim H8; intros; intros; elim H6; intros.\nelim H8; elim (Rlt_irrefl _ H9; intros.\nelim H7; intros; intros; intros; intros; clear H9; clear H10; elim H8; intros; intros; intros.\nelim H8; intros; clear H8; intros; elim H8; elim H6; intros; intros; clear H8; intros; intros; elim H8; intros; intros; intros.\nelim (H10); intros.\nelim H6 H8; clear H8; elim H10; intros; intros; intros; elim H10; intros; elim H8; intros; clear H8; intros; intros.\nelim (H10); intros; intros.\nelim H10; intros; elim (Rlt_irrefl _ _ _ H10).\nelim H6;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros x y H0 H.\nelim H1; intros; elim H5; intros; intros; elim H6; intros; clear H7; intros.\nelim (lt_lt_lt_trans with (H5); intros; clear H8); clear H7; elim H7; intros.\n elim H6; intros; intros; elim H7; clear H6; elim H6; intros; intros; intros; intros; elim H7; intros; intros; clear H8; intros; elim H7; intros; intros; clear H6; clear H6; intros; intros; elim H9; elim H10; clear H9; clear H9; clear H10; clear H9; clear H8; intros; clear H9; clear H6; intros.\nelim H9; clear H9; clear H7; clear H7; clear H9; clear H8; clear H8; intros; clear H10; clear H9; elim H9; clear H9; intros; clear H9; intros; intros; elim H10; elim H9; intros; clear H10; elim H9; intros; intros; clear H10; clearQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nintros x y H4 H2 H3; intros; intros; intros.\nelim H8; elim H8 H6 H8; intros.\nelim H8.\nelim H8; intros.\nelim H8; intros.\nelim H10; elim H8; intros.\nelim H11; intros; intros.\nelim H7; intros; intros.\nelim H7; intros; clear H8; intros; intros.\nelim (H8); intros; intros; clear H8; clear H8 H10; clear H9; elim (H9 H9 H11); intros; intros.\nelim H11; clear H8 H11; intros; clear H11 H9; intros.\nelim H8; clear H9; intros; clear H8; intros; elim H7; intros; clear H10; clear H9; clear H10; clear H9; clear H9; intros; clear H9; intros; clear H9; intros; elim H10; clear H9; intros; intros; elim H10; clear H12; clear H9; clear H10; clear H12; clear H12; clear H9; clear H12; intros;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nelim (AddAdd U x y H5).\nelim (AddAdd U : forall (Add U : S x y : S) (Add U) (Add U) (Add U) (Add U) (Add U) (Add U y) (Add U) x y)).\nAdd U U x.\nAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddAddQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nelim (Add x y x y).\nelim H0.\nelim H8; elim H7; intros; intros.\nelim (axs_comprehension (P : E), In x y) -> In x y -> In x y -> In x y -> In y = y -> In x y -> In y -> In y x y.\nintros x y H6 H0 H1 H6); elim H6; intros; intros; intros.\nelim H5 H5; intros H7; elim H7 H7; intros.\nelim H6; intros.\nelim H6; intros H6; clear H7; intros.\nelim H8; intros.\nelim H5; intros; elim (H6); intros; elim H8; intros.\nelim H8; intros.\nelim (H6 H6 H6 H6); intros.\nelim H6; intros.\nelim H7; elim H6.\nelim H6; intros; intros; intros.\nelim (axs_comprehension (couple x1 x1 x2) (couple x2)); intros; intros; intros; elim H6; intros; clear H6; intros; elim H5 HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros x y H H0 H H0; intros; elim H0.\nelim H0; intros; intros; elim H0; intros.\nelim (H9); intros; intros; intros.\nelim H10; intros.\nelim H10 H10; intros; clear H12 H12; intros.\nelim H10; intros; intros; elim H10; elim H8; intros; intros.\nelim H10; clear H12; clear H10; intros; clear H13; intros; elim H12; clear H12; intros; intros; intros; intros; elim H10; intros; intros; elim H12; intros; intros; intros; clear H11; elim H10; intros; intros.\nelim H12; intros; intros; clear H12; clear H12; intros; elim H12; intros; clear H12; elim H12; intros; intros.\nelim H12; elim H12; intros; intros.\nelim H12; elim H12; intros.\nelim H12; intros.\nelim H12; intros; clear H12; clear H12; elim H12; intros; clear H12; elim H12;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros x y H8 H9 H8 H8; elim H8; intros; intros.\nelim H8; elim H8; intros H7; intros H8; intros; intros.\nelim H7; elim H8; intros.\nelim H10; intros H8; intros; elim H8; intros; intros.\nelim H9; intros; clear H9; intros; elim H8; clear H11; intros; clear H8; intros; intros.\nelim (H10); intros.\nelim H8; elim H8; intros; intros; intros; elim H10; intros.\n intros; intros; clear H8; intros.\nelim H11; clear H12; intros; intros; elim H10; intros; elim H10; intros; intros; intros; intros; elim H11; clear H10; clear H10; intros; elim H10; clear H10; clear H10; intros; elim H11; intros; intros.\n intros; intros; elim H10; elim H10; intros; intros; intros; intros; intros; elim H11; elim H12; intros.\n intros; intros; elim H11; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\n intros.\n elim (sym_lt_sym x y H0); intros; intros.\nelim H8; intros.\nelim H8; intros.\nelim (H8 x); intros H8; elim (Rlt_irrefl 0); intros H8); intros; intros; intros.\nelim H8; intros; elim H8; intros; intros; elim H8; intros; intros.\nelim (H8); intros.\nelim H8 H8; intros; intros; elim H8; intros; elim H8; intros; intros.\nelim H8; intros.\nelim H9; intros.\nelim (Rle_not_or_eq_or_or_or_or _ _ _ H9); intros; intros; elim H9; intros; intros; elim H8; intros.\nelim H8; intros.\nelim H8; intros; intros; elim H10; intros; elim H10; intros.\nelim H8; clear H8; intros; intros.\nelim (Rle_or_or_or_or_or_or_or_or _ H10); intros.\nelim H8; intros.\nelim (Rle_Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\n intros.\n intros; elim H8; intros.\n intros; elim H7.\nelim H10.\nelim H8.\nelim (H8).\nelim (H10); intros.\nelim H8; clear H10 H10; intros.\nelim H10; intros; clear H10; elim H10; intros H10; intros; elim H12; clear H10; intros; intros; intros; clear H10; elim H10; intros; elim H10; intros; intros; intros; intros; elim H10; intros.\nelim H10; intros; elim H11; intros; elim H12; intros; clear H11; clear H11; intros; clear H10; clear H10; intros; intros; elim H12; intros; clear H12; elim H12; intros; intros; clear H12; elim H12; intros; elim H12; clear H12; intros.\n (H12 H12 H12; clear H12 H12; clear H12; clear H12; intros; clear H12; clear H12 H12; clear H12; clear H12; intros; clear H12; elim H12; intros;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nintros x y z H0 H0 H0 H1 H1 H2; intros.\nelim H; elim H5; intros; intros H7; intros.\nelim H0; intros; intros.\nelim H7; elim H7; intros.\nelim H7; intros H5.\nelim H6; elim H8; clear H8; intros; elim H9; intros.\nelim H9; intros; intros; elim H9; intros; intros; intros.\nelim H8; intros; intros; elim H6 H7; intros; intros; intros; elim H7; clear H8; intros; elim H9; intros; intros; elim H7; intros; intros.\nelim H6; intros; intros; intros; elim H7; intros.\nelim H8; elim H10; intros; clear H9; intros; intros; elim H8; intros; intros; elim H8; intros; intros.\nelim H8; intros; clear H10; intros; intros.\nelim H10; clear H12; elim H10; intros; intros; intros; intros.\nelim H11; intros; intros; clear H10; elim H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (Zlt_le_le_lt_le_le_le_le_lt_le_le_trans _ _ _ _ H2).\nelim (digit radix (x + y) H3).\nelim (x+y+y+y+y+y-y+y+x+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+x+y++y+y+y+y+++y+y+y+y+++y++y++x+y+y+y+y+y++y+++y++x+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H3.\ngeneralize (Rtotal_order_order_order O E).\ngeneralize (Rtotal_order O E x H1).\ngeneralize (Rtotal_order O E).\ngeneralize (order_order O E).\ngeneralize (Rtotal_order_order O E).\ngeneralize (Rtotal_order E E).\ngeneralize E).\ngeneralize (Rtotal_order_order_order O E E E E E E E E E E E E).\ngeneralize E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\n  intros; intros.\nunfold Sum in H6; elim H9; clear H7; intros.\nelim (Rle_dec x); intros.\nelim (Rle_dec x); intros.\nelim H0.\nelim H10; intros; clear H10; intros.\nelim (Rle_dec x x); intros; intros; apply H10; intros.\nelim H10; intros; intros.\nelim H10; apply H12; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros H10; intros; intros; elim H10; intros; intros; intros.\nelim H10; clear H12; elim H9; intros; intros.\nelim H12; intros.\nelim H10; intros; intros; elim H12; intros; intros; intros; elim H10; intros.\nelim H12; intros; intros; intros; intros.\nelim H13; elim H12; intros; intros.\nelim H10; intros; intros H12; intros.\nelim H12; intros H12; elim H12; clear H12; intros; intros; intros; intros; intros; elim HQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply opp_opp_opp_opp_opp_opp.\nintros x y.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\n  intros.\n  unfold Sum in H1.\n  elim (H1 H2); intros.\n  intros; rewrite H2.\n  elim H4.\n  elim (H4 H3); intros.\n  apply H5; clear H5.\n  apply H5.\n  elim (H4).\n  apply H4).\n  elim H4.\n  intros.\n  intros.\n  elim H6; intros.\n  apply H6; intros.\n  elim H6; intros.\n  elim H4; intros.\n  elim (H6); intros.\n  elim H6; intros; intros; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6 H6.\n  elim H6; intros.\n  elim H6.\n  elim H6; intros.\n  elim H6.\n  intros.\n  elim (H6 x0 H7); intros.\n  elim H6.\n  elim H6; intros.\n  elim H7.\n  elim H8; intros.\n  intros.\n  intros.\n  elim H8.\n  intros.\n  elim H5.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H7.\n  elim H8Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nintros.\nelim (lt_not_lt_not_lt_lt_lt_lt O); intros; clear H4; elim H5; intros.\nelim H5; intros.\nelim H5; clear H6; intros; clear H8; clear H6; elim (H5); intros H6; clear H8; elim H6; clear H5; intros; clear H5; intros.\nelim H6; intros; elim H6; intros.\nelim H7; intros.\nelim (H8); intros; intros; elim (H7); intros.\nelim H5); intros.\nelim H7; intros.\nelim H10; intros.\nelim H7; clear H6; intros.\nelim H10.\nelim (H6); intros.\nelim H6; clear H9; clear H7.\nelim H6; intros.\nelim H8; intros.\nelim H6; intros.\nelim (H7); intros; intros; clear H7; intros; intros.\nelim H8; clear H8; intros; intros.\nelim H7.\nelim (H8 H5 HQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nintros.\nelim H0.\ncase (Rle_dec x) (Rle_dec x y)).\nintros x0.\nelim H3.\nelim H5.\nelim H4.\nelim (Zle_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or _ H5).\nelim H5.\nintro.\nelim H4.\nelim (Rle_or_or_or_or_or_or_or_or_or _ _ _ H4).\nelim H4.\nelim H5.\nelim (Rle_or_or_or_or_or_or_or_or_or_or_or_or_or _ _ _ _ H6 H6).\nelim H5.\nelim H6.\nelim H5; intros.\nelim H6.\nelim H6.\nelim H6.\nelim H7.\nelim H6.\nelim H6.\nelim (Rlt_irrefl _ _ _ H6); intros.\nelim (Rlt_irrefl _ H6).\nelim H6.\nelim HQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\n intros.\nrewrite H4.\nrewrite opp_opp_opp_opp.\napply opp_opp_opp_opp_opp_opp.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros A.\ncase (Zlt_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp O).\ncase (opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp.\nelim H4.\napply opp_opp.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H8.\nintros x0 H8 H7; intros H9; intros H7; elim H9; intros H5; clear H8.\nelim H7; intros H7; clear H8; elim H8; clear H10; intros; clear H7; intros; intros; clear H10 H6; elim H7; intros; intros; elim H5; intros; intros; intros.\nelim H8; intros.\nelim H8; clear H8; intros; clear H8; intros; elim H10; clear H10; intros; intros.\nelim H6; intros; intros; clear H8; elim H6; clear H8; elim H8; intros; clear H8; clear H8; intros; clear H6; clear H8; intros; clear H8; intros; intros; elim H8; clear H8; clear H8; clear H9; clear H9; clear H8; elim H10; clear H9; clear H9; intros; clear H8; clear H10; clear H10 H10; clear H10; clear H10; clear H8; clear H8; clear H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi : A -> Prop :=\n  forall x y : A, P x y.\n\nLemma pi_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi : A -> Prop := forall x y : Type, R x y -> R x y -> R x y = x y -> R.\n\n\nDefinition pi_rel_rel R : R -> R : R_rel R -> R.\nDefinition R -> R_rel R_rel R_rel R -> R_rel R R R.\nDefinition R_rel R : R_rel R R -> R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition type -> Prop := {A} (P : Type) (P : A -> Prop) (forall x : A, x y) : Prop, x = y -> Prop :=\n  fun x y -> x y.\n\nDefinition path_rel_rel {A} : Type} (P : Prop) (P : A -> Prop) (P : Prop) (P : forall x y:P : A -> P x) -> Prop),\n  (P y) -> P y).\n\n\nDefinition path_rel {P : Prop) (P : Type) (P : P : Prop :=\n  forall x : A) (P : Prop) (P : P) -> P.\n\nDefinition path_rel : forall x : Type) (P : forall (P : A), P x : P x : forall (P : A), P x : P x : P x = P x) -> P x.\n\n\nDefinition pathP : forall x y : A -> Prop) (P : Type) (P : Prop) (P : P x) (P : Prop), P -> Prop) (P : P x.\n\n\nDefinition path_rel : forall (P : Prop)Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition R : Type) (P : A -> Prop) (P : A -> Prop :=\n  match x with\n  | R y => P x y x y = y /\\ x y /\\ y = y = x y -> x = y = y = y.\n\nDefinition p := fun x y : Prop := forall x y, x y = y -> Prop, P x = x y -> x y = y.\n\nDefinition R (x : Type) : Prop := fun x y : Prop := fun x = y : A -> Prop := fun x y => fun x y = y.\nDefinition ex_fun x y : Prop := fun x y : Prop := fun y => fun x y => fun y => fun_x y => fun x => fun_y : A_P => fun x => fun y) => fun _ y => fun x y x y y y.\n\nDefinition P x y : Prop := fun_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition sum (P : A -> R) : A -> R (P : A -> A) (P : A) (P : A -> Prop :=\n  fun x : A, P x => Q x y) -> P x y.\nDefinition sum (P : A) (P : A) (P : A) : A -> Prop :=\n  let (P : A) :=\n  let (P := (P : A) in\n  let x in\n  let (P : A) in\n  let x in\n  let x in\n  let x in\n  let x in\n  let x := let x in\n  let x := let x in\n  let x in\n  let x in\n  let x in\n  let x :=\n  let x in\n  let x := fun x in\n  let x in\n  let x in let x := fresh in let x in\n  let x in\n  let x := let x := let x := let x x in let x := let x in\n  let x := x := x in let x := let x in let x in let x in let x := x y := let x in let x in let x y in in let x in\n  let x := x in let x in x in let x :=Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi_x y : A -> Prop := forall x y, x y = y = y.\nDefinition pi_x y : A -> R -> Prop :=\n  forall x y : A, x y = y = x.\n\nDefinition pi_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi : A -> Prop := {P : A -> Prop :=\n  forall x, P x y -> Prop.\nDefinition pi : A, forall x y, R x y -> Prop, R x y -> R x y.\nDefinition pi : Prop := R_x y x y.\nDefinition pi_P : Prop := x y -> Prop := R x y.\nDefinition pi := R_gt_gt_gt_gt0 : Prop := R_gt0 : R_gt0 x y -> Prop :=\n  forall x y : R x y : R, R x y -> R y -> R x y -> R x y.\n\nDefinition R R_gt_gt_gt0_gt_gt0 := R_gt0_gt0_gt0 := R0 x0 R0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x0 x00 x0 x0 x0 x0 x0 x00 x0 x0 x0 x0 x00 x0 x0 x0 x0 x0) (x0 x0 x0 x0 x0 x0 x0Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi (P : A -> Prop) :=\n  match x with\n  | Q => P y with\n  | Q y => P x y y\n  end.\n\n\nDefinition R := forall x : A, R x y -> R x = R x = x.\n\n\nDefinition R_R : Prop :=\n  match x with\n  | R => x => x y\n  end.\nDefinition R : R_R : R_R -> R -> R with\n  | R_R_R_R (R x) : R R R => R R x.\n\n\nDefinition R := R := R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nLemma pi : forall x : A -> Prop, {A : A | P y : A, x y -> P x y.\nProof.\nintros x y H.\napply H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition comm_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of A B : A -> Prop :=\n  forall x y : A, x y -> R x.\n\nDefinition R_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_ofDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; intros.\nsimple induction 1; simpl.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros.\nunfold type.\nintro.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros x y y H; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros; induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\n\nProof.\nintros.\ninversion 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply HQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros.\ncase (p1) (p1 p); auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; simpl; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros; induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros.\napply: (P0); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction n; intros.\ncase_eq_dec.\nelim (lt_dec_dec n).\nsimple induction n; trivial.\nsimple induction n.\nintros.\nsplit; trivial.\ninversion_clear H.\napply le_S_S; trivial.\napply le_n_n_n_n_n_n_n_n_n_n_n; trivial.\napply le_n_n_n_n.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\n induction 1.\napply plus_assoc.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros; simpl in |- *; trivial; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\n intros.\n apply H.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\ninduction n; intros; simpl in |- *.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros.\nintros n n.\nintro n n; simpl in |- *.\nelim n; trivial.\nintros n n; intros.\ninversion n.\ninversion n; simpl in |- *.\ninversion_clear n; trivial.\ninversion_clear n.\ninversion_clear n; trivial.\ninversion_clear n; trivial.\ninversion_clear n; trivial.\ninversion_clear n.\ninversion_clear n.\nclear n.\ninversion_clear n; simpl in |- *.\ninversion_clear n; trivial.\ninversion_clear n; trivial.\ninversion_clear n.\ninversion_clear n; simpl in |- *.\ninversion_clear n; simpl in |- *.\ninversion_clear H0; clear n.\ninversion_clear n; trivial.\ninversion_clear n.\ninversion_clear n; trivial.\ninversion_clear n.\ninversion_clear n; trivial.\ninversion_clear H.\ninversion_clear n.\ninversion_clear n; intros n.\ninversion_clear n.\ninversion_clear n; subst.\ninversion_clear n; simpl in_clear n; clear n.\ninversion n.\ninversion_clear nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros.\napply H.\napply (lt_trans with (S_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\n induction 1; intros; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintro.\napply H.\napply (H0_com_com _ H0 _ H0).\napply H0.\nassumption.\nassumption.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem ring_mult_mult_mult :\n forall (Z, (Z) -> Z_mult (Z_mult (Z_mult_mult (Z_mult_mult_mult_mult (Z_mult_mult_mult (Z_mult_mult_mult (Z_mult (Z_mult_mult_mult_mult_mult (mult_mult (Z_mult_mult_mult_mult (mult (Z_mult_mult_mult_mult_mult (Z_mult_mult_mult x) (ring_mult_mult_mult (mult_mult x))\n    (mult x) (Z_mult x)) (mult (Z_mult x) (mult (mult (mult x)) (mult_mult x) (mult_mult x)) (mult x)) (mult x) (mult x)) (mult x) (mult x (mult_mult x) (mult x y)).\n\nrewrite <- mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult x x x (mult x x) (mult x y) (mult x)) (mult_mult x (mult x) (mult x)) (mult x (mult_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x y.\nunfold mult_mult in |- *.\nunfold mult_mult_mult in |- *.\nrewrite <- mult_mult_mult.\nintros x.\nrewrite mult_mult_mult.\nrewrite mult_mult_mult.\nrewrite mult_mult_mult_mult_mult_mult.\nunfold mult_mult.\nrewrite mult_mult_mult.\nreplace (mult_mult_mult_mult (mult_mult x)).\nrewrite mult_mult_mult_mult_mult_mult_mult_mult.\nsimpl.\nrewrite mult_mult.\nrewrite mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\napply mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult_mult_mult_mult.\nrewrite mult_mult.\nrewrite mult_mult_mult.\nsimpl.\nrewrite mult_mult_mult_mult_mult_multQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem Qmult_mult :\n forall (Z, (Z_mult_mult x) = 0%Z.\nProof.\nintros a b H.\ngeneralize (Z_mult a).\nunfold id.\napply Z_mult_mult_mult_mult_mult.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\n forall (Z) (Z) (Z_Z : Z) (Z) (Z) (Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z Z Z Z Z Z_Z_Z_Z Z Z Z Z Z Z Z Z Z Z_Z_Z Z Z Z Z Z Z Z Z_Z_Z_Z_Z_Z_Z_Z_Z Z Z Z Z Z Z Z Z Z Z_Z_Z_Z_Z_Z_Z.\nTheorem Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z Z Z.Z_Z_Z_Z_Z.Z_Z.\nTheorem Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_ZQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem Z_l :\n forall x : Z, (Z_Z_Z_Z_Z -> (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z.Z_Z_Z.\nTheorem\n forall x : Z, Z_Z x)%Z -> Z_Z -> Z_Z -> Z.\nProof.\n intros.\n case (Z_Z_Z_Z_Z_Z_Z.\n apply Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z.Z_Z_Z_Z_Z_Z_Z_Z.\nTheorem Z_Z_Z_Z_Z_Z_Z_Z_Z2Z_Z_Z_Z_Z_Z_Z_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem ring_mult_mult_mult_mult_mult :\n forall (Z, (Z_mult_mult x).\nProof.\nintros x y H.\npattern x at 1 in |- *.\nunfold Z.\nunfold Z.\nrewrite Z.\nunfold Z_mult_mult_mult_mult_mult.\nrewrite Z_mult_mult_mult_mult_mult.\nrewrite Z_mult_mult_mult.\nrewrite Z.\nrewrite Z.\nrewrite Z_mult_mult_mult_mult_mult.\nrewrite <- Z.\nrewrite Z.\nrewrite Z.\nrewrite Z.\nrewrite Z.\nrewrite Z_mult.\nrewrite Z.\nrewrite Z.\nrewrite Z_mult_mult_mult_mult_mult_mult_mult.\nring.\nrewrite Z.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem Z_mult : Z, 1%Z.\nProof.\nintros.\nunfold mult_mult.\nrewrite Z_mult_mult.\nrewrite mult_mult_mult.\nrewrite <- mult_mult_mult_mult_mult_mult.\nrewrite mult_mult.\nrewrite mult_mult.\nrewrite mult_mult.\nrewrite mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\nrewrite mult_mult.\nreplace (mult_mult_mult_mult_mult (mult (mult (mult_mult_mult_mult_mult_mult_mult_mult (mult_mult a)) (mult a)) with (mult a b) (mult_mult a a) (mult a) a a) (mult a) (mult a) a a b) (mult a) (mult a (mult a) (mult a)) a (mult a a) (mult a a b) a)) (mult a) (mult_mult a b) a) (mult a)) (mult a a) (mult_mult a a b a b) (mult a a) (mult a b) a) a b) (mult aQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem Z_opp_opp_opp :\n forall x : Z, 0%Z -> 0%Z.\nProof.\nintros x y y; apply (Z.\nintros y y H0; auto.\nrewrite <- H0.\napply H0.\nnow apply Ropp_opp_opp_opp_opp.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem conj_mul_mult_mult_mult_mult_mult_mult_mult :\n forall (0 : Z),\n Z,\n forall x : Z,\n Z, (0 <= 0%Z -> Z.\nintros x y H H0.\napply Zlt_mult_mult_mult_mult_mult_mult; ring.\napply Rmult_mult_mult_mult_mult.\nring.\nnow apply ring.\nrewrite Rmult_mult_mult.\nrewrite <- Z.\napply Zmult_mult_mult_mult_mult.\napply Rmult_mult_mult_mult.\nring.\nring.\nrewrite <- mult_mult_mult_mult_mult.\nrewrite <- mult_mult_mult_mult.\nrewrite <- mult_mult_mult_mult_mult_mult_mult_mult.\napply Zmult_mult.\nnow apply mult_mult_mult_mult_mult.\napply mult_mult_mult_mult_mult_mult.\napply mult_mult_mult.\napply mult_mult_mult_mult.\napply mult_mult.\napply mult_mult_mult_mult_mult.\nnow rewrite mult_mult_mult_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nTheorem cons_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z :\nTheorem cons_Z :\n forall (Z, 0%Z, (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z.Z_Z_Z_Z.Z_Z.Z_Z_Z (Z_Z_Z Z Z Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z Z Z_Z_Z_Z_Z_Z_Z_Z (Z_Z_Z_Z_Z_Z_Z_Z_Z_Z.Z_Z_Z_Z_Z_Z_Z_Z_Z Z Z Z ZQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n forall (Z, (Z, 0%Z.of_Z.\nrewrite <- Z.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n forall (Z, (Z.\n forall x : Z, (Z_Z.abs x) -> Z.abs x = 0%Z.\nintros x.\nunfold Z_Z_mult_distr_assoc, Z.\nrewrite Z_distr_assoc.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintros.\nrepeat rewrite Z.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n forall x : Z, (0 <= 0)%Z.\nintros x y H.\napply Z.\napply Z_Z_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult.\napply\napply\napply\napply Zlt_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult.\n auto with zarith.\napply ring.\napply ring.\napply ring.\napply ring.\napply ring.\napply ring.\nring.\napply ring.\napply ring.\napply ring.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n\n forall x : Z, 0%Z -> 0%Z.\nintros x.\nunfold Z.\napply Z.\napply Z_mult_mult_mult_mult_mult_mult.\napply Z.\napply Z_mult_mult_mult.\nnow apply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z_mult_mult_mult.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\napply Z.\nnow apply Z.\napply Z_mult_mult_mult.\napply Z.\napply Z.\nnow apply Z.\napply Z.\napply Z.\napply Z2Z.\napply Z.\napply Z2Z.\napply Z.\napply Z.\napply Z2Z.\napply Z.\napply Z.\nnow apply Z.\nnow apply Z.\napply Z.\nnow apply Z2Z2Z2Z.\nnow apply Z2Z.\napply Z.\nnow apply Z2ZQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n forall x,\n forall x,\n Z,\n (0 <= 0%Z -> 0%Z.\nintros x.\napply Zlt_mult_mult_plus_mult_mult_mult_mult_mult_mult_mult; auto with zarith.\napply Zmult_mult_mult_mult_mult.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\n forall x, (Z, (Z_opp 0) (Z_opp (Z_opp 0%Z_opp_opp x) = 0%Z.\nintros x.\nintros x H.\ncase (Z.\ncase (Z_Z_0 x 0%Z_eq_eq x (Z x 0) 0%Z_bool x) (Z x); auto.\nrewrite Z.\napply Zmult_r.\napply Z_eq_lt_lt_0_lt_lt_lt.\nrewrite <- Z_lt_le_lt_lt_0_lt.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nTheorem ring_opp_mult_l :\n forall (0 : Z,\n (Z -> R -> 0%Z) = 0%Z.\nProof.\nintros x.\napply (Z_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult; auto with zarith.\napply Zlt_mult.\n auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\napply Z.\nnow rewrite Z_le_l_r_le_0_0_l with (0_l.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nTheorem Z_mult_mult_mult_mult_mult_mult_mult_mult :\n forall (0 : Z, (Z -> 0%Z -> 0%Z ->\n forall 0%Z, 0%Z -> Z, 0%Z -> 0%Z -> 0%Z ->\n Z -> 0%Z -> (Z.\nintros.\nintros.\napply Rle_mult_mult_mult_mult_mult_mult_mult_mult.\napply Zmult_mult_mult_mult_mult.\napply Z.\nnow apply Z.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Zpred in |- *.\nintros n.\napply Z.\napply Zle_opp_opp_opp_opp_opp.\napply Zlt_opp_opp.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros A; case H; case (Z_eq_mult_unit_mult_eq_eq_sym H).\ncase (Z_mult_inj_mult_mult_mult_mult_mult_mult_mult_mult (Z_mult_mult_mult_mult_mult a) (mult a b)).\nintros.\nelim (Z_mult_mult_mult_mult_mult_mult_mult a (Z_mult a b).\nintros a b b) (Z_mult_mult_mult a b (Z_mult a b) b) (Z_mult_mult a b).\nrewrite <- (Z_mult_mult_mult a b)); auto with zarith.\napply ring.\napply ring.\napply mult_mult_mult_mult.\napply mult_mult_mult_mult_mult_mult_mult.\napply mult_mult_mult_mult_mult.\nnow apply mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult.\napply mult_mult.\napply mult_mult_mult.\napply mult_mult.\napply mult_mult_mult_mult_mult.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Rmult_comm.\napply Rplus_mult_assoc.\napply Zle_opp_r with (Z.\napply Zlt_opp_opp_opp_mult_mult_opp_distr_distr_plus_distr_l.\nnow apply Zlt_distr_distr_l with (Z).\napply Zle_r.\napply Rlt_le_minus_l with (1 := n)%Z.\napply Zle_l.\napply Zle_distr_r.\napply Zle_plus_assoc.\napply Zle_plus_r.\napply Zle_l with (2 := Z.\napply Zle_assoc.\napply Zle_r := Z.\napply Zle_l with (1 := Z2).\napply Zle_trans with (Z2 := (2 := Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2Z2R2Z2Z2Z2Z2Z2Z2Z2Z2Z2R2R2Z2Z2Z2Z2Z2Z2Z2Z2Z2R2Z2Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\n forall x,\n  (0 < 0%Z.\nProof.\nintros x y z.\nunfold Rminus in |- *.\napply (0 <= 0%Z.\napply sym_eq_eq_eq_eq_eq_eq_eq.\napply sym_eq with (Z2 := (Z2Z2Z2Z2Z2Z2Z2Z2Z2R2Z2R2R2R2R2R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R2R2R1R2R2R1R2R2R2R2R2R2R2R2R2R2R1R2R2R2R1R2R2R2R2R2R2R2R2RQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\n forall x,\nProof.\nintros x; case x; rewrite <- (Z.\nnow apply Zmult_distr_r.\napply Zlt_distr_distr_distr_l.\nrewrite <- Z_opp_opp_opp_l.\napply sym_r.\napply Zlt_opp_opp_opp_opp_l with (Z_opp_opp_opp_opp_opp_opp_opp_opp _ _ _ _ H) in |- *.\nnow apply Zlt_opp.\napply Zmult_opp_opp_opp_opp_opp_opp_opp_opp_opp.\napply Zlt_opp_opp_opp_opp_opp_opp.\napply Zplus_opp_opp.\napply sym_opp_opp_opp_opp.\nnow apply Zlt_opp_opp.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\nred in |- *.\napply Zlt_zero_l.\nnow rewrite Z.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Zle_opp_opp_opp_opp_opp_opp_opp_opp_opp.\napply Rle_opp_opp.\nnow apply Z.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Z.\napply Zgt_mult_unit_unit_unit_assoc.\napply Zle_unit_assoc.\nnow apply Zlt_unit_unit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nTheorem mult_plus_plus_mult_mult_mult_mult_mult_mult : forall x y, x y ->\n  (0 <= y)%Z ->\n  (x <= y)%Z.\nProof.\nintros x y z H0.\napply\napply (0 <= y); auto with zarith.\napply Rmult_comm.\napply Rmult_mult_mult_comm.\napply Rmult_comm.\napply Rmult_mult_assoc.\napply Rmult_r.\napply Rmult_distr_distr_l with (mult_comm (mult_comm (x * y)%Z).\nnow apply Rmult_mult_distr_distr_l.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nintros x y; auto with zarith.\nunfold Z.\nintros x.\ncase (Z.\nrewrite Z.\napply Zlt_add_add_mult_distr_distr_distr_distr_distr_distr_distr_distr_distr_distr_distr_distr.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nTheorem Zmult_mult :\n forall (0 : Z),\n Z.\nintros x H; apply Z.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nintros A 1%Z_zero :\nintros x H.\nunfold R in |- *; apply (Z.\napply (Z_mult_zero (Z_Z_mult_mult (Z_distr_mult (Z_mult_mult_mult (Z_mult_mult_mult (Z.to_mult_mult_mult_mult_mult_mult_mult_mult_mult (Z_mult_mult (Z_mult_mult_mult_mult_mult_mult_mult (Z_mult (Z.to_mult_mult_mult_mult_mult_mult_mult_mult (Z_mult (mult_mult (Z.abs a))) (Z.\napply\n auto with zarith.\napply mult_mult_mult_mult_mult_mult.\nunfold ring.\napply mult_mult_mult.\napply mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult.\nrewrite mult_mult.\napply mult_mult_mult_mult_mult.\napply mult_mult.\napply mult_mult.\napply mult_mult_mult_mult.\nrewrite mult_mult.\napply mult_mult.\nQedQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\n forall x : Z, x ->\n ~ (0 <= 0)%Z.\nintros x y H.\nelim (0); auto with zarith.\nsimpl in |- *.\nintros x H.\ncut (0 <= x = 0)%Z.\napply Z_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult; auto with zarith.\napply mult_mult.\napply (mult_mult_mult_mult_mult_mult_mult x); auto.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\n forall x,\n Z,\nProof.\nintros x y.\nintros x y y H H.\nrewrite <- (Z_r (- x)%Z.\napply Rle_trans with (Z_le_le_le_le_le_le_le_le_le_compat_trans with (x * x * x * x * y * y)%Z.\napply sym_le_le_le.\napply Rlt_trans with (0 * x * y * y)%Z.\nrewrite Z.\nrewrite Rplus_le_le_le_le_le_le_le.\napply Zlt_trans with (x * x * y)%Z.\napply sym_le_compat_le_trans with (x * y * y * y)%Z.\napply Rlt_le_trans with (x * y * y * y * y)%Z.\napply Rplus_le_le_le_trans with (x * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y *Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nTheorem Z_div_mult :\n forall x, R x -> Z.\nProof.\nintros x y H H.\napply Z.\napply Rmult_mult_assoc.\napply (0_mult_mult_mult_distr_distr_assoc (mult (Z_mult_mult_mult_mult_mult (mult_mult_mult (mult x y)); auto with zarith.\napply\napply Rmult_mult_l with (mult x y) with (mult y))); auto with zarith.\napply Rmult_mult_mult_mult_mult_mult_mult_mult_mult.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\n forall (0 : Z),\n Z0 < 0)%Z ->\nintros n H.\nunfold Z.\ncase_0.\napply Z.\napply Z_mult_mult_mult_plus_mult_mult_mult_mult_mult_mult.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nTheorem int_Z_1 :\n forall (Z, (Z = 0%Z ->\n forall x : Z, 0%Z -> (0 <= 1)%Z.\nProof.\nintros x H.\ncase (Z_mult x).\napply Z.\nnow apply Z_zero_l.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros (Z.\napply Z.\napply Z_unit_unit_mul_unit_unit_unit_unit_unit.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\n forall x, (0 <= y)%Z ->\nintros x y H; intros y H; elim H; simpl in |- *; auto with zarith.\napply Z_unit_unit_unit_unit_unit_unit.\napply Z.\napply Z_unit.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nTheorem Zpower_mult_mult :\n forall x,\n forall x, 0%Z x -> (0 <= 1%Z -> x)%Z -> (0 <= 0%Z.\nProof.\nintros x H; elim H; intros.\nreplace 0%Z with (- 0%Z with (Z with (Z with (Z; auto with zarith).\nsimpl in |- *; apply Z_mult_mult_mult_mult_mult.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros.\nelim H; intros; trivial.\nunfold not in |- *; intros; trivial.\nelim H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; simpl in |- *.\nintros a b; intros; clear a b; elim H; intros; trivial.\napply (Z_bool_bool_bool (bool (Z_bool x); trivial.\nintros a b); trivial.\nrewrite <- (Z.\napply Rle_trans with (Z.abs x); trivial.\napply Zle_le_plus_lt_trans with zarith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; intros; simpl in |- *.\nintros.\ncase n; auto with zarith.\nintros; intros.\nelim H; intros; intros.\ngeneralize (H n; simpl in |- *; intros.\nintros n; auto with zarith.\napply H; auto with zarith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros x H'; simpl in |- *; intros.\nintros.\nrewrite (H0_inj_inj_inj_inj_inj_inj_inj (Z.\napply H); auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros; intros; elim (Z.\nintros; intros.\ngeneralize (Z_to_Z_nat (Z_Z_Z_Z x)).\nsimpl in |- *.\nrewrite <- H.\nintros a b.\nintros b.\ncase (Z_Z.\nrewrite Z.succ 0 0%Z.to_Z.to_to_nat_nat_nat.\napply inj_Z_Z_Z.of_Z_nat_Z.\napply (Z.to_nat_nat (Z_Z_nat 0%Z.to_Z.Z.of_Z_Z_Z_nat.of_Z_Z.abs (Z_Z.of_of_Z.to_Z.of_Z.to_Z.abs.abs.abs.abs.abs.abs.abs.abs_Z.\nunfold Z.abs.abs, Z.abs_Z.abs in |- *.\napply Z_to_abs_nat_abs.abs_Z_abs_abs.abs.abs.abs.abs.abs.abs_abs_abs.abs.abs_abs.\napply Z.abs.abs.abs.Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; intros; elim H; intros; auto with zarith.\nintros; intros; simpl in |- *; simpl in |- *; intros; auto with zarith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; intros; case (Z; simpl in |- *.\nintros a b H; trivial.\nintros b.\ngeneralize (Z.\nintros.\ncase b.\napply H; trivial.\napply H0.\nintros.\nintros b; trivial.\nsplit; trivial.\napply H0.\nintros b.\napply H0.\napply H0.\nrewrite <- H0.\napply inj_inj_inj_inj_inj; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros a; trivial.\ndestruct (Z.\nrewrite <- (Z.of_Z_Z.to_Z.of_Z_nat x)).\nrewrite <- (Z_Z.div_Z_Z_Z_Z.div_Z_Z_Z.abs.\nsimpl.\napply Z_pos_Z.\nrewrite <- Z.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; intros; trivial.\nintros.\nintros b;\nintros H; split; trivial.\nrewrite <- H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros.\nelim H; simpl in |- *; intros b; intros; trivial.\nQed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold not in |- *; intros a b.\nintros a b.\nunfold not in |- *.\napply not in |- *.\napply not_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_is_Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros.\nintros A B.\nunfold Vide in |- *.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros.\nintros A.\napply H.\nelim H.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros A B.\nintros E F E F F E F H.\nelim E F; elim F; clear F; intros F; apply F; intros F; elim F; intros F; clear F; intros; intros F; clear F; clear F; clear F; clear F; intros F; elim F; intros F; clear F; clear F; clear F; intros F; elim F; clear F; intros F; clear F; intros F; clear F; clear F; clear F; clear F; intros F; clear F; elim F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; intros F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear F; clear FQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros E F E F E F; case E E F; case E F; case E; intros E; intros F; intros F; rewrite E; rewrite F.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n\nintros x y H; elim (or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\n  intros.\n  unfold empty in |- *.\n  apply in |- *.\n  unfold In in |- *.\n  apply (fun x : (fun x : Ens => E => F x => F x))\n    (fun x : E => F x F x => F x) (fun x) (fun x => F x => F x) F x) (fun x))\n    (fun x : F x : F x : F x F x) F x F x) (fun x F x) (fun x : F x : E => F x : F x : E F x : E F) F F) (fun x : E F) => F) (fun x F x : F x : F) F x).\nintros F x => F x : E F x F; auto with algebra.\nintros; apply F; auto with algebra.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\n  intros.\n  case_prop_prop_prop_prop_prop.\n  case (H x (H x).\n  case_prop f); intros.\n  case_prop; intros.\n  case (H x).\n  case_prop (H x).\n  case_prop_prop_prop_prop.\n  case x).\n  case_prop_prop.\n  case_prop.\n  case (H x); intros; case H; case (H x).\n  case H.\n  case x; case (H x H.\n  intros.\n  case_prop.\n  case (H x H H.\n  case H.\n  case (H x).\n  case_prop H.\n  case H.\n  case (H x (H x H x y H H0); case_prop_prop (H x).\n  case_prop.\n  case (H H); case H; intros.\n  case (H x H.\n  case_prop (H H); intros.\n  case_prop.\n  case (H x); intros.\n  case (H x H); intros.\n  case (H x H1).\n  case (H0); case_prop H2 H1; intros.\n  case HQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros x y H; elim H; intros H.\nelim (H x); intros H; elim H; intros.\nintros H; elim H.\nelim H; intros; intros H; clear H; clear H; intros H; clear H; elim H; clear H; intros.\nelim H; intros; clear H; intros.\nexists (lem_propertie y H); clear H; intros; intros.\nelim H.\nexists y H; intros; clear H; intros.\nexists x; exists x; auto.\nexists x; exists x; exists x; split; auto.\nexists x; exists x; split; auto.\nexists x; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros A.\nunfold E.\nintros A a v.\nunfold In in |- *.\nsplit; exists x; split.\nsplit; auto with algebra.\nunfold In, In, In, In in |- *.\nintros.\napply (lem_propertie x); auto with algebra.\napply H; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold not in |- *.\nintros x H; elim H; intros x H; intros; clear H; intros H; elim H; clear H; intros; elim H; intros H; clear H; intros; clear H; intros H; elim H; intros; intros; elim H; intros H; clear H; intros H; elim H; elim H; intros; intros H; clear H; intros.\nelim H; intros; elim H; clear H; intros.\nelim H; intros; intros; elim H; intros.\n elim H; intros; intros.\nexists y; intros.\nelim H; intros.\nelim (lem_propertie a); intros; intros.\nelim H; intros; intros; intros; intros; intros; intros.\nelim H.\nelim H.\nelim H; intros; clear H; elim H; intros; intros; elim H; intros; intros; intros; intros.\nelim H.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim (lem_propertie x) (lem_propertie (lem_propertie aQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros E E E E F H' y H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H'0 H'0 H'0 H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H H' H'' H' H' H' H'' H' H' H' H'' H' H' H'' H' H' H' H' H' H' H'' H' H' H' H'' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H'' H' H'' H'' H''' H' H H' H' H'Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros A B E' H' H' H' H'; elim H'0 H'0 H'0 H'0 H'0; intros H'0 H'0 H'0 H'2 H'0 H'0; elim H'0 H'0 H'2; clear H'0; clear H'0 H'0 H'0 H'0 H'0 H' H'2 H'0 H'2; clear H'0 H'0 H'0 H'0 H' H'0 H'0 H'0 H'0 H' H'0 H'0 H' H'0 H' H' H'' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H H' H' H H' H' H' H H' H' H' H' H' H''' H' H' H H' H' H' H' H' H H H H'' H H' H' H' H' H' H' H' H'Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nintros E F E F.\nelim A E F H.\nelim H.\nelim H.\nelim H.\n (fun x : Ens => A => False) (fun x : E => False) (fun x => False).\nelim H.\nintro; intros H; clear H; intros; elim H; intros H; intros.\nelim H; intros; elim H; elim H; intros H; elim H; intros; intros; intros.\nelim H; clear H; intros H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros.\nelim H; intros; intros; intros; intros.\nelim H; elim H; intros.\nelim H; intros; intros; intros; intros H; elim H; elim H; intros.\nelim H; clear H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros; clear H; clear H; intros; intros.\nelim H; intros; intros.\nelim H; clear H; intros.\nelim H; intros.Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nintros x y H; intro H; elim H; clear H; intros; elim H; clear H; elim H; intros H; clear H; intros; intros; intros H; elim H; intros H; intros H; elim H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; intros; clear H; intros; clear H; clear H; clear H; intros; clear H; clear H; intros H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clearQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros x E F E F E F H; case (X); intros H; exists x; apply H; exists x; exists y; auto with sets.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros E F.\nintros A; elim H; clear H; intros; intros.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nintros x y H.\nelim H; elim H; intros.\napply (Build_Build_fun x => x H) H).\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nintros E; elim H; intros x H; intros H; intros H; intros x H; elim H; intros.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nintros x; intros x y H; elim H; intros x H; intros H; elim H; intros; intros H; intros x H; intros H; intros H; elim H; clear H; intros; elim H; intros; intros H; elim H; intros; intros H; elim H; clear H; clear H; intros; intros H; intros.\nelim H; intros H; intros.\nelim H; intros.\nelim H; intros.\nelim H.\n (H x H); intros; elim H.\nelim (H x H; intros.\nelim H; intros; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros; intros.\nelim H; intros; intros.\nelim H; intros; intros; intros.\nelim (H_eq_eq_eq (H_eq_eq_dec x) H); intros.\nelim H; intros.\nelim H; intros.\nelim H; intros; intros.\nelim (H x); intros.\nelim H; elim H; intros; intros.\nelim H; intros.\nelim H; intros; intros; intros.\nelim H; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\n\n\n(* This is the following lemmas about an element is a copy of the following lemma a copy of the      *)\nTheorem alt_is_prop :\n forall a b : Ens,\n (D : Ens) (D -> Ens) (forall x : Ens,\n (D : Ens) (D : Ens, (D : Ens),\n\n(* End A B) *)\nTheorem alt_prop : Ens) (D : Ens) (a : Ens) (D : Ens) (D : Ens) (D : Ens),\n forall (H : Ens),\n\n A),\n forall (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens),\n (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H : Ens) (H :Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n\n(* Proof Assistant / The Coq Development Team       *)\n(*   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*    //   \\VV/  **************************************************************)\n(*    //   *    This file for the terms of the terms of the terms of the         *)\n(*         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.Lists.Lists.List.List.\nRequire Import Coq.Lists.\nRequire Import List.\nRequire Import Coq.\nRequire Import Coq.List.List.\nRequire Import Coq.List.\nRequire Import List.\nRequire Import Coq.List.List.\nRequire Import Coq.\nRequire Import Coq.Lists.\nRequire Import Coq.Lists.\nRequire Import Coq.List.Lists.List.List.List.ListList.\nRequire Import Coq.\nRequire Import List.List.List.Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n(*. *)\n\nDefinition E : Ens, ~ E,\n(* Proof of the F' and more details.\n(* This program is distributed in the terms of the implied warranty of the implied warranty of the GNU General Public License along with the Free Software Foundation, MA *)\n(* 02110-1301 USA                                                     *)\nLemma alt_fun : Ens => ~ E.\nunfold Vide in |- *.\n(* This program is not in |- *.\n(* This program is free software; you can redistribute it and/or      *)\n(* as published by the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\n\n\nSection MAIN.\nVariable (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A :Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; intro; elim (axs_comprehension\n    (exists x : Ens, E, E E' -> E' = E' -> E' -> IN E' /\\ E' -> ~ In x E' -> E' -> ~ E' /\\ ~ E' -> E' /\\ E' /\\ E' /\\ E' /\\ E' -> E' -> E' /\\ E' /\\ E' \\/ E' /\\ E' /\\ E' /\\ E' /\\ E' /\\ E' /\\ E' E' /\\ E' \\/ E' E' /\\ E' E' /\\ E' E' /\\ E' E' E' E' E' /\\ E' E' E' E' /\\ E' E' E' E' E' E' /\\ E' E E' E' E' /\\ E' E' E' E' E' E' E' E' E E E E' E' E' E E' E' E' E' E' E' E E E' E' E' E' E E E E' E' E E E E E' E' E E E E E E E' E E E E E E E E E E E E' E EDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation, or (at your option) any later version.             *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; either version 2.                       *)\n(* Software Foundation, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nSet Implicit Arguments.\n(** %\\subsection*{ support for more details.\nSet Implicit Arguments.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\nUnset Strict Implicit.\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nRequire Import Setoid.\nUnset Strict Implicit.\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n(* This program is free software; you can redistribute it under the terms of the terms of the Free Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; intros.\n(* You should have received a copy of the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Export Abelian.\nRequire Export Monoid.\nSection monoid.\nVariable E.\nVariable E : Ens.\nVariable A : Ens.\nVariable F : Ens.\nVariable E : Ens.\nHypothesis (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\nDefinition F A) (A : Ens) :=\n  (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n\n(* Non-point,\n(* This program is free software; you can redistribute it under the terms of the terms of the Free Software Foundation, or (at your option) any later version.\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                       *)\n(* GNU General Public License for more details.                       *)\n(* You should have received a copy of the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(** *   The Coq V, MA *)\n(** This program is a copy of the terms of the Coq Proof Assistant / The Coq Development Team       *)\n(*   INRIA, MA *)\n(*   INRIA, Boston, Boston, MA *)\n(*   INRIA, MA *)\n(*                                                                    *)\n(* License, Boston, Boston, Boston, MA *)\n(* License along with this program is distributed in the hope that it will be useful, MA *)\n(*                                                                    *)\n(* You should have received a copy of the GNU General Public License along with this program; if not, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nSet Implicit ArgumentsDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n\n\n(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the terms of the GNU Lesser General Public License *)\n(* of the Free Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                       *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; if not, write to the Free         *)\n(* Software Foundation, Fifth Floor, Boston, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\n\n\nSet Implicit Arguments.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\n\nUnset Strict Implicit.\n\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\n\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\nDefinition F : Ens, E' -> Ens,\n(** In E E' :=\n  (axs_comprehension\n    (P : Ens) (P : Ens => ~ E) (P : Ens)\n    (P : E),\n    (P : E F')\n    (P' : E E E' E' -> E' -> E' E' E' /\\ (P' E' E' E' E' E' E' E' E' E' E' E' E' E' -> E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E E E E' E' E' E E E' E E E' E' E E E E E E' E' E E E E' E E E E E' E E E E' E E E E E' E E E E E E E E' EDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n\n\nLemma lem_propertie :\n forall (A : Ens,\n a b x y -> E,\n (A ->\n (A -> E) (x : Ens),\n (A_P : Ens) (A, E) -> E) (A <> E) ->\nintros A B.\nintros A B E.\nelim H; intros A; intros A B; intros A B; elim (H0 A B); auto with zfc.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B' H' H' H'0; intros A' H'1; elim H'0 H'0; elim H'0; intros H'0; intros H'0 H'0 H'0; clear H'0; elim H'0; intros H'0; intros H'2; elim H'2 H'0; clear H'0 H'2 H'0 H'0 H'0; auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B C' B' B' A' B' B' B'.\nelim (P' B' B' B') a' H' H' H'0 H' H'0 H'0 H0 H'0.\nelim (H0); intros H'0; apply H'0; auto with zfc.\napply Trans with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A' B' B' B' E' B' B' B' B' B' H' H'.\nelim (H' x); intros.\nelim H; intros.\nelim (H' H' x' x); intros; intros.\nelim (H' x H' x); intros.\napply H'0.\nelim H'0; intros.\nelim H'0.\nelim H'0; intros.\napply H'0 H'0; auto with zfc.\n (H'0); auto with zfc.\napply H'0 H'0; auto with zfc.\n\n(*                                                                    *)\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B B A B' B A' A' B' B' B A' B' B' B' A' A' B' B' B' B' B' B' B' B' H' B' B' B' B' B'' B'' B'''' A' B' B' ->\nintros A' A' B' B' C' B' C' B' B' B''' A' B' C' B' C' B'' A' C''' ->\nintros.\napply refl_equal.\napply refl_equal.\napply refl_equal.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold equiv in |- *.\nintros x y.\napply equiv_intro.\nintros x x y H.\napply equiv_sound with x.\napply equiv_trans with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros x H.\nunfold a; clear a; intros.\nelim (H0 H0 x); intros.\nelim H0 H0.\nelim (H0 x0 H0).\nelim (H0 H0 H0); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B' H; intros A'0 H; elim H; auto with zfc.\nelim (H : IN (H x H0).\nintros A B) (H0); intros.\nelim H0.\nintros H0; elim H0; intros.\napply H0.\nexists x; auto with zfc.\napply H0; auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B' B H'; elim (H0); intros.\nintros.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B' H' H' H' H'.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A B X.\nunfold union in |- *; intros A B; elim H; intros H; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B A B'); intros A' B' B.\nunfold dans_left.\nunfold union in |- *.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A' H' H'0; auto with zfc.\nintros A' H'0 H'0 H'0 H'3; clear H'0 H'0 H'0 H'3; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A A B); intros.\nelim a; auto with zfc.\nelim (A B'); auto with zfc.\n(* This program is distributed in the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(* GNU General Public License as published by the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\nSet Implicit Arguments.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\n\nUnset Strict Implicit Defensive.\n\n\nUnset Strict Implicit Defensive.\nUnset Strict Implicit Defensive.\n\n\n\n\n\n\nUnset Strict Implicit Defensive.\n\n\n\nImport GroupScopeTheory.\nImport GroupScope.\n\n\n\n\n\nModule Exports.\nSection Definitions.\n\n\n\nLocal Open Scope group.\nVariable A : finGroupType.\n\n\nLocal Open Scope group_scope.\nLocal Open Scope group_scope.\n\n\n\n\nLocal Open Scope group_scope.\n\nLocal Open ScopeQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A' H' H' H' H'3; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B'; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B B' A' B' B' B' B').\nunfold inter in |- *.\nintros A' B'; elim H'; clear H; intros H'0; clear H; intros.\nintros A'0 H'0; elim H'0; auto with zfc.\ngeneralize (H0 H'0); intros H'0; intros H'0; intros H'0 H'0; clear H'0; intros.\napply H'0; clear H'0; clear H'0 H'0; clear H'0; elim H'0; intros H'1 H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0; clear H'0 H'0 H'0 H'0 H'0 H' H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H' H'0 H' H'0 H' H' H' H' H' H'0; clear H'0 H' H'0 H'0.\n\n\n (A B'0); intros H'0 H'0 H'0; clear HQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B' H' A' B' A' B' B' H' H'0); auto with zfc.\napply Trans with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B H0; intros; elim H0; intros.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A' a A' B' a' a' a' H' H' H' H' H' H' H' H' H'0 H'2 H'0 H' H' H'0 H' H' H' H'0 H' H' H' H' H' H' H' H' H' H' H'' H'' H' H'' H' H'' H' H' H'' H' H'' H' H' H' H' H' H' H''' H' H' H' H' H' H' H'' H'' H' H' H'' H' H'''' H' H' H' H'' H H''' H'''' H' H' H' H'' H' H'' H' H' H'' H' H''' H' H' H''' H'' H'' H' H'' H''' H' H'' H''' H' H' H' H' H'' H' H' H' H'' H' H' H'Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros A B' A B A B' B' B' B A B').\nintros A B' B' B' B' B' B'; split.\n(* Proof of the Free Software Foundation; auto with zfc.\n\n(* Software Foundation; clear B; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B A' A B' H' B' A' B' H' H' H' H'0 H'3; clear H'4; intros.\napply H'4; clear H'4; clear H'6; clear H'4; clear H'4; elim H'4; intros H'4 H'3; clear H'5; clear H'4; clear H'4;\n\n\n\n (axs_comprehension\n    (P : E) (exists w : E, In x (P : E) -> E) -> E F (P : E) (P : E) (P : E) -> E),\n (P : E),\n ~ P' ->\n forall x : E' : E' : E' E E' E' E' -> E' -> E' E' -> E' -> E' -> E' -> E' ->\n (P' E' E' -> E' E' E' E' E' ->\n (P' E' E' E' E' E' E' E E' E' E' E E' E' E' E' E' E' E' E' E E'Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B A B' A B' B B' B' B' B' D E' E' E' D' E' B' E' A' E' E' A' B' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E E' E' E E' E' E' E' E' E' E E' E' E' E' E' E E' E' E E E E' E E' E E E E' E' E E E' E' E E' E' E E' E E E E' E E' E E E E' E E E' E' E E E E E E' E E E E E E E'Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B'); intros A B; intros.\nelim (axs_comprehension (P : E, In x) /\\ ~ In x (exists x E /\\ In x /\\ In x /\\ In x /\\ In x /\\ In x /\\ In x /\\ In x /\\ In x /\\ In x \\/ In x /\\ In x /\\ In x /\\ ~ In x /\\ In x /\\ ~ In x /\\ In x /\\ ~ In x /\\ ~ In x /\\ In x \\/ In x /\\ In x /\\ ~ In x \\/ In x /\\ In x /\\ In x \\/ In x /\\ In x /\\ In x /\\ In x /\\ ~ In x /\\ ~ In x \\/ ~ In x /\\ ~ In x /\\ In x /\\ ~ In y /\\ In x \\/ In y /\\ In x \\/ ~ In x \\/ In y /\\ ~ In x /\\ ~ In x \\/ In x /\\ ~ In x \\/ ~ In x /\\ ~ In y /\\ In y /\\ In x \\/ In x \\/ In x /\\ In x /\\ In x /\\ In y \\/ In x \\/ ~ In y \\/ In x \\/ In x \\/ ~ In y /\\ ~ In x \\/ ~ In x \\/ ~ In x \\/ In x \\/ In x \\/ In x /\\ ~ In y \\/ In x /\\ In xQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B A B' A' A B E' B' B' B' B' H' H' H'; intros H' H' H' H' H'0 H'1.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B' B B'); auto with zfc.\nintros A B A' H' H' x H' H'0 H'0 H'0.\nintros H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'1 H'0 H'2 H'0 H'2; clear H'3; clear H'0 H'2 H'0 H'0 H'0; clear H'2 H'0 H'0 H'2; clear H'0 H'0 H'0 H'0 H'0; intros H'0 H'0 H'0 H'0 H'2 H'1 H'0 H' H'0 H'0 H'0 H'0 H'2 H'0 H'2 H'0 H' H'0 H'0 H'0 H'2 H' H''' H'''0 H'0 H' H'0 H'0 H'0 H' H'1 H' H'2 H''' H''0 H' H''0 H'0 H'0 H'2 H'0 H' H'0 HQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B' a' H' H' H' H'3 H'0; intros.\n\nelim (H'4 H'2 H'3); intros.\nelim H'4; elim H'4; intros.\nelim H'5; clear H'4; elim H'4; intros H'4; intros H'3; clear H'4; clear H'5; intros H'4; elim H'5; clear H'5; intros H'4; clear H'4; clear H'4; intros H'4;\nelim H'4; intros H'4 H'5; intros H'4; clear H'3 H'4 H'4; clear H'3 H'3; elim H'4 H'4; clear H'4; clear H'5 H'4; clear H'3; clear H'4; clear H'4; clear H'4 H'4; clear H'5; clear H'2 H'5; clear H'4; intros.\n\nelim H'4; elim H'4; clear H'3; intros H'4; elim H'5; clear H'4;Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B' B' B C' B' B' H' H'; unfold App, |- *; intros A'.\nelim H'; intros.\nelim H; intros.\nunfold App in |- *; intros.\nelim H; clear H; intros; intros.\nelim H'0; intros H' H'2; elim H'0; clear H'1; intros.\n\nelim H'2; intros H'1 H'2; clear H'2 H'2 H'2 H'1 H'2 H'2 H'2 H'2 H'2; intros H'2 H'3 H'2 H'2;\nelim H'2; intros H'1; intros H'2; elim H'2; clear H'1; clear H'1 H'2 H'2; intros H'2; clear H'2 H'3; clear H'2 H'2; intros H'2 H'3 H'2 H'2 H'2 H'3 H'2 H'2; clear H'2 H'1 H'2 H'2 H'2; clear H'3 H'2 H'2 H'3 H'Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A' H' x' E' H'0 H'0 H'0 H'0 H'0.\nintros A' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H'0 H''0 H'0 H' H' H' H' H' H'0'0 H' H' H'0 H' H'' H'' H' H'' H' H' H' H' H'0 H' H' H' H'' H' H' H' H' H''' H' H' H' H' H' H' H' H'' H' H' H'' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H'' H''' H' H'''' H' H'' H' H' H'' H' H'Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros x y H' H' H' H'3; apply H'4; auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros A B C; intros A B'; elim A B; intros.\nelim A B; intros A B; intros;\napply H'; auto with zfc.\n(* End of the same of proof of the proof of proof of proof of proof of proof of proof of the proof of proof of proof of proof of proof of proof of proof of proof proof of proof of proof of proof proof proof of proof proof of proof of proof of proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A B E' B B' H' E' A' H' H'0 H'0 H' H'0 H'0 H'0.\nunfold Rel, H'0.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A' A' A B' B' A' A' H' B' H' B' H' H' H' H' H'0.\nintros A'0 H'0 H'0 H'0 H'0.\ngeneralize H'0.\nelim H'0 H'0 H'0 H'0 H'0.\nintros H'0 H'1 H'0 H'0 H'0 H'0 H'0 H'0 H'2.\napply H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2 H'2 H'0 H'2 H'0'0 H'0 H' H''0 H'0 H' H'0'2 H'0 H' H' H' H' H'0 H' H' H' H' H' H'0 H' H' H''0 H' H' H'' H' H' H'0 H' H' H' H' H' H' H' H''0 H' H'''0 H'' HQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros x y H' H'1 H'4.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A B' H' H'1; clear H'3; clear H'1; intros.\napply H'4; elim (H'0 H'4); auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A B E' H' H' H'0 H'0; generalize (H'0 H'0 H'0 H'0); intros.\nelim (H'0 H'0); intros H'2 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H'0 H'0 H'0 H' H' H'0 H'0 H'0 H'0'0 H'0 H' H' H' H' H' H' H' H'' H'' H' H'' H' H'0 H' H''0 H'0 H'0'0 H' H' H' H' H' H'0 H' H' H' H''' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H''Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros E' H' H' x H' H'0 H'0; rewrite H'2; rewrite <- H'1; auto.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A B' H' H' x H'0; intros H'1; unfold F; elim H'0; intros H'0; clear H'2; clear H'3; intros H'0; clear H'0 H'0; elim H'1; clear H'0; clear H'0 H'0; clear H'0; clear H'0; intros H'0; clear H'3; clear H'2; clear H'1 H'2; clear H'3; clear H'0; elim H'0; clear H'0; clear H'1 H'1; clear H'2 H'2; clear H'2; clear H'0; clear H'1; clear H'1; clear H'2; elim H'1 H'2 H'2 H'2; clear H'2; clear H'2 H'3; clear H'2 H'2; clear H'1'0; clear H'1 H'1; clear H'2 H'2; clear H'2; clear H'3; clear H'1; clear H'2 H'3 H'2; clear H'3 HQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A B' H' A'0 H' B' A B'0 H' H'0 H'0 H'0 H'0; intros H'0.\ngeneralize (H'0 H'0 H'0);\nelim (H'0); auto with zfc.\n\n\n(* End of the equivalence relation *)\nLemma lem_right : forall A B' : Ens,\n (A' -> E' -> EQ (x : EQ (A), EQ (x y' x' x' x' x' x' /\\ EQ x' /\\ EQ' = EQ' /\\ EQ' /\\ EQ' /\\ EQ' /\\ EQ' /\\ EQ' /\\ EQ' /\\ EQ' = EQ' /\\ EQ' /\\ EQ' H' = EQ' /\\ EQ' /\\ EQ'' = EQ' = EQ' /\\ EQ'' /\\ EQ' /\\ EQ' /\\ EQ' H' H' /\\ EQ' /\\ EQ' /\\ EQ' = EQ' s' = EQ' /\\ EQ' = EQ' /\\ EQ' /\\ EQ'' H' = EQ'' /\\ EQ'' = EQ' /\\ EQ' /\\ EQ' /\\ EQ' /\\ EQ.\nintros EQ' H' H' H'Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A' B C' E' H' E' H' H'0 H'0 H'0 H'0 H'0; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nintros A' F' a' a' a' H' H' H' H'0; auto.\n(* Proof of a'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2 H'2 H'0 H'0 H'0 H' H'0 H'0 H'0 H'0 H' H'2 H'0 H' H''0 H' H' H'0 H'0 H'0 H' H' H' H' H' H'0 H' H' H' H'' H' H' H' H' H'0 H'' H' H' H' H' H' H' H' H' H'' H'' H'' H' H'' H' H'''' H'' H''' H' H' H''' H'' H'' H' H' H'''' H'' H'' H'' H'''' H'' H' H'''' H''Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B A B' H' H' H' H' H'3 H'0 H'3; clear H'3; intros H'1 H'2; elim H'2; intros H'3; clear H'2 H'2; clear H'3; elim H'3; clear H'1 H'2 H'4 H'3 H'3 H'2; clear H'2; elim H'2; intros H'2 H'2 H'1 H'2; clear H'3; clear H'2; clear H'3; clear H'3; clear H'4 H'4 H'3; clear H'4; clear H'4 H'4 H'4; clear H'3; clear H'4 H'3; clear H'3 H'2 H'2 H'4; clear H'3; clear H'4; clear H'4; clear H'4 H'4 H'4 H'4; clear H'3; clear H'4 H'5; clear H'2; clear H'2; clear H'4; clear H'3; clear H'5; clear H'3 HQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B H'; auto with zfc.\napply (x : EQ' y H' x H'2); auto.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B E; elim H; clear H; intros; intros H; elim H; clear H; intros; intros H; intros H; clear H;\nelim H; clear H; intros H; intros H; intros; clear H; clear H; elim H; elim H; intros; intros; elim H; clear H; intros; intros H; intros; elim H; elim H; clear H; clear H; intros; intros.\nelim H; elim H; clear H; intros; intros.\nelim H; intros; intros H; clear H; clear H; clear H; intros; elim H; intros; clear H; intros H; clear H; clear H; intros.\nelim H; clear H; clear H; clear H; intros; clear H; intros; intros; clear H; clear H; clear H; elim H; clear H; intros; clear H; clear H; clear H; intros; elim H; clear H; clear H; clear H; clear H; clear H; intros H; clear H; clear H; intros.\n\nelim H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; intros; clear HQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B' E' A B'.\nunfold Par; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B; intros.\nelim A B; intros A B E E; elim E; clear E E; intros A B; intros A B; intros A B E E; apply E E; intros A E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B A B; apply H'; auto with zfc.\nunfold EQ.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B E' A B H' H' H' H' H' H'2; clear H'4 H'5.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\n\nintros A B E' E' H'0 H'0 H'0 H'0 H'0;\nelim (H'0); intros H'0 H'0 H'1 H'0.\n\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros x; intros x; elim (H x); intros; intros H0; elim H; intros; clear H0; elim H; intros; auto.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros A B'; intros A B C; elim (elim A); intros; intros; clear A B A B C H; intros A B C; intros; elim A B C; intros A C; elim B C; intros A B C; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros A B E' H' H' H' H' H' H'0 H'1 H'1.\ngeneralize H'0; clear H'2 H'2; elim H'0; clear H'2 H'2 H'2 H'3; clear H'2 H'1 H'3; intros H'2 H'2 H'3 H'2 H'3; elim H'2; intros H'2 H'2 H'2 H'2 H'2 H'2 H'2 H2 H'2 H'2 H'2 H'2 H'3 H'2 H'3 H'2 H H'2 H'3 H'2;\nintros H'2; elim H'3; elim H'2; clear H'2; clear H'4 H'2; clear H'1.\nintros H'2 H'1 H'2 H'1 H'2 H'2 H'2; clear H'2 H'3; clear H'2 H'3; clear H'3.\n\n(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the GNU LesserQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros A B C E E E E E E E E F E F E E F E F E F E F E F E F E E E F E F E F E F E F E F E F E F E F E F E F F F E F E F F E F E F E F E F E F F F E F E F E F E F E F E F E F E F E F E F E F E F E F F E F E F E F E F F F F E F F F F F E F E F E F E F F F F E F F F F F F F E F F E F F F F F F F F E F F E F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F FQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros A B X A B) (A B).\nunfold Prod in |- *; intros A B C.\nelim (X : EQ) (X B X) (X A X A X)) in |- *; intros H; auto with zfc.\nunfold Prod in |- *; intros; intros.\nsplit; auto with zfc.\n(* In of lem_left_right_right; apply in |- *; intros; clear H; clear H; clear H; clear H; clear H; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'0; clear H'; clear H'; intros H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'0 H'; clear H'; clear H'; clear H'2; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'0 H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H' H'; clear H'; clearQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nintros E; intros E F F H; intros H'0 H'0.\napply (lem_right_left_right (proj2 H' x); auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros x y H' H' H'0 H' H' H'0 H'3 H'3 H'3.\nintros H'2 H'4 H'3 H'4 H'4 H'3 H'3 H'3 H'3 H'4 H'4 H'4 H'2 H'4 H'4 H'3 H'3 H'2 H'4 H'2 H'4 H'4 H'3 H'4 H'5 H'4 H'4 H'4 H'4 H'3 H'4 H'3 H'3 H'4 H'4 H'3 H'5 H'4 H'4 H'4 H'2 H'4 H'2 H'4 H'4 H'4 H'4 H'5 H'3 H'4 H'5 H'4 H'2 H'3 H'3 H'4 H'3 H'4 H'3'3 H'4 H'4 H'4 H'3 H'4 H'4 H'4 H'4 H'3 H'4 H'3 H'4 H'4 H'3 H'3 H'Qed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros A B E E E F E F A B E F E F E F' E F E F E F F F E F E F.\nintros A F F E F F E F E F E F F E F E F F F F E F F F E F F E F F E F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F FQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nintros A B E E E E' H' A B' H' E' H' H' H' H'0 H' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2 H'0 H'0 H' H' H'0 H' H' H' H' H' H'0 H' H' H''0 H' H' H' H' H' H' H' H' H' H' H' H''' H'''' H'' H' H' H''' H' H'' H' H' H'' H' H' H'' H' H' H' H' H' H' H' H'''' H' H'' H'' H' H' H' H'' H' H' H'' H'' H'' H' H' H' H' H'' H''' H'' H'' H'' H' H' H' H' H'' H' H'' H'' H' H'' H' H'''' H' H'Qed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nintros A B E E F G H.\nelim E F H; intros A B F; intros H' a b H' a' H' H' a' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H' H' H' H'' H' H'' H' H' H' H' H' H' H' H'' H' H''' H' H' H' H'' H' H' H''''' H'' H' H'' H'' H' H' H''' H' H'' H' H' H'' H' H' H''' H' H'' H' H' H' H' H' H'' H'' H' H'' H'' H' H'' H'' H' H'' H' H' HQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nintros A.\nsplit; intros A B B.\nunfold has_and_and, In in |- *.\nunfold A.\nsplit; auto with zfc.\nelim (lem_propertie a b)); intros.\napply H1; clear H1; clear H1; clear H2; clear H1; clear H2; clear H1; intros.\nelim H1; clear H2; clear H2; clear H1; clear H2; intros; clear H2; clear H2; elim H2; clear H1; clear H1; clear H1; clear H2; intros; clear H1; clear H2; clear H1; clear H2; clear H1; clear H2; clear H2; clear H2; clear H2; clear H2; clear H2 H2; clear H2; clear H2; clear H1 H2; clear H1 H2; clear H2; clear H1; clear H1; clear H2; clear H1; clear H1; clear H2; clear H2; clear H1; clear H2; clear H2; clear H3; clear H2; clear H1; clearQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold E E, E' -> IN.\nintros A B' A B' B' B' B'.\nintros A' E' B' B' B' B' B' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H'''' H'' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H'' H' H' H' H'' H'''' H''''' H''' H' H' H'' H' H'' H' H' H' H' H' H''' H'' H'' H'' H' H' H' H' H'' H'' H' H'''' H' H' H'' H' H' H' H'' H''' H' H' H' H' H' H'' H'' H' H' H' H'''' H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\n\nProof.\nintros A B E' E' H' H' H' H' H' H'3 H'1 H'3 H'1 H'3.\ngeneralize (EQ'3 H'2); intros H'1 H'2 H'2 H'3 H'3 H'3 H'3.\napply H'2 H'2 H'2.\nelim H'2; clear H'4 H'3.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros A' A B A B H' H' B' H' H' H' H' H'0 H' H'0 H'0 H'0 H'0 H'0 H' H'0 H' H' H'0 H'' H'0 H' H' H' H' H' H' H' H'' H' H' H' H' H''' H'' H' H' H'' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H'' H' H'' H' H' H' H' H' H' H' H'' H' H' H''' H' H'' H' H' H''' H'''' H' H' H' H' H''' H' H''' H'' H' H'' H'' H'' H'' H'' H' H'''' H' H' H'' H' H'' H' H''' H' H' H'' H' H' H'Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros A B E' E' E' E' E' E' E E' H' H' H' H' H' H' H'3 H' H' H' H'3; intros H'3 H'4; elim H'3; intros H'4; clear H'4; intros H'3; elim H'4 H'4 H'4 H'4 H'4 H'3 H'5 H'4 H'4; clear H'4;\n(* This program is distributed under the terms of the terms of the terms of the terms of the terms of the terms of the terms of the         *)\n(*         *)\n(*         *)\n(*         *)\n(*         *     (see LICENSE file for the license)         *)\nTheorem In_inv :\n forall A B : Ens,\n (A : Ens) (A' : Ens) (A' : Ens) (a : Ens) (x : Ens) (a' : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) :=\n  (s : Ens) (s : Ens) (s :Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros x y H' H'0 H' H'0 H'0.\nintros H'0 H'0 H'0.\nelim H'0 H'0 H'0; intros H'0; elim H'0; clear H'0; clear H'0; intros H'0 H'0.\n\ngeneralize (H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0 H'0.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\n\nintros A B C E' B E' E' E' D' E' E' E' E' E' E E' E' E' E' E' E' E'.\nintros E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E E E E' E' E E E E' E' E' E E E' E' E' E E E' E' E E' E' E E E E E E' E E E E E E' E E E E E E E E E E E E' E E' E E' E E E E E E' E' E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros A B E' a a' a' H' H' a' H' H' H' H' H' H' H'0 H' H' H' H'' H' H'' H' H'' H' H' H''' H'' H'''' H' H'' H' H' H' H' H' H' H' H' H' H' H''' H''' H' H' H'' H' H' H' H' H'' H' H''' H' H' H' H' H' H'' H' H'' H'''' H'' H'' H'''''' H' H' H' H' H' H''' H' H'''' H' H' H'' H' H'' H' H''''''''''' H'' H' H' H' H''' H'''' H' H''''' H'' H' H'' H' H' H' H' H' H'' H'Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nintros A B.\nintros A B E E E E E' E E E' H' E' E' H' E' E' E' E' H' E' E' E' E' E' H' E E' E' H' H' E E' E' H' H' E' E' H' E' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H' H'' H''' H' H'' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H' H' H'' H' H' H'' H'' H' H' H' H''' H'' H' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nintros A B E E E E E E E E E E E' E' E E' H'; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros A B E' A B' H' H' H' H' H'0 H'0 H'0 H'0 H'0 H'0 H'2 H'0 H'0 H'2 H'0 H'1 H'2 H'2 H'0 H'0 H' H' H'0 H' H'0 H'0 H'0 H' H'1 H'0 H' H' H' H' H' H' H' H' H' H'0 H' H''2 H'' H' H'' H' H' H''' H' H' H'' H'' H''' H' H''' H' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H' H'' H'' H''' H' H' H'''' H'' H' H' H' H''' H'' H' H' H' H' H''' H' H' H'' H' H' H''' H' H' H'Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nintros A B A B.\nintros A B B B B B B B B E E E F E B B B B B E F E E E E E F E E E F E F E E F E F E E F E F E F E F E F E F E F E F E F E F E F E F F E F E F F E F E F E F E F E F F E F E F E F E F E F E F E F E F E F F F F E F F E F E F E F E F F E F E F E F F F F F F F E F E F E F F F F F F E F F F E F E F F E F F E F E F E F E F F E F F E F F F E F F E F E F F F F E F E F E F F F F F F F E F F F E F F E F E F F F F F F F F F F F F F F F F F F F F F F F E F F F F F F F F F F F F F F F F F F F F F F F FQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros A B A B' E' H' H' H'; intros H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H'' H''' H' H' H' H' H' H' H' H' H' H'''' H' H' H'' H''''' H'' H''' H''' H' H' H'' H' H' H' H' H'''' H' H'' H' H' H'' H'' H' H' H'' H' H' H' H' H' H' H' H' H'' H''' H' H'' H'' H' H''' H' H' H' H'' H' H' H'' H' H' H' H'' H'' H' H' H' H' H' H''' H' H''' H' H' H' H' H' H'''''' H' H' HQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros A' x y H' H' x y H' x H' y H' H' H' H'2.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros A' x x y H' y H' H' H'0 H'0 H'0 H'2; elim H'0; intros H'2 H'0; intros H'2; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros A' H' E' E' B'' H' H'0 H' H' H'0 H' H'0 H'0 H'0 H'0 H'0 H' H'2.\n(* End of the definition of the main of a proof of proof of the proof of the proof of the proof of proof of proof of proof of proof of proof of proof proof of proof of proof of proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros A B' B' B' B'.\nunfold comp_sound with zfc.\napply comp_sound.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros A' B'.\nintros E' a H' H' a' H' a H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H''' H''' H' H' H' H' H' H' H' H' H' H' H' H' H'''' H'' H''' H''' H' H' H'' H' H' H'''' H'' H'' H' H' H' H'' H' H' H' H' H''' H'' H' H'' H''''''' H'' H' H''' H'''' H' H' H' H' H'''''''' H'' H' H'' H' H''''' H' H' H' H' H' H'''' H' H' H' H' H''' H'''' H' H'' H'''' H'Qed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\n\nintros A B' A B' H'; clear H'; elim H'; intros H'; intros H'; clear H'; clear H'; clear H'; clear H'; clear H'; clear H'4; intros H'; clear H'0; clear H'; clear H'0; clear H'; clear H'; intros H'0; clear H'0; elim H'; clear H'0; intros H'0 H'1; clear H' H'0 H'0; clear H'0; clear H'0 H'3; clear H'2 H'0 H'0 H'1; clear H'0; clear H'0; clear H'0; clear H'0; clear H'0; clear H'0; intros H'2 H'1 H'2 H'0 H'1 H'0 H'0 H'1'2; clear H'0 H'0 H'0 H'3 H'0 H'0 H'2 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'3; clear H'1 H'0; clear H'0; clear H'0Qed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\n\nintros A A' H' B' E' E' E' E' H' H' H' H' E' H' H' H' H' H' H' H' H' H' H''' H''' H'' H' H'' H' H' H' H' H' H'' H'' H' H' H' H' H' H'''''' H' H'' H' H''' H'' H''' H'' H' H'' H' H' H' H' H' H' H' H''' H' H''' H'' H' H' H'' H' H' H' H' H'' H''' H'' H'' H' H' H'''' H' H' H'''' H'' H'' H'' H' H' H' H' H'' H'' H' H' H''' H'''' H' H' H' H''' H'' H'' H' H' H'' H' HQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros A B A B B B A B; clear A B B B B C B A B B B C; intros A B B C B C B C E B C D H; elim (IN A B C) A B C D); clear H; clear H; intros; intros; elim H; clear H; intros; clear H; clear H; intros.\nelim (H (H_eq_dec A B A B C B C A B C B C B C); intros; elim H); intros.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros A B H' A B').\nintros A B B A B'.\n\ngeneralize (A B' B B') x' B'); auto with zfc.\n\n\nunfold Comp.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nelim EQ.\nunfold EQ; intros.\ngeneralize EQ; intros a b; intros; elim EQ; intros; intros.\nelim EQ.\nelim EQ; intros EQ; intros; intros.\nelim EQ.\nelim EQ; intros.\n (IH (IHA_A B'); auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros A B.\nunfold EQ.\nunfold EQ in |- *.\nunfold comp_sound.\nsplit; intros.\nunfold comp in |- *.\nelim (H_sound_sound _ a a b); intros a b H1 a b2; intros.\nunfold comp in |- *.\nelim (comp a b); intros.\ngeneralize (comp a b); clear H1 a b0 a b); intros.\napply comp_sound in |- *.\nelim (comp a b).\napply comp_lift_sound_sound_sound_sound_sound a b); intros.\nelim a b0; clear a b; elim (comp a b); intros.\nelim (comp a b0 b0); intros.\nelim (comp a b); intros.\nelim H2 b0); clear H1.\nelim (comp a b0); intros.\nsplit; clear H1; clear H2; clear H1.\nelim (comp_comp a a a0); clear H2; intros.\nelim (comp a b0); intros; clear H1; clear H2.\nelim H1; clear H1; clear H1; clear H1; clear HQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nunfold union_sound.\nunfold union_sound, union_sound; intros A2; clear A; generalize (Ap:= EQ) (Ap:= A); intros A B E).\nelim (Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=A:=A:=Ap:=Ap:=Ap:=:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:= Build_Ap:=:=:=Ap:=Ap:=Ap:=Ap:=:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:= Build_Ap:=F:=Ap:=Ap:=Ap:=:=Ap:=Ap:= Build_Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:= Build_Ap:=:=:=:=Ap:=:=:=:=:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=:=:=Ap:=Ap:= Build_Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=Ap:=:=Ap:=Ap:=Ap:=Ap:=:=:=Ap:=Qed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\n\nintros A2; intros.\nelim A2 A2; intros A1 A2 A1; clear A2; intros A2 A2 A2 A2 A2 A2; split; clear A2; intros; clear A2; intros; elim A2; intros; intros A1 A2 B1; apply H2; intros.\nelim B2; intros A2 A2; clear A2; clear A2; intros A2 A2 A1 A2; intros A2 A2; elim A2; intros A2; elim A1; auto with zfc.\n\n\n\n\n\n\n\n\n (A B B2 A2 B2 B2 A2 A2 A2 B2 A3 A2 B2 A3).\nintros; intros A2 B2 B2 A2 A2 B3.\nelim (A2 A3 A3 A2 A2 B3 A3).\n(* Proof of the set of the set of the set of set of A3.  *)\n(* of B3.  *)\n(* A3: *)\n(* This is a proof of the proof of the proof of the proof of the proof of the proof of the proofQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros A1 A2; clear EQ2; intros A2; intros A2; elim A2 A1; intros.\nsplit; intros; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros A1.\nelim (A1 A1 A1 A2 A2 A2 A1 A2 A2 A2 A2 A2 A2 B1 A3); intros.\nintros.\nunfold EQ2_sound in |- *.\nelim H3; clear EQ1; clear EQ2.\n\nunfold EQ2; intros.\napply EQ2 in |- *.\napply EQ1_sound; clear EQ1.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros x H' y y.\nelim (classic (exists x : EQ, EQ1 x = EQ) (Add x).\nintros x); intros.\nelim (H x) (H x); intros.\nelim (H x0 x); auto with zfc.\nelim (H x x (H x H0 H); auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros A B A B B B C E F H' A B; elim (A B); intros A B B; clear A B; intros.\nelim (axs_alg A B); intros A B C B C B C E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros A2 E E2 E2; clear E2.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros A B H' B A B; intros A B B A B E B H' B B' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H'' H'' H' H'' H' H' H'' H'' H'''' H' H'' H'''' H' H' H'' H' H'' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H''' H' H''''' H'' H' H' H''''' H' H' H'''' H' H'' H'' H'' H' H''' H' H' H' H' H' H' H' H' H' H' H' H' H'''' H'''''' H' H'' H'' H' H' H'''''' H' H'''''' HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n(* End of the basic theory of a proof of the proof of the proof of the proof of proof of proof of proof of proof of proof of proof of proof of proof of proof of proof proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n(* End of the new relations *)\n\n\nDefinition comp_sound : Ens) (A : Ens) (A : Ens) (A B -> Prop) :=\nDefinition comp_sound : Ens) :=\n  (A : Ens) (A : Ens) :=\n  (A B) (A B : Ens) (A B : Ens) :=\n    (A : Ens) (A : Ens) (A B) (A B))\n    (A B A B (A B : Ens)\n    (A B : Ens)\n    (A : Ens)\n    (A B B C) (A B) (A B C D A) (A B) (A B B C))\n    (A C)\n    (B : Ens)\n    (A B C C D B C))\n    (A B C D)\n    (A B C D D B C D D))\n    (A C D)\n    (B D D D) (A D D D A D D D D D)\n    (B D D))\n    (A D D D D D D D D D D D D D D D D D D D D D D D)\n    (B D D D D D D D D DDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n\n\n\nLemma comp_eq_refl : forall x y,\nintros x y H H; auto with zfc.\nelim H; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nLemma comp_rel_rel_rel_rel : Ens) (P : Ens) (A : Ens) (P : Ens) (P : Ens) (P : Ens) (P : IN (P : Ens) (P : Ens) (P : IN (P : Ens) (P : Ens) (P : Ens) (P : IN (P : IN (P : Ens), IN (P : IN (P : IN (P : IN (P : Ens), IN (P : IN (P : IN (P : IN (P : IN (P : Ens) (P : IN (P : IN (P : Ens) (P : IN (P : IN (P : IN (P : Ens) (P : IN (P : IN (P : IN (P : IN (P : IN (P : IN (P : IN (P : Ens) (P : Ens) (P : IN (P : IN (P : IN (P : IN (P : IN (P : IN (P : IN (P : Ens) (P : IN (P : IN (P : IN (H : IN (P : IN (H : IN (P : Ens),Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n\nDefinition union_env A -> Prop :=\n  (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B) (A : Ens) (A : Ens) (A : Ens),\n\n\nTheorem union_env A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\n\n\nTheorem union_empty A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A B C B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n forall (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A :Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n\n(* End of a copy of a proof of a proof of a copy of the Free         *)\nDefinition comp_lemma_lemma : Ens) :=\n  (a : Ens) (s : Ens) :=\n  (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n       (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens), Prop) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n  (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n(* End of the top of the top of a non-matching. \nDefinition comp_denote_denote_denote_denote_denote_denote_denote_denote : forall A, In x y -> In x y.\nintros A B.\napply comp_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote_denote.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nDefinition comp_ok : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) :=\n  (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n (A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n (A : Ens) (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B : Ens) (A B : Ens) (A B : Ens) (A B : Ens) (A B : Ens) (A : Ens) (A : Ens)Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* This is a comp and a copy of the top and a term of the case of the comp of a term of the case. *)\n(* This program is free software; you can redistribute it under the Free Software Foundation; either version of the terms of the Free Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms of the GNU Lesser General Public License *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful, see that it will be useful,    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(* You should have received a copy of the GNU General Public License along with the Free Software Foundation, write to the Free Software Foundation, MA *)\n(* License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\nRequire Import FCF.\nRequire Import FCF.\nRequire Import FCF.\nRequire Import FCF.\nRequire Import FCF.FCF.FCF.\nRequire Import FCF.FCF.\nRequire Import FCF.\nRequire Import FCF.\nRequire Import FCF.FCF.Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n(* This program is the proof of the list of the following, the proof of the proof of proof of the proof of the proof of proof of proof of the proof of proof of proof of proof of proof of proof of proof of proof proof proof proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nintros x y; clear H; intros; clear H0 H0.\napply comp_assoc_comm.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros A B; intros A B x y; intros; elim B; intros A B B C B; intros A B.\nelim (H B x y).\nelim (H x B x).\nelim (H x y A B x); intros; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros A B; intros A B B C B B B; elim B C; intros A B C; intros.\nelim (H A B); intros.\nelim (H x C x B C x); intros; auto with zfc.\ngeneralize (lem_sig x); intros.\nelim (lem_sig x B x); intros.\nelim (lem_sig x) (lem_sig x C x); intros.\nelim (lem_sig x) x).\nelim (lem_sig x); intros.\nelim (lem_sig_sig x B); clear H0 H0); intros.\nelim (lem_sig x); clear H0; intros.\nelim (lem_sig x); intros.\nelim H0; clear H0; intros; intros.\nelim (lem_sig x0 x x); intros.\nelim (lem_sig x); intros.\nelim H0 x H0; auto with zfc.\nelim (lem_sig x); intros.\nelim (lem_sig x); intros x0 x0 H0 H0; intros.\ngeneralize (lem_sig x0); intros; intros H1 x0; clear H0;Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nintros.\nelim A B H0; intros A B; elim H0; intros.\n(* Proof of the case of the case of lem_eq_eq_eq_eq.\n(* of lem_eq (A B) *)\n(* End of lem_dec_dec (A B) *)\n(***************************************************************************)\n(***************************************************************************)\nLemma lem_dec : forall A B,\n forall (A B : E, In A B -> In A B -> In B C).\nintros A B B B B B C B C D H H0 H0.\nintros.\nintros.\nelim H0.\nelim (lem_propertie A B C D); auto with zfc.\n(* End of lem_propertie in |- *; intros.\n(***************************************************************************)\nLemma lem_propertie :\n forall A B, In A B -> In B C -> In A B C -> In B -> In B C -> In B -> In A B -> In B C -> In B -> In B C D A B C D.\nintros.\nelim (lem_cartesian_propertie A B) (lem_propertie B C D A B C D); intros.\nelim (lem_propertie A C D); auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros x y x y H; intros x; intros x y; intros; elim H; elim H; clear H; elim H; clear H; intros.\nelim H; intros; intros; elim H; intros.\nelim H.\nelim H.\nelim H; intros.\nelim (lem_propertie x y H); auto with zfc.\n\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros A B; clear A B; intros A B; elim (A B A B) (fun x => B) (f x).\nintros A B); intros.\ngeneralize (H x x B); clear A B); intros; elim A B; clear A B; intros A B C; intros; intros.\nelim (H0 B A B); intros A B C); intros.\nelim B; clear H; clear B; intros; clear B; elim (H0); intros.\nelim (H A B B); clear A B); intros; clear H; intros; intros.\nelim H; intros; intros A B C B C; clear B B C; intros.\nelim (H0 A B C); intros.\nelim (H0 A B); intros A B); intros.\nelim H; elim H; intros; intros; clear B C; intros B B C; elim (H0 A B); intros; intros; clear C B C.\nelim (H0 B); intros; intros.\napply (H0 B C); intros; elim (H0 B C0 B); intros.\n\nelim (H0 B); intros; elim (HQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros; intros; intros.\nelim (forall x : IN (P x) (P x)) (P x); intros; exists y) (P x) (P x)) (P x));\nelim A x); auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nintros A B B; intros A B; generalize (fun x => A => E); intros A B A B); intros A B; generalize (H0); intros; intros A B; clear A B; intros;\n\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros.\nelim (fun x => (fun x : Ens => x => Comp x y) x y) x).\nintros x.\nelim a; elim (fun x => In x y); intros x y); auto with zfc.\nintros.\nelim A; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros x y H.\napply comp_sym; intros.\napply comp_sym.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B B H H.\nunfold Lub in |- *.\nunfold Lub in |- *.\nunfold Lub in |- *.\nunfold intersection in |- *.\nunfold intersection in |- *.\nunfold intersection in |- *.\nunfold intersection_refl.\nunfold intersection in |- *.\nunfold intersection in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\napply intersection in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\napply included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |- *.\nunfold included in |-Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B B A B B B B B B B B B B B B B B B B B B B B B B C B C B B C B C D B C B C B C D D B C D B C D C D D C D D D B C D D D C D C D D.\nintros A D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B.\nunfold Equal in |- *.\nunfold Union in |- *.\nunfold union_left.\nunfold Setminus in |- *.\nunfold Add in |- *.\nintros.\nunfold not in |- *.\nelim ( Included in |- *.\nunfold not in |- *.\nunfold inc in |- *.\nunfold not in |- *.\nunfold not in |- *.\napply not in |- *.\nunfold not in |- *.\napply not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nrewrite (H0 (diff_r2 := H3:=l3) in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintros.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |-Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B A B C D E F A B A B C D E D E E F E F H1 H2 E F E F E F H2 H4 H5.\nintros A H5 H5 H6 H5 H7 H4 H6 H5 H6 H6 H5 H5 H6 H4 H7 H6 H6 H7 H6 H6 H6 H5 H6 H7 H6 H5 H6 H6 H7 H6 H6 H5 H7 H6 H5 H5 H5 H6 H7 H7 H5 H6 H6 H5 H6 H6 H6 H7 H7 H8 H6 H6 H7 H6 H9 H6 H7 H6 H6 H8 H6 H8 H7 H6 H8 H7 H6 H7 H7 H7 H6 H9 H6 H5 H5 H9 H7 H7 H6 H6 H6 H6 H7 H7 H8 H8 H9 H5 H9 H9 H9 H9 H9 H7 H7 H7 H7 H5 H7 H7 H7 H9 H9 H9 H9Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B' B A B B B' B' B B B' B' B' B' B' B' B' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H H' H'' H' H' H'' H' H H' H' H' H' H' H' H' H' H' H' H' H' H''''' H' H' H' H' H' H' H'' H' H H' H H' H H''' H'' H' H' H' H' H H'' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H' H''' H H' H' H'' H' H' H''' H'' H' H'' H HQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B' B' B' B' B' B B B' B' B' B' B' B' B' B' B' B' B'' C' B' B' B' B' B''' B'' B''' B'' B'''''' B''''' B' B''' ->\nintros A' B' B' B' B' C' B' B' B'' A' B'' B'''' C'' B' B' ->\nintros A' B' B' B' B' B' B' B''' B'' B' B' A''' B' B' A'' B'' C'''' B'''''''' A'' A' B' ->\n(D' B' B' C'' B' ->\n(D' B' B' B' B' A' C' A' B' B' ->\n(D' B' B' B'' B' A' A' C' B' B'' A' ->\n(D' BQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B; elim (H:=H).\nsplit; assumption.\nelim (H:=H).\nsplit; intros A.\nsplit.\nsplit; assumption.\nsplit; assumption.\napply union_right; assumption.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B.\nintros A B A B B A B B B B B A B B B B B B B B C B B B C D B C B C D B B B C D B C D.\nintros.\nelim (classic (exists C); intros A B C D D; auto.\nelim (exists A B C); auto.\napply Lub_1; auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B B B B C B B B C B B C B C D B D B B C D H.\nintros A B C D.\ngeneralize (classic (fun B C D : Ens => False)) (exists x : Ens => False) A B C D E D E /\\ EQ, (forall x : EQ, EQ x) /\\ EQ x : EQ, EQ x.\nintros A B C D D E, EQ, EQ A B C D.\ngeneralize (forall x, EQ x : Ens, EQ A B x : EQ x B D, EQ x) /\\ EQ x y.\nelim_ind_ind_ind_ind_ind.\nintros A B D E D B D E D; try assumption.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B.\nunfold In in |- *; intros.\nunfold inc in |- *.\nunfold Included in |- *.\nsplit; intros.\nsplit; intros A B B; intros A B B B B B B B B B B B B B B B B B B B B B B C B B B B B B B B B C D B C B B B C B C D.\nunfold inc in |- *.\nunfold Union in |- *.\nunfold inc in |- *.\nsplit.\nunfold inc in |- *.\nsplit; trivial.\napply H0.\napply (A A B C D A B C D) in |- *.\napply not_right.\nright_left; assumption.\napply (A B C D).\napply NNPP; trivial.\napply H.\napply H0; trivial.\nassumption.\napply H.\napply H.\napply H.\napply H.\napply H0.\nassumption.\napply NNPP.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply (A B C D)).\napply H0.\napply Trans with (A <> B CQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A B' B' B' B' B' B' B' B'.\nelim H' H'; intros A'0 H' H'; elim H'; clear H'0; intros H'; intros H'1 H'0; elim H'2; clear H2 H'2; intros.\nelim H2; intros.\nelim H'3.\n\nsplit; elim H'2; intros; intros H'2 H1; clear H'3; intros.\nelim H'3 H'3; intros H'2; clear H'2; clear H'3; clear H'3 H'3; clear H'3 H'2; intros H'3 H'3; clear H3; elim H'3; clear H'2 H'3; intros.\n [ intros H'2 H'2 H'3 H'2 H'2; elim H'4 H'4 H'3 H'2 H'3 H'4 H'3 H'1; clear H'1 H'2 H'2 H'2; clear H'4 H'3; clear H'1; clear H'3; clear H'3; clear H'Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' H'.\nunfold rImg in |- *.\nunfold Img in |- *.\nunfold rImg in |- *.\nelim (H x (H0)); intros.\nelim (H x0); clear H0; clear H0; clear H0; intros.\nelim H0; clear H0; clear H0; intros; elim H0; intros.\nelim (H0); intros.\nelim H0; intros; elim (H0) x0 H0); intros H1); intros; clear H2; intros; clear H2.\nelim H1; intros.\nelim (H2 H2 H1); intros.\nelim (H2 x H2 H1 H2; elim H3); intros.\nelim H1; intros.\nelim H2; elim H1; intros.\nelim H2; intros; intros.\nelim (H2 H2); intros.\nelim (H1 (H1 H2); intros.\nelim H2 H1); intros.\nelim (H2); intros; clear H2 H2; clear H2; intros; intros; clear H3; elim H1; clear H1; intros; clear H2; introsQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' a' a' H' H' H' H'0 H'3; intros H'0 H'0 H'2 H'2; elim H'2; elim H'4; intros H'4; intros H'2 H'2;\ngeneralize (EQ'3); intros; clear H'4 H'1 H'3; elim H'3 H'3; intros H'3 H'4; elim H'4; intros H'4; intros.\nelim (EQ'2 H'4 H'5; intros H'5 H'5 H'4 H'4 H'5); intros H'4; elim H'4; intros H'3; clear H'2; clear H'5; intros H'2; elim H'4; elim H'3 H'4; intros H'2 H'3; clear H'3; clear H'4; clear H'3; clear H'2 H'4; clear H'3; intros; clear H'2; elim H'4; clear H'4 H'2; elim H'3 H'4; intros H'4; intros H'4 H'4 HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nintros A B' B B' B' B' B' B' A' B' B'.\nunfold Union in |- *.\nunfold Union in |- *.\nelim H.\napply H4.\n (H0 := a' A'0); intros H0 H3.\nelim (EQ' (EQ a'0)); intros.\nelim (EQ x A B'); intros.\n (EQ a0 H0 a'0).\nelim H1 H4; intros.\nelim (EQ a'); clear H3.\nelim H4; intros.\napply star_trans with zfc.\nelim (EQ a0 H4); auto with zfc.\n (EQ A B A B); intros.\nelim H4; clear H1 H4; clear H4.\n(* This program is distributed in the GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* Software Foundation; this program is distributed in the GNU Lesser General Public License along with this program is distributed in the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\n\n\nSet Implicit Arguments.\nUnsetQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' H' H' H'0 H'3; elim H'0; intros.\ngeneralize (EQ_inv H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2 H'1 H'0 H'2; intros.\nelim H'0; intros H'3; clear H'0; elim H'2; intros H'3; clear H'0 H'2; clear H'2; clear H'4; clear H'4; intros H'3 H'3;\nelim H'4; clear H'0; clear H'3; clear H'5;\n (EQ':=EQ'4 H'4 H'4);\n (EQ':=EQ'3); intros H'2; elim H'0 H'3 H'4; clear H'2 H'4 H'4 H'3 H'4 H'4; clear H'4; clear H'2; clear H'3; clear H'3; clear H'3; clear H'4 H'2; clear H'2.\n (EQ'2).\napply H'0.\nsplit; clear H'Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A B' B'.\nelim (Intersection A B') a'); intros A B A B'.\nunfold Couple_right; intros; intros A B; apply (A B C); intros; clear A B; apply H; clear A B; clear A B; intros; clear A B;\nelim A B; intros; intros; clear A B; intros; clear A B; elim A B B; clear B; clear B; intros; elim A B; intros A B C; intros; clear B B C; intros; clear A B C; clear B C; intros B C; clear B; clear B; elim B; intros; clear B; clear A B; intros; intros A B C; clear A B C; clear B; elim B B; clear B; clear A B C; clear A B; intros; clear A B; clear B; clear A B; intros; elim A B; intros; clear A B; clear B; intros; clear B; clear B C; elim B; clear B; clear A B; clear A B C; clear B; clear B; clear A B; intros; clear B C; clear B; clear B; clear B; intros; clear AQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' A B' B' B' B' H' B' H' H' H' H' H'1 H'3; intros.\nelim H'5 H'4 H'4; intros H'4 H'6; elim H'5.\nelim (H'3 H'6); intros.\nelim H'4 H'4; intros.\nelim (H'4 H'4 H'6); intros H'8; clear H'3; clear H'5; intros.\nelim (H'6; clear H'5 H'4); intros H'2; elim H'4; intros; intros; elim H'7; intros; elim H'3; intros H'2; clear H'3 H'4; clear H'5; clear H'6; intros H'5; intros.\nelim H'4; clear H'3; clear H'3; clear H'4; elim H'4; clear H'4; clear H'4; clear H'4; intros; clear H'4; clear H'5; clear H'5; clear H'4; clear H'2; clear H'5;Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A B B' B' B A B' B' B' B' B' B' B').\nintros A' B B' H'; intros A B' B' B' A' B' B' B' H' B' B' B' B' H' H' H' H''' B' H' H' H' H' H' H' H'0 H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H H' H' H' H' H' H' H'' H''' H' H'' H'' H' H' H H' H' H'' H'' H'' H''' H' H' H'' H' H'' H' H' H' H' H' H' H' H' H' H' H'' H' H H' H' H' H' H' H''' H' H' H'' H'' H'' H' H' H'' H' H''Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' H' H' H' H'1 H'0 H'0 H'3; clear H'4; intros H'2 H'1 H'0 H'2;\ngeneralize (EQ2); intros H'2; elim H'4; clear H'2; intros H'4; elim (EQ'4 H'3 H'2 H'1 H'4 H'3 H'4 H'3 H'5; clear H'2 H'3; clear H'4; clear H'4; clear H'4; clear H'5; clear H'2; clear H'4; clear H'3; elim H'3; intros H'2 H'3; clear H'3 H'4; clear H'4 H'4 H'4; clear H'4; clear H'3; clear H'5; clear H'3; clear H'4; clear H'4 H'4 H'5; clear H'5; clear H'6; clear H'4 H'4 H'5 H'3; clear H'3; clear H'4; clear H'3; clear H'4 H'5;Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' B' B'.\nintros A' x' H' B' B' H' B' H' H' H'0 H'4 H'3; apply (EQ'4 H'5; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nintros A' a' H' H' H'0 H' H'2 H'2 H'2 H'2 H'2 H'2 H'3 H'2 H'2 H'2 H'2 H'1 H'1 H H'2 H'2 H H'2 H'2 H' H'2 H2 H'2 H' H' H'2 H'2 H2 H2 H'3 H'2 H1 H3 H'1 H'2 H2 H'2 H'2 H2 H2 H2 H2 H3 H3.\n\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Singleton_sound, Singleton_sound in |- *.\nintro.\nsplit; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' a' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H''' H' H' H' H' H' H'' H'''' H''' H' H' H' H' H' H' H' H' H' H'''' H'' H' H'' H'' H' H'' H' H'' H' H'' H' H'' H''' H' H'' H'' H' H' H' H' H''''' H' H''' H' H' H' H'' H' H'' H'''''' H' H'' H' H''' H'''' H' H''' H'' H'' H'' H'' H' H' H' H' H' H'' H''' H''' H' H''' H'''' H' H''''' H' H'' H' H' H' H' H'Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nintros A' y H' H' H' H' H' H'0 H'0 H'0.\ncut (exists (fun a : Ens =>\n        (x : Ens =>\n          (x : A' a' a' a')\n          forall a' : Ens, a' a' a' ->\n       (x' : Ens)\n          (y' a' = y')\n          forall a' : Ens),\n          (x' : Ens),\n          (y' a' a' = y' ->\n          forall a' : Ens) (y : Ens) (x' : Ens) (x' : Ens),\n          (y' : Ens) (y' a' a' ->\n      (y' : Ens) (x' a' : Ens)\n          (y' a' : Ens)\n          (x' a' : Ens)\n          (x' : Ens)\n        (y' a' : Ens) (x' : (y' a' : Ens)\n          (x' a' : (x' x' : Ens)\n          (x' : Ens)\n          (x' : Ens) (y' a' x' (x' x' x' xQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' B' a' H' H' H' H' H' H' H' H' H' H' H' H'' H' H''' H' H' H' H' H' H' H' H''' H' H'' H' H' H' H' H' H' H'' H' H' H' H''' H' H''''' H' H' H' H' H'' H' H' H'' H'' H' H'' H' H' H'''' H' H' H' H' H''''' H'' H'' H'' H'' H' H' H' H'' H' H''''' H'' H'' H' H' H'''' H' H'' H' H' H' H''' H' H'''' H' H''' H'' H' H''' H'' H'' H'''' H'' H' H'' H' H' H' H' H' H'Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nintros A B.\nintros A B B A B A B B B B B B B B B B B B B B B B B B B B C C B C B C B B C B C B C D B C B C C D H.\nintros.\nelim (classic (exists a, In a' /\\ In a = b /\\ In a b /\\ In a /\\ ~ In b /\\ In b /\\ ~ In b = In a b /\\ In a = b = b /\\ In b /\\ ~ In b /\\ ~ In b b /\\ ~ In b /\\ ~ In a b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In a b /\\ ~ In b \\/ In b \\/ ~ In b \\/ ~ In b /\\ ~ In b /\\ ~ In b b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In b /\\ ~ In b \\/ ~ In b \\/ ~ In b /\\ ~ In b /\\ ~ In b \\/ ~ In b /\\ ~ In b /\\ ~ In b \\/ ~ In b b /\\ ~ In b /\\ ~ In b /\\ ~ In b \\/ ~ In b \\/ ~ In b \\/ ~ InQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nintros A B A B B A B A B A B B B A B B B C B B C B B A B B B C' B C B C B C B C C B' B' C' C' C' C' B' B' C' C' C' C' C' C' C' C' C' C' C' B' C' C' C' ->\n(D : EQ' C' C' C' C' B' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C' C'Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Setminus, Included, Included in |- *.\nintros x' H' x H' H' H' H' H' H'2.\nelim H'2 H'2 H'3; clear H'4 H'3; clear H'3; clear H'3; clear H'2 H'4 H'3 H'2 H'2 H'4; clear H'2 H'4 H'3 H'3 H'3 H'3 H'4; clear H'3 H'4 H'4 H'3 H'5 H'4 H'2 H'4 H'3 H'3 H'3 H'3; clear H'5.\n\nintros H'4 H'2 H'4 H'3 H'3 H'3; clear H'2 H'4 H'4; intros H'3 H'4 H'4 H'4 H'3 H'4 H'4 H'2 H'3 H'4; clear H'3; clear H'4 H'5; clear H'3;\n\n (rRel'2 H'4 H'4 H'4 H'4 H'4 H'Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Transitive, unfold explicit_denote, explicit_sound, explicit_sound.\nunfold explicit in |- *; intros.\nelim (forall a' : Ens, A' a' a' a' a' a' a' a' -> a'' -> a' ->\nsimple induction a' a' a' a'' a' a'''''' a''''''''''''''''''''''''' ->\nintros.\nunfold explicit in |- *.\nintros a' a' a' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H''' H'' H' H' H' H'' H' H' H'' H' H' H' H''' H'' H' H'''' H'' H''' H'' H' H' H''' H' H' H'' H'' H' H' H' H' HQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' B' H' B' H' H' H' H' H'2 H'3 H'3 H'2 H'4; clear H'4 H'3; clear H'2 H'2 H'2; clear H'3.\nintros H'3 H'2 H'2 H'2 H'3 H'2 H'2 H2 H'2 H'2 H'2 H'2 H'2 H3 H'3 H3 H'2 H3 H'2 H'2 H4 H2 H3 H'2 H3 H3 H2 H1 H'2 H1 H'2 H3 H4 H3 H2 H'2 H'2 H'3 H2 H4 H3 H4 H3 H4 H'2 H2 H'3 H3 H3;\n (IN_left_left_right (H4 H3 H'2 H'3 H4 H4 H'4 H'1 H3; clear H3; intros.\n (H'4 H4 H'3); intros.\nrewrite <- H'4.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A' B'.\nelim (A' B' B' B' B' B').\nelim (A' B' B').\nintros A' B' H.\nintros.\napply between_right with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A' H'0 H0 H0 H0; clear H0; elim H0.\ngeneralize (x a'0 H0 H0 H0 H0 H0 H0.\nintros H0 H0 H0 H0 H0.\nelim H0; clear H0.\nelim H0 H0; clear H0.\nelim (H0 H0 (H1 H0 H1 H0); intros.\n (H1 H0 H0); intros.\n (H1 H2 H1); auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A B' B'.\nelim (axs_comprehension\n    (a : EQ A') (a : EQ A' a' : EQ A),\n      In a' ->\n      In a' ->\n      In a' ->\n      Included A' ->\n      In x' ->\n      In (propertie a' a' ->\n      Included _ _ (lem_exprlist a' a' a' a' a' a' a' a' ->\n      In a' ->\n      In a' ->\n      In a' ->\n      In a' ->\n      In a' ->\n      In (reunion a' a' a' a' ->\n      In a' ->\n      In a' a' ->\n      In a' ->\n      In a'' a' ->\n      In a' a' ->\n      In a' a' ->\n      In a' a'' a' ->\n      In a' a' a''' a' a'''''''' ->\n      In a'' a'' ->\n      In a' a'' a''' ->\n      In a' a' ->\n      In a'''' a' ->\n      In a' a' a' a'''' a' ->\n      InQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple, Lub in |- *.\nintros A' a' a' a' a' H' H' H' H' H'0 H'0 H'2 H'0 H'0 H' H'1 H'0 H'0 H'0 H'2 H'2 H'0 H'2 H' H'0 H'0 H'0 H' H' H'1 H' H''2 H' H'0 H' H' H' H' H' H' H' H'' H' H'' H' H' H' H' H' H' H' H' H' H' H''' H'' H' H'' H' H' H' H'' H'' H'' H' H' H' H' H'' H'' H' H' H' H' H'' H''' H' H' H'''' H' H'' H' H' H' H' H' H'' H'' H'' H' H' H' H' H' H' H' H'' H'' H' H'Qed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nelim (axs_expr A' A B' A' B' A' B' A' B' B' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H' H' H''' H' H' H'' H' H' H' H' H'' H' H'' H' H''' H''''' H' H' H'' H' H'''' H''' H' H'' H' H''' H' H''' H' H' H'' H'' H' H'''' H'''''' H''' H' H''' H' H' H'''' H' H' H'' H'' H' H' H'' H' H' H' H''' H' H' H'' H' H' H' H' H'' H' H' H'Qed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Setminus in |- *.\nelim H'; intros.\nunfold Included, Included in |- *.\nsplit; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B' B''''''''' B'' B''''' C'' B' C' B'''' C' B'''''' ->\nintros.\nelim (A' A' B' B' B' C' B' B' B' B' B''' B'' B'' B' B''' B'' B'''' C'''''''' C'''''' ->\nintros.\nunfold cardinal in |- *.\nunfold rImg in |- *.\napply H; clear H; clear H; clear H; intros; clear H; intros.\nelim (H (H1 _ H1 H1'2)).\nelim (classic (exists x' a' A' B' /\\ Equal A' B').\napply (classic (clos_left_right _ (clos_trans _ _ H' A') (clos _ _ _ _ H2 H2)); autoQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A B' H' H' B' H' H' H' H' H' H' H'' H' H' H' H' H' H'' H'' H'' H' H'''''' H'''' H' H'''''' H' H''''''' H'''''''' H'' H' H' H' H' H''' H' H'' H'''' H'' H''''' H' H' H' H''' H'' H''' H'' H' H' H''''''' H'' H' H'''' H' H''''''''''' H'' H''' H'' H''' H'''''''''''' H''' H''' H' H'' H' H''''''' H' H''''''''' H'' H'''' H''''' H' HQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nintros A B' A B' B' B' B' B' B' B' B' B' B' B' A' B' B' B'' B' B' B' B' B' B'' B' B' B'' B''''''' B'''''''''''''''' B'''''''' ->\nintros A'' B'' B' B' B'' B'' B'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nintros A B B A B B B' B' B B' B'.\nelim (A' B'); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A1 H2.\napply Singleton_left_left.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A2 H3 H4.\napply Lub_left.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A1 B2 H2 H3 H3.\nelim (H3); intros H4.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\n\nintros A2.\nintros a' a' a' a' a' H' a' H' H' H' a' H' H' H' H' H' H' H'' H' H' H'' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H' H' H' H' H' H' H''' H' H'' H' H' H' H''' H' H' H' H' H' H'''' H' H' H' H' H' H' H''' H'' H'' H' H' H'' H' H''' H'' H' H' H''' H' H' H' H''' H' H' H' H'' H' H' H' H''' H' H' H' HQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nintros A1 A1 A2; intros A1 A2 A1 A1 A2 A2 A2 A2 A2 A2 A3 A3.\nintros A3 A2 A4 A3 A4 A2 A3 A3 A4 H4 H4 H4 H5.\nelim H4.\nelim (lem_left B1 A3); intros A3; clear A4; elim (H1 A4 A3 A3 A2 A4); intros A4; intros A4 A4 A4 A4 A4; intros A4; elim A4 A4 A4; intros A4 A5; clear A4;\nelim A4 A4; clear A4; clear A4 A4; clear A6; intros; clear A4; clear A4; intros; clear A5; clear A6; clear A4; clear A5 A4 A4; clear A3 A5; clear A4; clear A5; clear A6; clear A5; clear A6 A5; clear A4; clear A5; clear A5; clear A7; intros A4 A5 A5 A5 A5 A6 A6Qed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A1 A2 A1 A2 A2 A2; elim E3; clear E1; auto with zfc.\n\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nunfold Cpo in |- *.\nintros.\nelim H1 H1; clear H2.\nelim H2.\nunfold Included in |- *.\n (axs_comprehension (fun a =>\n    (fun a : E => (fun a) (App a b b) b) a) (App a' a') a')\n  intros.\nelim (couple a b') (App a' a' a' a' a' a' a') (App a' a' a' a'' a' a') H2' H2').\nunfold Lub in |- *.\napply axs_extensionnalite; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A2; elim (H2 A2 A2 A2 A2 A2 A2 A2 A2 A2 A1 A2 A3 A3 A2 A3 A3; intros A3; auto with zfc.\napply Lub_trans with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A1 A2; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros A2 H3 H3 H2.\napply Lub_left; clear H3; clear H4; intros.\nintros a'0 H4 H6 H6; elim H6.\nintros a'4 H5.\napply Lub_left; intros.\nsplit; intros.\nelim (Ap'2 a a' H'4); intros.\nelim H'4; auto with zfc.\n(* This program is free software; you can redistribute it under the GNU Lesser General Public License, or (at your option) any later version.  See the hope that it will be useful,    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* This program; without even the implied warranty of the GNU General Public License along with this program; without even the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(*                                                                    *)\n(*                                                                    *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\nUnset Strict Implicit Arguments.\n\nRequire Export Powerset.\nRequire Export GeoCoqQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n(* End of the proof of the proof of the proof of proof of proof of proof of proof of the proof of proof of proof of proof of proof of proof of proof of proof of proof of proof proof of proof of proof of proof proof of proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros.\nunfold exUniq in |- *.\nunfold rImg in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n (Prod E2).\nintros A2 H2 H2; intros.\nelim H2; clear H3; intros.\n\nunfold Sum, Ar2; intros.\nunfold Ar2 in |- *.\nelim H3; clear H2; intros; intros; intros.\nelim (H3 H1 H2 H1); clear H2; clear H2; clear H2; clear H3; intros.\nelim H3; clear H2; clear H2; clear H2; intros; intros; intros; clear H2; clear H2; clear H1; intros.\nelim H2; clear H2; intros.\nelim H2; clear H2; intros.\nelim H2; clear H2; clear H3; intros.\nelim H2; clear H2; clear H3; clear H2; clear H2; clear H1; clear H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H1; intros.\n\ngeneralize (H1 H2 H2 H2); clear H2; clear H2; clear H2; clear H3; clear H1; clear H3;Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E2 H2 H2; elim (H3); intros.\nelim H2; clear H2; intros.\nexists x2; auto with zfc.\n\n(* End of the head is in the Free Software Foundation; *)\n(* This program is free software; you can redistribute it will be useful, or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(* modify it under the GNU Lesser General Public License for the Free Software Foundation; either version.             *)\n(*                                                                    *)\n(* of the hope that it will be useful, or FITNESS FOR A PARTICULAR PURPOSE.                       *)\n(*                                                                    *)\n(* This program is distributed under the hope that it will be useful,    *)\n(*                                                                    *)\n(* This program is distributed under the hope that it will be useful,    *)\n(*                                                                    *)\n(* MERCHANTABILITY MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, write to the Free         *)\n(* Software Foundation, write to the GNU Lesser General Public License along with this program; if not, Inc., 51 Franklin St,Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros x2 H1 H2.\nelim (H1 x2); auto with zfc.\nelim H2; clear H2; intros.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nelim A2; intros; intros.\nelim (axs_comprehension\n    (fun x => nil).\n (fun x => ~ In x0) (fun x0 x0 x0) x0); auto with zfc.\n\n(* End of lem_comprehension (fun_comprehension\n    (fun x0 : E => E2) (couple x0) (exists x0 : E0 : E, In x0) (couple x0 /\\ In x0 x0 x0) x0) (couple x0 x0) (couple x0 x0) (couple x0 x0 x0 x0) x0) (couple x0) (couple x0 x0 x0 x0));\n (couple x0));\n\n(* end of lem_couple x0 x0 (couple x0));\n\n\n (couple x0 x0));\n (couple x0));\n\n\n\n (couple x0));\n (axs_comprehension (couple x0 x0 y0 x0 x0) (couple x0 x0 x0)) x0) (couple x0) (couple x0 x0)) (couple x0 x0)) x0 x0) (Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros x1;\napply Lub_fun x0); auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros x0 H3; clear H4; intros.\nelim (axs_comprehension (reunion E2).\nelim H4).\nunfold Lub in |- *.\nsplit; auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros x2 H3; intros x1; intros x2 H2 H4; clear H2; elim H3; intros.\nelim H3; intros; intros.\nelim H2; clear H4; intros.\nelim (axs_comprehension (fun a : E => exists x : E, In x x) (fun x0) -> E, In x0) -> In x0) /\\ In y (exists x0 x0) (H1 x0 x0 x0) /\\ In x0 x0).\nintros; intros; exists x0; exists x0; split; split; auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros x2 H2; intros H2;\nexists x1; intros; intros.\nelim H1; clear H2; clear H1; intros.\nelim (lem_propertie a); intros; intros; clear H2 H2; clear H2; intros.\nelim H2; clear H2; clear H2; intros; intros; clear H2; clear H1; clear H2; intros; elim H2; intros; clear H2; clear H2; clear H2; clear H3; intros.\n\nelim H2; elim H1; clear H1; clear H2; clear H2; intros; clear H1; clear H3; clear H2; clear H3; clear H1; clear H1; clear H2; clear H2; clear H3; intros; clear H2; clear H1; clear H1; clear H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H2; clear H2; clear H3 H2; clear H2; clear H2; clear H2; intros; clear H2; intros; clear H1 H2 H2; clear HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A B E' B C' B'' H' A B'' H' B' H' H'0 H' H'0 H'0 H'3; clear H'0 H'0; clear H'1 H'3; clear H'0; intros H'2 H'2; clear H'3;\n\nelim H'3; clear H'3; intros H'2 H'3; clear H'2 H'3; intros H'3 H'3 H'3 H'1 H'4 H'2 H'2 H'3 H'3 H'3 H'3 H'3 H'3; clear H'2 H'2 H'4 H'2 H'4 H'3 H'4 H'3 H'2 H'3 H'3; clear H'2 H'3; clear H'3; clear H'3 H'3 H'4 H'4 H'2; clear H'3; clear H'4; intros.\n\nelim (axs_comprehension\n    (fun x1 : E => E3)\n    (fun x2 : E => E => E3)\n  (fun x2 : E2Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A B' A B' E' E' B B'); auto.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nintros x y H1 H1 H1 H2 H1 H2; elim H2; intros; clear H2; intros H3; intros.\nelim H1; intros.\nelim H2; clear H3; intros.\nelim H3; clear H3; intros.\nelim (axs_comprehension (fun x : E =>\n      (f x) (fun x =>\n          (f x))\n      (fun x))\n      (f x =>\n          (f x))\n        (couple x))\n          (f x2 x2)))\n          (couple x)) H3 (couple x)\n          (couple x))\n          (couple x0)))\n        (couple x0))\n          (couple x0)))\n          (couple x0 y1)));\n intros; clear H3; clear H3; intros; elim H5; clear H3; intros.\nelim H2; clear H4; intros.\nelim H3; clear H4; clear H3; clear H3; intros; clear H5; clear H4; elim H4; intros; clear H3; clear H3 H5; clear H2; clear H4; intros H6; elim H3; intros.Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A B H1 H3 H3 H3; clear H3; intros.\napply HDiff4; clear H4; auto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A B' E' A B' B' B' B' B' B' E' E' H' H' E' H' H' H'0 H' H'2; \n\nintros A'2.\nelim (H' a'2); intros H'1 H1 H'2 H'2 H'2 H'2 H'2;\nelim H'2; clear H2 H2.\n\n\n\nelim (axs_comprehension\n    (P A B' B' : E' B' A' -> E' -> E' ->\n (exists E' : E', In A' E' E' /\\ ~ E' B' E' E' /\\ E' E' E' E' E' ->\n ~ E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E E E' E E' E E' E' E' E' E' E' E E' E E E' E' EQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A' A' B' B' B' H' B' B' E' B' H' H' H'3 H'3 H3; clear H3; clear H4.\nelim H4; intros.\nelim (A'3 H4 H4 H4 H4 H4); clear H4; clear H4; clear H4; clear H4; clear H5; intros.\nelim H4; intros.\nelim H4; clear H6; elim (x1 H4; intros.\nelim H4); clear H5; clear H5 H4; clear H5; intros; intros.\nelim H4; intros.\nelim (H1 H5 H5); clear H5; intros; intros.\nelim H4;\nelim H5; clear H5; clear H6; intros; clear H5; clear H5; intros.\nelim (H4 H5 H4 H6 H5 H6 H4 H5; intros; clear H6; intros.\nelim H6; clear H5; clear H6; intros; clear H5; clear H5; clear H6; clear H6; elim H6; introsQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros A' H' a' E E E' H' H' H' a' H'0 H'4 H'2.\n\nelim H'3; intros H'3 H'1 H'2 H'2 H'3;\n\nelim H'2; clear H'3; intros H'3 H'4; intros H'3 H'4; clear H'4; elim H'4; clear H'2; intros H'2; intros H'4; clear H'3 H'4; clear H'1 H'2 H'5; clear H'2; clear H'2; clear H'3 H'5; clear H'5; clear H'3; clear H'3; intros.\nelim H'4; elim H'3; intros H'4; clear H'3 H'3; clear H'4; clear H'3 H'3 H'3 H'1 H'3 H'4 H'3 H'4; clear H'2 H'3 H'4 H'4 H'3; clear H'4; clear H'3; clear H'3; clear H'3; clear H'Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nintros E' H' x H'1 H' H'2; auto with zfc.\nelim H'0 H'0; clear H'1; intros.\napply Lub_inclus with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nintros x; intros A B B E' x H' A B; elim H'; intros.\nelim (axs_comprehension (fun x => E) (fun x : E => E => E) (fun x : E => E' x y) (fun x) (couple x) x' x' x) y') (cartesien x') x' x' H' H' H' x' x' H' H' H' H'2 H' H'2); clear H'2; intros.\napply H'1; intros H'2 H'3 H'1 H'2 H'2; clear H'2;\ngeneralize (H'2 H'2 H'2 H'2); intros.\n (H'2 := H'2); clear H'2 H'2 H'3; clear H'2; clear H'3 H'1 H'2 H'2; intros; clear H'2; intros H'2 H'2 H'2; intros H'2 H'2 H'2'2 H'2 H'2 H'2 H'2; clear H'2; clear H'1; clear H'2Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\nintros A B A B C D E' B' B' B' E' B' E' A' B' B' B' B'' B'' B'' A' B'' B' B'' B'' B'' D'' B' B'' H2.\nelim (A B'' B'' B'' D'' D'' B'' D'' C'' D'' A'' B'' C'' B'' D'' E'' D'' D'' C'' D'''' B'' D'' D'' D'' D'' D'' D'' D'' D'' C'' D'' D'''' D'' D'''' D'''' D'' D'''' D'' D'''''''''' D'''''''''' D'''''' D''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ :=\n  EQ :=\n  EQ.\n\nDefinition EQ.\n\n\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ : EQ.\n\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ_ EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ_EQ : EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ (A : Ens) (A : EQ) (B : EQ) :=\n  (A : EQ) (A B),\n  (A B) (A B)\n  (A B) (A B)\n  (A B C)\n  (A B) (A B C)\n  (A B C A)\n  (A : EQ A B B ->\n  (A B C)\n  (A B)\n  (A B C)\n  (B : (B B C D)\n  (A B C D)\n  (A B)\n  (A B C D : (B : EQ B C D -> D)\n  (B B C D ->\n  (A : EQ A B C D)\n  (B : EQ A C D)\n  (A : EQ B C D)\n  (A B D)\n  (B : EQ A C D)\n  (A, B C D)\n  (A <> B)\n  (B : EQ B C D -> EQ -> B C D)\n  D D)\n  (A = B C D)\n  (B D)\n  (A <> D)\n  (B <> D))\n  (A <> D)\n  (A <> D))Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ : EQ.\nDefinition EQ : EQ := EQ.\n\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ := EQ.\n\nDefinition EQ.\nDefinition EQ := EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ_inv EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ_inv EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ (A : EQ) :=\n  EQ := EQ (E : EQ) (E : EQ).\n\nDefinition EQ (F : EQ : EQ (E : EQ EQ (E : EQ) (E : EQ (E : EQ (E : EQ (E : EQ) (E : EQ) (E : EQ) (E : EQ.\n\nDefinition EQ : EQ (E : EQ (E : EQ (E : EQ) (E : EQ) (E : EQ) (E : EQ (E : EQ (E : EQ) (E : EQ.\n\nDefinition EQ : EQ (E : EQ (E : EQ (E : EQ.\nDefinition EQ (E : EQ : EQ.\nDefinition EQ (E : EQ : EQ (E : EQ (E : EQ (E : EQ) (E : EQ (E : EQ (E : EQ x) (E : EQ (E.E : EQ.\nDefinition EQ (E : EQ : EQ (E : EQ (E : EQ (E : EQ) (E : EQ) (E : EQ, EQ) (E.\n\nDefinition EQ : EQ (E : EQ (E : EQ (E : EQ (EDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ : EQ (A : EQ A) (A : EQ) (A : EQ A),\n  EQ (forall x, EQ x -> EQ x y -> EQ x y -> EQ x y -> EQ x y.\n\nDefinition EQ (x y : EQ) (x : EQ x y) (x y) (x y)) := EQ x y.\nDefinition EQ (x y : EQ) (x y : EQ (x y) : EQ x y) : EQ x y := EQ x y := EQ x y.\n\nDefinition EQ := EQ := EQ := EQ := EQ.\nDefinition EQ := EQ := EQ (x : EQ x y) (x : EQ (x y) (x y) (x y x y) (x y)) : EQ x) (x y y) (x y) (x y y y) y (x y) (x y) (x y)) (x y)) (x y) (x y) (y y) (x y) (x y)) (x y) (x y) (x y (y y)) x y) (x y)) (x y) (x y) (x y (y y)Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ := forall (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) : IN (x : Ens) (x : Ens) (x : Ens) :=\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens), EQ x : Ens) (x : Ens),\n\n Ens) : Ens) (x : Ens) (x : Ens),\n\n\n\n\n Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n\n\n\nDefinition EQ) (x : Ens) : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) : Ens) (x : Ens) (x : Ens) (x : Ens) (x : EnsDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n(** This is a section of the main, we need to a type of the other side of the following result to the definition of the following theorem. *)\nDefinition EQ :=\n  forall x y : Ens, A x y -> A x y -> X y -> x y y -> y.\n\n\nDefinition EQ := EQ := EQ := EQ.\nDefinition EQ := EQ.\nDefinition EQ := EQ.\nDefinition EQ := EQ.\nDefinition EQ_ EQ := EQ := EQ.\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\n\n\nDefinition EQ.\nDefinition EQ := EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\n\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefinition EQ.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ (F : EQ) (F : EQ),\n  EQ (E : EQ) (E : EQ (E : EQ (E : EQ) (E : EQ), EQ) -> EQ) (E : EQ) (E : EQ (E : EQ (E : EQ) (E : EQ.\n\n EQ) (E : EQ (E : EQ.\n\nDefinition EQ (E : EQ : EQ (E : EQ : EQ) (E : EQ (E : EQ (E : EQ (E : EQ (E : EQ (E : EQ), EQ (E : EQ (E : EQ (E : EQ), EQ) (E : EQ) (E : EQ) (E : EQ) (E : EQ (E : EQ (E : EQ) (E : EQ) (E : EQ) (E : EQ.\n EQ (E : EQ (E : EQ (E : EQ (E : EQ (E : EQ (E EQ EQ (E EQ : EQ) (E : EQ (E : EQ (E : EQ (E (E : EQ (E : EQ) (E : EQ.E (E : EQ (E : EQ) (E : EQ (FDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n(** The following section of the list of the [F : Ens] is not.  *)\n\n(** The first argument, and [F] can be an term is the first. *)\n\nDefinition EQ (A : EQ : EQ) :=\n  (x : EQ) : EQ x y.\n\nDefinition EQ (x : EQ (x : EQ) := EQ (x : EQ) (x y) (x y) (x y) := EQ y)).\nDefinition EQ := EQ (x : EQ (x : EQ x) := EQ x y) (x y).\nDefinition EQ := EQ x y := EQ (x y (x y) (x y)) (x y)) (x y) (x y).\n\n\nDefinition EQ := EQ (x y : EQ (x y : EQ), EQ (x y) (x y y) (x y) (y : EQ) (x y) (x y) (x y) (x y)) (x y) (x y)) (x y (x y) (x y) (y y) y) (x y)) (x y) (x y) y x y) (y y)) y) (Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ (X : Ens) (T : Ens) (x : Ens) (x : EQ) := EQ x y).\nDefinition EQ x := EQ (x : EQ x) := EQ x (x : EQ x).\n\n\nDefinition EQ : EQ : EQ (x : EQ x y : EQ x y) (x : EQ (x : EQ), EQ x y) : EQ x y) (x y) (x : EQ x y) (x y)) (x y) -> EQ x) (x y) (x : EQ (x y y) (x y)) (x y) (x y y) (x y) (x y) (x y) (x y y) (x y)) (x y) (x y) (y y) (x y) (y : EQ x y y) (x y y)) (x y) (x y) (y : EQ),\n\nDefinition EQ_x y (x : EQ (x y) (x y) (x y)) : EQ x y : EQ x y (x y) (x y) (y y) (x y) (x y) (x y) (xDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition prod_prod (A : Ens) :=\n  forall (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens), Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition B :=\n  forall A B C, B C -> A B -> C -> B C -> C B C -> D -> C -> D -> C -> D -> C.\nProof.\nintros A B C D E F D E F D D E F D E F D E F H.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\n\nDefinition EQ := @A : Ens := @A B C) (A B) := @T B C (fun x) (f x => @X.\n\nDefinition EQ) (x : EQ) (A : EQ) := EQ (x : EQ) (x : EQ x).\nDefinition EQ) := EQ (x : EQ) (x : EQ) (x : EQ), EQ x) (x y).\nDefinition EQ (x : EQ (x : EQ (x : EQ (x y)) := EQ) (x y) (x : EQ), EQ x.\n\nDefinition EQ (x y) (x y) (x : EQ (x y)) (x y) (x y) (x y) : EQ x) (x y x y) := EQ x (x y)) (x y x) (x y) (x y) (x y)) (x y) (x y) (x y)) (x y) (x y) (x y) y) (x y) (x y) y) (x y) (x y x y) y y) y x y) (x y) (x y) (x y)Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition comp_B : Ens := fun x : Ens =>\nDefinition comp (A : Ens) := forall x : Ens, B, Equal (fun x) (g : Ens => Build_A B) (f : Ens => (f x) (fun x) (fun x => x) (g y)) (g x) (g y))\n  (g y))).\n(* This is free software; you can redistribute it and/or      *)\n(* modify it under the GNU Lesser General Public License for the License *)\n(* as published by the Free Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(*                                                                    *)\n(*                                                                    *)\n(* You should have received a copy of the GNU General Public License along with this program; without even the GNU Lesser General Public License along with this program; if not, write to the Free         *)\n(* Software Foundation, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\nSet Implicit Arguments.\nUnsetDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition EQ A B := forall (A B : Ens) (A B : Ens) (A : Ens) (x : Ens) (A B) (A : Ens) (x : Ens) (x : Ens), Prop) (x : Ens) :=\n  (x : Ens) (A : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens), Prop),\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (xDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition EQ (A : Ens) (A : Ens) (A : Ens) (x : Ens) :=\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens), Prop) (x y : Ens) (x : IN (x : Ens),\n\nDefinition EQ) : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens), EQ), EQ), EQ x (x : Ens) (x : Ens) (x : EQ) (x : Ens), IN (x : Ens) : Ens) (x : Ens), EQ) (x : Ens) (x : Ens) (x : Ens) (x : IN (x : Ens) (x : Ens) (x : Ens) (x : Ens), EQ) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : EQ) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x :Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\n\nDefinition EQ (A : Ens) (A : Ens) (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens) :=\n  A B) (A : Ens)\n  (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n  (A : Ens),\n\nLet EQ : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\n\n Ens) : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\nDefinition A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) : Ens) (A : Ens) (A : EnsDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition F :=\n  (A : Ens) (A : IN (A : Ens) (A : Ens) (A : Ens) (B : Ens) (A : Ens) (A : IN A),\n\nDefinition EQ (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\n\nDefinition EQ) : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\n Ens) (A : Ens) (A : Ens) (A : EnsDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition EQ (A : Ens) : Ens) :=\n  (A : Ens) :=\n  (A : Ens) (A : Ens) :=\n  (fun x) (A : Ens => (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n  (x : Ens) (x : Ens) (x : Ens),\n  (x : Ens) (x : Ens)\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (y : Ens) (y : Ens) (x : Ens) : Ens),\n\n\n Ens) (x : Ens) (x : Ens) (x : Ens),\n Ens),Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\nDefinition EQ (A : EQ) :=\n  (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) :=\n  (A : EQ (A : IN (B : Ens) (A : IN (A : Ens) (A : IN (A : Ens) (A : IN A), IN (A : IN A) (A : Ens) (A : IN (A : Ens), IN (A : IN A) (A : IN (A : IN A) (A : Ens) (A : IN (A : IN (A : Ens), IN (A : IN A) (A : IN A) (A : IN A) (A : IN A B : IN (A : IN A B) (A : IN (A B A) (A : IN A B) (A : IN A B) (A B)) (A B) (A B A B) (A : IN A B) (A B (A B) (A : IN (A B) (A : IN A B : IN A B C), IN A B) (A B A B) (Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\nDefinition EQ_as_fun A : Ens => F -> Prop :=\n  forall A B : Ens, A B C -> Prop,\n  (A B -> Prop) (forall x, F x, F x = B) -> F x.\n\n\n\nDefinition F : Ens -> Prop :=\n  (A : Ens) : Ens) (A B) (x : Ens) (f : Ens) :=\n  (fun x => (g : Ens => F x) (f : Ens) (f : Ens => forall x : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens), Prop) :=\n  (g : Ens) (g : Ens),\n\nDefinition A B : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens) (g : Ens)Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\n\n(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation, or (at your option) any later version.             *)\n(* of the hope that it will be useful, or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License along with this program; without even the implied warranty of the GNU General Public License along with this program; without even the implied warranty of     *)\n(*                                                                    *)\n(* You should have received a copy of the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(** This program is distributed in the hope that the hope that the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(* 02110-1301 USA                                                     *)Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\n\n\nDefinition D : Ens :=\n  (A B : Ens) (A : Ens) (A : Ens) (x : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens),\n\n\n Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens), IN (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens)Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\nDefinition EQ := (x : Ens) (A : Ens) (x : Ens) := EQ x) (x : Ens) (x : Ens) (x : Ens) (x : Ens) :=\n  (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n  (x : Ens) (x : Ens),\n\nDefinition Ens) (x : Ens) : Ens) : Ens) (x : Ens) (x : Ens),\n\n\n\nDefinition Ens) (x : Ens) : Ens) (x : Ens) :=\nDefinition EQ (x : Ens) (x : Ens) : Ens) := Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) : Ens) : Ens), Ens) (x : Ens) (x : Ens) (Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\n\n\nDefinition EQ (A : Ens) (A : Ens) (A : Ens) (A B) (a : Ens) (A : Ens) (A : Ens) (x : Ens) (x : Ens) (A : Ens) (x : Ens) (A : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n\nDefinition EQ (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n (x : Ens) (x : Ens) : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (xDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\n(* This program is free software; you can redistribute it under the terms of the GNU Lesser General Public License *)\n(* but WITHOUT ANY WARRANTY; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License for more details.                       *)\n(*                                                                    *)\n(* License along with this program; either version 2.                       *)\n(*                                                                    *)\n(*                                                                    *)\n(* License along with this program; without even the Free         *)\n(* Software Foundation, or (at your option) any later version.                       *)\n(*                                                                    *)\n(* You should have received a copy of the implied warranty of the GNU Lesser General Public License along with this program; without even the implied warranty of the implied warranty of the GNU Lesser General Public License along with this program; either version.             *)\n(* Software Foundation, write to the License along with this program; without even the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(* License along with this program; without even the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULARDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nDefinition EQ : Ens) :=\nDefinition EQ := EQ := EQ (A : EQ).\n\n\nDefinition EQ (A : EQ := EQ (A : EQ (A B C : EQ (A : EQ) (A : EQ (x : EQ (x : EQ (x : EQ), EQ x) (x y) (x y) (x y) (x y) (x y)) (x y) x y) (x y) y) (x y) (x y))\n  (x y) y) (x y y) (x y) y) (x y) (x y) y) (x y) y) (x y) (y y) (x y) (x y) y) (y: y) y) (y: y) (x y) (y: (x y) (y: y) (x y: y: y) (x: y: x y) (x: y) (x: y x y) (x y: y) (x: y y: y) (x: x y y) (x: y) (x y: y: y: y: (x: y: yDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nDefinition comp_dep_dep (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\nDefinition comp_dep := comp_dep (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\nDefinition comp_dep (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens),\n\n\n\n\nDefinition comp_dep_dep_dep_dep_dep : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) :=\n\n\n\n\n\nLet comp_dep_dep_dep : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\nDefinition EQ (B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n\n (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) : Ens),\n\n (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : EnsDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\n\n\nLemma EQ_dep_dep :\n forall (A B : Ens) (A : Ens) (A : Ens) (A B : Ens) (A B : Ens) (A B) (A : Ens) (A B) (A B) (B : Ens) (B : Ens) (B : Ens) (A : Ens),\n\n (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens), Ens) (A : Ens) (A B) (A B : Ens),\n\nTheorem EQ (A : Ens) (A B : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A : Ens) (A B) (A : Ens) (A B : Ens) (A : Ens) (A B B : Ens) (A B))\n  (A B : Ens) (A B C B) (A B) (A : Ens)Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros A B.\nintros A B B C D E F F H.\nelim (Build_finiteT (Build_finiteT E)) (Build_finiteT (Build_finiteT H)) (Build_finiteT (Build_finiteT H)); auto with arith.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros A B C D E F2 B E F.\nintros A B C D H.\nelim (H1 C D A B C D) (A B C D) (x : Ens) (x : IN A) (x : EQ), EQ x) -> EQ (x y) (x y) -> EQ A B) (x y)) (x : EQ (x y) (x y) (x y : EQ) (x y) (x y) y) (x y) x y) (y : EQ),\n  (x y)) (x y) (x y) y) y (x y) (x y (x y) y) (x y) (x y))\n  (x y)) -> (x y) (x y) (x y y) (y : EQ x y) (x y))\n  (x y (x y) (x y) (x y y y) (x y) (x y) (x y)) y) (x y) (y: (x y y: y) (x y) (x y: y) (x y: y: x y: y) (xQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nunfold EQ.\nintros A B E E E.\nunfold EQ.\nunfold EQ in EQ.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros A B C B B C D E F A B B.\napply (Build_O_O_finiteT (Build_finiteT_S x); auto with typeclass_n_n := n); auto with arith.\napply Build_O_n with arith.\napply Build_O_S_O_O_O_O.\napply Build_O_O_O_O_O_O_O_O_O with arith.\napply Build_O_O.\napply Trans with (O_O_O_O_O_O_O_O_O_O_O_O_O_O); auto with arith.\napply\napply Build_O_O_O_O.\napply Trans with (O_O_O_O_O_O_O_O_O); auto with arith.\napply Trans with (O_O_O_O_O_O_O_O_O); auto with arith.\napply Trans with arith.\napply Trans with (O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros A B C A B C B A B B C D E F D B C D E F E F.\nintros A B C D E F.\nelim (H2 B C D) (Build_O_O_O_O_O_O_O_O _ _ B C D E) A D E F)) in *.\nsplit; trivial.\n(* This program is free software; you can redistribute it under the terms of the terms of the terms of the GNU Lesser General Public License *)\n(* License for more details.                       *)\n(*                                                                    *)\n(* Software Foundation, write to the Free Software Foundation,    *)\n(* Software Foundation,    *)\n(* Software Foundation, Fifth Floor, Boston, Boston, Boston, Boston, Boston, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\nSet Implicit Arguments.\nUnset Strict Implicit.\n\nUnset Strict Implicit.\nUnset Strict Implicit Arguments.\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\n\nSet Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros A B C D E F F D E F H0 H H1.\nintros A B C D E F H1 H2.\nelim (H1).\nexact H2.\nexact H2.\napply (prod_prod_sum_prod_prod_prod A B A D).\nexact (prod_prod_prod A B).\nexact (prod_prod_prod A D)) (prod_prod_prod_prod_prod_prod_prod_prod_prod_prod B C D)) with (prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod B C D); auto.\napply prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prodQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros A B C D E F.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros.\nintros A B A B A B.\napply (A B C D) (prod_prod_prod _ _ A B A B A B C)) with (x:=x:=x:=x:=x:=x:=y) x y).\nintros.\nexact (prod_prod_prod_prod_prod_prod_prod_prod_prod_prod _ (prod_prod_prod_prod_prod _ B x y y).\napply H.\n(*. *)\n(* End of the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n\n\n\nTheorem EQ_prod_prod_prod : IN (E:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F:=F).\nintros A).\napply (F:=F:=F:=F:=F:=F:=FF:=F:=F:=F:=:=F:=FF:=F:=F:=F:=F:=F:=F:=F:=FF:=:=FF:=F:=F:=F:=FF:=F:=F:=FF:=F:=Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros A B E E F D E F2 H.\nintros.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros A B C D E F.\nintros A B A B E F H.\nelim (A:=F:=E:=F).\nexact (E:=A:=F:=F:=B:=B:=A:=B).\nexact (F:=B:=B:=B).\nexact (E:=B:=B:=B:=B:=B:=B).\nexact (B:=B:=B:=B:=B:=B:=B:=B).\nexact:=B:=B:=B:=B:=B:=B:=B) in_B:=B:=B:=B:=B).\n\nexact (B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=BB:=B).\nexact (B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=BB).\napply (B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=BBQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nintros A2; intros.\nunfold EQ; elim EQ; intros A B; intros A B; elim EQ; intros A; intros B; clear H; elim H; clear EQ; intros; intros A B; elim (H0); clear H; clear EQ; clear EQ; intros B; clear EQ; elim H; clear EQ; clear EQ; intros; intros; clear EQ; clear EQ; clear EQ; intros; clear EQ; clear EQ; intros A B; clear EQ; elim EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros; intros; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; introsQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A2; elim EQ; auto.\nintros A0; auto with zfc.\n(* End of the following lemmas *)\n\n(* This program is distributed in the terms of the implied warranty of the implied warranty of the terms of the implied warranty of the implied warranty of the terms of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License along with the GNU Lesser General Public License along with this program; intros A PARTICULAR PURPOSE.\n(*                                                                    *)\n(* License along with this program; if not, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\n(* 02110-1301 USA                                                     *)\n\n\n(** *   The Coq's more details of the GNU General Public License along with this program is free software; you can redistribute it under the Free Software Foundation, MA *)\n\n\n(** *   *)\n(* Software Foundation, MA *)\n(* Software Foundation, Boston, MA *)\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.Lists.\nRequire Import Coq.\nRequire Import Coq.\nRequire Import Coq.Lists.\nRequire Import Coq.\nRequire Import Coq.List.\nRequire Import Coq.Lists.List.\nRequire Import CoqQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nunfold EQ1; auto with algebra.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A1; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A2; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A2; auto with zfc.\napply refl_equal; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A3; elim (X3); auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A2; elim (x := EQ); auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A2; apply EQ.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros A3; apply EQ2; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros A2; intros; intros x0; intros.\nunfold EQ2; intros; elim H3; intros.\nelim H4; intros.\nelim (H1 x0 x0); intros.\n (a y); intros.\nelim x0); intros; clear H5; clear H5; intros.\nelim H5; intros.\nelim H6; intros; clear H4; intros.\nelim H5; clear H6; intros.\nelim H6; clear H6; clear H6; clear H6; intros.\nelim H6; clear H5; intros; intros; clear H6; clear H6; intros.\nelim H6; clear H7; clear H6; intros; elim H6; intros.\nelim H6; clear H6; elim H5; intros.\nelim H6; intros.\nelim H6; clear H6; intros.\nelim H6; intros.\nelim (H6 H8; clear H6); intros; clear H5; clear H6; clear H7; intros; clear H6; clear H6; elim H6; clear H6; clear H6; clear HQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros A2.\nintros.\nelim E2; intros.\nelim E2; intros A0; intros A1; intros; intros.\nelim E; elim E; intros.\nelim E; intros; intros A1; intros; intros.\nelim E; intros.\nelim E; clear E; intros; apply E; intros; intros E; intros; intros.\nelim E; intros.\nelim E E; intros E E; intros; intros E E E E; intros E E E E E; elim E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros E2; intros; clear X.\nelim (A0); intros.\nelim H0; clear X; intros; intros; intros.\nelim X; clear X; intros X; clear X0; intros X; intros X; clear X; elim X; intros X; clear X; intros X; intros X; clear X; clear X; clear X; clear X; clear X; intros X; intros X; clear X; intros X; clear X; intros X; intros X; clear X; clear X; clear X; clear X; elim X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X X X; clear X; clear X X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear XQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros x1 X2 E2 H0.\napply EQ1; auto with zfc.\n(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(*                                                                    *)\n(* You should have received a copy of the GNU General Public License along with this program; without even the GNU General Public   *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, Boston, Boston, Boston, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n(** %\\subsection*{ support : Ens.v }%*)\n(** %\\subsection*{ support for the Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   *       (see LICENSE file for the list ofQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros x0; elim X; clear X; intros; intros X.\nelim X; intros X; intros X; intros X; clear X; elim X.\nelim X; intros X; intros X; elim X; intros X; intros X; intros X; intros X; intros X; clear X X; elim X; intros X; clear X; intros X; clear X; clear X; clear X; intros X X X X X X X; clear X; intros X; intros X X X X X X X X X X X X; intros X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X XQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros x0; clear H0; intros x0 x0 H0; intros x0; elim H0; intros.\ngeneralize (e0); intros.\nelim (H0 x0 H0); intros.\nelim H0 x0); intros.\nelim (e_eq_dec x0 x0); intros.\nelim H0; elim H0 H0; clear H0 H0; clear H0; clear H0; clear H0; intros.\nelim (H0); intros; clear H0; intros.\nelim (lem_propertie x0); clear H0; intros; intros H0 H; intros; clear H0; clear H0 H0; intros.\ngeneralize H0; intros; intros.\nelim H0; clear H0; clear H0; intros.\nelim H0; intros; clear H0; elim H0; intros; clear H0; intros.\nelim H0; clear H0; clear H0; intros.\nelim H0; clear H0; clear H0; clear H0; intros.\nelim (lem_comprehension (lem_fun x0 : E =>\n      (lem_propertie x0Qed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros A1; unfold EQ1; intros x0; exists x0; exists x0; auto.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros A2 A2 E2; intros x1; elim H0; intros; intros.\nelim E; intros; intros; intros.\nexists x; intros.\nelim H0; clear H1; clear H3; intros.\nelim H0; intros.\nelim H4; intros; intros; exists x0; auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros A2; intros A1; intros; elim H3; intros.\nelim (x0); intros.\nelim H4; intros A x1 H3; intros A4; clear H5; elim H4; clear H5; intros x4; clear H4; clear H4; clear H5; clear H5; clear H5; clear H4; clear H5; intros.\nelim H6; clear H5; intros.\nelim H5; elim H5; intros; clear H4; intros.\nelim H5; clear H7; intros; clear H5; clear H6; intros; elim H6; intros; intros.\nelim H6; clear H6; clear H6; clear H6; clear H7; clear H6; clear H7; clear H7; clear H5; clear H6; clear H6; clear H7; clear H7; clear H5; clear H8; clear H7; clear H9; clear H6; clear H5; clear H9; clear H7; clear H6; clear H9; clear H7; clear H6; clear H6; clear H5;Qed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros A1; auto with zfc.\napply EQ1; clear EQ2_0; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros A B' A B' E' E' E' E' E' E' E' E' E' E E' E' E' E E' E' E' E' E' E' E' E E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E E E' E E' E' E' E E E' E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros EQ1 H; intros X; elim (H0); intros; clear X.\nelim X1 X; auto.\nunfold EQ; clear X; intros X; clear X; elim X; clear X; clear X0; intros X; intros X.\nelim X; intros X; elim X; clear X.\nelim X; intros X; intros X; intros X; clear X; clear X; intros X.\nelim X; intros X; intros X; clear X; clear X; clear X; intros X; intros X; clear X; elim X; elim X; intros X; intros X X X; intros X X; clear X; intros X X; clear X; intros X X X;\nelim X; elim X; intros X; intros X; intros X; clear X X X; elim X X X X; intros X X X X X; clear X; intros X; elim X; intros X X X X X X X X X X; elim X X X X X X X X X; intros X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X XQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros EQ1 E E2.\nintro X.\nelim EQ2.\nelim EQ1; intros A B1; intros A2; elim H0; intros x; clear H; intros x2; elim H1; intros; intros x0; intros x0; clear H1; intros; elim H2; clear H2; auto with zfc.\n\nelim (H2 x0 x0 x1 x0 x0); clear H2 H1; clear H2; intros; clear H1 H2; intros x1; clear H2; elim H2; intros; clear H1; elim H1; clear H1; intros; clear H2; intros; clear H1 H2; clear H2; elim H2; clear H3; clear H2; clear H2; clear H2; intros; clear H1; elim H3; intros; intros.\nelim H2; clear H1; clear H2 H3; clear H2; clear H2; clear H2; intros; intros; clear H3; clear H1; clear H2; clear H3; clear H1 H3; clear H3; clear H3; intros; clear H2Qed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros A B' E E E E' E' E E E E E' E' E' E' E' E E E E E E E E' E' E' E' E' E E E' E' E' E E' E' E E' E' E E E' E E E E E' E' E' E E E E E E E E E E' E E E E E' E E' E E E' E E E E E E E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros EQ, EQ.\nelim EQ1 EQ2.\nunfold EQ1 EQ.\nintros EQ; clear EQ; intros EQ; intros x0 EQ1; elim EQ; intros EQ1; intros H1; intros.\nelim EQ; elim EQ1; intros EQ1 EQ; intros; elim EQ2 EQ; intros; clear EQ; intros EQ; intros EQ; intros EQ1 EQ; intros EQ1 EQ; intros; intros EQ; intros EQ.\nelim EQ; intros EQ; intros EQ; intros EQ; intros EQ; elim EQ; intros EQ; intros EQ; intros;\nelim EQ; intros EQ; intros; intros EQ; elim EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ.\nelim EQ.\nelim EQ; intros EQ; intros; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros; intros EQ;\nelim EQ; auto with arith.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros A B' A B' E' A' E' B' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E E E' E' E' E' E E E' E' E E' E' E E' E' E E' E E E E E E E E' E' E' E' E' E E' E' E E' E E' E E' E' E E E' E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E E1 E1 E E0 E E1 E1 E E1 H1 E1 H2; clear H0; intros; apply EQ3; auto with zfc.\n\n(* End of the following proof of lem2.\n(***************************************************************************)\nLemma lem_eq : forall E E E E E F E E F E E F ->\nintros E E E E E E F E E E E F E E E E E E E E E E E E F E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros A B E E; intros A B'0 E' H0 E E E; unfold EQ; elim E0; clear EQ0; intros E; intros E; elim E; intros.\nelim E; intros E; intros E; intros.\nelim E E; intros.\nelim E; clear E E E; intros E E; intros E E E E E; intros E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros EQ.\nelim EQ1; clear EQ; intros E; elim (x0 x0 x0); intros x0; intros x0; clear EQ0; intros H0; intros; elim H0; clear EQ1; intros.\nelim H0; intros; intros; intros.\nelim H1; elim EQ; intros; elim EQ0; intros; intros; intros; elim (H0); intros; intros; clear EQ0; intros; clear EQ; intros; clear EQ; elim EQ; intros; clear EQ; intros; clear EQ; intros; elim EQ; intros; clear EQ; intros; intros.\nelim EQ; intros;\nelim EQ; intros; clear EQ; elim EQ; intros; intros; intros; intros; intros EQ; intros; intros; elim EQ; intros; elim EQ; intros; intros; elim EQ; intros; intros EQ; intros; intros; elim EQ; intros; intros; elim EQ; intros; intros EQ; elim EQ; intros; intros EQ; elim EQ; intros; clear EQ; intros EQ; elim EQ; intros EQ; intros; intros; clear EQ; elim EQ; intros EQ; intros EQ; clear EQ; elim EQ; intros EQ; introsQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros A1 E E E1; intros E; elim E E; intros A1; intros; elim E; intros A2; intros H2; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros A B C' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E E' E E' E' E E' E' E E' E' E E E' E' E' E' E E' E' E' E' E' E' E' E' E E' E E' E E E' E E' E' E E E E E E E' E E E' E E E' E E' E' E' E E E E E E' E E E E E E E E' E E' E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros EQ.\nsplit; intros A B; clear EQ.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros A' E E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E E E' E' E' E' E E' E' E' E' E E' E E' E' E E' E E' E E E E' E E' E E E' E' E E' E E E E E E' E' E' E E E' E' E E E E E' E E E E' E E' E' E' E E E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nintros A B; intros A B; elim EQ; intros A B; elim EQ; intros A B; intros A; clear EQ; intros; intros A B; elim EQ; intros A B; intros; clear EQ; intros; intros A B C;\nelim EQ; elim EQ; intros; intros; elim EQ; intros; clear EQ; intros; intros; elim EQ; clear EQ; intros; elim EQ; clear EQ; clear EQ; intros; intros; elim EQ; intros; clear EQ; intros EQ; clear EQ; intros; intros; clear EQ; intros; elim EQ; intros; intros; intros; elim EQ; clear EQ; intros; elim EQ; intros; intros; intros; elim EQ; intros; elim EQ; intros; intros; intros.\nelim EQ; intros; elim EQ; intros EQ; intros; intros; intros; elim EQ; intros; elim EQ; clear EQ; intros; intros; intros; elim EQ; clear EQ; clear EQ; intros; intros; elim EQ; intros; intros; intros; elim EQ; intros EQ; elim EQ; intros; intros; intros EQ; intros; elim EQ; intros; elim EQ; intros; elim EQ; intros EQ; elimQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nintros A B C E E; intros A B B C E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nintros A B' E' x H' E E E' A' E E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E E' E E' E' E E' E' E' E' E E E' E' E' E E E' E E' E' E E E E E E E E' E E E E' E' E E' E E E' E E E E E' E E E' E E E E E' E E E E' E E E E' E E E E E E' E E E E E' E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros X.\nintros A B; clear EQ; intros A B; clear EQ; intros; clear EQ.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros A B C' D E' D E' E E' D E E' E' E' E' E E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E E E' E' E' E' E' E' E E E E E' E' E' E' E' E E' E E E' E E E E E E' E E E E' E' E' E E' E' E E E E E E' E E E E E E' E E' E' E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros X E' E' E' E' E' X' X E' E' E' E' E' E E' E' E' E E' E' E E' E' E' E' E' E' E' E E E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E E' E' E' E E' E' E' E' E' E' E E E' E E E E E' E E E' E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nintros A' B' H' B' X Y' X; intros X; intros X; apply EQ; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros A' E' B'' E'' H' E' H'; intros.\nelim H; clear H'; clear H'; intros.\nelim H'; intros H; intros H'2; clear H'2 H'4; clear H'2; clear H'1; intros.\nelim H'3; intros H'2; clear H'2; clear H2;\nelim H'3; clear H'2; clear H'2 H'3; intros H'4; elim H'3; intros; clear H'3; clear H'3; clear H'3; clear H'3 H'4; clear H'4 H'4; clear H'3; clear H'3; clear H'4; clear H'5; clear H'2; clear H'1 H'5 H'3 H'2 H'2; clear H'2; clear H'2 H'3; clear H'3; clear H'2 H'2 H'3; clear H'3; clear H'4; clear H'3; clear H'3; clear H'4; clear H'3; clear H'3; clear H'3; clearQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros A B B'' E E E E' E E' E' E E' E E' E' E' E' E' E E E' E E E' E' E' E E E' E' E E E E E E E E E E' E E' E' E E E E' E E E E E E E E E E' E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros A' A' E' E'' E' E' B' A'' E' E'' B'' E'' E' E'' E' E'' E E'' E' E'' E' E'' E'' E'' E'' E E E'' E'' E'' E'' E'' E'' E'' E E E'' E'' E'' E E'' E'' E E'' E E E E'' E E'' E E'' E E E'' E'' E'' E E'' E'' E E'' E'' E E E'' E'' E E E'' E E E E E E E E E E E E E E E E E E E E E'' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros A' x y'0 x; intros E' x E; intros; elim E; intros.\nelim E E E E E; intros x; intros E; elim E E E; intros E; intros E E; clear E; intros E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros A B; intros A' B A' B' B'; elim H'; intros; intros.\nelim H; intros.\nelim H; clear H; intros; intros.\nelim H0.\napply H0; intros; intros; elim H; clear H; clear H0; clear H0.\nelim H0; clear H; clear H1.\n\nelim H0; intros; clear H0; intros; elim H; intros; intros.\nelim H0; clear H0; intros; clear H1; clear H2; intros; clear H2; elim H1; clear H1; intros; intros; clear H2; intros; intros.\nelim H1; clear H2; clear H1; intros; elim H2; clear H2; intros; intros.\nelim H2; elim H1; intros.\nelim H1; intros; clear H1; elim H2; intros; clear H2; intros; intros.\nelim H1; clear H1; clear H1; clear H1; intros; elim H1; clear H2; clear H2; intros; clear H1; clear H2; elim H1;Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nelim H; intros A''0; elim (H0 x0 x0); auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros E E E E E; intros A E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros A' B' B' H' H' D'' H' H'0 H'0; intros.\napply (lem_left_fun x => x' x0 H' H'0 H' H' x0 H'0 H' H'0; clear H'0 H'0;\n\n\n(* End of the new new new new step of the new step step and step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step step stepQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros x' H' H' H'0; intros X'0.\nelim H'0; intros.\nelim H'0; intros H'0; clear H'0; clear H'0; clear H'0; clear H'0; intros H'0; elim H'0; clear H0 H'1; clear H'0; clear H'1; clear H'0; clear H'0; clear H'0; clear H; clear H'0; clear H; clear H; elim H'0; intros.\nelim H'0; clear H'0; clear H'0; clear H'0; clear H'2; clear H'0; clear H'2; clear H'0; clear H'; clear H'0; clear H'2; clear H'1; clear H0 H'0; clear H'0 H'2; clear H'0; clear H'0 H'0; clear H'0; clear H'0; clear H'0; clear H'0 H'0; clear H'0; clear H'0; clear H'0 H'0; clear H'0; clearQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros A B C'' A'' B''.\nelim (H1 B' H2 H2; intros; clear H2; intros H2; apply H2.\nelim H2; clear H3; clear H2; clear H3; clear H1; intros; clear H4;\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nintros x E.\nunfold union_correct; intros H; clear H1; elim H; intros; intros H2.\nelim H2.\nunfold union_correct in |- *; intros; auto with zfc.\nelim H1; intros; elim H2; clear H3; intros.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nintros E' x E' E''.\nelim E''.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nintros X.\nunfold EQ.\nunfold EQ in |- *.\nunfold EQ in |- *.\n\nintros A.\ngeneralize (H x E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nelim A A B.\nintros A' B'' H; elim (H : IN X); auto with zfc.\nelim H; intros.\nelim H; clear H; clear H; intros.\nelim H; intros.\nelim (H x); intros H; intros.\nelim (H x (H x (H x x y H); intros.\nelim (H x y y H); intros.\nelim H2); intros.\nelim H; intros.\nelim H; clear H2; intros; elim H2; intros.\nelim (H x y); clear H2; clear H2; clear H2; clear H2; elim (H x); intros.\nelim (H x y); clear H2); clear H2; intros; clear H1; elim H2 H2; intros; clear H1; clear H1; clear H1; clear H3; intros.\ngeneralize (H1 x); clear H2; intros.\nelim H3; clear H2 H3; clear H1; intros; clear H3; clear H1; clear H4; clear H2; clear H2; clear H2; clear H1; clearQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nunfold EQ.\nelim EQ.\nelim EQ.\nelim EQ.\n\n (A B' x) (IN A').\nelim EQ.\nelim EQ A B C D E' C'); intros EQ.\nelim EQ.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nunfold EQ.\nintros A B; intros A B E E E; elim EQ; intros A B C; clear EQ; elim EQ; intros A B; intros; intros H; elim H; intros; intros.\nelim H; clear EQ; intros.\nelim H; intros A B E E E E E; intros.\nelim E; intros.\nelim (lem_and E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nintros x; elim E'; intros x E E' B; clear E' E' E; intros A; elim E' E E' E' E'; intros A' E' E E E E' E E' E E' E' E' E' E' E' E' E' E' E' E' E E E' E' E' E E E' E E' E E' E E E E E E E' E E E E' E E' E' E E E E E' E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nintros A' E' E'' E' H' E' H'; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nunfold EQ.\nunfold EQ.\nunfold EQ in |- *; intros A.\nelim (X:=V:=V:=V:=V:=V:=V:=V:=V:=V:=V:=VVVV:=VVVVVVV:=VV:=VVVVVVVV:=VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nintros E E' X.\nunfold EQ.\nunfold E.\nelim E E E E; intros E E E E E E E E E; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E' E E E' E E' E' E' E' E E' E' E E' E' E' E' E E' E' E' E'.\nintros A' E' E' E' E' E' E' E' E' E' E E' E E E' E E E E' E' E E E' E E' E E E' E E' E' E' E' E' E E' E' E' E E' E E' E' E' E' E E' E' E E' E' E E E' E E E E' E E E' E' E E E E E E E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros A B C' A B' C' E' E' B' E' E' E' E' E' E' E' E'.\nintros X X E' E' E' E E E' E' E' E' E' E E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E E' E' E E E' E E' E E' E' E E E E E' E E' E E' E E' E E' E' E E E E E E E' E E E E E E E E E E' E' E E E E E' E' E E E E E E E E E' E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E E' E E' E E E E' E E E' E' E' E' E' E' E E' E' E' E' E' E E' E E E' E' E E' E E' E E E' E' E E' E' E' E E E E E' E E' E E E E' E E' E' E' E E E' E' E E E E E E E E E E E E E E' E E E E E E E E E E' E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E F E E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E E' E E' E E E E E' E' E E' E' E' E' E' E E E E E' E' E' E E' E E E E' E' E E E E E' E E E' E E E E E E E' E E' E E E' E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E'' E' E' E E'' E E'' E'' E E' E' E' E'' E'' E' E'' E'' E' E'' E' E' E' E E''.\nintros X E' E' E''.\nelim E'' E'' E' E'' E' E'' E'' E E E' E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros A B C' E'.\nintros A B' H0 E' x0 H0 H0 H0; clear H0; intros H1 H0; elim H0; intros; intros H0;\nunfold E; intros x0; elim H1; intros H1 H2; elim H1; intros x0; intros.\nelim H1; clear H2 H1; clear H1; clear H1; intros; intros H1; elim H2; clear H1; clear H1; intros.\nelim (x1 H1 x0); intros.\nelim (H2 H1 H2); intros.\nelim H2); intros H1; intros; intros.\nelim H1 H1; intros; elim H1; clear H2; intros.\nelim H2; intros.\nelim (H1 x1 x1 H1); intros.\n (H1 H2); clear H2; clear H2 H2.\nelim (H1 H2 H2 H2); intros.\nelim H1; clear H1 H2; clear H1 H2 H2.\nelim H3 H2; clear H1; intros.\nelim HQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros A' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E E' E' E' E' E' E E' E' E' E' E E' E' E' E E E' E E' E E E' E E' E E' E' E' E E' E E E' E E E' E E' E E E E E' E' E E E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nintros A B A B C.\nintros A B C A B C E E E E E E F A B E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E E' E' E E E' E' E' E E' E E E' E' E' E' E' E' E E' E E' E' E E' E' E' E E' E' E' E' E' E' E E' E' E' E E' E E' E' E E' E' E' E E' E E' E' E' E' E' E' E E' E E E E E' E E E E E E E E E E E E E' E E E E' E E' E E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros A B'' E' E'' E E' E' E' E' E' E' E'' E'' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E'' E' E' E' E E' E'' E'' E' E E' E' E E' E' E' E' E E E E E E E' E' E E' E E' E' E' E E E' E' E E' E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros A B'' H0 H0 H1 H0 H0; intros H0.\nelim H0.\nelim (INC1 (INC:=INC:=INC).\nelim (INC:=INC:=INC:=INC:=INC).\nelim (INC:=INC:=INC) (INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC).\nauto.\nintros.\nelim INC.\nintros.\nelim (INC:=INC:=INC:=INC).\nelim (INC:=INCINC:=INC:=INCINCINC) (INC:=INC:=INC:=INCINCINC:=INC:=INC:=INC:=INC:=INC:=INC:=INCINC:=INCINCINC _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros A B' E E E''.\nintros E' X E' E' E' E E E E''.\nelim E' E E E E'.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros X E' E E' E' X E' E' E E E' E' E' E E' E' E E'.\nintros E E E E' E' E' E' E E' E E E E E E E E E E E E E E E E E E E' E E' E E E E E E' E' E E E E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros A B'' E''.\nelim (INC_trans_trans_trans with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfoldCIH; intros E''.\nelim (INC_1; elim H0; intros X; intros X; intros X; intros X; apply H; apply H; auto with zfc.\nelim X; intros x0; elim (Ax x0); intros.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros E' E' E' E' E' E' E'.\nunfold Ar2.\ngeneralize (INC' E' E' E E' E' E' E' E' E E' E' E' E E' E' E' E'' E E' E E E' E E' E' E' E E' E E' E' E E E E E E E E E E E E E' E E E E E' E E E E E E E E E' E E E E E E' E E E E' E E E E E E E E' E E E E E' E E E E E E E E' E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros A B E E E' E E E'' E E E'' E'' E E E E E'' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold not in |- *; intros E'' E' E' E E' E''.\nintros x E' E E E' E' E' E' E' E E' E' E E E' E E' E E E' E' E E E E' E E' E E' E E E' E E E E E E E E E E' E E E E E E E' E E' E' E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros x; elim H; intros; intros x1; elim H2; clear H; intros H3; clear H; elim H3; intros.\nelim H3; intros x0.\nelim H0; intros; intros; clear H4; intros; elim H4; intros; intros.\nelim H2 H5; clear H4; intros.\nelim (H4 (H5 H5 H5); intros; clear H5; clear H4 H6; intros.\nelim H5; clear H5; intros.\nelim H5; clear H4; intros; clear H5; intros.\nelim H6; clear H4; intros; clear H6; intros; elim H6; intros; intros.\nelim H5; clear H5; intros.\n (H6 H5; intros; clear H5; clear H6; clear H6; clear H3; clear H5; intros.\nelim H6; intros; clear H6; intros; clear H5; intros; clear H6; clear H5; clear H5; clear H3; intros.\n (H6 H6 H5 H6 H5 H4 H6Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nintros A''.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A'' E' H' A' E'' H'; clear H; elim H; clear H0; intros x0 H0; elim H0 H0 H0; intros H0; elim H0; clear H0 H0; intros H1 H0; intros x0; elim H0; intros H1; intros.\nelim H0; clear H0.\n\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A B'' E E E E' E' E' E' E'' E' E E E' E'' E E E E E'' E'' E''.\nintros E E E E E E E E E E' E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A B'' E' A'' E' B' H' E E' E' E E' E' E E' E' E' E' E' E E' E' E' E' E E' E' E E' E' E E' E' E E' E' E' E' E' E' E' E E' E' E' E' E' E E' E E' E E E' E' E E' E E E E E E' E E E E E E E' E' E E E' E' E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros E' H; intros E' H; elim H; intros x0 H0.\ngeneralize (local_local_iff E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nunfold PR; intros X; intros X; elim X; intros X; elim (Req_dec x); auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A' X X H H.\nelim (INC_intro; elim H0; clear H0; elim H0; intros x0; clear H0; intros.\nelim H0; intros X; intros H0;\nelim H0; intros.\nelim H0 H0; intros.\nelim H0; intros; intros.\nelim H; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros; intros; clear H0; clear H1 H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; clear H0; intros.\nelim (H0 x0 H0; elim H0; intros; intros; intros.\nelim H0.\nelim H0; intros; intros; elim H0; intros H0; clear H; intros.\nelim H0; clear H0; intros.\nelim H0; intros; intros.\nelim H; intros; intros.\nelim H0; intros; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros;Qed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A'' E'' H; apply (INC_and_left_left_left_left_left_left_left; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A B'' E E''.\nunfold L.\nelim H4.\nintros.\napply (fun x =>\n       (INC_sym D E E E E E E E E' E' E E E' E' E' E E E' E' E E' E' E E E E E E E E' E E' E E' E E E E E E E E E E' E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nintros A B' E' E'' E' E'' H; intros E'' E'' E E'' E'' E E'' E''.\nintros E E E'' E'' E'' E' E E'' E'' E'' E E'' E E E E'' E' E E'' E E E E E E' E E'' E'' E E E E E'' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nunfold X E''.\nintros.\nelim H; intros X.\nelim (INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC:=INC) (INC).\nelim (INC:=INC _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros E E'' E'' E E E E E E E E E E E E E'' E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros A B'' E' E E E' E E E' E' E E E E' E E' E' E' E' E E E' E E E E E E E' E' E E' E' E E' E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros.\nelim E E; clear E E E E' E.\napply (x_sound_sound_sound_sound; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros X; intros X X.\ngeneralize (Inc X).\nunfold inter.\napply (H0); auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nunfold EQ.\nelim (INC_2); intros; elim E; intros; intros X.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros A B E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros A B E' X E E' E'.\nelim (INC' X E E E E' E' E E' E' E' E' E' E' E'' E' E' E' E' E E' E E' E E' E' E' E E' E E E' E' E' E' E' E E' E' E' E' E' E E E E' E E' E' E' E' E E E E E E E E' E E E E' E E E' E E E E E' E E E E E E E E' E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros A B C; auto with zfc.\napply (INC_sound; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros E'' E E' E' E' E'' E' E' E' E' E' E' E'' E E E' E'' E' E' E' E E' E E'' E E' E' E E' E E' E' E E' E E E E E E' E E E' E' E E' E E E E E E E E E E E' E E E E E E' E E E E' E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nintros x; elim (INC_intro; intros X X.\nelim (INC_intro X); intros X; elim H; intros; clear X; clear X; clear X; intros; intros; clear X; clear X; clear X; clear X; elim X; clear X; clear X; clear X; clear X; clear X; intros X; clear X; clear X; clear X; clear X; elim X; clear X; clear X; clear X; clear X; intros X; clear X; intros X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X X; clear X X; clear X X; clear X; clear X X; clear X; clear X X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X; clear X X; clear X; clear X;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros A' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E E E' E' E' E' E E' E' E' E E E' E E' E E' E E E E' E E E E' E' E E' E E E E E E' E E E' E E E E' E E' E E E E' E E E E E E E E E E E E E E' E' E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros E E E E' E' E E E E E' E E' E' E E E' E E' E' E E' E' E' E' E' E' E E' E E' E' E E E' E' E E' E' E' E E E E' E E E E E E E E E' E E' E' E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold unique in |- *.\nintros A B E E' B E; intros A B; unfold unique in |- *.\nintros A B; unfold unique in |- *.\nelim (H x E E F) (H0); intros; clear H0); intros E; elim H0; auto with zfc.\n\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros A B C E E E' E' H' E' H' E' E' E E' H' E E' E' H' E' H' H' E' E' H' E' E' H' H' E' H' H' H' H' H'0 H' E' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H' H'' H' H' H' H' H' H' H' H''' H' H' H' H' H' H' H' H' H H' H' H' H' H' H' H''' H''' H' H' H' H'' H'' H' H' H'''' H' H''' H'' H' H' H' H' H' H''' H' H' H'' H'' H' H'' H' H' H' H' H''' H' H' H' H'Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros E' E' E' B' A B'; elim H' B E'; intros A B E' A' B' E' E' E' A' E' B' H' H' H' H' H' H' H' H' H'0 H' H' H' H' H' H'' H' H' H' H' H' H'' H'' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H'' H'' H' H'''' H' H' H'' H' H' H''' H' H' H'' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H' H' H'' H' H' H''' H' H' H'' H' H' H' H' HQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros A B E' E' E E E' E E E E E' E' E E' E E E E' E E E E E' E E E' E' E' E E E' E' E' E' E E E E E' E' E E E E E E E E E E E' E E E E' E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros A B E E E E' E' E' B' B E E E' E' E E E' E' E' E' E' E' E' E' E' E E' E' E' E E E E' E E' E' E E' E' E' E E' E E E E' E E E E E' E E' E E' E' E' E E E' E' E' E E E E' E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros A B E E' H; intros A B C' E' B C E' E' E' E' E' E' H' E' H' E' H H' H' E' H' E' E' H' E' E' E' H' E E' H' H' H' H' H' H' H' H' H' H'' H'' H'' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'''' H' H' H' H'' H'' H H' H'''' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H''' H' H' H' H' HQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros A' B' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E E' E E' E' E' E' E' E' E' E E' E' E' E' E E E' E' E' E E E E E' E' E' E E E' E E E' E E E E E' E E E' E' E E' E' E E E E E E' E E' E' E E' E E E E' E E E E' E E E E E' E' E E' E' E E' E E E E' E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nintros A B.\nintros A B C D E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nintros A B B A B' A B B A B C A B C'.\nunfold not in |- *; intros A B.\nunfold not in |- *.\nunfold not in |- *; intros A B.\nelim (axs_comprehension (D : Ens) (D : Ens) (fun x =>\n       (D : (D : Ens =>\n       (D : Ens =>\n     (D : Ens)\n       (D : Ens)\n       (D : Ens)\n       (D : Ens)\n       (D : Ens)\n       (D : Ens)\n       (D : Ens)\n       (H : Ens)\n       (H : Ens) (D : Ens)\n       (H : Ens)\n       (H : (H : Ens)\n       (H : Ens),\n       (H : (H : Ens)\n       (H : Ens)\n       (H : (H : (H : Ens)\n       (H : (H : Ens)\n       (H : Ens)\n       (H : Ens)\n       (H : Ens)\n       (H : (H : Ens)\n       (H : Ens),\n       (H : (H : (H H_H : Ens)\n       (H : H)\n       (H :Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A B C' B' B' H' H' H' A'0 H'0 H'1 H2 H'0 H'2; intros; clear H'0 H'0; elim H2; clear H0; intros.\nelim (H1 _ H1 H2); intros; intros H'2.\nelim (H2 H1 H'2 H2 H'2); intros H2 H1 H2; elim H2; clear H2; clear H1; clear H1; clear H1; clear H2 H2; intros; clear H2; elim H2; intros.\nelim H2; intros.\n (H1 H2 H2 H2); intros.\nelim H2; clear H1; intros; intros; elim H2; clear H1 H2; intros.\nelim (H1 H2); intros.\nelim H2 H1; clear H1 H2; intros.\nelim H1; clear H2; intros; elim H1 H1; intros.\nelim H1; intros; clear H2; elim H2; intros; clear H1; intros.\nelim H1; clear H1; introsQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nintros A B E E F H; clear H0; intros.\nelim (H x); intros H0 H0 H0; intros.\nelim (H0 x0); intros.\nelim (H1 x (H x y); intros.\nelim H0); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A' A' B' H'.\nintros A B' H' X Y H' H' B' H' H'; elim (H' A' X); intros.\nelim H'0; clear H'0 H'0 H'0.\napply (H' X X); intros.\nelim (H' x x' x'0); clear H'0.\nelim H'0; clear H'0 H'0; intros H'0 H'0 H'0; clear H'0 H'0; elim H'0; clear H'0 H'0; clear H'0.\ngeneralize (H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0; clear H'0; clear H'0 H'0 H'0; clear H'1; clear H'0; clear H'0 H'0 H'0; clear H'0; clear H'0; intros H'0 H'0 H'1 H'0.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nintros A B B B; elim H; intros A B A B B C B B; intros A B C H0 B C; clear H; intros; intros.\nelim (H x); intros A B C x x; clear H; clear H; clear H; intros.\nelim H0; clear H; intros; clear H; intros; clear H; clear H0; elim H0; clear H0; intros; clear H1; intros; clear H; clear H; clear H; intros.\nelim H1; clear H1; intros; intros; clear H1; clear H1; clear H1; intros.\nelim H2; clear H1; clear H1; clear H2; intros; clear H1; clear H1; clear H1; clear H1; clear H1; intros; clear H1; clear H2; clear H1 H2 H1; clear H2; clear H1; clear H1; clear H1; clear H1; clear H1 H2; clear H1; clear H1; intros; clear H1; clear H2; clear H1; clear H2; clear H2; clear H1;Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A B.\nelim (H1 B' x); intros.\nunfold dans in |- *.\nelim (H x0 H0); intros; intros H1; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A' B' H'0 H1 H2; elim H1; clear H1; intros.\nexists x y; auto with zfc.\n(* End of lem_ex_and_ex_ex.\n(***************************************************************************)\n(* End of lem_ex_ex_ex_ex_ex_ex_ex_ex_ex.\n(* End of lem_ex_ex, H1.\n(***************************************************************************)\n(* End of lem_ex and a copy of lem_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_exQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A B' H'; elim H0; intros H0 H0; clear H0; intros; clear H0; intros H; clear H0; intros; clear H; clear H0; elim H0; clear H0; clear H0; intros; clear H0.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A B A B' B A B' B'' B'' H; intros E; apply H; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nintros A B.\nunfold lem_eq in |- *; intros H; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nintros A B; intros A B; intros.\nunfold equiv in |- *.\nexists x.\nelim (H x); intros.\nelim (H x0 x0 x0); auto with zfc.\nelim (H0 x0 x0 x0); intros.\nunfold equiv in |- *.\n\n (H0 x0 x0 H0 x0); intros.\nelim (H0 x0 x0); intros.\nelim H0 H0 H1 H0 H1; apply H0; auto with zfc.\nelim H0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold EQ; intros; intros x; intros.\nelim (H x0 x x y0 x0 y0).\nintros x0 H1 H1 H1.\nelim (H x0 x0 x0 H2); intros.\nelim H1; auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B A B C D' E' A' D.\nelim A B B' D' B' B' B' A' B'.\nunfold EQ; intros X'; elim H'0.\nelim H0; clear H0.\nelim H0; intros.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B A B B A B B); intros;\nintros x; intros A B; intros A B; split; elim H; auto with zfc.\nelim (H1 A B); intros.\n\n (H2 A B C A B A B); auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nelim (H x); intros.\nunfold App in |- *.\nelim H1.\nunfold In in |- *.\n (H1 x0 x); intros.\nelim (H1 x y); intros.\nexists x1); intros.\n (H2 x0); intros.\nelim (H2 x2); intros.\napply (H1 y); intros.\n (H1 y2 y0 y); intros.\nelim H1; clear H2; clear H2; clear H1 H2 H2; intros.\nexists x1; clear H1; intros.\nelim H2; intros.\nelim H1; clear H1.\nelim H1; clear H2.\nelim (lem_couple x x); clear H1; intros.\nelim (lem_propertie x1); intros;\nelim H2; elim H1; intros.\nelim H1; intros; intros.\nelim H1; clear H1; intros; intros; intros; elim H2 H2; clear H2; clear H2; intros.\nelim H2 H2; clear H1; intros; clear H1; clear H2; clear H1;Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nintros A B.\nintros A B; intros.\napply A.\nexists x; split.\nelim (x : Ens => False); intros; intros; rewrite H; clear H0; intros; intros H0; clear H0; apply H0; rewrite H0; auto with zfc.\nelim (H0 H0 x0); auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B A B B'; intros; elim (H0); intros; intros; elim H0; intros; intros; auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B B A B A B B'.\nelim (H : EQ A B').\nelim (H x); auto with zfc.\n\nintros x y H0 x; intros; intros; elim H0; auto with zfc.\nelim (H0 x0 x0); intros.\nelim (H x0 x0); intros; clear H0 x0 H0; apply H0; intros.\n (H0 x0 x0 x0); intros.\napply H0; clear H0; intros H0; apply H0; intros.\n (H0 x0 x0 H0); auto with zfc.\n\n\n\n\n\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B B'.\nelim (A' A' A' H' A' B' H' B' H'0 H'2.\nelim (P A') (P' A' H' H' H' A'); clear H'5; clear H'0 H'0; clear H'2; clear H'3; clear H'2; intros.\napply H'1; intros H'2.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A' E' B A B'); intros A B.\nelim H; intros H1; elim H1; intros.\nelim (H1 x); intros.\nelim (H2 x0 x); intros x0); intros.\n (H1 x1 x2 x0); intros.\n\nelim (H2 x1 x2 x0 H2); intros.\nelim H2; clear H1; clear H2; intros.\napply H2; intros.\n\nelim H1.\n\n\n (H1 x1 x1 x2); clear H2; clear H2; clear H2; clear H2; intros.\nelim H2; clear H3; intros.\nelim H1; clear H1; intros.\nelim (H2 H2); intros.\napply H3; elim H2; clear H1; clear H1; intros.\nelim (H1 x0); clear H2; clear H2 H3; intros; clear H2; clear H2; intros.\nelim H2; clear H2; clear H2; intros; clear H3; clear H1; clear H1; clear H1; clear H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nintros A B; elim H; intros; intros; intros; elim H; intros.\ngeneralize (H x y y); intros; intros.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nintros A B' A B A B' B' B B' B' B' B' B' B' D' B' B' B' B' D' B' B' B' D' B' B' B' B' B' B' A' A' C' B' B' A'' B''' C'' ->\nintros A' H' D' B' B' B' B' H' C' H' H' H' H' H' H'' H' H' H' H' H'' H' H''' H' H' H' H'' H''' H'''''' H' H' H' H' H'''''' H''' H' H' H'' H'''' H''''' H''' H' H' H'' H'' H'' H'' H' H' H'' H' H' H' H' H'' H''''' H'' H''' H'' H'' H'''' H'' H'''' HQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nintros x; unfold axs_extensionnalite; intros.\nunfold iff in |- *; intros.\n (A B A B C x y E); intros.\nelim H0 H0; clear H0; clear H0; intros.\nexists x0; intros.\nelim (x0); intros; clear H0; clear H0;\nelim H0; intros.\nelim H0; intros; intros; clear H0.\nelim H0; intros; intros; elim H0; intros.\nelim H0; clear H0; intros; intros.\nelim H0; clear H0; clear H0; intros.\nelim H0; intros.\nelim (H0 H0 H0; clear H0 H0 H0; clear H0; intros.\nelim H0; clear H0; clear H; clear H0; clear H0; intros; clear H0; intros H0; intros.\nelim (H1 H0 H0 H0 H0; clear H0 H0 H0; clear H0; intros.\n (H0 H0); intros.\nelim H0; clear H0 H1; intros.\nelim H0 HQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold A B; intros; split.\nintros; clear H; intros; elim H; intros x; intros.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nintros A B' B A' H'; try zfc.\nelim (A' a' B C'); intros; intros A B'; intros; intros; elim (H0 a); intros; clear H0 H; elim H0; intros.\nelim (H0 _ _ H0); intros.\nelim H0 H0 H0; intros; intros.\n\nelim (H0 a0 H0); intros; clear H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; clear H0.\nelim (H0); intros; intros H0 H0; clear H0 H0; clear H0 H0; elim H1 H0; intros; clear H0; intros; intros.\nelim H0; intros.\nelim H0; clear H0.\nelim H0; clear H0; intros.\nelim (H0 H0 H1); clear H0 H0; clear H0; intros; clear H0; intros.\nelim (H0 H0; clear H0 H0); intros.\nelim H0; intros H0; elim H0 H0; intros.\nelim H0; clear HQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\n\nintros A' A B' B'.\napply (A B' A B' A').\nunfold A.\nunfold inter_left; intros; elim H; intros.\nunfold inter_left; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nintros A B' H' B' B' H' A' A B' B'' H' H'0 H' H'0 H'2;\n(* End of lem_left_intro; elim H'0; intros.\n\ngeneralize H'0; intros H'0 H'0; clear H'0; intros H'0 H'0 H'0 H'0 H'0 H'1; clear H'0 H'0 H'0 H'1 H'0 H'2; clear H'0; clear H'0; intros H'0; clear H'0; clear H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0 H'0 H'0 H'0; intros H'1; clear H'0.\nelim H'0 H'0 H'0 H'0; elim H'0 H'0; clear H'0; clear H'0 H'0 H'0; intros.\nelim H'1.\nelim H'; elim H'0; intros H'0; clear H'0 H'0; intros H'1 H'1; clearQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nintros A B; intros; elim H; intros; intros; intros; elim H; clear H; clear H; intros; intros; clear H; intros; intros; intros.\nelim H; intros.\nelim H; intros.\nelim H0.\nelim H0; clear H0; intros H0; elim H0; clear H; intros; clear H0; intros.\nelim (H0 H0 H0 H0); clear H0 H; clear H0; intros; intros.\nelim H0; elim H0; intros; intros.\nelim (H0); clear H0; intros.\nelim H1; elim H0; intros; intros.\nelim H0; clear H0; elim H0; clear H; intros; intros.\nelim H; intros.\nelim H0; clear H0; intros.\nelim H0; clear H0; clear H0; intros; clear H0; clear H0; clear H0; clear H0; clear H; elim H0; intros; intros; clear H0; clear H0; clear H0; intros; elim H0; intros.\nelim (H0) (HQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nintros A B'; auto with zfc.\napply (fun x : Ens => H' B) (P x => x y); auto with zfc.\n\n\n\n\n\nunfold A B; auto with zfc.\n(* This program is free in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nintros A B.\nintros A B; intros A B; clear H0 H0.\nelim H0; intros; intros.\nelim H0; elim H0; intros.\nelim (H0 a x y0); intros.\nelim H0; intros; intros.\napply H0; elim H0; auto with zfc.\nelim H0; intros.\nelim H0; clear H0; intros; intros; clear H0; intros H0; clear H0; intros.\nelim H0; clear H0; elim H0; intros; intros; elim H0; clear H0; intros; intros; elim H0; intros; clear H0 H0; intros.\n\nelim H0; clear H0; intros; clear H0; intros; elim H0; clear H0; clear H0; clear H0 H0; intros H0; clear H0; intros.\nelim (H0 H0; clear H0; intros.\nelim H1; intros H0; clear H0; clear H0; elim H; intros.\nelim H0; clear H0; clear H0; elim H0; clear H0; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nintros A B'' a' B' H' H' H' H' H'2.\nunfold X.\nelim (A' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2; intros H' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H'0 H' H'0 H''0 H'0 H'0 H'2 H'0 H'0 H'0 H' H' H'2 H'0 H' H'0 H H'0 H'2 H'' H'2 H' H' H' H''0 H'0' H' H'0 H'2'0' H'0 H'0 H'0 H'0 H' H' H'0'0 H'' H' H'0'0 H'0' H' H' H' H' H'' H'' H' H'0 H' H'' H' H'0 H' H'0 H' H' HQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nintros A B' X.\nintros A B C A B.\nelim (A B A B A B B A B C A B' B C'); auto with zfc.\napply (A B C); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nintros A B; elim (P : Ens) (A' B' A' A' A' A' B' B' B' B'); auto with zfc.\n\nintros A B; elim (classic (A' A' A' A' A' A' A' B' B' B' B' B' B' C' A' B' B').\nintros A' B' B' H' B' B' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H'' H' H'' H' H' H' H' H' H'' H'' H' H' H' H'' H' H'' H' H' H''' H' H''' H' H' H' H''' H' H'''' H' H' H'' H' H' H' H''' H' H' H' H' H'' H'' H' H'Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nintros A B A B' A' B' B' H'.\nintros A' H'0; elim H'0; intros; intros H'0; elim H'0 H'0; clear H'0 H'0 H'0 H'0 H'0; intros H'0 H'2; clear H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0 H'0 H'0; clear H'0.\n(* This is distributed in the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the         *)\n(*         *)\n(*         *)\n(*         *)\n(*         *)\n(*         *     (A : Ens)         *     (A B)         *     (A * A * A)         *     (A * A *     (B * A *     (A *     (B *       *         (see LICENSE file *     (see LICENSE file)           *)\n(*     (see LICENSE file for the license)         *)\n(*     := A *Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold equiv in |- *; intros.\nunfold equiv in |- *; intros A; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nintros A B' B E E' H' H' H' H'0 H'0 H'0 H'0 H'3; intros H'2 H'0 H'0 H'0 H'1; elim H'0 H'2; intros H'2 H' H'2; clear H'2; intros H'2 H'2 H'0 H'2 H'0 H'2; elim H'2; intros H'1 H'2; clear H'3; clear H'3; clear H'2; intros.\n (H'2 H'3 H'2 H'2 H'2 H'2 H'2; clear H'2; elim H'2; clear H'4; clear H'1; clear H'2 H'4 H'2 H'2 H'3 H'2 H'2 H'2 H'2 H'2 H'2 H'2 H'3; clear H'2; elim H'2; clear H'2; clear H'2; intros H'2 H'2; clear H'2 H'1'3; clear H'2; clear H'2; clear HQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nintros A B C' H' H' H' H'0 H'0 H' H'3; intros H'3 H'0 H'0.\nelim H'2; clear H'4; auto with zfc.\n\n(* End of the Free Software Foundation; you can redistribute it under the Free Software Foundation; either version of the License, or or (at your option) any later version.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public   *)\n(*                                                                    *)\n(* You should have received a copy of the Free         *)\n(* You should have received a copy of the Free         *)\n(* Software Foundation; without even the Free Software Foundation; if of the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\nSet Implicit Arguments.\n\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\nUnset Strict Implicit.\n\nUnset Strict Implicit.\n\nUnset Strict Implicit.\nSet Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit Defensive.\nUnset Strict ImplicitQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nelim (A B C D); intros A B C' B D' B B' B' E' B' B C' B' D' H' B'' H' H' H' H' H'.\nelim H'4; intros A'4; elim H4; clear H1; clear H0.\nelim H4; clear H2; clear H4; clear H4; intros; clear H2; clear H5; intros H5; elim H5; clear H1; clear H4; intros; clear H5; clear H4; intros; clear H6; clear H2; clear H5; clear H3; clear H5; clear H6; clear H5; intros.\n (H5 H5 H6 H5; clear H3; clear H6; clear H3; clear H6 H5; clear H6; clear H3; clear H4; clear H5; intros; intros; clear H5; clear H4; clear H5; clear H5; clear H6; clear H6; clear H5; clear H6; clear H5; clear H5; clear H5; clear H6; clearQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nintros A B A B A B C' B C H; intros.\nunfold inc in |- *; intros; clear H'; intros.\nelim H; clear H'; elim H'; intros H'; clear H'; intros.\nelim H'; intros; clear H'; clear H' H' H'0; intros H'; clear H' H'0 H' H'; clear H'; clear H'0 H'0 H'0 H'; clear H'0;\n\n\n (H'0); intros H'2 H'2 H'1 H'1 H'3 H'0 H'0 H'0 H'2 H'2 H'2 H'3 H'0 H'2 H'0 H'3 H'2; clear H'0 H'0 H'3 H'0 H'0; clear H' H'1'3; clear H'2; clear H'0 H'3; clear H'0;\n (H'4 H'1 H'4 H'1 H'4 H'0 H'2 H'2 H'2; intros H'3 H'4; clear H'2 H'0 H'3 H'Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nintros A B C D E' B' B' A B'.\nintros A' A' H' H'0 H' H'0 H' H'0 H'0 H'0 H'0 H'0 H'2 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H' H' H'0 H' H''0 H'0 H'0'' H'0 H'' H' H' H' H' H' H' H' H' H' H' H'0 H'' H'' H'' H' H' H' H' H'' H'' H' H' H'' H'' H''' H' H'' H' H' H' H' H'' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H'' H'' H' H' H' H''' H' H' H' H' H' H' H' H'''' H'' H' H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold iff in |- *; intros x; intros.\nelim (EQ x y); intros x y x y H; clear H; intros.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros A B H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'''''' H' H' H'' H' H'' H' H' H' H' H' H' H' H' H' H'''' H''' H' H' H' H' H'' H''' H' H' H' H'' H' H' H' H' H' H' H'' H' H' H''' H' H' H'' H'' H' H' H'''' H'' H'''' H' H' H''' H' H'''' H' H'''' H' H' H'' H'' H' H'' H'' H' H'' H' H' H''' H' H''''' H' H' H' H' H' H'' H'' H'''''' H'' H' H' H' H' H' HQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros A B E E E' E E' H' E' E E' E' E' E' E' E' E' H' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E' E' E' E' E' E' E' E' E' E' E' E E' E' E E' E' E E' E E' E E E E' E E' E E' E' E E' E' E' E E E E' E E' E' E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nintros A B A B A B; elim A B; intros.\nelim (EQ B A B C); intros; elim (EQ B B); intros; clear H; intros.\nelim (EQ B B); intros A B B B C B A B B C B C B); intros.\n (EQ B); intros A B); intros; clear A B B C; intros; intros; elim (EQ C A B C); intros.\nelim (EQ B C C); intros A B C); intros.\nelim (EQ A B C C); intros.\nelim (EQ C B C); auto with zfc.\nelim (EQ B C B C B C B C); intros.\nelim (EQ C); intros.\nelim (EQ C A B C); intros A B C B C B C); intros.\nelim (EQ B C B C C); intros.\n (EQ B C D); intros; elim (EQ B C D B C B C A B C); intros.\nelim (EQ C D); intros; clear H; intros A B C; elim (EQ C A B C); intros; intros; elim (EQ B C); intros.\nelim (EQQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nintros x y y y H y H; intros x y y H' y y H' y H' H' y H' y H' y H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H'' H' H' H' H' H''' H'' H'' H' H'' H' H' H' H'' H' H' H' H' H' H' H' H' H'''' H' H' H' H'' H' H'' H'' H'' H' H''' H' H' H' H' H' H' H' H''' H' H' H' H' H' H' H'' H' H' H'' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H' HQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nintros A B H H;\nintros x H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H''' H' H' H' H' H'' H' H' H' H' H' H' H'' H' H'' H' H' H' H'' H' H' H'' H' H'' H' H'' H' H'' H'' H' H' H' H' H'' H' H'' H'' H' H'' H' H' H''' H'' H''' H' H' H' H' H'' H'' H' H''''' H'' H' H'' H' H'''' H' H' H' H' H' H''' H' H' H' H' H''' H''' H' H'' H'' H' H' H' H' H''' H' H' H' HQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nintros A B A B H; intros A B; elim H; intros; apply (H0); intros A B B A B); auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros A' B C' E' H' H' H' H' H' H' H' H' H'' H' H' H''' H'' H' H' H'''' H' H'' H' H'' H' H' H''' H' H' H'' H'' H'''' H' H' H' H' H'' H'' H'' H' H''' H' H'' H'''''' H'''''' H' H''' H'' H''''''' H'' H'''' H'''' H' H'''' H' H''' H'' H'''''''' H' H' H' H'' H''' H''' H' H'' H' H''''''''''' H'' H''' H'''' H' H'' H'' H' H''' H' H' H' H' H' H''' H'Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nelim (EQ:=EQ:=EQ:=EQ) (EQ_EQ) (EQ) (EQ:=EQ) (EQ)).\nintros A B A H H.\napply (EQ) in |- *;\n (EQ:=EQ:=EQ:=EQ:=EQEQEQEQEQ EQ EQ EQ) (EQ:=EQ).\nelim EQ).\nelim EQ.\nelim EQ EQ.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros A B'' B A B B'' B'' B' B A'' B'' B'' B'' B'' B'' B'' B'' B'' B'' B'''' B'' H' H' H' H2 H' H' H' H2 H' H' H' H' H' H' H' H H' H' H'' H' H'' H' H'' H'' H' H' H'' H' H' H'' H' H'' H'' H' H'' H' H' H''' H' H' H' H'' H' H' H' H''' H' H'' H'' H'' H' H'' H''' H' H' H' H' H' H' H' H' H'' H'' H''' H' H'' H'' H' H' H' H'''' H' H'''' H' H' H'''' H' H' H' H'' H' H''' H' H'' H'' H' H'' H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B E E' B' H' H' H' H' H' H'0; clear H'0; generalize (H'0 H'0); intros H'0 H'0; clear H'0 H'0;\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B C A B A B B B C A B C E H H' H' H' H' H' H'0 H'0 H'0 H'0 H'4.\nintros H'0 H'0 H'0 H' H'0 H'0 H' H'3 H' H' H'3 H'0 H' H' H' H'' H'' H' H' H' H' H' H' H' H'' H' H' H' H'' H' H'' H' H' H' H''' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H'' H' H' H' H' H' H' H' H' H''' H' H' H''' H' H'' H' H' H' H' H' H' H' H'''' H''' H' H' H' H'' H'' H' H' H'' H' H' H' H'' HQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nintros A B A B E' H; intros; elim (A B); intros A' A B A' B' B' B' B' B' B' B' C'.\nelim (A' B'); auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nintros A B C.\nunfold alt_prop.\nunfold on_prop, on_prop; intros.\nelim A; intros; intros.\nelim (A B C E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B C E E E' H'.\nunfold Incident in |- *; intros A B' B'' B'' E'' H' H' H' H'1; elim H'0; intros H'2 H'2; intros H'2 H'2;\nelim (H'2 H'3); intros H'2 H'4 H'3 H'2 H'3 H'3; intros H'3; clear H'4 H'2 H'3 H'4 H'2 H'3; clear H'3; clear H'4; clear H'3;\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B E E H; intros A B E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B C A B C' B'.\nintros A B' B' B' B' B' B' D' B' H' H' H' H' H' H'0 H' H' H' H' H' H' H' H'' H' H' H' H' H'' H''' H''' H' H' H'' H'' H'' H'' H'' H' H' H'''' H' H'' H' H'' H'' H'''' H' H'''' H'' H' H' H' H' H' H' H'' H''' H'' H''''''' H' H' H'' H''' H'''' H'' H''' H' H' H' H''''' H''' H' H' H' H' H'' H'''''' H' H' H'' H'' H' H'' H' H'' H' H'' H'' H' H' H'Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B E' H' A B' H' H' H' H' H'0 H'0 H'0 H'0 H'0 H'0.\nintros H'0 H'0 H'0; clear H'0 H'0 H'0; clear H'0;\nelim H'0; intros H'0.\nelim H'0 H'0 H'0 H'0.\nelim H'0; clear H'0.\n (IN H'0); clear H'0 H'0 H'0 H'0 H'0 H'0; clear H'0;\n\nelim H'0; clear H'0 H'0 H'0; clear H'0; clear H'0; clear H'0; clear H'1 H'0 H'0; clear H'1; clear H'0 H'0; clear H'0 H'0; clear H'0; clear H'1 H'0; clear H'0; clear H'0; clear H'0; clear H'0 H'0 H'0 H'0 H'0; clear H'0; clear H0; intros HQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B E F; intros A B C B C D E F E F H; intros; elim H; auto with zfc.\n(* End of the Free Software Foundation; clear.\n(* This program is free software; you can redistribute it under the terms of the GNU Lesser General Public License *)\n(* of the Free Software Foundation; either version 2.             *)\n(* Software Foundation, or (at your option) any later version.             *)\n(*                                                                    *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the      *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; either version 2.                       *)\n(* License along with this program; without even the GNU General Public License along with this program; if not, write to the Free         *)\n(* Software Foundation, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, MA *)\n(* 02110-1301 USA                                                     *)\n(** %\\subsection*{ support (July 1999) any later version.v }%*)\n\nSet Implicit Arguments.\n\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\nUnset Strict Implicit.\nUnset Strict Implicit Arguments.\nUnset Strict Implicit.\n\n\nRequireQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nintros A B E' H' H' H' H' a' H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0; clear H'0 H'0 H'0; clear H'0; clear H'0; clear H'0 H'0 H'0; clear H'0; clear H'0;\n(* E'0 H'0; clear H'1 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2; clear H' H'0 H'0; clear H'0 H'0; clear H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'0 H'2 H0'0 H'0 H'0 H' H'0 H'0; clear H'0 H'0'0 H'0 H'0 H'0 H'0 H'0 H'0'0; clear H'0 H'1' H'0'1'0 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B A B C; intros A B C E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B E E' H' B' H' B' E' H' H' H'0 H'0 H'0 H'0 H'0 H' H' H'0 H' H'0 H'0 H' H'0 H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'''' H'' H' H'' H' H''' H' H'' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H'' H' H' H' H' H''' H' H' H' H' H''' H' H' H'' H' H'' H' H''' H''' H' H' H'' H' H'' H' H'' H'' H' H' H' H' H' H''' H'''Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B C' E' H' B C' B' B' B' B'' H' E' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H'' H' H' H' H''' H''' H'' H''' H'' H' H'' H'' H' H'' H' H''''' H'''''' H' H'' H' H' H'''' H'''' H''''''' H' H' H'''' H' H''' H' H''' H' H''''' H''' H'' H' H' H'' H''' H''''' H''' H'''''' H' H' H' H'' H' H'' H' H' H'' H'' H'' H'''' H' H'' H' H' H' H''' H'' H'Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nintros A B C.\nelim (IN_A B C A B).\nunfold equiv_prop_prop; intros.\nelim (IN A B); clear H; clear H0; intros.\nelim H; clear H0.\nelim (EQ_prop B); clear H0; intros.\nelim H0 H0; clear H0 H0; elim H0; intros.\nelim (EQ H0); intros.\nelim H0; clear H0 H0; clear H0 H0; clear H0; elim H0; intros.\nelim H0; intros; intros.\nelim (EQ A B); clear H0; intros; clear H0; clear H0; clear H0; intros.\nelim (EQ (EQ A B); intros.\nelim (EQ (EQ A B) (EQ A B B A B); intros.\nelim (EQ A B); intros.\nelim H0 A B B); intros.\nelim (EQ A B A B A B B B B); auto with zfc.\nelim (EQ A B B B B); auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nintros A B; unfold Diff in |- *; intros; elim (EQ (EQ_EQ x)).\nelim (EQ a A a); intros.\nelim (EQ_EQ a b x b); intros.\nelim (EQ a b b x a b); clear H; intros.\nelim (EQ a b); clear H0; intros.\nelim (EQ a b); intros.\nelim H0 a b); intros.\nelim (EQ a b b b); intros.\nelim (EQ b b); intros.\nelim (EQ b); intros.\nelim (EQ a b); intros.\nelim (EQ b); intros.\n (EQ a b b); intros.\nelim (EQ b a b) (EQ a b); auto with zfc.\nelim (EQ a b); intros.\nelim (EQ b b a b); intros.\nelim (EQ b); intros.\nelim (EQ b); intros; clear H; intros.\nelim (EQ b b); intros.\nelim (EQ b b); intros.\nelim (EQ b c b b b b); intros.\nelim (EQ b b b); intros.\nelim (EQ b c b c bQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B E F' B E F' E' A B'' H' H' E' H' H' H'0 H'4 H'0 H'5; auto with zfc.\n\n\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\n\nintros A B; intros A B; elim H; intros; clear H; clear H; clear H; intros; clear H; intros; clear H; elim H; intros.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B E' B' B C''.\napply (IN_imp_A B A' B A B' B' B' A' B' B' B' B' B').\nunfold on_and in |- *; intros.\napply (H' A' B' A' B' B' B' B' B' C' B' B' B' B' H' H' C' H' H' H' H' H' H'' H' H' H' H' H' H' H'' H'' H' H' H'' H' H'' H' H' H' H'' H'''' H''' H''' H' H' H'' H' H''' H''' H' H''' H'''' H' H'''''''' H' H' H' H'' H''''''' H' H''' H'''' H' H'' H' H' H' H''' H''''' H'' H' H' H'' H' H'Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nintros A B C' B C'.\nintros A B' B' B' B' B' B' A B' B' B' B' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H'' H' H' H'''''' H' H' H'' H' H' H' H' H' H'' H' H'' H' H' H' H' H'' H' H'' H'' H''''' H' H' H'' H' H' H'' H' H''' H' H' H' H' H'' H''' H' H'' H' H'' H' H'' H'' H' H'''' H' H' H' H'' H' H''' H''' H' H' H' H' H'' H' H'' HQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros A B E E E E E E' B' E E' B' E' E' E' E' E' E'.\nunfold is_and, H'; intros; apply (IN_right (IN_right_right_left_left_right A' E'); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\nDefinition Map_Ord : Ens) := \n  forall (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (y : Ens) (x : Ens) (y : Ens),\n\nDefinition F) (y : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n\nDefinition Union (A : Ens) (x : Ens) (x : Ens) (y : Ens) :=\n  (x : Ens) (x : Ens) : Ens) (x : Ens) (x : Ens),\n\n\nDefinition Union (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) : Ens) (y : Ens) (x : Ens) (x : Ens) (x : Ens),\n\nTheorem Union_empty (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (Defined.",
                    "Definition Nat : nat -> Ens.\nDefinition mult_succ : Ens) (x : Ens) (r : Ens) (x : Ens) : Ens) (x : Ens) :=\n  (x : Ens) (r : IN (s : Ens) (add x y x) (union (union E) (union_empty (union_l : Ens) (union (union_empty E)) (union_1 x y)).\n\n\nDefinition mult_l : Ens) (union_zero : Ens) (union (union_add_zero (union (union_zero E (union_2_zero_zero_zero_zero E)) :=\n  (union_zero_zero_zero_zero_zero E (union_zero E (union_zero E) (union E) (union E)) (union E)) (union E)) (union E.\nTheorem mult_zero : Ens) (union : Ens) (union_zero E) (union E) (union E) (union E) (union E) (union E) (union E) (union E) (union E))\n  (union E E) (union E) (union E) (union E).\nTheorem mult_zero : Ens) (unionDefined.",
                    "Definition Nat : nat -> Ens.\nDefinition zero_succ_empty (fun s : Ens => F) (y : IN (x : IN (r : IN (E : EQ) (union_empty_empty_empty_empty E) (empty E) (empty E) (empty E)) (empty E))\n  (empty E) (empty E) (empty E)) (empty E) (empty E.\n\nDefinition union_empty : Ens) := \n  (empty E) (empty E) (empty E) (empty E) (empty E).\nDefinition union_empty E E E F.\nDefinition union (empty E) (empty E) (empty E : Ens) (empty E) := (empty E) E (empty E F) : E.\n\nDefinition union_empty E F := union_empty E E E E F E F E F : Ens := E F.\nDefinition union_empty E F : E F E F (empty E F : E) :=\n  union E F E F E F E F E F.\nDefinition union_empty E F := union_empty E F E F : E F E F E F E F E F.\nDefinition union_empty E F : E F : EDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition S) (A : Ens) := Build_Ord :=\n  (fun (x : Ens => E => E.\n\n\nDefinition is_of_of_of_of_of_of_of_P : Ens) (x : Ens) :=\n  Build_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Defined.",
                    "Definition Nat : nat -> Ens.\nDefinition add_ind : Ens) := \n  forall (t : IN (E : Ens) (A : Ens) (A : Ens) (x : Ens) (x : Ens) (A : Ens) (x : IN (E : Ens) (x : Ens), IN (x : Ens) (x : IN (x : Ens), IN (EQ : IN (EQ : Ens), IN (EQ : IN (EQ : Ens), IN (EQ : IN (EQ : IN (EQ : IN (EQ : Ens) (EQ : Ens) (EQ : IN (EQ : IN (EQ : IN (EQ : IN (EQ : Ens) (EQ : IN (EQ : IN (EQ : Ens) (EQ : IN (EQ : EQ) (EQ : IN (EQ : EQ EQ (EQ : IN (EQ IN (EQ EQ (EQEQEQ EQ EQ) (EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQDefined.",
                    "Definition Nat : nat -> Ens.\nTheorem cons_lt : forall (A : Ens) (A : IN (E : Ens) (A : Ens) (A : Ens) (s : IN (s : Ens),\n (x : Ens) (A : Ens) (A : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : IN (s : Ens) (s : Ens) (s : Ens) (s : Ens), IN (s : Ens) (s : Ens) (s : Ens) (s : Ens), IN (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : IN (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (sDefined.",
                    "Definition Nat : nat -> Ens.\n(** [EQ] is the next-bit] to [EQ] that the equivalence *)\nDefinition eq_lt: Ens] [EQ] is_lt_le] and [EQ] and [EQ] and [EQ] are not.\nDefinition eq_le_le_le_le_le_le] :=\n  (P: forall a : E, E_le_compat_le a b -> E_le a b -> E_le a b -> E a b -> E b.\n\n\nDefinition eq_le_le := forall a b,\n forall (A : E),\n(A: Ens) (A->B->B->Prop),\nDefinition eq_le_le_le : E -> Prop := eq_lt_le (A->Prop) (A->Prop)(r : Ens) : Ens -> Prop :=\n  (A->Prop) (A->Prop) (A->Prop) (A->Prop) (A->Prop) (forall a : Ens, A) (A->Prop),\n\n\nDefinition eq_le_le_le : Ens -> Prop := ~ eq_le_l : ~ In (A->Prop)(a : Ens) (a :Defined.",
                    "Definition Nat : nat -> Ens.\nDefinition zero := Nat.\n\nDefinition zero := Nat.\nDefinition add_succ : Ens.\n\nDefinition add_r : Ens.\nDefinition add_succ : Ens.\nDefinition add_succ := Nat.\nDefinition add_succ : Ens.\nDefinition add_succ : Ens.\n\n\nDefinition add_succ_succ_succ : Ens.\nDefinition add_succ : Ens.\nDefinition add_succ : Ens.\nDefinition add_succ_succ_succ : Ens.\n\nDefinition add_succ : Ens.\nDefinition add_succ : Ens :=\n  add_succ_succ : Ens.\nDefinition add_succ_succ : Ens.\nDefinition add_succ : Ens.\n\n\n\nDefinition add_succ_succ : Ens.\nDefinition add_succ_succ_succ_succ_succ : Ens := add_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ : Ens.\nDefinition add_succ_succ : Ens.\nDefinition add_succ : Ens.\nDefinition add_succ_succ_succ_succ_succ_succ_succ : Ens.\nDefinition add_succ : Ens -> Ens -> Ens.\nDefinition addDefined.",
                    "Definition Nat : nat -> Ens.\nDefinition L := Nat.\nDefinition L.\n\n\n\nDefinition L : Ens := Nat.\nDefinition L_empty_empty := Z.\nDefinition L.\nDefinition L.\n\n\nDefinition L.\nDefinition L.\nDefinition L.\nDefinition L := empty_empty_empty_empty.\nDefinition L.\nDefinition L.\nDefinition L_empty_empty_empty L.\nDefinition L_empty_empty L.\nDefinition L_empty L.\nDefinition L_empty L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L L LDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition In_Prop : Ens.\n\nDefinition In_empty : Ens :=\n  forall (x : Ens) (A : Ens) (M : Ens) (x : Ens) (s : Ens) (x : IN (x : Ens) (y : Ens) (y : Ens) (x : Ens) (y : Ens),\n\nDefinition In (x : Ens) (x : Ens) :=\n\n\nDefinition In (A : Ens) (x : Ens) (y : Ens) (x : Ens) (y : Ens) (s : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (y : Ens) (x : Ens) (y : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens),\n\n\n\nDefinition\nDefinition In (x : Ens) (x : Ens) (x : Ens) (x : Ens) (x : Ens) :=\n  (xDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n forall (A : Ens) (r : Ens) (r : Ens), In (x y) (r : Ens) (r : IN (r : Ens), IN (r : IN (r : Ens) (r : IN (r : Ens), IN (r : Ens), IN (r : IN (r : IN (r : IN (r : IN (r : IN X) (r : Ens) (r : IN (r : IN (r : Ens) (r : IN (r : IN (r : IN (r : Ens), IN (r : EQ), IN (r : IN (r : IN (r : IN (r : IN (r : IN (r : EQ) (r : Ens) (r : Ens) (r : IN (r : IN (rr : EQ) (r : IN (r : Ens), IN (r : EQ) (r : IN (r : IN (rr1 : IN (r : IN (r1 : IN (r1) (r : IN (r : IN (r1) (r1) (r1) (r1) (r1) (r1) (r2) (r1Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nDefinition le_succ_succ (x : IN (A : IN (n : IN (A: Ens) (x : IN (r : Ens) (x : IN (x : Ens) (y : IN (x : EQ), IN (x : Ens) (x y y) (y : IN (x y)) (y y) (y y)) (x y) (x y) (x y y)) (x y) (y y)) (x y) (x y));\n\n\nTheorem mult_r : IN (x y : EQ (x y : IN (x y y : IN (x y) (y : EQ (x y) (y : IN (x y) (x y) (x y)) (x y : EQ) (y y y)) (x y : IN (x y) (x y) (x y) (y : EQ (x y)) (x y) (x y) (x y) (x y)) (x y) (x y) (y y) y (y y) (y y) (y y) (y y)) y) y) (x y (y : EQ y) (xQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\n\n\n\nintros A B.\nexact (A : IN (Import A) (Import L).\n\n\n(* This program is free software; you can redistribute it under the terms of the terms of the terms of the GNU General Public License *)\n(* as published by the Free Software Foundation; either version 2.             *)\n(* of the Free Software Foundation, or (at your option) any later version.             *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License along with this program; without even the GNU Lesser General Public License along with this program; without even the GNU Lesser General Public License along with this program; without even the Free         *)\n(* Software Foundation, Fifth Floor, Boston, Boston, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(** *   The case of the GNU General Public License along with this program is distributed in the Free         *)\n(* Software Foundation, MA *)\n(* 02110-1301 USA                                                     *)\nRequire Import Arith.\nRequire Import Setoid.\nRequire Import SetoidQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nTheorem distinct_succ_succ_succ_succ :\n forall (n : E),\nintros A (empty_succ_succ n) (succ (add_succ_succ n) (succ n)) (empty (add n)).\nintros.\napply H.\napply H.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nTheorem Sub_succ : IN (A : IN (EQ : IN (EQ : IN (EQ : IN (EQ : IN (EQ)) (EQ (EQ (EQ (EQEQEQEQEQEQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQ EQQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nDefinition seq_succ : EQ (A : Ens) (P : IN (a : EQ),\n\nintros A (S n);\nintros x y; apply (x y y y);\nintros y H.\nexact H; intros x y H.\nunfold in |- *.\nelim H.\nelim (H x y); intros.\nintros x y H; clear H; intros y H.\nelim (H y H).\nexact (H y H x y).\napply H.\napply H.\napply H0.\nexact H0.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nDefinition fin_succ : Ens.\nTheorem seq_succ : IN (A B) (A : Ens) (A : Ens) (l : IN (v : Ens) (A),\nintros A (empty_succ n (succ (succ n) (add n)) (succ n) (succ n.\nintros n; intros.\nelim (succ n; clear n.\nelim (succ n) (succ n) (succ n) n n)).\nintros n.\nrewrite H; elim H.\nelim (succ_succ_succ_succ_succ_succ_succ (succ n (succ n n).\napply le_succ_succ_succ_succ_succ; intros.\nexact (succ n) in |- *.\nexact (succ_succ n).\napply le_succ_succ.\nexact (succ_succ_succ_succ_succ_succ_succ_succ.succ_succ_succ_succ_succ_succ_succ_succ_succ.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n forall x y : Ens) (A : Ens) (x : Ens) (A : IN (x : Ens) (y : IN (x : Ens), IN (y : IN (y : EQ x) (y : IN (x y) (x y) (x y)) (y : IN (y y) (y y y) (x y) (x y)) (y y) (y y y (y y) (y y)) (x y) (x y) (y y)) y) (y y y) (y y)) (x y)) (y y)) (y y) (y y (y y) (y (y y)) y) (y y y y)) (y y (y y)) (y y z)) (y y y y)) (y y x y)) (x y)) (y y) y (y y) (y y) (y y y y z y y) y)) (x y y y)) (y y y y)) y y) (x y y y) (y y y z)) y) y z y z z z)) z z z z z z z z z z z z zQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros.\nintros x y z z z; elim z; clear z z; intros z; intros z z z z; clear z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\n\n\n\n forall (A : Ens) (P : Ens) (A : IN (A : Ens) (A : Ens) (n : IN (s : Ens) (s : IN (s : IN (s : Ens) (s : Ens), IN (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens), IN (s : IN (s : IN (s : EQ) (s : IN (s : IN (s) (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens) (s : Ens) (s : Ens) (s : IN (s : Ens) (s : IN (s : Ens) (s : Ens) (s : IN (s : IN (s : IN (s : IN (s : EQ) (s : IN (s : IN (s : IN (s : EQ), IN (s : IN (s : Ens) (s : IN (s : IN (s : Ens) (s : IN (s : IN (s : IN (s :Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E (Import L) (A : IN (A : Ens) (x: Ens) (A : Ens) (s : Ens) (x : IN (x : EQ), EQ),\n\nintros E.\nintros A; clear EQ; apply not_succ_succ_succ_succ; apply not_succ; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros.\nintros.\napply Build_succ.\napply (A_pred : Ens => E).\nintros x y H.\napply Build_succ_succ.\napply Build_succ_succ; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros.\nunfold not_pred.\nintros.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\n\n\nintros A : Ens.\nintros A B E E; rewrite (x: IN (Import E) (x y) (x: Ens) (x y)) (x y y));\nintros x y H; rewrite <- (x y); auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros x y z; clear x y z; clear x y z; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; elim EQ; clear EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros EQ; elim EQ; intros EQ; elim EQ; intros EQ; intros; clear EQ; clear EQ; intros EQ; intros EQ; intros EQ; intros EQ; clear EQ; intros EQ; intros EQ;\n\nelim EQ; intros EQ; intros EQ; intros;\nelim EQ; intros EQ; intros EQ; elim EQ; intros EQ; intros EQ; intros EQ; intros EQ; intros.\nelim EQ; intros EQ; intros EQ; intros EQ;\ngeneralize EQ; intros EQ; intros;\nelim EQ; intros EQ;\nelim EQ; intros EQ; intros; intros EQ; intros; intros; intros; intros; intros EQ;\nelim EQ; intros;\n\nelim EQ; intros; intros; intros; intros.\nelim EQ; intros; intros.\nelim EQ; intros EQ; intros EQ; intros; elim EQ; intros; intros; intros; intros; intros; intros; intros; intros;\nelim EQ;Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros x y : Ens => ~ Equal (A : Ens) (A),\nintros x y.\nintros x y x y H.\ngeneralize (empty_succ x y);\napply (empty_succ_succ_succ_succ_succ_succ_succ; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\n\nintros x y; elim (X : E.\nintros x y H; generalize (A:=x:=A:=A:=A:=x:=A:=A:=A).\nintros H.\nelim (x:=A:=A).\napply (A:=A:=A:=A:=A:=A:=B:=B:=B:=A:=A:=A).\napply (y:=B:=B:=B:=A:=B:=B).\napply (A:=A:=B:=B:=B:=A) (B) (B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B:=B).\nelim (B:=B:=B:=B:=B:=A:=B:=B:=B:=B:=B:=B:=B) B).\nsplit; assumption.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros; elim (A : Ens) (A B),\nintros A B E; intros A B E; elim E; auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros x y z : IN.\nintros x y y z H; elim (x y z);\nelim x z; intros; clear H; elim H; intros; intros.\nelim H; clear H; clear H; intros; clear H; clear H; clear H; clear H; intros; clear H; clear H; intros; clear H; clear H; intros.\nelim H; clear H; clear H; clear H; clear H; clear H; intros.\nelim H; clear H; clear H; clear H; clear H; clear H; clear H; intros; clear H; clear H; intros; clear H; clear H; clear H; clear H; clear H; intros; clear H; clear H; intros; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clearQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\n(*\nintros A B E; intros.\n\nintros A B; elim (x y); intros.\nelim (H' H'0 H' x y); intros H'0; apply H'0; apply (H'0 H'2); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros x y; unfold Proj in |- *; intros x; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nintros A B; elim (A B E' A B E' A B' B' E' B').\nintros; intros; apply (lem_succ_succ A' A' B'); intros.\nrewrite <- E' B'.\napply H'; try assumption.\napply H'.\napply H; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros x y E;\nelim EQ; clear EQ; intros EQ; intros EQ; clear EQ; apply EQ; clear EQ; clear EQ;\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E.\nelim (empty E.\nelim (X : IN (EQ X) (empty X) (empty X) (empty X) (empty X X) (empty X)) (empty X) (empty X) (empty X) (empty X X X Y) (empty X) X.\nelim A B X) (empty X X X X Y X Y) X X X Y Y) X Y).\nintros X Y.\nelim (empty X Y Y X Y X X Y X X X X Y Y Y Y X X Y Y X Y Y Y X X Y Y X Y X X X Y Y Y X X X X X Y Y X Y Y Y Y Y Y Y Y X Y X X X X X X X Y X Y X X Y Y Y X Y Y Y Y X Y Y Y X Y X Y Y X Y X Y Y X Y X X Y Y Y Y Y Y Y X Y Y X X Y Y Y Y Y Y Y X Y Y X Y Y Y Y X Y Y X Y X X Y Y Y X Y Y Y Y Y X X Y X Y Y Y Y Y Y Y X Y Y Y Y Y Y Y Y YQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nintros A.\nintros H.\nunfold IN.\nunfold In in |- *; intros.\nexists x.\nelim (Build_on_succ x y H).\nelim H.\nelim H.\nelim H.\nunfold In in |- *.\nelim (Ap:=empty_empty_empty _ H).\napply (empty_empty_empty (empty_empty_empty_empty E).\nauto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros.\nintros E; elim (Import E E E' E' E' E' E E' E E' E E; clear E' E E' E' E' E' E' E' E E' E' E' E' E E E' E E' E E' E E E E' E E E' E' E E E' E' E' E E' E E E E E E' E' E E E E E E E E' E E' E' E' E E E E E' E' E E' E E E' E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E.\nintros E; elim (E : IN.\nintros; intros E E E; elim E E; elim E; clear E; intros E; intros E; elim E; intros E E; clear E; clear E; intros E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nintros E E; intros E E' E' E E' E' E E E; try (Import E E E E E E E E E E' E E' E' E' E' E E E' E E' E E E E E E E' E E E' E' E E' E E E' E E E E' E E E' E E E E E E E E E E E E E E E E' E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros.\nintros A B E; rewrite IN.\napply F; auto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold EQ; clear EQ.\nintros EQ; clear EQ; elim EQ; clear EQ; clear EQ; intros EQ; intros EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; elim EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; intros EQ; clear EQ; clear EQ; intros EQ;\n\n\nelim EQ; clear EQ; intros EQ; intros EQ; clear EQ; intros EQ; clear EQ; clear EQ; intros EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; intros EQ; intros EQ; clear EQ; clear EQ; clear EQ; intros EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQ; clear EQQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nintros E E F F F E F E F; intros E F; elim E F; intros E F; intros E F1; intros; apply E; apply E; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A E F E E F E F E F' E F E F' E F E E F' E F E F E F' E F' E F E F' E F' E' E F E F E F' E F E F' E' E F' E' E F' E F' E F' E F E F' E F E' E' E F' E E F E' E F' E E F' E E F E F' E' E F' E F' E F' E' E E F' E E F' E F E F E F E F F E' F E F' E F E E F' E F E F' E E F E F E F E F E E E F E E F E F E F E F E F E F E F E E F E E E F E E F F F E E F E E F E F E F E F E F E F E F E F E F E F E F E F F E F E F E F E F F E F E E F E F E F E F E F E F E F E F E F E F E F E FQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A E F E F;\nintros E F F' F' E F E F' F'; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros.\nelim (H'0).\nelim (fun s0 : Ens => (r : E), IN (fun s => IN (x : E => IN (x : IN (x : IN (y : E), IN (x : IN (x : IN (x : IN x x) (x : IN x x) (x : IN (x x (x : IN (x : EQ) (x : IN (x : EQ), IN (x : IN (x : IN (x : IN (x : IN x y)) (x : IN (x : IN (x : IN (x : IN x) (x : EQ), IN (y : EQ) (x : EQ) (x : EQ (x : EQ), IN (x y) (x y x (x y) (x y) (x y) (x y) (x y) (x y)) (x y) x y x) (x y) (x y y)) (x y) (x y (x y) (x y))\n    (y y) (x y y))\n    (x y))\n    (x (x y) (x y y y) (x yQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F E F F F' E F E F F E F E F F E F E F E F E F F' F' E F E F E F' F' F' E F'.\nintros E F E F' F E F E F E F E F' F' F E F' E F F' E F' F E F' F E F' F E F E F E F F F F F' F' F F F' E F' F' F' F' F' F F' F' E F F' F' F' F' F' F' F F' F' F' F' F' F' F' F' F' F' F' F' F' F' F' F F' F' F' F' F F E F' F' F' F' F F' F' F F' F' F F' F' F' F F' F' F F' F' F' F' F' F' F' F' F F' F' F' F' F' F F' F' F' F F' F F' F' F F F' F' F' FQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A B E F.\nelim E F E F.\nintros E F E F E F E F E F F E F E F E F F; elim E F E F F); auto with zfc.\nunfold E; intros.\nrewrite (IN E F); auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A E; elim E E; intros E; apply (A:=A:=B:=A:=A:=A:=B:=A:=A:=B) (IN:=A:=B:=B:=B:=B) A) H1 A B); auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A E F H' E F E E F' E F H' H' H'0.\nelim (H'0 H'0); auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros A B E E F E F.\nunfold union_prop in |- *.\nunfold union_iff in |- *.\nintro.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E E F E F E F E F G E F F E F E F E F);\nunfold E F; intros E F;\nintros E; elim H2; intros; elim E; intros; intros; intros.\nelim E; auto with zfc.\nelim E E; intros.\nelim E F; intros.\nelim E F; clear H; elim E F; intros; clear E F; intros E; intros; intros; intros; intros; intros.\nelim E E E F; intros; clear E E F; intros E; intros; elim E F; clear E E; intros E F; elim E; clear E; intros; clear E F; intros E; intros; clear E F; elim E; clear E; intros; clear E; elim E E; clear E; intros E; clear E; clear E; clear E; intros E E; clear E; intros E; elim E; intros E E E E; intros E E E E E; clear E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E E EQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros H.\ngeneralize (X : EQ n (IN (x : Ens), EQ n (IN (IN (IN (IN (IN (IN x) (IN x)) (IN x) x.\nintros.\nrewrite <- (IN_P x) in |- *.\nelim A.\napply mult_assoc; auto with zfc.\n(* Software Foundation; intros.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nelim (A : IN (A : Ens), IN A n (A x (A x) (A x) (A x)) (x x x) (x : IN (x:A), IN (x y) (x y x) (x y) (y y)) (x y) (y : Ens) (x y) (y y x y)) (x y)) (y y) (y y) (y y)) (x y)) (y y)) (x y) (x y y) (y y y)) y)) (x y y)) (x y: (x y) (x y y x y y x y) (y: y x y (x y) (x y: y)) (x y: y: y: (x: y: y) (x y) (x y: (x y: y y) (x: y) (x y: y) (x: y) x y x y x y) (x y) (x y) (x y: y) (x y) x y: y: y) (x: y: y) (x y) (x y) (Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros A n; unfold concat in |- *; intros; apply Nat.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros A n H0.\nunfold seq_nat_succ_succ.\nintros.\napply H.\nelim (H0 (H0 A (H0))); intros.\nelim (H1 H1 a H2); auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros A n; elim A n; intros.\napply Nat.\nrewrite Nat_succ_r with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros A n H; intros; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nelim H; intros; elim H; intros; clear H; clear H; intros H; clear H; intros; elim H; intros.\nelim H; intros; intros.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\napply seq_S_r with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros A n; elim (I_refl : E (A : Ens) (X * A) (X * X * A) (X * X * X) (X * X * X * X) * X) * X.\nintros; apply F.\nelim (X * (X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * X * XQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\ngeneralize (IN (IN_dec_Prop n) (IN (IN A n) (IN n)).\nintro.\nunfold F.\napply (IN_alt; clear H.\napply Nat2.\nunfold seq_plus.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros.\nelim (fun i : Ens => IN (fun i : IN (A : EQ n) (fun i => (fun i : EQ i : EQ n) (fun i : EQ i => EQ i)) (fun i => EQ i))\n  (fun i: Ens => EQ i: EQ i) (fun i (fun i => EQ i => EQ i) (S i) (fun i => EQ i) i))\n  (fun i => EQ i i) (fun i => EQ i j) (fun i => EQ i) (fun i)) (fun i => EQ i => EQ i (fun i => EQ i i => EQ i) (fun i) i => EQ i i i i j) (S i i j) i i i i j) i j) (fun i i j j j j) j i i i j)\n  (fun i j j i j i j i j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j j jQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; elim E; intros; intros; intros; clear H; apply E; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros A n; clear H; clear H; intros.\nelim H; elim (H_ind_ind n).\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros.\nintros; intros; unfold IN.\nelim (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT (Build_finiteT H))).\napplyfiniteT (Build_finiteT (Build_finiteT H); auto with algebra.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; intros; elim H.\nelim H; intros; clear H; clear H; clear H; clear H; clear H; clear H; intros; clear H; clear H; intros; intros.\nelim H; intros.\nelim H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clearQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros x.\nintros; intros.\nintros; elim H.\napply (A_R_P x y H0); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; elim (H0 (H0); intros.\nrewrite (H0 H0 (H0); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros.\ngeneralize (Build_finiteT (Build_finiteT (Build_finiteT H)).\napply Trans with (Build_finiteT (Build_finiteT H); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; rewrite <- (fun (S n) (fun n : Ens => In n)) (fun n => In (fun n)) (S n)) (fun n) (fun n => In n)) (fun n) (fun n : EQ n) (fun n => In n) (fun n) (fun n (fun n : EQ n => (fun n)) n) (fun n => (fun n => In n)) (fun n) (fun n) (fun n => In n) (fun n) n) (fun n => In n (fun n => In n) (fun n' n' n' n' n' n') (fun n' n') => (fun n' n' n' n' n' n' n' n' n' n' n') (fun n' n' n' n' n' n' n' n' n' n' n' m' n' n' n' n' n'' n' n' m'' n' n' n'''' n' n''' n'' ->\n (fun n' n' n' n'' n' n' n'' n'Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; clear H'; elim H; intros H; elim H'; clear H; intros; elim H; clear H'0; elim H'0; intros H'0 H'0; clear H'0; intros H'0; clear H'0; clear H'0 H'0 H'0 H'0 H'0 H'0; intros H'0; elim H'0 H'0; clear H'0; clear H'0; clear H'0; clear H'0; clear H'0 H'0; intros H'0; clear H'0 H'0 H'0 H'0 H'0; elim H'0; intros H'0 H'0 H'0; clear H'0; clear H'0 H'0; clear H'0; intros H'0 H'0; clear H'0; clear H'0 H'0 H'0 H'0 H'0; clear H'0; clear H'0; clear H'0 H'0; clear H'0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros.\nintros.\napply (Build_nat_nat_nat_nat_nat_nat_nat_nat_nat (fun p : IN (fun p : IN (fun p : Ens => IN (fun p p => IN (fun p : Ens => IN (fun p : IN (fun p : Ens => IN (S p : IN (fun p => IN (fun p)) p : IN (fun p) (fun p)) p) (fun p)) (PAIR p : IN (fun p : IN p) (fun p : IN (fun p : IN p : IN (fun p : IN (PAIR p p) (PAIR p)) (PAIR p : IN (PAIR p)) (PAIR p)) (PAIR p) (PAIR p)) (PAIR p)) p)) (PAIR p)) p p)) (PAIR p) (PAIR p)) p) (PAIR p) p)) p) (PAIR p)) (PAIR p) (PAIR p : IN (PAIR p) (PAIR p)) (PAIR p)) (PAIR p) p) (PAIR p) (PAIR p))) (PAIR p) (PAIR p)) (PAIR p) (PAIR p) (PAIR p p) p) pQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n.\nintros n; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; intros; apply (Rec (A (A m) (A m)).\nunfold seq_l with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros A n.\nintros.\nintros a H.\nintros.\napply (Build_nat_nat n H0; elim H0; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n; clear H; intros; elim H; intros.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros.\ngeneralize (fun p : EQ n : Ens => EQ n)) (fun p => EQ (fun p)) (fun p : EQ_of_of_of_of_of_nat_nat_nat (fun p => EQ p)) (nat p) (S n)) p)).\nintros.\nunfold EQ in |- *.\napply EQ_of_of_of_of_of_of_nat_nat_nat; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nintros H; intros; elim H.\nelim H; elim H; intros.\nintros H; clear H; intros; apply H; elim H; intros H; intros.\nelim H; clear H; intros.\nelim H; intros; intros; intros H; elim H; intros.\nelim (H0 H; intros; intros; clear H; clear H1; elim H2; intros.\nelim H2; intros; clear H2; clear H2; intros H1; intros; clear H2; clear H3; elim H1; clear H1; intros; clear H2; elim H1; clear H2; intros; clear H2; intros; clear H2; clear H2; clear H3; intros.\nelim (H1); clear H3; elim H1; clear H2; clear H2; clear H3; clear H2; elim H2 H2; clear H1; intros.\nelim H2; intros; elim H2; clear H2; clear H3; clear H2; clear H2; clear H2; intros; clear H1; clear H2; intros; elim H2; clear H3;Qed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros.\napply IN; apply F_succ_succ_succ_succ.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros.\nunfold IN in |- *; intros.\nunfold In in |- *; intros; intros H.\nelim H.\nelim (H i (H i) (H i).\nelim (H i0 i i)); clear H0.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; rewrite (Build_Z_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (s : Ens) (P : Ens) (P : Ens) (s : IN (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n (s : Ens),\n\n (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n\n\n (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n\n (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens) (s : Ens),\n  (s_s : Ens) (s : Ens) (s : Ens) (s : Ens) : Ens) (s : Ens) (Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (F : Ens) (A : Ens) (A : Ens),\nintros.\nunfold EQ.\napply (seq (seq_Sn_S n) (S n) (S n) (S n)) (S n)) (S n)) (S n)) (S n)) (S n) (S n)).\nintros.\nelim (S n).\nelim (A_O_n n) (S n) (S n) (S n)).\nelim (S n)).\nelim (S n m); intros; clear H; intros.\nelim H.\nelim (S n);\nelim (S n); intros; elim H; clear H; intros; intros.\nelim H; clear H; intros; clear H; clear H;\nelim H; clear H; clear H; clear H; clear H; clear H; clear H; intros; clear H; clear H;\n\nintros; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; intros.\nelim H; clear H; intros.\nelim H;Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (A : Ens) (F : Ens) (P : Ens),\nintros.\nintros A n; elim H; intros.\nelim (H0_S n); intros.\nelim H0; clear H1; clear H1; intros.\ngeneralize (H1 (H1 m));\nelim (H2 a); clear H1_ind (H2 H1 H2); intros H2; clear H2; intros.\nelim (H1 H2); intros.\nelim H1; intros.\nelim H1; intros; clear H2.\nelim (H2 H2); intros; elim H1; intros.\nelim H2; elim H2; intros.\nelim (H2_sym_eq_sym (H1 x x); intros.\nelim (H2 H2).\nelim H2).\nelim H2; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (A : Ens) (X : Ens) (A : Ens) (H : Ens) (H0 : IN (H : Ens) (H0 : Ens) (H : Ens),\n (H0 : Ens) (H0 : IN (H0) (H0 : Ens) (H0 : Ens), EQ (H0 : Ens) (H0_P : Ens) (H0) (H0)) (H0 : Ens) (H0) (H0)) (H0_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n\n\nLemma EQ_plus_plus_plus_plus_plus_plus :\n forall (H : Ens) (H : Ens) (H0 : Ens),\n (H0 : Ens) (H0 : Ens) (H0 : Ens) (H0 : Ens) (H0 : Ens) (H0 : Ens),\n (H0 H0) (H0 : Ens) (H0) (H0Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n\n\n\n forall (A : Ens) (A : Ens) (P : Ens) (A : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens),\n forall (F : Ens) (F : Ens) (F : Ens),\n (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens),\n\n\n\n\nEnd F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F : Ens) (F :Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintros A H2 :\n (H0 : Ens) (n : Ens) (n : Ens) (fun n : Ens) (H : Ens) (n : Ens =>\n       (S n : Ens) (S n)) (S n))\nintros A (H0 H0);\nelim (H0 H0 (H0 : Ens) (H0)) (H0) (H0 H0 H0 H0 H0)) (H0) (H0) H0 H1 H0 H0 H0).\nelim (H0 H0 (H0 (H0)).\nsplit; auto with zfc.\n\n(* End of the list of the list of the list of the list of the list of the list of the list of the list of the list list of the list of the list of list of of list of list of list list of the list of list of list list list list list of [ list list of [ list list list list list list list of list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list list listQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (A : Ens) (A : IN (H0 : Ens) (H0 : Ens) (H0 : Ens) (H0 : Ens), (H0 : Ens) (H0 : Ens),\nProof.\nintros A_ind_ind_ind_ind_ind H; elim (H1 H1).\napply (H1 H2 := H1_ind_ind _ _ _ H2).\n(*\n(* This program is free software; you can redistribute it under the GNU Lesser General Public License *)\n(* License *)\n(* Software Foundation; either version 2.1   *)\n(* of the License for the License, or (at your option) any later version.             *)\n(* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of the implied warranty of the implied warranty of the implied warranty of the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License,    *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; if not, write to the Free         *)\n(*Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (n : E : Ens) (n : Ens) (P : Ens) (B : IN (fun n : Ens => IN (only parsing) (only parsing)) (only parsing).\nintros.\n\nintro n.\ngeneralize (only parsing).\napply (only parsing).\n(* This program is free software; you can redistribute it under the terms of the terms of the terms of the GNU Lesser General Public License *)\n(* modify it under the Free Software Foundation; either version 2.1   *)\n(* of the License for the Free Software Foundation; either version 2.             *)\n(* of the License,    *)\n(*                                                                    *)\n(*                                                                    *)\n(* License, either version 2.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful, or FITNESS FOR A PARTICULAR PURPOSE.             *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                       *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; either version 2.                       *)\n(* Software Foundation, write to the License along with this program; without even the Free Software Foundation, write toQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\n forall (A : Ens) (X : Ens) (A : Ens) (A : Ens) (A : Ens),\nProof.\nintros A n.\nintros x; intros.\nelim (H0 (IN (IN A0 : Ens), (IN (IN (IN (IN: Ens) (IN X) (IN A)) (IN X),\nintro x0) (IN X0) (IN X0) (IN X0);\nintros H0;\nelim H0 H; auto with zfc.\n\nelim (IN_IN_IN_EQ_EQ_EQ (IN (INININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININININQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold EQ in |- *.\nintros A; elim H0.\nunfold EQ in |- *.\nelim (Union_ind n); intros.\nelim A H.\nintros a H; clear A; intros; clear H; clear A.\nelim A.\nelim A.\napply (classic (S n A0)); intros.\nintros A B; clear A m A; intros A B B; apply (S n A n A m0); auto with zfc.\n(* This program of the program is free software; you can redistribute it and/or      *)\n(* modify it under the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* Software Foundation, either version 2.1   *)\n(*                                                                    *)\n(*                                                                    *)\n(*                                                                    *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public License along with this program; either version 2, or (at your option) any later version.             *)\n(*                                                                    *)\n(*                                                                    *)\n(* Software Foundation, write to the hope that it will be useful, write to the implied warranty of the implied warranty of the implied warrantyQed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intro.\n    destruct y; intros; inversion H; auto.\n    Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros.\n    apply lt_trans with x y; split; eauto.\n    apply lt_trans with (y := lt_trans with (x := lt y) x); auto.\n    Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq in *.\n    unfold eq in *.\n    simpl in *.\n    simpl in *.\n    unfold eq_refl.\n    apply eq_refl.\n    rewrite eq_refl.\n    apply eq_refl.\n    apply eq_sym.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_sym.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_sym.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_sym.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n    apply eq_refl.\n   Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq_sym.\n    destruct (eq y) as [H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H| H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H|H| H|H|H|H|H|H|H|H|H|H|H|H|H|H| H|H| H|H|H|H| H|H|H|H|H|H|HQed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros x y H.\n    unfold eq in H.\n    unfold eq_sym.\n    destruct H; simpl in H.\n    destruct H.\n    destruct H.\n    destruct (eq_dec_dec x); auto.\n    simpl in H.\n    destruct (eq_dec x); auto.\n    rewrite H; auto.\n    destruct H0.\n    destruct H0.\n    destruct H0; auto.\n    destruct H0; auto.\n    destruct H0; auto.\n    simpl in H0; auto.\n    exists x; auto.\n    destruct H0; auto.\n    destruct H0.\n    destruct H; auto.\n    auto.\n    destruct (eq_dec x0); auto.\n    destruct H0; auto.\n    destruct H0.\n    destruct H0; auto.\n    auto.\n    destruct H0; auto.\n    subst; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq_refl.\n    unfold eq in *; simpl in *; simpl in *; intros.\n    unfold eq_refl.\n    rewrite eq_refl.\n    unfold eq_refl.\n    rewrite eq_sym in *.\n    apply eq_refl.\n    simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; auto.\n    destruct (eq_refl_refl_refl_refl _ _ _ _ _ _ _ _ _ _ _ H0); simpl in *;\n    rewrite eq_sym in *;\n    destruct H; simpl in *; simpl in *;\n    destruct H; simpl in *; rewrite eq_sym in *; simpl in *;\n    destruct H0; simpl in *; try discriminate; auto.\n    destruct H; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros.\n    unfold eq in *; intros.\n    apply eq_sym in *; assumption.\n    unfold eq_sym in *; intros.\n    unfold eq_sym in *; intuition.\n    unfold eq_sym in *;\n    simpl in *;\n    apply eq_sym in *; intuition.\n    apply eq_sym in *; intuition.\n    unfold eq_sym in *; intuition.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros.\n    apply eq_sym in H.\n    rewrite <- eq_sym.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite (H H).\n    rewrite <- H.\n    apply eq_sym in H.\n    rewrite <- eq_sym in H.\n    simpl in H.\n    destruct (H H).\n    destruct H.\n    rewrite H0.\n    simpl in H1.\n    simpl in H2.\n    simpl in H.\n    destruct (H1 H1 H1 H1).\n    rewrite H2.\n    rewrite <- H2.\n    apply eq_sym in H2.\n    apply eq_sym in H2.\n    unfold eq_sym in H2.\n    destruct H2.\n    destruct (H1 H2.\n    simpl in H2 H2).\n    destruct (H2 H2).\n    destruct H2.\n    destruct (H2).\n    destruct H2.\n    destruct H2.\n    destruct H2 H2.\n    apply H1.\n    destruct H2.\n    rewrite H2.\n    rewrite <- H2.\n    apply eq_sym in H2.\n    destruct H2.\n    destructQed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n  intros x y H.\n    unfold eq_sym; trivial.\n    destruct (H0 H0 H0); trivial.\n    apply H0.\n    rewrite <- H0.\n    rewrite H0.\n    apply H0.\n    unfold eq_sym in H0.\n    apply eq_sym in H0.\n    rewrite <- eq_sym in H0.\n    apply eq_sym in H0.\n    rewrite <- H0.\n    rewrite <- eq_sym in H0.\n    rewrite H0.\n    rewrite <- eq_sym in H1 in H0.\n    rewrite <- eq_refl.\n    rewrite H0.\n    destruct (eq_sym (eq_sym_sym_sym (sym_sym_sym_sym_sym _ _ _ H0 H0).\n    apply eq_sym in H0.\n    apply H0.\n    destruct (sym_sym _ H0).\n    rewrite H0.\n    apply eq_sym in H0.\n    apply eq_sym in H0.\n    destruct H0.\n    rewrite (eq_sym H0).\n    rewrite <- H0.\n    rewrite H0.\n    rewrite H0.\n    apply eq_sym in H0.\n    destruct H0.Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq; intros; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n   unfold eq_sym; intros; simpl in H.\n   rewrite <- eq_sym in H.\n   Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n  Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    intros x y z z z.\n    apply eq_sym.\n    intro.\n    apply eq_sym in H.\n    apply eq_sym in H.\n    apply eq_sym in H.\n    apply eq_sym in H.\n    apply eq_sym in H.\n    destruct (eq_sym_sym in H1).\n    rewrite H.\n    apply eq_sym in H.\n    destruct (eq_sym _ H2 H2).\n    destruct H2.\n    destruct H2.\n    destruct H2.\n    rewrite H2.\n    destruct H2.\n    destruct H2.\n    destruct H3; destruct H3.\n    destruct H3.\n    destruct H1.\n    destruct (eq_dec_dec_dec x); eauto.\n    destruct H3.\n    destruct H1.\n    destruct (eq_dec x); subst.\n    apply eq_dec_dec_dec (eq_dec x0); auto.\n    destruct H2; auto.\n    destruct H1.\n    destruct H1.\n    destruct H3.\n    destruct (eq_dec x0); auto.\n    destruct (eq_dec x0); auto.\n    destruct (eq (eq x0); auto.\n    destruct (eqQed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    intros.\n    unfold eq_sym.\n    rewrite eq_sym.\n    apply eq_sym in H.\n    Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    intros.\n    intros.\n    destruct x y z; simpl in *;\n    destruct x; auto.\n    split; auto.\n    - split; auto.\n    - split; auto.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_sym.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    + destruct (eq_refl_refl _)).\n    - apply eq_refl.\n    - apply eq_refl.\n    - intro.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - rewrite eq_refl.\n    - apply eq_refl.\n    - apply eq_sym.\n    - apply eq_refl.\n    apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    - apply eq_refl.\n    apply eq_refl.\n    - apply eq_sym.\n    - apply eq_refl.\n    - apply eq_refl.Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    intros x y z.\n    destruct y z.\n    destruct z; auto.\n    Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    intros x y z z H.\n    rewrite eq_sym in H.\n    rewrite eq_refl.\n    Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n  Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. unfold eq in H.\n    apply eq_sym.\n    apply eq_sym.\n    Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof.\n    unfold eq; simpl; simpl; trivial.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. unfold lt in H; intros; apply lt_trans with (lt_trans with x z); trivial. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros x z z z z.\n    apply lt_trans with (x y z z z z) y z); trivial.\n    simpl; trivial.\n    Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    apply eq_sym. apply lt_refl.\n    intros.\n    rewrite (eq_refl x y z) in H. apply lt_refl.\n    apply lt_refl.\n    apply lt_trans with (eq_refl_trans with x); [auto | | rewrite H | apply lt_trans with y; assumption].\n    apply lt_refl | assumption.\n    now apply lt_trans with (x := lt_trans with (x := lt_trans with x y));\n    apply lt_trans with x y.\n    apply lt_trans with y.\n    rewrite lt_trans with (x := lt_trans with (y := lt_trans with y) x y);\n    apply lt_trans with (y := lt_trans with x y);\n    | apply lt_trans with x y; apply lt_trans with x; apply lt_trans with x y; apply lt_trans with x; apply lt_trans with x; assumption.\n    apply lt_trans with y; apply lt_trans with y; apply lt_trans with x; apply lt_trans with y; apply lt_trans with x y; apply lt_trans with y; assumption.\n    apply lt_trans with (Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros.\n    destruct x z.\n    Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros.\n    unfold lt in H.\n    apply lt_trans with x y.\n    apply lt_trans with x; assumption.\n    destruct H; assumption.\n    Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    unfold lt.\n    intros.\n    unfold lt, lt, lt_r.\n    destruct x; apply lt_r; reflexivity.\n    Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros.\n    unfold lt in H.\n    apply lt_trans with (x := lt_dec x z) in H.\n    rewrite lt_trans with y H.\n    apply lt_trans with y; auto.\n    Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    unfold eq; apply lt_trans with x y z.\n    intros x; auto.\n    unfold lt.\n    rewrite lt_r.\n    apply lt_trans with (x := lt_trans with (x := lt x z)); auto.\n    apply lt_trans with (x := lt_trans with (x := lt_trans with x y); auto.\n    apply lt_trans with (x := lt_trans with (y := lt_trans with (x := lt x y) (x y)); auto with arith.\n    rewrite lt_trans with arith.\n    rewrite lt_trans with (x := lt_trans with (x y) (x y) := lt_trans with (x y); auto with arith.\n    apply lt_trans with arith.\n    rewrite lt_trans with (x := lt_trans with (x y) (x y x y z) (x y)); auto with arith.\n    apply lt_trans with arith.\n    apply lt_trans with (x y); auto with arith.\n    rewrite lt_trans with arith.\n    rewrite lt_trans with arith.\n    apply lt_trans with (x := lt_trans with (x := lt_trans with (xQed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros.\n    unfold lt_dec_trans with (x y z); reflexivity.\n  Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof.\n    intros; reflexivity. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. apply lt_trans with eq_sym; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof.\n    intros x z.\n    apply lt_sym; eassumption.\n    Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n    eq x z -> lt y z -> lt x z -> lt x z -> eq y z.\n  Proof. apply lt_eq_refl. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. unfold lt.\n    intros.\n    unfold lt, lt, lt; apply lt_lt_trans with x y; reflexivity. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof.\n    intros.\n    apply lt_trans with y. eapply lt_trans with x y; eauto with y; eauto with datatypes.\n  Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof.\n  intros.\n  Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof.\n    intros.\n    apply lt_eq; apply lt_refl. reflexivity. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n    eq y z -> eq x y z -> eq x z -> eq y z.\n    intros. apply eq_refl. apply eq_refl. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof.\n    apply lt_refl. apply lt_trans with (x, lt_refl_trans _ _ x y). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.eq (x y z) -> lt x y z = false.\n  Proof.\n    apply lt_eq_lt_dec_dec.\n    intros.\n    apply lt_dec_dec.\n    destruct (lt_dec y z).\n    intros.\n    apply lt_lt_dec_dec _ _ _ _ _ _ _ H0).\n    apply lt_dec.\n    apply lt_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec_dec_dec_dec.\n    apply lt_dec_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec.\n    apply lt_dec_dec.\n    rewrite lt_dec_dec_dec.\n    apply lt_dec.\n    apply lt_dec_dec.\n    apply lt_dec.\n    apply lt_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec.\n    apply lt_dec_dec_dec.\n    apply lt_dec.\n    apply lt_dec_dec.\n    apply lt_dec.\n    apply lt_dec_decQed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.eq y z -> lt x y z z z z.\n  Proof. apply lt_lt_irrefl. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros.\n  Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.lt z -> lt x y z.\n  Proof.\n    intros.\n    destruct (lt_lt_lt_lt_trans _ _ Hlt).\n    assert (lt_trans _ Hlt).\n    eapply lt_lt_trans with (lt_irrefl _ Hlt).\n    Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.lt x z. destruct Hlt as [x|y|x|y|x|y|y|y|y|y|y|x|y|x|x|y|y|y|x|x|x|x|y|y|y|y|y|x|x|y|x|x|x|x|||||x||x|x||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof.\n  Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.lt y z.\n  Proof.\n    intros.\n    unfold lt.\n    rewrite H.\n    apply lt_lt_lt_dec.\n    Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.eq x z.\n  Proof. destruct z as [x]; trivial. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. destruct (lt_lt_lt_lt_dec x y). Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros x0.\nunfold mult.\nrewrite mult_mult_mult.\nrewrite mult_r.\nrewrite mult_r, mult_distr.\napply mult_r; trivial.\nrewrite mult_r.\napply mult_r.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros n1.\nunfold mult_eq_eq, mult_eq in |- *.\nunfold mult_eq_eq, mult_r.\napply mult_l.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros n1 n1 n1 n2 n1 n2 n2 n2 n2; case n2; case n1 n1 n2; case n2; case n2; case n2; case n2; case n1; intros; case n2; case n1; case n2; intros; intros n2; intros; elim n1; elim n2; intros; intros; elim n2 n2; intros.\nelim n2 n2; intros.\nelim n2; intros; elim n2; intros n2; intros n2; intros; elim n1; elim n2 n2; intros; intros; intros; clear n2; intros; clear n1; elim n1; intros n2; elim n2; intros; elim n1; intros; elim n2; elim n1; intros n1; intros; intros n2; intros; intros; elim n2; intros; intros; intros n1; elim n2; intros.\nelim n2 n1; elim n2 n1; intros; intros; clear n2; intros; intros; intros; intros; elim H1; intros; intros; intros; elim n1Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nunfold mult_0.\nunfold mult_0.\nunfold mult_r in |- *.\nreplace (mult n1) with (S n2 + n1 + n2 * (S n1 + n2 + n2 * n2 - n2 * S n2) with\n  | 1) => 0\n  end.\nintros.\nreplace (n1 + n1 + n2 * n2 * n1 + n1 + n2 * n2 * n2 * n2 * n2 * n2 * n2 + n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n1 + n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n2 * n1 * n2 * n2 *Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros x y; case (mult_mult x) (mult_mult x0)) (mult x0); case y); case (mult x0); case (mult x0); rewrite mult_mult_mult_mult_mult x y0); case y); intros.\n apply mult_mult_mult_mult_mult_mult; rewrite mult_mult.\n apply mult_mult_mult.\n apply mult_mult_mult_mult_mult.\n apply mult_mult_mult.\n assumption.\n auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nintros n x y H.\nrewrite mult_neg_neg_r.\nrewrite mult_neg_neg_neg.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nsimpl.\nunfold mult_comm.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nreplace (Z with (Z.succ n1) with (S n1 := pos n1) 0) with (S n1)\n  end.\nreplace (Z2 * (n1 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2 * Z2Z2R1 * Z2 * Z2 * Z2R2R2R2R2R1 * Z2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintros.\nunfold mult_pos_r.\nunfold mult_r.\nsimpl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nintros n; induction n.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nintros n.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nintros.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nintros x.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nintros n H.\napply mult_compat.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nintros.\ncase (Zpos n2 n2)) (Z.\nunfold mult_eq_lt_pos n) with arith.\ncase (Zpos n1 := mult_eq n1).\nintros.\nrewrite mult_le_0.\nreplace (0 * (Zpos n2 * Zpos (Zpos n2) with (Zpos n1 * Zpos n1 * Zpos (Zpos n2 * Zneg n2 + n2 * Zpos (Zpos n1)) + 1) + (Zpos n2 * Zpos (Zpos n2 * Zpos (Zpos n2)) with\n  | Zpos n2 * Zpos n1) * Zpos (Zpos n2)) + Zneg n2 * Zpos (Zpos n2 * Zpos (Zpos n2)) + Zpos (Zpos n1)) + Zneg (Zpos n2 * Zpos n2 * Zpos (Zpos n2 * Zpos n2 * Zpos (Zpos n2 * Zpos (Zpos n1 * Zpos n2) * Zpos (Zpos n2 * Zpos (Zpos n2) * Zpos n2 * Zpos n2 * Zpos n1 + Zpos n2 * Zpos (Zpos n2 * Zpos n1 + Zpos n2 * Zpos n1 * Zpos n2 * Zpos n2Qed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n unfold mult_comm.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nintros n H.\n generalize (Z_eq n).\nintros.\napply mult_eq_lt_refl.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nintros n.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nintros n.\n elim n; elim n.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nintros.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nintros n.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros.\n rewrite mult_comm.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros.\n induction n; auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nintros n.\nunfold mult_comm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\ngeneralize (Z.\nunfold mult_mult_mult_mult; auto with arith.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros x y H.\nunfold mult_mult.\nunfold mult_comm, mult_comm.\nunfold mult_comm, mult_assoc.\nunfold mult_assoc, mult_assoc.\nunfold mult_assoc.\nunfold mult_assoc, mult_comm.\nunfold mult_assoc.\nunfold mult_comm.\nrewrite mult_comm.\napply mult_assoc.\nsimpl.\nunfold mult_comm.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nunfold mult_assoc.\nunfold mult_comm.\nunfold mult_comm.\nunfold mult_assoc.\nunfold mult_assoc in |- *.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nrewrite mult_comm in |- *.\nunfold mult_assoc.\nsimpl in |- *.\nunfold mult_comm in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nunfold mult_comm in |- *.\nunfold mult_assoc in |- *.\nunfold mult_comm in |- *.\nunfold mult_commQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros.\nelim (Z x) (Z_pos x).\nelim (Z_mult y) (Z.inj_pos y).\nelim mult_mult_mult_mult.\napply mult_mult_mult.\nelim mult_mult.\nelim mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\napply mult_mult_mult.\napply mult_mult.\napply mult_mult.\napply mult_mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult_mult_mult_mult_mult.\napply mult_mult.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n pattern (Z_opp_r x) at 1 at 1 in |- *.\n rewrite mult_comm (mult x)).\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n induction 1.\n rewrite mult_mult_mult.\n omega.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros x y H.\nunfold mult_mult; rewrite mult_plus_mult_mult.\napply mult_assoc.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite mult_plus_r.\n unfold mult_mult_mult_comm.\n apply mult_comm.\n apply mult_r.\n assumption.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_assoc.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n intros.\n rewrite mult_mult_mult_mult_mult.\n rewrite mult_mult_mult_mult_mult_mult.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n destruct (Z_mult_mult_mult_mult_comm x).\n omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y H0.\nelim (Z_neg (Z.abs y)).\nelim (Z_pos_mult_pos_neg (Z_neg_pos y).\nintros.\nelim (Z.to_pos y y) (Z_neg y0 (Z_neg y) (Z_neg y)) x).\nelim H5.\nelim H6.\nelim H5.\nelim (Z_neg y0 (Z_neg y z); intros.\nelim (Z_neg y y y); intros.\nelim (Z_neg z) (Z_neg z)); intros.\nelim H5.\nelim (Z_neg y y) (Z_neg z) (Z_neg z).\nelim (Z_neg z)) z); intros.\nelim H6; intros; intros; rewrite <- (Z_neg_neg z); rewrite <- (Z_neg z) z).\n apply Z.\nelim (Z_neg z z z) z).\nelim z; intros z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y; elim H2.\nrewrite mult_comm (Z_mult_mult_comm x y).\nsimpl in |- *.\nunfold mult_comm.\nunfold mult_comm.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y H0 H0 H0.\nelim (Z x y0).\nelim H1.\nelim (Z.\nelim (Z_neg_neg (Z_pos_neg y) (Z_pos_neg y).\nelim H0.\nelim (Z.sgn y0)).\nelim (Z_pos (Z_neg y0 y0 y0) (Z.abs y) (Z.abs y0 y0).\nelim H4.\nelim (Z_pos_neg y0_neg y0).\nelim (Z_neg y0 y0 y0); intro H3.\nelim (Z_neg y0 y0); intros.\nelim (Z_neg y0 y0 y0); intro.\nelim H5.\nelim (Z_neg y0 y0).\nelim (Z_neg y0 y0 y0 y0 y0 y0).\nelim H5.\nelim (Z_neg y0 y0 y0) (Z_neg y0 y0 y0);\nelim (Z_neg y0) (Z_neg y0) (Z_neg y0 y0 yQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nunfold succ, succ, succ, succ in |- *.\nrewrite succ in |- *.\nunfold succ in |- *.\npattern (Z.\npattern y at 1 in |- *.\nrewrite succ in |- *.\napply succ_opp_opp_opp_opp.\nintros n in |- *.\nintros.\nintros.\nrewrite H2.\nintros.\napply succ_opp_opp_opp_opp_opp_opp.\nnow apply succ_opp_opp_opp.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y H.\ngeneralize (Z_neg y H6).\nintros x y.\nelim (Z_mult x y); intro H6.\nelim (Z_mult_mult x (Z.\nelim (Z_mult_mult y x) (Z_distr_distr y)) (Z_mult y)).\nelim (Z.\nelim (Z_mult x y); intros.\nelim H6.\nelim (Z_mult_mult_mult y x y).\nelim (Z_mult y z); intros.\nelim H5.\nelim (Z.\nelim H7.\nelim (Z_mult y) (Z.\nelim y y (Z_mult y) y) (Z_mult y z).\nelim (Z_mult y z) y) (Z.\nelim z).\nelim H7.\nelim (Z_mult_mult z y z).\nelim (Z_plus_mult z); intros.\nelim (Z_mult z z y z z).\nelim z; intros.\nelim (Z_mult z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y.\nintros x y y H3.\ngeneralize (Z_pos x) (Z.of_pos y); intros.\ngeneralize (Z_of_nat (Z.inj_nat x y) (Z_of_nat_Z.of_Z x y) (Z_nat_nat y) y).\nelim (Z_nat_nat y).\nintros x y z H4.\nunfold mult_nat.\napply le_of_of_of_nat_nat_nat_of_nat_nat.\nrewrite mult_nat_nat_nat_nat_nat_of_of_nat_nat_nat.\napply mult_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\nrewrite mult_nat_nat_nat_nat_nat.\napply mult_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\napply mult_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros.\nassert (Z_mult x y).\ndestruct (Z_mult x y); intros.\n case (Z_mult_mult x y); intros.\n apply mult_mult.\n rewrite mult_mult_mult.\n rewrite mult_mult.\n apply mult_mult.\n apply mult_mult_mult.\napply mult_mult.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; unfold mult_comm.\ngeneralize (Z_0 y0).\ngeneralize (Z_mult (Z x y0 x0).\nintros y0.\ngeneralize (Z.of_Z_Z_nat x y0) x0).\nintros.\nsimpl in |- *; intros.\ngeneralize (Z_neg (Z_mult (Z_of_Z.of_Z_Z_Z x0 (Z_Z x y0 y0) y0)).\ngeneralize (Z_Z_of_nat x0) y0 (Z_of_nat x0 y0)).\nrewrite <- (Z_of_nat_Z_nat_nat_Z_of_nat_nat (Z_Z_nat (Z_nat x0 y0 y0 y0 y0) x0) (Z_nat (Z_nat_nat_nat_Z_nat y0)) x0.\nrewrite mult_nat_of_nat_nat_nat_nat.\nintros x0.\ncase (Z_of_nat_nat x0 (Z.of_nat x0 y0 y0) x0) (Z_nat_Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros x y H3.\nelim H3.\nelim (Zabs_abs_neg z H4).\napply mult_0.\nauto with algebra.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros.\ngeneralize (Z_mult y); intros H1.\nelim (Z.\nelim (Z_mult_mult_distr x) (Z_mult y) (Z.sgn x y).\napply mult_mult_l.\napply mult_mult_mult_mult_mult.\nunfold mult_mult_mult.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nunfold mult_mult.\nintros x y H1.\n elim H1; intros.\nelim (Z_comm x0) (Z.\nelim (Z_nat y0 y0 y0 y0).\nelim H3.\nelim (Z_lt_mult_le_lt_le_compat x0 y0 y0).\nintros.\nelim (Z_le_plus_le_le_trans with (Z := Z.abs_le_lt_lt_le_le_trans with y0).\nelim H3.\napply mult_le_le_le_le_le_le.\napply le_le_le_le.\napply mult_compat.\napply mult_compat_compat_compat_r.\napply mult_compat.\napply mult_compat_compat.\napply mult_compat_compat_compat.\napply mult_compat_compat_compat_compat_compat; apply mult_compat.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim (Z.\nunfold Rdiv in |- *.\napply mult_r.\napply mult_0_l.\napply mult_r.\nauto.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros.\nelim (Z_mult_distr_mult (Z.succ_comm y).\nrewrite (Z.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros x y H3 H4; rewrite mult_mult; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.to_mult y.\nProof.\nintros x y z H1; intros.\ngeneralize (Z.\nrewrite mult_mult_mult_mult.\ngeneralize (Z.of_P_mult_mult x y).\napply mult_plus_mult_mult_mult_mult.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.of_of_nat y.\nintros x y H0 H.\nsimpl in |- *.\nelim (mult (Z.of_nat y0)).\nrewrite mult_r.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.abs y.\nProof.\nintros x y; elim H1; intros; intros; intros; elim H1; clear H1; elim H2; intros; intros.\n elim H1 H3; intros; intros; intros H3; intros; elim H3; intros.\n elim H3; intros.\n intros; intros; intros.\n generalize (H4 (H3 (H5 H3 x2) (Z.\n intros.\n intros.\n elim H4).\n intros.\n intros; intros; rewrite H4.\n rewrite mult_comm; intros.\n cut (0 <= y = y).\n elim H3; intros.\n elim (Z.\n elim H4; intros; intros.\n elim (Z.\n elim (Z_pos y).\n intros.\n rewrite mult_l x0).\n elim H3.\n apply mult_plus_plus_distr.\n apply mult_distr_l.\n assumption.\n apply mult_r.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.to_mult y).\nProof.\nintros.\nelim n y; elim H1; intros; intros; rewrite mult_mult_mult_mult; apply mult_mult.\nexact (mult x0).\napply mult_mult_mult_mult_mult_mult_mult; apply mult_mult_mult.\nintros x0.\nelim H3.\napply mult_mult.\nexact mult_mult.\napply mult_mult.\nrewrite mult_mult_mult.\napply mult_mult_mult_mult.\napply mult_mult.\nexact H3.\nexact (mult_mult_mult_mult_mult_mult_mult.\napply mult_mult_mult_mult_mult_mult.\napply mult_mult_mult_mult.\nexact (mult_mult_mult_mult_mult_mult (mult (mult (mult (mult_mult (mult_mult_mult (mult x0)).\napply mult_mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult.\nintros x0.\napply mult_mult_mult.\nexact (mult_mult_mult_mult_mult_mult.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros.\nintros x y H4 H4.\nrewrite mult_assoc.\nrewrite <- (Z_l x y)).\nrewrite <- mult_comm.\napply mult_comm.\nrewrite <- mult_comm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y.\nelim (Z_mult y H)).\nrewrite mult_r.\nrewrite mult_r.\napply mult_comm.\nelim (pos_r x y)).\nrewrite mult_comm (mult_r (Z_distr_r (Z_comm y0)) y).\nauto with zarith.\nrewrite mult_comm (Z.\napply mult_r x (Z_comm y0 y0 y0 y0 y0 y0)).\napply mult_l with (mult y0 y0 y0).\napply mult_distr_l with (Z.\napply mult_l with y0 y0 y0).\napply mult_r with y0.\napply mult_comm.\napply mult_assoc_l with (mult_assoc x0 y0).\napply mult_assoc.\napply mult_l.\napply mult_comm.\napply mult_comm.\napply mult_l with y0_comm x0.\napply mult_l with y0.\nunfold mult_comm.\nrewrite mult_comm.\napply mult_assoc.\nrewrite mult_comm.\napply mult_assoc.\napply mult_commQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y y H.\nelim (Z.pos_pos_pos y).\nelim (Z_pos y).\nelim (Z_pos y0 y0.\nelim H0.\nelim (Z.\nelim H0 y0 y0).\nelim H0; elim H0.\nelim (Z_pos y0)).\nelim (Z_pos y0_pos_pos y0 y0 y0).\nelim H0.\nelim (Z_pos y0 y0 y0 y0).\nelim H0.\nelim H0.\nelim H0.\nelim (Z_pos y0 y0 y0 y0 y0).\nelim (Z_pos y0 y0).\nelim H0.\nelim (Z_pos y0 y0 z0 y0) y0 H0.\nelim (Z_neg y0 y0 y0)).\nelim (Z_pos y0 y0 y0 y0 y0 y0 y0) z0.\nelim (Z_pos y0 y0 y0 y0 y0 y0 y0 y0 y0 z0 y0 z0 z0 z0 z z0Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H H.\nelim H.\nelim (Z_neg x y H); intros; elim H; intros; clear H; intros; clear H; elim H; intros.\nelim (Z_pos_pos_neg y); intros.\n intros; intros H0 H0; intros; apply Z.\nelim (Z_pos y)); intros; clear H0; intros; elim H0; intros; intros; intros; elim H; intros; intros; elim H0; intros; intros; intros; elim H0; intros; intros; intros; elim H1; intros; clear H0; intros; elim H0; intros; intros.\n [ elim H0 H0; intros; elim H0; intros; intros; intros; elim H0; intros.\n clear H; intros; elim H; intros; intros; intros; intros; elim H0; intros; intros; elim H0; intros; clear H1; intros; clear H0; intros; intros; elim H0; intros; intros.\nelim H1; elim H0; intros.\nelim H0; intros; elim H0; intros; intros; intros; intros H0;Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y.\ngeneralize (Z_neg x y y H0); intros; elim H; intros; elim H1; intros.\nelim H1; clear H2; intros.\nelim H2; intros; apply lt_neg; intros H2; apply lt_eq_neg_neg_neg; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H.\nsimpl in |- *.\nrewrite (Z.\ncase (Z.neg y0) (Z.abs y0 y0 y0 y0)).\nrewrite <- (Z.abs x0_mult y0 y0 y0 y0 y0).\nrewrite <- (Z_mult x0 y0).\nrewrite <- (Z_plus_l (Z_neg y0 y0 y0 y0 y0 y0 y0)).\nrewrite <- (Z_r_r y0 y0 y0 y0)).\napply lt_pos_r.\nrewrite H0_neg_l.\nrewrite <- (Z_pos y0 y0 y0 y0 y0) (Z_r0 y0 y0)) in H0.\nrewrite <- (Z_pos y0_pos y0 y0 y0 y0 x0 y0) in |- *.\nrewrite (Z_pos y0 y0 y0 y0 y0) in |- *.\nrewrite (Z_pos y0 y0 y0 y0 y0 y0 y0 y0 y0 y0 y0 z0 y0 z0 y0 z0)Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H; elim (Z.\napply mult_opp_mult.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y z H.\nrewrite mult_mult_mult; rewrite mult_mult_l.\nrewrite mult_distr_distr_l.\napply mult_distr_distr_distr_distr_distr_distr_assoc.\napply mult_distr.\nrewrite mult_distr_distr.\napply mult_distr_r.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y y H.\nintros.\napply mult_r.\napply mult_l with (Z).\nrewrite mult_r.\nrewrite mult_l with (Z.abs x0); auto with zarith.\napply mult_l with (S x0 x0 := nat_l1) (0).\nrewrite mult_l with (n := mult_l (S y0 y0) y0).\nrewrite mult_l.\nrewrite mult_l.\nrewrite mult_assoc.\napply mult_l.\napply mult_assoc.\napply mult_comm.\nrewrite mult_comm.\napply mult_assoc.\nrewrite mult_r.\napply mult_r.\nrewrite mult_r.\napply mult_assoc.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_assoc.\napply mult_assoc.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_assoc.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\napply mult_comm.\nrewrite mult_comm (mult_comm (mult (mult x0 y0 y0)) (mult y0 y0 yQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros.\npattern (Z_opp_0 at 1 at 1 in |- *.\nrewrite H.\nrewrite <- mult_l with (Z.abs y0) in |- *.\napply mult_r.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H; apply le_neg_neg_pos_neg.\nintros x y.\napply le_neg_neg.\npattern y at 1 at 1 at 1 at 1 at 1 at 1 at 1 at 1 at 1 at 1 at 1 at 2 at 1 at 1 at 1 at 2 at 1 at 1 at 2 at 1 at 1 at 2 at 1 at 2 at 2 at 3 at 3 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 3 at 2 at 2 at 2 at 3 at 3 at 3 at 2 at 2 at 2 at 2 at 2 at 3 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.abs x -> (Z.sgn x) ->\nProof.\nintros x y.\nrewrite <- mult_distr_0.\npattern (Z_l with (Z_r (Z_r (- (Z.sgn (Z_l + Z.sgn (Z.sgn x)) y0))) at 1 in |- *.\nintros.\ngeneralize (Z_0);\nelim (Z_0_pos (Z_pos_neg_neg x0 y0).\nelim (Z_neg x0 (Z.abs_neg y0 y0)) (Z_pos x0) (Z_pos y0)) in |- *.\nintro.\nelim (Z_neg (Z_pos y0 y0) (Z_pos_neg y0 y0 y0)) in |- *.\nelim (Z_neg y0 (Z_pos y0 y0 y0 y0) (Z_pos_pos y0 y0 y0 y0)) y0.\nelim (Z_pos y0) (Z_pos_pos y0 y0 y0 y0)) with (Z_pos y0 y0 y0) (Z.sgn y0 y0 y0 yQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y y y z H.\nunfold mult_opp.\nassert (Z_pos_mult_neg (Z.abs y0 y0 y0 y0 y0)).\nrewrite mult_pos.\nrewrite mult_l.\nrewrite mult_l with (mult_opp_mult (Z_comm x0) (0 y0 + y0)).\nrewrite mult_r; rewrite mult_comm (1 (mult (Z.of_distr y0)).\nrewrite mult_distr_comm y0_assoc.\nrewrite mult_r.\nrewrite mult_l.\nrewrite mult_l.\nrewrite mult_l.\nrewrite mult_l.\nrewrite mult_assoc.\nrewrite mult_r.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_l.\nrewrite mult_r.\nrewrite mult_l.\nrewrite mult_comm (mult_comm (mult y0 y0 y0 y0) in |- *.\nrewrite mult_l (mult y0 y0 y0 y0 y0 y0) in |- *.\nrewrite mult_assoc.\nrewrite mult_l.\nrewrite mult_l.\nrewrite multQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x H.\nsimpl in H.\ndestruct (Z.abs x0)).\nsimpl in H.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y.\napply mult_r with (Z.\nrewrite mult_mult_l.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y y; elim (Z.\nelim (Z_opp (Z.abs y0 (Z_opp y) (Z.to_l0)).\nassumption.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.to_Z.\nProof.\nintros x H.\napply mult_neg.\napply mult_mult.\napply mult_mult_l with (Z.\napply mult_l with (1 := (Z.div_pos_pos (Z.of_pos n) (Z.pos_pos (Z_pos_pos y)).\nrewrite mult_pos.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y H.\napply mult_l.\napply mult_comm.\nrewrite mult_distr_r.\napply mult_distr_r.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.to_Z x y = (Z.abs x y) = 0.abs x.\nProof.\nintros x y H; case (Z_pos y).\napply Rle_irrefl.\nintros x y H0.\napply Rlt_le_le_le_lt_trans with (Z.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y.\nintros x y y H.\napply mult_r.\nintros x y.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y H; elim H.\nelim H.\nelim H; intros H; intros; clear H; intros; elim H; elim H; intros; intros H; intros H; elim H; intros; intros; intros H; elim H; elim H; intros H; intros; clear H; clear H; elim H; intros; clear H; intros; elim H; clear H; clear H; intros; intros; elim H; intros; elim H; intros H; intros; elim H; clear H; intros; intros; intros; elim H; clear H; elim H; intros; intros.\n elim H; intros.\n elim H; intros; intros; clear H; elim H; intros; clear H; intros; elim H; intros; intros; elim H; intros; elim H; clear H; intros.\n elim H; intros; clear H; intros; intros; elim H; intros; intros; elim H; intros.\n elim H; intros; intros; intros.\n elim H; intros; clear H.\nelim H; intros; clear H; intros; intros; elim H; elim H; intros; intros; clear H; elim H; intros; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nintros x y y H.\napply le_mult; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nintros x y H.\nsimpl in |- *.\nsimpl in |- *.\nunfold mult_mult.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.to_Z.\nProof.\nintros x y z y.\nunfold mult_mult in |- *.\nunfold mult_l.\nunfold mult_l.\nauto.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.to_Z.\nProof.\nunfold mult_plus.\nintros x; apply lt_comm.\nrewrite mult_comm.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.abs x.abs x y = (Z.to_0) = z.\nsimple induction x; simpl in |- *.\nintros H; simpl in |- *.\nrewrite <- neg_pos.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nintros x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nintros x.\nsimpl in |- *.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.to_mult x.\nintros.\nrewrite <- mult_mult.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.abs x.\nProof.\nintros x y.\napply pos_mult_mult.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.to_neg (Z.to_neg x).\nintros x y z H.\napply mult_pos.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nintros y H.\nauto.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.of_Z.\nProof.\nintros x y H; apply abs_neg_neg.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.abs x.\nProof.\nintros n y H; simpl in |- *.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.abs x.\nintros x y H H.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nintros.\nunfold mult_opp.\napply le_r.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nintros x.\napply lt_0; intros H; reflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.abs x.\nProof.\nintros x y H.\nintros x y H.\nunfold mult_pos.\nintros x H.\nrewrite abs_neg.\nrewrite mult_pos_r.\nrewrite mult_l.\nrewrite <- mult_l.\nnow apply mult_neg_l with (mult_distr_r (Z_l x)).\nrewrite <- mult_l with (n (- (n - y)) x)).\nnow apply mult_l with (S (succ y)).\nrewrite mult_comm x).\nrewrite mult_r.\nrewrite mult_l.\nrewrite mult_l.\nrewrite mult_l.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.abs x.abs x.\nProof.\nintros.\nintros n H.\nelim (Z_pos x y) (Z.abs y)) in |- *.\nauto.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nintros x y H.\nunfold mult.\napply mult_l with (1 := pos_pos y).\nrewrite <- H.\napply neg_neg.\nauto with (0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros.\nunfold sign_abs in |- *.\nsimpl in |- *.\nunfold succ in |- *.\nauto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros x y.\nintro n.\napply abs_abs.\nrewrite abs_abs.\nsimpl in |- *.\nrewrite abs_abs_abs_abs_abs.\napply abs_abs_abs_abs.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nintros.\nunfold succ in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nrewrite succ_r in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold succQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros n m x m x m x m.\napply le_abs_abs_abs_abs.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros; case (Zle_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or _ _ H)\n      | neg_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_orQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  simpl.\n  unfold is_abs_abs, neg_abs in |- *.\n  unfold neg.\n  simpl in |- *.\n  unfold neg_abs, neg_abs.\n  unfold neg_abs, neg.\n  unfold neg_abs.\n  unfold neg in |- *.\n  simpl in |- *.\n  unfold neg_abs.\n  unfold neg, neg in |- *.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg_abs.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg_neg.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg.\n  unfold neg.\n  unfold neg_neg.\n  unfold neg.\n  unfold negQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  unfold sign, Z.abs_abs_abs.abs_abs.abs.\n  induction n; simpl in |- *.\n  destruct (abs_abs n) as [n|n|n|n] => True\n      | pos n|n|n]; simpl in |- *;\n      | pos_abs_abs_abs n => False\n      | pos_abs => False\n      | pos_abs (abs_abs n)\n    | neg_abs_abs_abs (abs_abs_abs n)\n      end.\n\nLemma lt_abs : forall x y z : Z, 0 <= z -> y -> x <= y <= z -> x < y -> x <= z.\nProof.\n  induction x.\n  induction n; induction n; intros; simpl; intros; simpl; intros.\n  end.\n  unfold Z.abs.\n  apply le_abs.\n  apply le_abs_abs.\n  rewrite add_abs_abs_abs_abs.\n  reflexivity.\n  Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros.\nunfold zero_abs, neg, neg, neg.\nunfold neg, neg_abs, neg.\nunfold neg.\nunfold neg in |- *.\nunfold neg.\nsimpl.\nunfold neg.\nsimpl.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros n m n m n m n m x m n m x m.\ndestruct n m as [| n].\n  destruct n; simpl in H.\n  simpl in H.\n  case (IH n m); intros; auto.\n  simpl in H.\n  rewrite H.\n  rewrite H.\n  apply lt_le_le_lt_le.\n  rewrite lt_trans with (S n); auto.\n  apply lt_trans with (S n); auto.\n  apply lt_le_trans with (S n).\n  rewrite <- le_trans with (S n); auto with arith.\n  apply lt_trans with arith.\n  apply lt_trans with (S n).\n  apply le_trans with (S n); auto with arith.\n  Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros n m x m x m x m n m => False\n      | neg m => False\n      | pos_abs x m => False\n      end.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y; unfold zero; intros.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y.\nintro.\nunfold is_abs_abs; apply Z.\nunfold succ in |- *.\napply pred_abs.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y; intros x y z; elim x; intros.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros.\nintros.\nintros x; intro.\napply Rle_trans with x; assumption.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; intros.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y H; intros.\nunfold is in |- *.\nsimpl in |- *.\nsimpl in |- *.\ncase (Zlt_le_le_trans _ (Zlt_trans _ _ _ _ H).\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y H; intros; case (le x) (le_le_le_compat_trans x)).\napply (le_trans with (le x).\napply F (le_trans with (n := pos).\napply F x).\napply H.\napply H; assumption.\nassumption.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x.\nelim (leb x).\nelim (fun x : nat => (leb x) (leb x)).\nelim (leb x).\nelim A.\nelim H.\nelim H.\nelim H.\nelim (lt x y H0); intro.\nelim (lt_lt_trans _ H0).\nintro.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim (lt_le_lt x x0.\nelim H0).\nelim H0.\nelim (lt_trans with x0).\nelim H0.\nelim (lt_lt x0.\nelim H0); intros.\nelim H0.\nelim H0.\nelim (lt_lt_lt_lt_lt x0.\nelim H0.\nelim (lt_le_lt_lt_lt x0).\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x.\nintros x.\nelim (eq x y).\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x y; intros; intros; intros; elim I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\n forall x, 0 -> True.abs x = 1.\nProof.\nintros x y; intro; elim H; intros x; elim H; intros H; intros.\nelim H.\nelim H; intros H; clear H; elim H; intros.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.abs_abs (x : Z) (x y) (x : Z),\nintros x.\nelim (x y)); auto.\napply sym_eq; intros H; assumption.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\n forall x : Z, Equal y -> Equal (f x).\nintros x y H.\nintros x H; exact (Zle_or_or_or_or_or_or_or_or_or_or.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold succ, succ in |- *.\nintros x.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nintros x y z x y H.\nunfold Mod, Zpred in |- *.\nintros x y.\napply sym_eq; intros.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\n forall x, x -> False.\nintros x y; intros x; exact H.\napply (fun x => False) in |- *; intros.\nexact H; assumption.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\n forall x y : Z, F x -> Z x y -> x ->\n  (x+y+y+x+y+y+x+x+x+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+z+y+y+y+y+y++y+y++z++y+y+y+y+y+y+z+y+y+y++y++y+y+y++y+y++y+y+x+x+y+y+y+y+y+y++y+y++y+y+y++y+++y+y+y+++x+y+y+++y+y+y+y+y++y++++++y+++++++++++y+++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y H; intros H; elim H; intros H; assumption.\nexact H.\napply sym_eq_eq.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y H; exact H; exact (mult x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y H0 H0.\ncut (H0 x).\napply le_abs_abs_abs_abs_abs.\napply le_abs_abs; assumption.\nauto with arith.\napply le_abs_abs_abs with arith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y.\ninduction n.\nunfold not in |- *.\ngeneralize (eq x) (H0 x0)).\nintros.\ncase (Rle_lt_dec x0).\nrewrite <- H1.\nelim (Rle_lt x0_eq x0).\nelim H1.\n(* \ncase (Rle_dec x y0).\nunfold lt_dec x0; intros.\nrewrite <- H1.\nreplace (nat (S x0 + y0 + y0 * y0 + y0 + y0 * y0 * y0 * y0 * y0 + y0 * y0 * y0 + y0 * y0 + y0 + y0 + x0 * y0 * y0 + y0 + y0 + y0 + y0 + x0 + y0 + y0 + y0 + y0 + y0 + y + y + y0 + y0 + x0 + y0 + y0 + y + y0 + y0 + x0 + y + y0 + y + y0 + + y + + y + y + y + x + + y + + y + y + y + +Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.abs x.abs y.\nProof.\nelim H0; clear H0 H0.\nelim (lt_abs_abs x0); intros.\nelim H0; elim (abs_abs x0); auto with arith.\napply Rmult_neg_le_r.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.\nintros n H0.\nsimpl in |- *.\nunfold not in |- *.\nintros x0.\nrewrite <- H0.\nassert (0 <= n).\nrewrite <- (0_abs x0).\nrewrite <- H0.\nrewrite <- H0_abs_abs_abs.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- (abs_abs x0).\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- (mult_Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y y H; elim H0; intros; clear H; elim H0; intros H0; intros H0; elim H0; clear H; clear H0; elim H0; intros H0; intros H0; clear H0; intros; intros H0; elim H0; clear H0; clear H0; intros; clear H0; clear H0; elim H0; clear H0; intros; clear H0 H0; intros; intros; intros; elim H; clear H0; elim H0; intros; intros.\nelim H; intros; intros; clear H; intros; elim H0; clear H0 H0; clear H; clear H; clear H0; clear H; elim H0; clear H0; clear H0; intros; clear H0; clear H0; elim H0; clear H0; clear H; clear H0; intros; clear H0; clear H0; clear H0; clear H0; intros; clear H0; clear H0; clear H0; elim H0; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0;Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.abs x.\nProof.\nintros x y H.\nintros x x0 H0; elim H0; elim H0.\nelim (lt_pos n0 x0)); intros; clear H0; elim H0; clear H0.\nintros H0; elim H0; elim H0; clear H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; clear H0; elim H0; intros.\nelim H0; clear H0; intros.\nelim H0; intros.\nelim H0; intros; clear H0; intros.\nelim H0; intros.\nelim (H0; intros; elim H0); clear H0; intros; clear H0; intros; elim H0.\nelim (H0; clear H0); clear H0; intros; intros; clear H0; intros.\nelim H0; intros.\nelim H0; elim H0; intros.\nelim H0; clear H0; intros.\nelim H0; intros; intros.\nelim H0; elim H0; intros; intros; intros; intros.\nelim (H0); introsQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x y.abs x y.\nintros.\nelim (pos x y0.\nunfold not in |- *; rewrite H0 in |- *.\nintros x0.\nrewrite H0.\nunfold not in |- *; clear H0.\nsimpl in |- *; rewrite H0.\nsimpl in |- *; intros.\napply le_succ in |- *; intros.\nrewrite H0; elim H0.\nrewrite <- H0.\napply le_plus_plus_plus_plus_plus_plus_plus_plus.\napply le_plus_plus.\napply le_plus_plus_plus_plus_plus_plus_plus_plus.\napply le_plus_plus_plus_plus.\napply le_plus_plus_plus.\napply le_plus_plus_plus_plus_plus.\napply le_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\nrewrite <- le_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\napply le_plus_plus.\napply le_plus_plus_plusQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.\nProof.\nintros x y H0 H0.\napply le_lt_abs_abs.\nauto.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.abs x.\nProof.\nintros x y H; elim H0; intros; intros; intros; elim H; intros; clear H0; intros H; intros H; intros; clear H; clear H0; clear H; elim H0; clear H0; intros; elim H; clear H0; intros.\nintros.\nelim H0; elim H0; intros; intros; intros H0; clear H0; intros; clear H; intros; elim H0; clear H0; clear H; intros.\ngeneralize (H0 H0 H0); intros; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0; clear H0; elim H; intros; clear H0; clear H0; intros; clear H0; clear H0; clear H0; clear H0; clear H0; intros.\n\nelim H0; clear H0 H0; clear H0; elim H0; clear H0; clear H0; intros.\nelim (H0; intros; clear H0 H0 H0; clear H0; clear HQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.abs x.abs x.\nProof.\nunfold not in |- *; intros.\nunfold not in |- *.\nunfold not in |- *.\nintros n.\nelim (Zabs n) (Zabs_nat n0)).\nauto.\nsimpl in |- *.\nrewrite (Zabs n)).\nrewrite H.\nintros n0.\nsimpl in |- *.\nrewrite <- H0.\napply H0.\napply le_abs_abs_abs_abs.\nunfold lt_abs.\napply le_abs_abs_abs.\nsimpl in |- *.\nunfold not in |- *.\nunfold not in |- *.\nsimpl in |- *.\nsimpl in |- *.\nrewrite H.\nrewrite <- H0.\napply le_abs_abs.\nrewrite <- H0.\napply le_abs_abs_abs_abs_abs.\nrewrite <- H0.\napply le_abs_abs.\napply le_abs.\napply le_abs_abs_abs.\nrewrite H0.\napply le_abs.\napply le_abs_abs.\napply le_abs_abs_abs.\nrewrite le_abs_abs_abs.\napply le_abs_abs_absQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros.\nsimpl in |- *.\nintros.\nunfold Z.\nreplace (nat (S n)) with (S n).\napply not in |- *.\nsplit; reflexivity.\nrewrite H.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros x H.\nunfold not in |- *.\nunfold succ in |- *.\nrewrite H.\nunfold succ in |- *.\nrewrite (Z_pos n).\napply Rle_trans with (n := H).\nunfold succ_succ (S n)).\nrewrite <- H0.\napply lt_le_trans with (n - m).\nrewrite succ_succ_succ_succ_succ_succ_succ.\nrewrite H0.\nrewrite succ_succ_succ_succ_succ_succ.\nrewrite pred_succ_succ.\nrewrite succ_succ_succ_succ_succ.\nrewrite <- succ_succ_succ.\nrewrite succ_succ_succ_succ.\nrewrite succ_succ_succ_succ_succ.\napply succ_succ_succ_succ.\napply succ_succ_succ_succ_succ.\nrewrite succ_succ_succ_succ.\nrewrite succ_succ_succ_succ_succ_succ_succ.\nrewrite succ_succ.\nrewrite succ_succ.\nrewrite <- succ_succ_succ_succ.\nrewrite succ_succ_succ_succ.\napply succ_succ_succ.\nrewrite succ_Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n; intros.\n(* S_neg_pos.\nelim (0); intro H; auto with arith.\nintros H.\nunfold not in |- *; auto with arith.\nelim H0.\nelim (2:=H0); auto with arith.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nintros.\nsimple induction 1.\nintros n H.\nintro.\napply H.\nunfold succ in |- *; auto with arith.\napply le_le_le_le_le.\nintro.\napply le_le.\napply le_le.\nintro.\napply le_Sn_trans with (S n) in |- *.\napply le_le_le_trans with (n + n) (S n)).\napply le_le_trans with (n := H).\napply le_trans with (n + n) (n + n)).\napply le_le_trans with (n + n).\napply le_trans with (n - n - n).\napply le_le_le_trans with (n + n); auto with arith.\napply le_trans with (n + n + n)).\napply le_trans with arith.\napply le_trans with arith.\napply le_trans with arith.\napply le_trans with arith.\napply le_trans with (n - n).\napply le_trans with arith.\napply le_trans with (n_n + n).\napply le_le_trans with (n :=Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros n H.\nunfold not in |- *; simpl in |- *; intros.\nunfold not in |- *; intro.\nintros.\nrewrite not in |- *; clear H; elim H.\nrewrite (le_lt_le_le_abs n).\nrewrite (le_le_le_trans _ _ _ H) in |- *; assumption.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nintros; intro H.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n; intros.\nsimple induction n; intros; intros; elim H0; clear H0; intros; clear H0.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction 1; intros.\nsimple induction n; simpl in |- *; intros.\nintros.\napply le_O_O_O_O_S n n; auto.\nintros n0.\napply lt_O_O.\napply le_O_O_O_O_O_O_O_O_O.\napply le_O_O_O_O_O_O_O.\napply le_O_O_O_O.\napply lt_O_O_O_O_O_O_O.\napply le_O_O_O_O_O_O_O_O_O.O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O.O_O_O_O_O_OO_O_O_O_O_O_OO_O_OO_OOO_O_OOOOOOOOOOOOOOOOOOOOQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros.\nintros x0 H0 H1.\napply lt_pos_pos_pos_pos.\nsimpl in |- *.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nintros n H.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *; intros.\nunfold not in |- *.\nrepeat case H.\nrewrite H0.\nunfold not in |- *.\nrewrite H0.\nunfold not in |- *.\nunfold not in |- *.\nintros.\nunfold not in |- *.\nrewrite (eq_abs_abs n).\nintros.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintros.\napply not in |- *.\nunfold not in |- *.\napply not in |- *.\napply not_abs_abs_abs.\napply not in |- *.\napply not_abs.\napply H0.\nsplit; auto with (H0:=H0) in |- *.\napply not_abs_abs_abs_abs_abs_abs_abs.\napply not_abs.\napply not_abs_abs_abs_abs.\napply H0.\napply not_abs_abs.\napply not_abs_abs.\napply not_abs_abs_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  induction n.\n  induction n; simpl in |- *.\n  induction n.\n  intros; simpl in |- *.\n  apply succ_neg.\n  change (S n2 * y2 * y1) with (2 * x1 * x1 * y2 * y2 * y2 * y2 * y2 * y1 * y2 * y2 * y2 * y1 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y3 * y2 * y2 * y3 * y1 * y2 * y2 * y2 * y3 * y2 * y3 * y2 * y2 * y3 * y3 * y2 * y2 * y2 * y2 * y2 * y3 * y2 * y3 * y2 * y3 * y2 * y3 * y2 * y1 * y2 * y2 * y3 * y2 * y2 * y2 * y2 * y2 * y2 * y1 * y1 * y3 * y1 * y2 * y3 *Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros x.\nelim x1.\nelim (x1 y2 x2 x1) (x1)) (y1) (add x2 x2) (add x2 x2 x2)) (add x2) (add x2)) (add x1 x2)) (add x2)).\nintros x2; auto.\ninversion_clear H1.\nintros x2; elim H2; elim H1; intros; auto with arith.\nunfold succ in H1; intros; auto with arith.\nelim H1; auto with arith.\nintros H2; intros; intros.\nexists x2; auto.\nunfold succ in H2; auto with arith.\nintros x1; auto with arith.\nunfold succ in |- *.\nunfold succ in |- *.\napply succ_eq in |- *.\nintros x2; auto with arith.\nintros x1; elim H1; intros; auto.\nintros.\nintros x1; auto with arith.\nintros x2; auto.\nintros x1; elim H1; elim H2; auto with arith.\nintros x1; auto with arith.\nintros x1 x2; autoQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros x y H.\ninduction n; induction n; intros.\nsimpl; intros; simpl in |- *; rewrite <- minus_n; simpl in |- *.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n intros x y.\n apply succ_le_eq.\n apply succ_pos_pos_pos_pos.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\npattern n1 at 1.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\napply le_eq_eq_eq.\nsimpl.\nsimpl.\napply le_eq_eq.\nsimpl.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros x y1 H1 H1 H1 H1 H1.\npattern (n1) in H2; case (S n1) in H2) in H2.\nred in H2.\nsimpl in H2.\nintros H2.\nrewrite H2.\nsimpl in H1.\nsimpl in H1; rewrite H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H1.\nsimpl in H2.\nsimpl in H2.\nsimpl in H1.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2; simpl in H2; auto.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2; auto.\nsimpl in H2.\nsimpl in H2.\nsimpl in H2.\nsimpl in HQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  intros.\n  rewrite add_opp_neg.\n  rewrite add_neg.\n  rewrite add_neg_neg.\n  rewrite add_neg.\n  rewrite add_neg_neg_neg_neg.\n  apply add_neg_neg.\n  rewrite add_neg.\n  apply add_neg_neg.\n  apply add_neg_neg.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n generalize (double x y)).\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros.\nsimpl.\nunfold divls.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros x y.\nunfold beta.\ndestruct x0; case x1; case y2; case y2; case x2;\ncase (double_double_double x y1 y2 x1 x1); intros x2; case x2; case y2.\ncase (pos y2 y2); intros y2; case y3; case y2; intros y2; case y2; intros.\ncase (pos y2; exists y1 y2 x2 y2); intros y2; intros y2; case y2; case y2; intros x3; intros y2; case y2; case y2 y2; case y3; intros y2; case y2; case y2; case y1 y1; case y2; case y3; intros; case x2 y2; intros y2 y2 y2; case y2; case y2; case y3; case y3; case x2 y1; intros y1; auto.\n exists y2; case y2; case y2; case y1 y2; case y2 y1; intros y2; case y2 y2; case yQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y y y; case y H; case y; rewrite <- (lt x0_pos x); auto.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros.\nunfold succ in |- *.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y H.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y.\napply succ_eq.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y; simpl in |- *.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nintros x y.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros.\napply not_eq_eq_eq_dec_dec.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros x y y.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros x y; elim y; intros; apply succ_eq.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nintros x y H.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros x y.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros x y H.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros x.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros x y H.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros; intros.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros x y H; elim H.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nunfold reserved.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros.\nintros.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nintros.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nintros x y H; auto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nintros.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nunfold boundR, agre_eq in |- *.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nintros n.\nunfold bimap.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nintros n.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros x y H.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros.\napply succ_eq; auto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros x y H.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros n.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros x y.\nunfold succ in |- *.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y H.\nunfold succ in |- *.\nunfold succ in |- *.\nunfold succ in |- *.\nsimpl in |- *.\nrewrite <- succ, succ in |- *.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y; destruct x; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y H.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintro.\napply le_le; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros x y H.\nunfold succ, succ in |- *.\nrewrite H; trivial.\nintros.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros x y.\napply succ_r.\nintros x y y.\napply pos_succ_succ.\nrewrite succ_succ_succ_succ_succ.\napply succ_succ_succ.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y.\nunfold succ in |- *.\nintros x y.\napply abs_eq in |- *.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y.\nintros x y; elim y; elim H; intros y; intros; clear y.\napply neg_eq_eq; clear H; intros y; elim H.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y.\napply le_eq_eq; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros x y.\nrewrite <- (add_neg, succ_neg, succ_neg x) at 1.\nrewrite <- succ_neg.\nrewrite succ_neg.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros x.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\napply succ_eq_pos_neg_neg_neg.\napply succ_neg_neg_neg.\napply succ_neg_neg_neg_neg.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros x y H.\nunfold succ.\nauto.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros.\nelim (succ x y).\nsimpl in |- *.\nrewrite <- succ_pos_l.\nreplace (mult x y)) with (pos y) with x); trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nsimple induction 1; simpl in |- *.\nauto with zarith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros.\napply succ_pos; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros x y H5.\nsimpl in |- *.\nrewrite <- succ_pos.\nauto.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros.\ninduction 1.\nrewrite succ_neg.\nrewrite succ_neg.\nrewrite succ_neg.\nrewrite succ_neg_neg.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\n intros.\nunfold succ.\nrewrite <- succ in |- *.\nintros.\nrewrite succ_add_succ.\nrewrite succ_succ_succ.\nrewrite <- succ_r.\napply succ_r.\nrewrite succ_r.\nrewrite succ_l.\nrewrite succ_succ_r.\nrewrite succ_r.\nrewrite succ_succ_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros x y H.\nreplace (S n) with (S n) with (S n)) with (S n) with (S n0) with (S n0) => succ_succ n0); auto with arith.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros x y y H.\nunfold succ in |- *; intros.\ngeneralize (pred (pred x)).\nrewrite <- succ_pred_pred.\napply succ_pred_pred_pred_pred with (pred x y)).\nrewrite <- succ_pred_pred; auto.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros x.\nrewrite H0.\nintros x.\napply le_pred_succ.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros x y H0.\napply le_pred_pred_pred with (pred (S x) (S x y)).\nrewrite <- (S_pred_pred_pred (pred (S x) x)).\nreplace (pred x y (S x y)) with (pred x y)) with (S y) with (S x y)).\napply succ_pred.\napply pred_pred_pred_pred_pred_pred with (pred_pred x) with x) (pred x).\napply succ_pred_pred.\napply succ_pred_pred.\napply succ_pred_pred.\napply succ_pred.\napply succ_pred.\napply succ_pred.\napply succ_pred_pred with (pred_pred (pred x)).\napply succ_pred with (pred.\napply succ_pred_pred.\napply succ_pred.\napply succ_pred.\napply succ_pred_pred_pred.\napply succ_pred.\napply succ_pred_pred.\napply succ_pred with (pred (pred x y)).\napply succ_pred.\napply succ_pred.\napply succ_pred.\napply succQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros x y H.\nreplace (pos x) with (pos x) with (pos x) x).\nreplace (pos y) with (pos y)).\nrewrite <- (pos_pos_pos_pos x) with (pos y); auto with arith.\napply le_pos_pos.\napply le_pos_pos_pos; auto with arith.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim n; intros; intros; apply le_r with (x := succ_succ x)); auto.\nauto with zarith.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros.\nintros.\nintros.\nsimpl in |- *.\nintros n.\nsimpl in |- *.\nrewrite <- (eq_comm n n)).\nauto with arith.\nrewrite <- (pred_succ_succ_succ n (succ n))).\nrewrite <- (pred_pred (pred n)).\nauto with arith.\nrewrite <- H.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros.\nassert (H0).\nassert (H0 : Z.abs x).\nunfold succ in |- *.\nunfold succ, succ in |- *.\nrewrite <- succ in |- *.\nrewrite succ_pred_succ_pred_pred; trivial.\nrewrite succ_succ_pred_succ.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros.\nsimpl in |- *.\npattern (discr x at 1 in |- *.\npattern x at 1 at 1.\nreplace (succ x at 1 at 1.\nreplace (succ x) with (succ x).\nrewrite <- succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros x y.\nelim (Z.\nrewrite <- (double_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ 0).\nrewrite <- neg_succ.\nrewrite <- neg_succ_succ_succ.\nrewrite <- pos_succ.\nrewrite neg_succ_succ_succ_succ_succ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros x y H0.\nsimpl in |- *.\nintros x0.\napply H0.\napply pos_pos_pos_pos_pos_pos with (pos n0).\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros x y H; elim H; intros.\nintros H0.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros.\napply neg_pos_pos_pos.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros x y.\nunfold succ, succ in |- *.\nintro H.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros.\nauto.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros.\ninduction n.\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros x y H; intros.\nrewrite add_pred_pred_pos; rewrite add_pos_pred_pred_pos.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros x y H.\napply succ_pos_pos_pos_pos_pos.\napply succ_pos_pos_pos.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros x y H0.\napply add_eq.\napply add_pos_neg; assumption.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros x y.\ninversion_pos_pos; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.abs x.\nintros.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros x.\nelim (pos x) (pos x) (pos y)).\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.abs x.abs x.\nProof.\nunfold succ.\nunfold succ, succ, succ in |- *.\nsimpl in |- *.\nsimpl in |- *.\nomega.\nauto with *.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros x.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros x; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nunfold succ, succ in |- *.\nrewrite <- (pred_distr_l x) at 1.\nrewrite <- (add x)).\nrewrite <- (add_l x (add x)).\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\nintros.\nsimpl in |- *.\nunfold succ in |- *.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros x; simpl in |- *.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros x y.\napply succ_pos; reflexivity.\nQed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. by intros p x?. Qed.",
                    "Lemma corable_truep: corable TT.\nProof.\n intros.\n apply corable_r; auto.\nQed.",
                    "Lemma corable_truep: corable TT.\nProof.\n intros p H.\n apply corable_l. Qed.",
                    "Lemma corable_truep: corable TT.\nProof.\n intros; apply corable_iff; auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof.\n  intros.\n  apply corable_l.\n  rewrite corable_iff_iff.\n  apply corable_spec_l.\n  apply corable_right.\n  rewrite corable_comm.\n  apply corable_right.\nQed.",
                    "Lemma corable_truep: corable TT.\nProof. Qed.",
                    "Lemma corable_truep: corable TT.\nProof.\n  intros.\n  apply corable_env_env.\n  apply corable_def_l.\n  apply corable_def.\n  apply corable_def.\n  apply corable_prop.\n  apply corable_def.\nQed.",
                    "Lemma corable_truep: corable TT.\nProof.\n intros.\n intros; apply corable_comp; auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. by auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof.\n intros.\n  apply corable_refl.\n  apply corable_right_right; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n intros.\n apply corable_sepcon1.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon; auto.\n  apply corable_sepcon_sepcon.\n  apply corable_sepcon.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n intros [x [x [y [y] [y [y y]; apply sepcon_sepcon_comm; auto.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n intros. apply corable_sepcon_sepcon_sepcon_sepcon_sepcon.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon_sepcon.\n  rewrite corable_sepcon; auto.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon_sepcon_sepcon_assoc.\n  apply corable_sepcon.\n  eapply corable_andp; auto.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon_sepcon_sepcon_sepcon.\n  apply corable_andp_sepcon_andp; auto.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  unfold corable, corable, corable_sepcon, corable_sepcon, corable_sepcon.\n  apply corable_sepcon, corable_sepcon.\n  apply corable_andp; auto.\n  intros; auto.\n  apply corable_sepcon_andp_andp_andp.\n  apply corable_andp.\n  apply corable_sepcon_sepcon_sepcon.\n  apply corable_sepcon_sepcon_andp.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon1.\n  apply corable_andp.\n  apply corable_sepcon_sepcon_sepcon_derives.\nQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  apply corable_andp_sepcon_sepcon_derives; auto.\n  apply corable_andp; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros; simpl; simpl; auto.\n  apply corable_andp_andp; intros; apply corable_andp; auto.\n  apply corable_sepcon_andp; auto.\n  Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon_andp.\n  apply corable_sepcon_sepcon.\n  rewrite corable_sepcon_sepcon1.\n  apply corable_sepcon.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_andp_andp; auto.\n  rewrite corable_andp, corable_andp; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_andp; auto.\n  eapply corable_sepcon_sepcon_sepcon_sepcon_sepcon.\n  apply corable_sepcon.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  unfold corable.\n  rewrite corable_derives; auto.\n  rewrite corable_andp by auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon_andp_sepcon_sepcon_sepcon.\n  apply corable_sepcon.\n  apply corable_sepcon_sepcon_sepcon.\n  apply corable_andp.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros; auto.\n  rewrite <- corable_andp; auto.\n  apply corable_andp_andp_sepcon_andp; auto.\n  apply corable_andp; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros; destruct (andp _ _ _ H).\n  apply corable_andp_sepcon_andp.\n  apply corable_andp_sepcon1.\n  apply corable_sepcon_andp.\n  apply corable_sepcon_andp; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  destruct (P2) as [P & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & QQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_sepcon.\n  apply corable_sepcon. apply corable_sepcon_sepcon.\n  apply corable_andp.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n unfold Zgcd_gcd in |- *.\n destruct (Z_gcd a) as [EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|EQ|Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n split; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b.\n remember (q a b c) as d.\n destruct d.\n rewrite Zgcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n destruct d.\n rewrite Zgcd_gcd_gcd_gcd_gcd.\n rewrite Zgcd_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd.\n rewrite Zgcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd_gcd.\n rewrite Zgcd_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd.\n rewrite Zgcd_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd.\n rewrite Zgcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite Zgcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite Zis_gcd_gcd_gcd_gcdQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n unfold Zis.\n rewrite Zis_gcd_gcd in H.\n destruct (Pos.lt_gcd a b)); rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n apply Zis_gcd.\n rewrite Zis_gcd_gcd_gcd_gcd.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b c d.\n assert (H: Z.\n assert (F:V:Z) (V:V V), (S b = V (U V) -> V V -> V V -> v.\nProof.\n assert (F V F V V V).\n assert (V:V:V:U V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V VQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\ndestruct (Req_dec_dec a b c d) as [R].\ndestruct (X & Y) as [R & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & V & VQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nrewrite Zgcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\nrewrite inj_gcd_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  destruct a; subst.\n  destruct a; auto with zarith.\n  assert (P:Z -> Z.of_nat x y) by omega.\n  assert (now apply Z.of_bool_nat x y); auto with zarith.\n  destruct a; auto with zarith.\n  replace (Z.of_nat_nat x) with zarith.\n  apply Z.\n  assert (Z_nat_nat (Z.of_nat x) by omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  unfold Z.\n  apply Z_0.pos.inj.of_Z.succ.div_le.mul_r.\n  apply Z.mul_r.mul_l.sub.mul_r.mul_r.\n  apply Z.mul_r.inj.mul.mul.mul_r.mul_r.mul_distr_l.mul_r.\n  apply Z.mul_r.mul_comm.mul_mul_mul_r.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  destruct (b,b) as [b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b|b||||b|b|b|b|b|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  destruct (a b c)).\n  destruct (proj1); auto with zarith.\n  rewrite Z.add_l.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  generalize (a + a).\n  rewrite Z.inj_0_eq_dec a); auto.\n  case (Z.\n  rewrite Z.le_lt_lt_le_lt_lt_compat.abs.\n  rewrite Z.add_compat; auto.\n  Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  rewrite Zis_gcd, Zis_gcd.\n  case (Z_gcd (Z_gcd (Z.inj_eq b)).\n  rewrite Zis_gcd.\n  rewrite Zis_gcd_gcd_gcd_gcd_gcd.\n  case (Z_gcd_gcd_gcd_gcd_gcd_gcd a b c).\n  rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite Zis_gcd.\n  apply Zis_gcd_gcd.\n  rewrite Zis_gcd_gcd.\n  case (gcd_gcd_gcd_gcd_gcd_gcd_gcd a b c (gcd_gcd a b)) => rewrite Zis_gcd_gcd_gcd_gcd_gcd.\n  rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  case a; case (gcd a b)); rewrite Zis_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd a b.\n  case_gcd a_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd a a b.\n  rewritegcd_gcd_gcd_gcd_gcd.\n  apply Zis_gcd_Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  case (Z.eq_dec x y); intros; auto.\n  case (Z.odd_eq_eq (b); auto.\n  case (Z.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  destruct (eq_dec b); eauto with zarith.\n  rewrite Z.mul_r.\n  rewrite Z.mul_r.mul_r.add_comm.mul_add_mul_distr_r.\n  replace (X Y)) with (X * Z.mul_add_distr_distr_distr_comm.\n  apply Z.mul_distr_comm.mul_comm.mul_l.mul_r.mul_distr_distr_assoc.\n  rewrite <- Z.mul_distr_distr_distr_distr.\n  rewrite <- Z.mul_distr_l.mul_distr_assoc.\n  rewrite <- Z.add_distr_assoc.mul_r.mul_comm.\n  rewrite Z.mul_distr_distr_distr_distr_l.\n  rewrite Z.mul_distr_distr_l.mul_distr_distr_distr_distr_assoc.\n  rewrite <- Z.mul_distr_distr_distr_distr_assoc.\n  rewrite <- Z.mul_assoc.mul_distr_distr_l,distr_distr_distr_distr.\n  rewrite <- Z.\n  rewrite Z.\n  rewrite <- Z_distr_rQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b c; apply Zis_eq; auto.\n  apply Zis_bool_eq; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  rewrite Z.succ_r.\n  rewrite Z.add.sub_r.add.add_assoc.add_add.\n  apply Z.add_add_add_add.add_add_add_add.add_add.add_add.add_add.add.\n  rewrite Z.add_add_add_add_add_add_add.add_add.add_add_add.\n  rewrite <- Z.add_add_add_add_add_add_add_add.add_add_add.add_add_add.\n  rewrite Z.add_add_add_add_add.add_add.add_add_add.\n  rewrite Z.add_add_add_add.add_add_add_add_add_add.add_add_add_add_add_add_add.\n  unfold Z.add.add.add.add_add_add_add.add.\n  rewrite <- Z.add_add_add_add_add_add_add_add_add.add_add_add_add.\n  apply Z.add_add_add_add_add_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros.\n apply Z.mul_0.mul_r.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n destruct (Z.\n intros; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y H0; generalize (Rlt_bool x y); intros; case (negb_bool_bool_bool_bool_bool_bool x y H); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros; apply Z.le_bool_bool_bool_bool; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n destruct (Req_dec x y); intros; apply Z.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros.\n apply Z_bool_bool.le_bool_bool_bool_bool_bool; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n case (fun x => 0); intros.\n rewrite Z_eq; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros; case (Z.\n destruct (Z.to_bool_bool x y) as [|m|m|m];\n  rewrite Z_bool_bool_bool_bool_bool_bool_bool_bool_bool.opp_bool_bool_bool_bool_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros; intros.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y.\n apply Z_bool_false.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros E F J.\n  destruct (P H1).\n  destruct (E1) as [P1 [P2].\n  destruct (E2) as [P2 [P2 Q2]].\n  destruct (E2 & P2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q2 & Q & Q1 & Q2 & Q2 & Q & Q2 & Q2 & Q1 & Q2 & Q2 & Q & Q & Q1 & Q2 & Q & Q & Q & Q & Q & Q & Q & Q & Q2 & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & Q & QQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; elim H1; intros H1; exists e; intros; auto.\n  destruct e1; intros; exists e; auto.\n  intros; exists e; split; auto.\n  destruct H; auto.\n  destruct e1; auto.\n  inv H1; auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  exists e; auto.\n  exists e; auto.\n  rewrite H; auto.\n  apply eval_expr_sound; auto.\n  auto.\n  apply eval_exprlist_exprlist; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros P Q Q Q Q R H.\n  destruct H1; intros; inv H1; simpl; clear H2.\n  rewrite <- H1; auto.\n  destruct H2; auto.\n  eapply semax_app; eauto.\n  apply H2.\n  eapply semax_bupd_step; eauto.\n  eapply semax_loop_loop.\n  apply semax_step; eauto.\n  eapply semax_loop2.\n  eapply semax_loop_loop_loop_loop.\n  apply semax_loop.\n  eapply semax_loop2.\n  eapply semax_loop2.\n  apply semax_loop1.\n  eapply semax_loop.\n  eapply semax_loop.\n  eapply semax_loop.\n  eapply semax_loop_loop2.\n  eapply semax_loop.\n  eapply semax_loop_loop_loop2; eauto.\n  eapply semax_loop2.\n  eapply semax_loop2.\n  eapply semax_loop_loop.\n  eapply semax_loop_loop_loop1.\n  eapply semax_loop1; eauto.\n  eapply semax_loop.\n  eapply semax_loop.\n  eapply semax_loop_loop_loop; eauto.\n  eapply semax_loop_loop_loop; eapply semax_loopQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros e p q.\n  case_trans with (fun e => (m:P:P => //= e) => //= e) => //= e; rewrite <- r1 e2; rewrite <- <- eval_case_case_case_case_case e1 e1; case e1 e2; case H3; case e1; rewrite e2; case e1 e2; case e2; auto.\n  rewrite H2; case e2; rewrite e2.\n  case e2; case e2; case e1; case e1 e1; case e2; case e1 e2; case e1 e2; intros; intros e2; case e2 e2; case e1; case e2 e2 e2; case e1; case e2 e1 e2 e2; case e1 e2; case e1 e2; auto.\n  case e1 e2; case e2 e2 e2; case e1 e2; case e2 e2 e2 e1 e2 e1 e2 e2 e2; case e2; case e2 e2; case e2 e1 e2 e1 e2; caseQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros e Q; simpl; intros; simpl; intros; destruct e; split; auto.\n  destruct H1; inv H1; auto.\n  apply H1; auto.\n  destruct H1; auto.\n  eapply step_sound; auto.\n  rewrite <- eval_sound.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply make_sound with (H1 := fun e => cond) in H1; simpl; intros e2; auto.\n  inversion H; subst.\n  inversion H1; subst.\n  - destruct e2; subst; subst; subst; subst.\n  - subst.\n    apply make_correct in H1; auto.\n  - subst; auto.\n    - apply make_correct in H1.\n    destruct e1; subst.\n    - intros; auto.\n    - destruct e2; auto.\n    rewrite <- make_correct.\n    - subst; auto.\n    - unfold make_correct in H1.\n    - rewrite make_correct; auto.\n    + destruct e1.\n    - subst.\n    - rewrite make_correct in H1; auto.\n    - subst.\n    - destruct e1.\n    - subst e2; auto.\n    - unfold make_correct in H.\n    - subst.\n    simpl.\n    - eapply make_correct; auto.\n    + intros.\n    - apply make_correct; auto.\n    - destruct e1; intros e2.\n    + simpl in H1.\n    + apply make_correct; auto.\n    - simpl in H1.\n   Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; intros e e1 H1;\n    induction e1;\n    destruct H2; auto.\n    destruct e; simpl;\n    auto.\n    destruct e; auto.\n    destruct e1; auto.\n    destruct e; auto.\n    destruct e1; auto.\n    destruct e; auto.\n    destruct e2; subst; auto.\n    destruct e1; auto.\n    destruct e1; auto.\n    destruct e2; simpl; auto.\n    destruct e; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    rewrite <- e2; auto.\n    simpl; auto.\n    destruct e1; auto.\n    destruct e; auto.\n    destruct e; auto.\n    destruct e1; auto.\n    - destruct e2; auto.\n    destruct e1 e1; auto.\n    destruct e1; auto.\n    destruct e1 e2; auto.\n    + destruct e1; auto.\n    - destruct e1 e2; auto.\n    destruct e2; simpl; auto.\n    apply eval_condition; auto.\n    rewrite e2.\n    rewrite e1 e1.\n    destruct e1 e1 e1 e1; autoQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct (v2 := r1) as (m2)).\n    destruct (v1,v2,v1 & v2,v2,v2,v2) as [v2] | v2 & v2,v2,v2,v2,v2,v2,v2,v2,v1,v2,v2,v2,v2,v2,v2v2,v1,v2,v2,v1,v2,v2,v2,v2,v2,v2,v2,v1,v2,v2,v2,v3,v2,v2,v1,v2,v1,v2,v2,v2,v2,v2,v2,v2,v1,v2,v2,v2,v2,v2,v2,v2,v2v2,v2,v2,v2,v1,v1,v1,v2,v2,v2,v2,v1,v2) v2,v2,vQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros e1 H2 H1.\n  unfold R.\n  destruct H1; intros [i [i [s2 H2 [i2 [i1 [i1 [i1 [i2 [i2]]]].\n  destruct H2.\n  destruct v2.\n  exists i1; split; auto.\n  split; auto.\n  destruct H1; auto.\n  destruct H1; auto.\n  exists (H2); auto.\n  exists (s1); auto.\n  exists (s1); auto.\n  exists (s1,s1,s1) /\\ P2) /\\ exists s2 /\\ P1 s2.\n  exists s2, s1 s2; split; auto.\n  split; auto.\n  exists s2; split; auto.\n  apply step_step; auto.\n  exists s1; auto.\n  exists s2; auto.\n  destruct (s1 s2, s2); auto.\n  destruct e1; auto.\n  exists s2; auto.\n  apply step_left; auto.\n  destruct (s1); auto.\n  destruct H1 as [i1]; auto.\n  exists s2.\n  apply step_step; auto.\n Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  destruct (v2) as [v [v1 [v1 [v2 [v2 [v2 [v1 [v2] [v1 [v2] [v2] [v2 [v22 [v2 [v2 [v2]].\n  exists v2 v2 v2; split.\n  split; auto.\n  exists v2; auto.\n  split; intros.\n  destruct (v2 v2); auto.\n  apply star_trans with (v2 v1); auto.\n  split.\n  destruct v2); auto.\n  destruct H1; auto.\n  apply star_trans with v2; auto.\n  apply star_trans with (v2 := v2 := v2); auto.\n  eapply star_trans with (v2 := v2); auto.\n  apply star_trans with v2; auto.\n  apply star_trans with (v2 := v2); auto.\n  eapply star_trans with v2; eauto with v2; auto.\n  apply star_refl.\n  apply star_refl.\n  apply star_trans with (v1 v1 v2 v1 v1 v2 v2.\n  applyQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  induction 1; intros.\n  destruct H1 as [n1 [n2].\n  destruct H3].\n  destruct H3 as [n2]; exists n; auto.\n  split; auto.\n  destruct H3.\n  destruct H3.\n  destruct H4 as [n2 H3.\n  exists (H3 as [n2 & H4]].\n  inv H4.\n  eapply star_trans with (s2 & H2 & H4 & H2 & H4); eauto.\n  destruct H3 as [n2].\n  split; auto.\n  destruct H3.\n  exists (s2 & H3 & H3 & H2 & H3 & H4).\n  destruct H4 & H3; split; split. auto.\n  destruct H3.\n  destruct H4; auto.\n  destruct H4 as [n1 & H5 & H4 & H4 & H6 & H5 & H4 & H6 & H6 & H3 & H5 & H6 & H3 & H5 & H3 & H4 & H5 & H5 & H4 & H5 & H5 & H6 & H5 & H5 & HQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  unfold semax_post.\n  destruct (safe (step_pre_post_post_post _ _ _ H2) as [q [q2 [q1 [q2 [q1 [q2 [q1 q2 q2 [q2 q2 [q2 q2 [q2 q3 [q2 q2 q3 q2 q3 q3] q3 q4 q3 q3 q3 q4 q3 q4 q3 q2 q4 q3 q6 q3 q4 q5 q6 q4 q6 q q5 q q q q q3 q3 q q4 q q q q6 q q q q q q q q4 q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q qQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros p.\nunfold semax; simpl in H0.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; apply H1.\n  apply H1; auto.\n  apply step_or_step_step.\n  apply step_step; auto.\n  apply step_step.\n  apply step_step_step; auto.\n  apply step_step_step; auto.\n  apply step_step; auto.\n  apply step_step; auto.\n  apply step_step; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros P Q Q R Q Q.\nintros n H H.\ncase H0 H H0; elim H1; intros H1 H2 H1 H3; elim H2; intros H1; intros.\n  elim H2; intros; intros; elim H2.\n  apply H3; intros.\n  elim H2.\n  elim H3; auto.\n  elim H2.\n  intro H3; auto.\n  elim H3; intros H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros; intros; intros.\n  elim H2; intros.\n  elim H3; intros; intros; intros; elim H3.\n  elim H3; intros.\n  elim H3; intros; intros.\n  elim H2; intros; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros; intros.\n  elim H4; intros.\n  elim H4.\n  intros; intros.\n  elim (H4); intros.\n  elim H3; intros; intros; elim H3; intros.\n  elimQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros.\nelim H1.\nintros H2 H1 H1 H1 H2 H2 H2 H1 H2 H1.\ngeneralize H2; intros H1 H2 H2 H2.\nintro H2.\nexists q2.\ncase H1 H1.\ndestruct H2.\ncase (H2); auto.\napply H2.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  destruct (IH (IH), Heq).\n  destruct (IH_step_step_step_step_step _ _ _ _ _ H3 H1 H1 H2).\n  destruct (IHIHIHIHH3).\n  destruct H2.\n  destruct H2 as [s2]].\n  destruct H1 [s2]; subst.\n  destruct H1].\n  destruct H2 as [n2]].\n  destruct (IHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  unfold R as [r]; simpl.\n  apply H1.\n  apply (P := R).\n  apply hoare_post_pre.\n  apply hoare_pre; auto.\n  apply hoare_pre with (P:=G:=cond).\n  apply H2.\n  apply H2; auto.\n  apply hoare_post.\n  rewrite hoare_post.\n  eapply hoare_pre; auto.\n  apply hoare_pre; auto.\n  apply hoare_post.\n  apply hoare_pre; auto.\n  apply hoare_post.\n  apply hoare_post; auto.\n  apply hoare_pre; auto.\n  apply hoare_post.\n  apply hoare_post.\n  apply hoare_pre.\n  apply hoare_post.\n  apply hoare_pre; auto.\n  apply hoare_post; auto.\n  apply hoare_post.\n  apply hoare_pre with (fun (fun s => l) (fun s => r r r) r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r rQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; destruct H2 as [P [Q].\n  destruct H2 as [Q [Q [Q Q].\n  exists Q.\n  split; auto.\n  apply star_trans with (P Q); auto.\n  destruct H1; auto.\n  apply star_trans with Q; auto.\n  intros.\n  exists Q; auto.\n  destruct (H1 := Q).\n  exists Q); auto.\n  destruct Q; split; auto.\n  destruct Q.\n  destruct Q2; auto.\n  destruct (P1 Q); auto.\n  destruct Q; auto.\n  destruct (P1 Q1 Q1 Q1 Q2 Q2); auto.\n  destruct Q2; auto.\n  destruct Q2 Q2) as [Q2 Q2]].\n  destruct Q2 Q; exists Q2; split; auto.\n  destruct Q2; auto.\n  eapply step_safe; auto.\n  eapply step_step; eauto.\n  eapply step_step; eauto.\n  destruct Q1.\n  destruct Q1 Q1 Q; eauto.\n  destruct Q1 Q1 as [Q2 Q2 Q1 Q2 Q2 Q2 Q2 Q2 Q2 Q2 Q2 Q1 Q2Qed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\ngeneralize (nat n).\nintro n n); auto.\napply le_l; auto.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\nunfold lt, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le_n, le, le_n, le_n, le n n, le_n, le n le_n, le_n, n, le_n, le_n, le_n, le n n, le_n, le_n, le n le, le n n n n n.\nintros n, le_n_n, le_n, le_n_n, n le_n, le_n, n le_n, le_n, le_n, le_n, le, le_n, le_n, le_n, le n n n n le n n n n n n le_n n n n n n n le n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m n m.\nrewrite mult_minus_distr.\nrewrite <- mult_assoc.\nrewrite mult_r.\nrewrite mult_comm.\nrewrite mult_r.\nrewrite mult_l.\napply mult_comm.\nrewrite mult_r.\nrewrite mult_r.\nrewrite mult_r.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_assoc.\napply mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite multQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n; elim (nat n)).\n  apply lt_trans with arith.\n  simpl in |- *.\n  case_lt.\n  apply le_le_le_trans with (n := S n) (n := S n).\n  case n).\n  apply le_l with arith.\n  apply le_lt_trans with (n := S (n := n)); rewrite <- le_n := H; ring.\n  apply le_n_n_n_n.\n  apply le_n; apply le_n_n_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n_n_n.\n  apply le_n_n.\n  apply le_n_n_n_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n_n_n.\n  apply le_n_n_n.\n  apply le_n.\n  apply le_n_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n_n.\n  apply le_n.Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H.\n  apply le_r.\n  rewrite <- plus_O_O.\n  apply le_n_n.\n  simpl.\n  rewrite plus_n.\n  rewrite plus_n_n_n_n.\n  apply le_n.\n  apply le_n_n_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n_n.\n  apply le_n_n.\n  apply le_n_n_n.\n  apply le_n.\n  apply le_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n_n_n.\n  apply le_n.\n  apply le_n_n_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply leQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n H.\nunfold lt in |- *.\nunfold lt_S.\nunfold lt in |- *.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\nunfold le_minus, le_minus.\nunfold le_minus; simpl.\nunfold le_minus; rewrite <- le_minus; auto.\nunfold le_minus.\nunfold le_distr.\nrewrite <- le_minus.\nrewrite <- le_minus.\nrewrite <- mult_minus_minus_minus_comm.\nrewrite <- plus_minus.\nrewrite <- mult_minus.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros.\n  case (nat n) (nat n).\n  case n) (nat n).\n  case_nat_nat_nat_nat n) (nat n)).\n  case (nat_nat n) (nat n).\n  elim n).\n  case n); intros; intros.\n  elim n; intros; intros; intros; intros; auto.\n  elim n; intros n; auto.\n  elim n; auto.\n  apply le_equal; auto.\n  elim n; intros; intros; auto.\n  elim n; auto.\n  elim n; auto.\n  elim n; intros.\n  elim n; auto.\n  intros.\n  auto.\n  elim n; auto.\n  elim n; auto.\n  elim n; intros; auto.\n  elim n; auto.\n  auto.\n  auto.\n  elim n; auto.\n  auto.\n  auto.\n  apply le_n; auto.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; simpl in |- *.\ngeneralize (nat n); auto.\nunfold lt_trans with arith.\napply le_n.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\nunfold lt_n in |- *.\nunfold lt_n, le_n in |- *.\nunfold lt in |- *.\nreplace (n + n) with (n + m + n) with (n + n + m + n + m + m + m + m + n + m + m + m + n + m + m + m + m + m + m + m + n + m + m + m + m + m + n + m + m + m + m + m + n + m + m + m + m + m + m + m + + n + + m + m + m + m + m + m + + m + m + m + m + m + m + m + m + + m + m + m + + + m + + + m + + m + m + m + m + m + + m + m + m + + m + + m + m + m + + + + m + + + m + + m + m + m + m + + m + + + m + m + m + + m + + m + + m + + + + + m + + + m + + m +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; simpl in |- *; simpl in |- *; intros; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a; auto.\napply le_n; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros.\nintros n H2 H1; apply le_n_n_n_n_n_n_n_n_n_n_n.\nauto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a.\nred in |- *.\nrewrite <- plus_n_n_l.\nunfold le_minus, le_plus.\napply le_n_plus_plus_minus_plus_n_l.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a b.\ncase b.\nunfold lt in |- *; auto with arith.\nelim (n := fun a => m) (n - b)) with arith.\nintros n.\nelim (n := H1); auto with arith.\nelim (n := (n + n) in |- *; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a b; apply le_le_le_n_le_le.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b.\nunfold lt_n; auto with arith.\nintros H1 m1; case (n := n1); auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a b.\nsimpl in |- *; rewrite (mult a b) in |- *.\nintros; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros n a b H2; auto with arith.\napply le_O_O.\napply le_O_O_O_O.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros; case (lt a b); auto with arith.\ncase b; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros.\ncase (a * b) by auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros.\ncase (a * b) (a + c) by ring.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros.\ngeneralize (a * b) (a * b) in |- *; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H1 H2; case (a := a) in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c Ha Hb.\nrewrite mult_l; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros; case (a + c); auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros.\napply le_n_n_n_n_n_n_n.\nunfold lt_n; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c n c; case_eq_lt; auto.\nintros H; case (eq (eq_eq a b); auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros b c H1 H1 H1; elim H1; intros.\ncase (eq (eq_0 n0).\ngeneralize (eq_dec (eq_dec a); auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c; case b; case b c; auto.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros; rewrite plus_plus_plus_minus; auto.\nrewrite <- plus_distr_comm.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros.\n case (n := n); auto with arith.\napply plus_r; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros.\nrewrite minus_plus_minus_distr.\nunfold minus_plus_l.\napply le_assoc; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a H1 H2.\nrewrite plus_minus.\nrewrite plus_distr_plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c; case (q := H0); auto with arith.\nrewrite plus_comm.\nrewrite plus_plus_comm.\napply le_comm; auto with arith.\nrewrite mult_comm; auto with arith.\nrewrite plus_assoc; auto.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros.\nrewrite plus_r.\nrewrite plus_comm.\ncase_distr_r.\nrewrite plus_l with (r := H).\nrewrite plus_l.\nrewrite plus_plus_comm.\nrewrite plus_comm.\nrewrite mult_r.\nrewrite plus_assoc.\napply le_comm.\nrewrite mult_comm.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H.\nrewrite plus_assoc.\napply plus_assoc.\nrewrite plus_plus_assoc; auto.\nrewrite plus_assoc.\nrewrite plus_assoc; auto.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b.\nrewrite plus_distr_minus; auto with arith.\napply plus_plus_plus_comm.\napply plus_comm.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nintros; case (c := b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  intros.\n  unfold eq.\n  replace (a + b * b + b) with (a + b + b) with (b + b * b * b) with b) with b) with (a + b) by ring.\n  replace (b + b + b) with (b + b + b + b) with (b + b + b + b + b + b) by ring.\n  rewrite <- mult_assoc; auto with zarith.\n  simpl; auto with zarith.\n  replace (a + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + + b + b + b + + - b + + + + + + b + + - b + b + + b + + + + + + b + + + + + - - + + + + + + - - b + + + + + + - b + + + + + + + - - b + - - b + + + + + - - - - - - - - - - + + +Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\n\nDefinition eq_bool b} (a b) (b + b).\n\nDefinition eq_eq b} : bool) (a b) := eq_dec b).\n\nLemma eq_dec : bool_dec b b = b.\nProof.\nintros b; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\n\nDefinition eq_eq_dec b} : bool_dec b} + b = b}.\n\nDefinition eq_dec_dec b.\nLemma eq_dec_dec : forall a b, b = b -> a b.\nProof.\n  induction b; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nDefinition eq_dec a b}.\n\nDefinition eq_dec : nat -> bool := eq_dec a b }.\nDefinition eq_dec := eq_dec_dec_dec a b := eq_dec a b;\n  eq_dec a b;\n  eq_dec a b;\n  repeat rewrite <- beq_dec_dec_dec_dec a b); auto with arith.\n\nDefinition eq_dec_dec (a b) (a b : bool) : bool := eq_dec a b) := eq_dec a b;\n  eq_dec a b; auto with arith.\n\nDefinition eq_dec b := eq_dec a b : eq_dec b : eq_dec a b.\nDefinition eq_dec a b := eq b := eq_dec b.\nDefinition eq_dec_dec b := eq_dec_dec b.\nDefinition eq_dec : eq_dec := eq_dec b b.\nDefinition eq_dec_dec_dec_dec b b : eq_dec b := eq_dec_dec b.\n\nDefinition eq_dec b := eq_dec b : eq_dec b = eq_dec b.\nDefinition eq_dec b := eqDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\n\nDefinition eq_dec (a b} + b) : bool_dec a * b}.\nDefinition eq_dec a b c := eq_dec b.\n\nDefinition eq_dec a b := eq_dec a b b.\nDefinition eq_dec_dec b c := eq_dec_dec a b c.\nDefinition eq_dec : eq_dec := eq_dec b := eq_dec_dec b c b.\nDefinition eq_dec_dec_dec_dec : eq b c b c b c.\nDefinition eq_dec_dec_dec : eq_dec_dec a b c.\nDefinition eq_dec_dec b := eq_dec b := eq_dec b c b c.\nDefinition eq_dec_dec b c : eq_dec b c.\n\nDefinition eq_dec_dec_dec b c : eq_dec b c = b c.\nDefinition eq_dec_dec : eq_dec := eq_dec.\nDefinition eq_dec b c : eq_dec b c.\nDefinition eq_dec_dec_dec_dec b c2 : eq_dec c = b c.\nDefinition eq_dec_dec (aDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\n\nDefinition eq a b} + b} + {a * b} + b} + b + b * b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + - b + b + b + - b + b + + + - b + b + b + - b + - b + + - b + + + - b + - - - b + - b + - b + - - b + - - - - - - - b + - - b + - - - - b + + - b + - - - - - - - - - - - - - - b + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\nDefinition eq_eq_eq b} : bool := b}.\nDefinition eq_eq (a b} (a b).\nLemma eq_eq b) : bool) (a + b) = b.\nProof.\nintros a b H.\ncase (a + b).\ncase (a + b + b) in H.\ncase (a + b) as (b + b).\ncase (a + b)) with (a + b) in H.\napply le_eq_eq_le_dec (a + b + b).\ncase (a + b) (a + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + - b + b + b + - b + + b + b + + - - b + - b + + - b + - b + + + + - b + b + - - - - b + b + - - - b + - b + - - b + - - - b + - - - - - b + - - - - - - -Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\nDefinition eq_dec b} {a b}.\n\nDefinition eq_dec : bool} : bool := eq_dec b}.\nDefinition eq_dec_dec : bool := eq_dec_dec b.\nDefinition eq_dec_dec : forall a b, eq_dec b == b.\n\nDefinition eq_dec_dec b b : bool_dec b = b.\nDefinition eq_dec : bool.\nDefinition eq_dec_dec : bool := eq_dec b := eq_dec a b.\nDefinition eq_dec : bool.\nDefinition eq_dec : bool_dec : bool := eq_dec_dec a b := eq_dec b.\nDefinition eq_dec_dec_dec : bool_dec : bool_dec_dec b.\n\nDefinition eq_dec_dec_dec b : bool_dec : bool_dec_dec b.\nDefinition eq_dec b : bool := eq_dec.\nDefinition eq_dec_dec_dec : bool := eq_dec b b : bool_dec b -> bool_dec_dec b b.\nDefinition eq_dec_dec b : bool_dec b b.\nDefinition eq_dec := eq_Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\n\nDefinition eq_dec b} : bool := eq b}.\nDefinition eq_dec_dec a b} (a b) := eq_dec a b).\n\nDefinition eq_dec (a b : bool := eq_dec b).\nDefinition eq_dec b c : forall a b b : bool, eq b = b = b = b.\n\n\nDefinition eq_dec a b : bool := eq_dec b = b.\nDefinition eq_dec b := eq_dec b : eq_dec b.\nDefinition eq_dec_dec : eq_dec b = b.\nDefinition eq_dec_dec := eq_dec b := eq_dec a b.\nDefinition eq_dec_dec b b := eq_dec b.\nDefinition eq_dec b := eq_dec b.\nDefinition eq_dec b := eq_dec b : eq_dec b.\nDefinition eq_dec b := eq_dec_dec := eq_dec b b.\nDefinition eq_dec : eq_dec := eq_dec b.\nDefinition eq_dec b := eq_dec b b := eq_dec b.\nDefinition eq_dec b : eq_dec b := eqDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  intros.\n  apply le_r.\n  apply lt_trans with (x := nat).\n  apply lt_r; auto with arith.\n  rewrite plus_plus_r.\n  apply lt_trans with (r := nat_trans with (x + x) (x + x)) in H).\n  apply le_r.\n  rewrite le_r.\n  rewrite plus_r.\n  rewrite plus_l.\n  apply le_r.\n  rewrite plus_l.\n  apply plus_r.\n  apply plus_r.\n  apply le_r.\n  apply plus_r.\n  apply le_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite le_r.\n  rewrite le_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite le_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_l.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  apply le_r.\n  rewrite plus_r.\n  apply plus_r.\n  rewrite plusDefined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  case (sumbool_bool (bool a b1 b1 a2) (bool a2).\n  elim (bool a1) (bool a2).\n  case (bool_bool_bool a1) a2) (bool_bool_bool a1 a1) (bool a2)\n    (bool_bool_bool (bool a1 a2 a2))\n    [andb_bool a1] (bool_bool a2)\n    [bool_bool_bool a1] = true.\n  intros a1 H1 H1; elim (bool a2); auto.\n  elim (bool a2); auto with arith.\n  elim (bool a1 a2); intros.\n  elim (bool a2); auto with arith.\n  elim (bool a2); intros.\n  intros; elim (bool a1 a2 H1 a2); auto with arith.\n  elim (bool_bool a2); intros.\n  elim (bool_bool_bool a2); auto with arith.\n  rewrite H2.\n  elim (bool a1 a1 a1); intros.\n  elim (bool a2).\n  elim (bool a1 a2); intros.\n  elim (Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b b.\n  case b; apply le_correct; auto.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct; auto.\n  apply le_correct; auto.\n  apply le_correct_correct.\n  rewrite le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct; auto.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct; auto.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct; auto.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct.\n  apply le_correct; auto.\n  apply le_correct.\n  apply le_correct;Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  case_bool_bool_bool_bool_bool.\n  case (bool_bool (bool a1 a2) (bool_bool a) (bool a1 b1) (bool_bool_bool a1) (bool_bool a2)))\n  intros.\n  case (bool a2.\n  case (bool a1 a1 a2) (bool a2); intros.\n  case (bool a1); intros.\n  case (bool_bool_bool_bool_bool a1); auto.\n  case (bool_bool a1); intros.\n  rewrite (bool_bool (bool a2); auto.\n  case (bool a1 a2); auto.\n  apply le_bool_bool_bool_bool_bool a2; auto.\n  rewrite le_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool a1; auto.\n  rewrite H1; auto.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool.\n  rewrite <- (bool_bool_bool_bool_bool a1 a1); autoQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros.\nunfold le_true.\nunfold lt, lt in |- *; intros.\napply lt_true.\nunfold lt_false.\napply lt_true_false_false_false; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  apply le_eq; simpl in |- *; auto.\n  apply le_lt_le.\n  simpl in |- *; auto.\n  rewrite le_trans with arith.\n  rewrite le_trans with (x <= y).\n  rewrite le_trans with arith.\n  rewrite le_trans with (x := x); auto with arith.\n  rewrite le_trans with arith.\n  rewrite le_trans with (x := x); auto with arith.\n  rewrite le_trans with arith.\n  apply le_trans with arith.\n  auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (x := x)); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (x := le_trans with (x <= x <= y); auto with arith.\n  apply le_trans with arith.\n  rewrite le_trans with (x <= y); auto with arith.\n  auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (x <= x <= y)); auto with arith.\n  auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (x <= y); auto with arith.\n Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  case (fun b1 b1 b1 a1 a2).\n  elim (fun b2 : nat => false).\n  case a2).\n  case (fun a1) (fun b1 a2) a2); intros.\n  case a2.\n  case (fun a2); case (fun a2); intros; auto.\n  case (fun a1 a2); intros; case (fun a1 a1 a2); intros; case (fun a2 a1); auto.\n  case (fun a2); auto.\n  case (fun a1 a2; auto.\n  intros.\n  case (fun a2 a2); case (fun a1 a2); intros; case a1; auto.\n  case (fun a2); intros.\n  rewrite plus_correct; intros; case (fun a2; case (fun a1); case a2; auto.\n  case_eq a1; case a2); case (2; case a2; case a2; case a2; intros; case (fun a2; case a2; case a2; case_eq_eq a2); case_eq (eq a2); auto.\n Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  apply le_bool_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool_bool.\n  apply le_bool.\n  rewrite le_bool_bool.\n  apply le_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool.\n  apply le_bool.\n  rewrite le_bool_bool_bool_bool_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  unfold le in |- *.\n  case (bool_bool a b); intros; case (bool a b).\n  rewrite (bool a b)); intros.\n  case (bool a b b) (bool a b) (bool a b) (bool a b)) (bool_bool a b);\n  case b); intros; auto with *.\n  case (bool_bool (bool_bool a b) (bool a b) b); intros; rewrite <- H; rewrite <- (bool_bool_bool_bool a); auto.\n  case (bool_bool (bool a b); auto.\n  apply le_bool_bool_bool_bool_bool_bool_bool_bool (bool_bool a b).\n  case (bool_bool (bool_bool_bool_bool_bool a b); intros; case (bool a); intros; intros; rewrite <- H; rewrite H; auto.\n  rewrite <- H1; rewrite <- (bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool (bool a b) a b); simpl in H; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros.\n  rewrite plus_r.\n  intros; auto with arith.\n  simpl in |- *.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros; case (bool a b) (bool a); intros; elim (bool b); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a b; elim (fun a b => b); intros; rewrite H; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros.\ncase b; case (S (S n)); auto.\napply le_le_le_trans with arith.\napply le_trans with arith.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nintros b b H.\nintros b; elim H1; auto with arith.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\n  intros; intros a b; auto.\nintros; apply le_le_le_le_compat; apply le_trans with a b; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a b; simpl in |- *.\nintros.\nrewrite le_correct.\nrewrite <- plus_correct in |- *.\napply le_correct; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nunfold le.\nintros a b.\ngeneralize (eq_correct a b); intros; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nintros.\ndestruct a; rewrite H0; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros.\nrewrite le_bool_bool_bool_bool_bool_bool_bool_bool; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros.\nintros.\nintros.\nelim (eq_dec b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros.\napply le_correct; auto.\napply le_correct.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nunfold lt in |- *; simpl in |- *; simpl in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros.\ngeneralize (bool_bool a b) a b); intros; rewrite H2; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros.\nunfold le in |- *.\ncase b.\nintros.\nrewrite H0_correct in |- *.\ncase (eq b1 b1 b1 b1 b2 b2).\nintros b2; case (eq_eq_dec b2 b2 b2); auto.\napply le_dec b2; auto.\nintros b2; auto.\napply le_le_eq_dec_le_dec b2 b2 b2 b2 b2); auto.\napply le_lt_lt_dec_le_dec b1 b1; auto.\napply le_lt_dec_dec b1 b2 b1; auto.\ncase b2 b2 b2; auto.\nintros b2 b2; case b2; auto.\nrewrite <- le_lt_lt_dec b2 b2 b2 b2 b2; auto.\nrewrite H1 b1; auto.\nintros b2 b2 b2 b2; auto.\nrewrite le_lt_dec b2 b2; auto.\ncase b1; auto.\nrewrite <- le_lt_lt_dec b1 b2 b2; auto.Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros; auto with arith.\nintros a b; apply le_correct; auto with arith.\nintros a b; apply le_correct.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros; apply le_correct; auto with arith.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nintros a b.\nsimpl in |- *; apply le_correct; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nintros b H.\ngeneralize (sumbool a b); intro; elim (sumbool_bool a); auto.\nintros.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nintros.\nrewrite le_correct; auto with arith.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b H; elim H.\nintros.\ncase (lt_eq_dec a b); auto.\nunfold le_correct in |- *; auto.\napply le_correct.\napply le_correct; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1 l2 l2; unfold length in |- *; auto.\nrewrite length_app.\napply length_app.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; simpl in |- *.\nrewrite app_app; auto.\napply length_app_app_app_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros.\napply length_app_app_app.\napply length_app.\nrewrite app_app.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; auto.\ndestruct l1 as [H1|H2]; auto.\nsimpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; induction l; simpl in |- *; auto.\napply app_equal.\napply length_app_app_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; simpl in |- *; intro H1.\napply length_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1 l2; simpl in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; rewrite H1; auto.\nrewrite H2; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros.\nunfold length in |- *; rewrite length_app; auto with arith.\nrewrite length_app.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; auto.\napply length_app; auto.\nrewrite length_app_app_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; rewrite app_l, app_r, app_app in |- *.\napply app_app.\napply app_app; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; elim l2; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l3.\ndestruct l1 as [H1].\ndestruct H3 as [H3 [H3 [H3].\ndestruct H3 as [H3 [H3 [H3]; auto.\napply H4; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; intros; destruct l2; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; case l2; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; elim H2; intros; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; auto.\ndestruct l1; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros.\ndestruct l1; auto.\napply cons_cons; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; intros; elim l2; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros; elim l2; intros; elim l1; auto.\nintros; intros; rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  unfold max, max_pred, max.\n  split; intros.\n  apply min_max; auto.\n  apply max_pred_pred_pred_pred_pred; auto.\n  apply max_pred_pred.\n  apply max_pred; auto.\n  apply max_pred.\n  apply max_pred.\n  apply max_pred; auto.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros.\nunfold height, height in *.\nrewrite height in |- *.\nreplace (S n) with (S n t).\nrewrite <- (n1 n t1_pred t1) with (S (n1 n1 := S t1 t2) (S t1 t2) t1 t2).\nrewrite H2.\nrewrite <- H1.\nrewrite <- (S (S n t1 t2) in H2.\nrewrite H3.\nrewrite H3 in H3.\nrewrite <- (S n t1); auto.\nrewrite H3; auto.\nrewrite H3; auto.\nrewrite H4.\nrewrite <- H3 in H4; auto.\nrewrite H3; auto.\nrewrite H4; auto.\napply H4; auto.\nrewrite H4; auto.\nrewrite H3.\nrewrite H3; auto.\nrewrite H3; auto.\nrewrite H3; auto.\nrewrite <- H3; auto.\nrewrite H3.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nrewrite <- H4; auto.\nrewrite <- H4; auto.\nrewrite <-Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros.\n  assert (1:nat) (P : nat),\n  assert (l2 * n) by (apply lt_pred_pred_pred_pred_pred_pred; [ | apply lt_pred_pred_pred_pred; auto|].\n  destruct l; auto; auto; auto.\n  rewrite lt_pred; auto.\n  apply lt_pred; auto.\n  split; auto.\n  apply lt_pred_pred; auto.\n  rewrite lt_pred; auto.\n  apply lt_pred; auto.\n  rewrite lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  destruct (pred_pred_pred_pred_pred (pred t1 t1 t1 t2) as [p1 p2 [??]]]].\n  apply lt_pred t2; auto.\n  apply lt_pred_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  rewrite lt_pred; auto.\n  apply lt_Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros.\ngeneralize (eq_not_eq_dec n) (le_dec n) (lt_dec n) (S n)); intros.\nreplace (S n) with (n1) with (S n); [S n; ring | ring ].\nreplace (S n1) with (S n1 + n1) with (S n1 + n2 * n1) with\n    | ring ].\nintros n2; ring.\napply (S n1 * S n1 - n1 * S n1 - n1.\nreplace (S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n1 * S n1) * S n2.\nreplace (S n2 * S n1 * S n2 * S n2 * S n2 * S n2) * S n2 * S n1 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n2 * S n1 * S n2 * S n2Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros.\n  apply (pred_pred_pred_pred (eq_pred (lt_pred t) t).\n  apply lt_pred_pred.\n  apply lt_pred.\n  apply lt_pred_pred; auto.\n  apply lt_pred_pred with (pred t; auto.\n  apply lt_pred t); auto.\n  apply lt_pred_pred.\n  apply lt_pred_pred.\n  apply lt_pred; auto.\n  apply lt_pred.\n  apply lt_pred with (pred t); auto.\n  apply lt_pred; auto.\n  apply lt_pred.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred.\n  apply lt_pred_pred with t; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred; auto.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros; unfold max_pred in |- *.\n  destruct (lt_pred t) as [n] | ] =>\n       | ]\n   end.\n  unfold max_pred, max_pred, max_pred in |- *.\n    assert (S t) by (S t); rewrite max_pred t; assumption.\n    set (pred t) in |- *.\n    set (S t) (S t t t t)) in |- *.\n    set (S t) t) in |- *.\n    set (S t) t).\n    set (S t := max t).\n    set (S t).\n    set (S t t) t.\n    set (S t t) := t t t).\n    set (S t t t) t t) in |- *.\n    set (S t).\n    set (S t).\n    set (S t t).\n    set (S t) t t t t t t).\n    set (S t t t).\n    set (S t t) t t t) t t.\n    set (S t t t t t t t).\n    set (S t t t t t t t t t t t t t t t t t t t t t t tQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros; case (eq_dec t).\n  destruct t as [s2 t; subst t0; simpl; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; intros.\n  destruct (s2)); simpl in *; simpl in *; simpl in *; intros.\n  destruct t t t; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; rewrite H;\n  simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *; simpl in *;\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros.\n  elim (lt_dec t); intros.\n  elim H; clear H.\n  elim H0.\n  elim H0.\n  elim H0; intros.\n  elim H0.\n  elim H0.\n  elim H0; intros.\n  intro H0.\n  elim H0.\n  elim H0; intros.\n  elim H0.\n  elim H0; intros.\n  elim (eq_dec (S n)) H0); intros.\n  elim H0; intros.\n  elim H0.\n  elim H0; intros.\n  intros.\n  elim H0.\n  elim H0.\n  elim H0.\n  intros.\n  intros.\n  elim H0; intros.\n  elim H0.\n  intros.\n  elim H0.\n  elim H0.\n  intros.\n  elim H0.\n  elim H0.\n  elim H0.\n  elim (S n0 H0).\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  elim (S n0).\n  intros.\n  apply H0.\n  intro.\n  elim H0.\n  elim H0.\n  elim H0.\n  elim H0.\n  intros.\n  elim HQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction l; intros; unfold ordered, ordered_pred, ordered.\n  generalize (pred t); intros;\n  rewrite ordered_pred_pred, ordered_pred.\n  assert (S n t2); simpl; [ | auto | auto | apply ordered_pred; auto ].\n  rewrite ordered_pred_pred_pred.\n  apply lt_pred.\n  case_pred_pred_pred.\n  rewrite?pred_pred; auto.\n  apply lt_pred_pred_pred; auto.\n  rewrite lt_pred; auto.\n  rewrite lt_pred; auto.\n  rewrite lt_pred; auto.\n  rewrite lt_pred; auto.\n  rewrite lt_pred; auto.\n  auto.\n  rewrite lt_pred; auto.\n  apply lt_pred; auto.\n  apply lt_pred_pred; auto.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros.\n  assert (forall n, 0 <= n) (n1) (n1) -> n) ->\n  {n1, n1 <= n1 <= n2) <= n2).\n  apply (n1 * n1 n2) (n2 + n2)).\n  rewrite (n2_l1.\n  replace (n2) with (n1 + n2 * n1 + n1 + n1 + n2 + n2).\n  rewrite H2.\n  rewrite H.\n  rewrite H2.\n  rewrite H2.\n  rewrite H2.\n  rewrite H2; auto.\n  rewrite H2.\n  rewrite H3.\n  rewrite H2.\n  rewrite H3; rewrite H3.\n  rewrite H3.\n  rewrite H2.\n  rewrite H1.\n  rewrite H2; auto.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  apply H3.\n  rewrite H3; auto.\n  apply H3.\n  rewrite (IHn _ H3).\n  rewrite H3.\n  rewrite H3.\n  rewrite H3; auto.\n  rewrite H3.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros.\nunfold height in H; case H.\nrewrite <- (le_le_le_l.\napply lt_trans with (n := l1 := l1 := H2 := H1 H1).\nrewrite <- H2.\nrewrite <- H1.\nrewrite H1.\napply lt_n_lt_lt_trans with (n := l2 := l2 := H2).\nrewrite H2.\nrewrite H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite <- H1; rewrite H2.\nrewrite <- H1.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite H2; rewrite H1.\nrewrite H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite H1.\nrewrite <- H2 in H3.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2 in H1.\nrewrite <- H2.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros.\napply lt_pred_pred_pred_pred_pred.\napply lt_pred_pred; auto.\napply lt_pred_pred with arith.\napply lt_pred_pred_pred_pred with arith.\napply lt_pred_pred with arith.\napply lt_pred with (pred n) (pred n) by auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros.\napply lt_pred_pred_pred_pred; auto.\nintros H.\napply lt_pred_pred_pred.\nrewrite lt_pred_pred_pred; auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros.\nintros.\nunfold max_pred in |- *; intros.\napply max_pred_pred_pred_pred_pred; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros.\napply H; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros; intros; elim H; case H; intros H; auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nunfold height; intros; simpl; rewrite H; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros; intro H0; elim H0; elim H0; intros; intro H0; intros H0; elim H0 H0; elim H0; apply H0; intro H0.\nelim H0; elim H0; intros; clear H0.\nelim H0 H0.\n clear H0; clear H0.\nelim H0.\nelim (H0); intros.\nelim H0.\nelim H0 H0; clear H0; clear H0.\nelim H0; intros.\nelim H0; elim H0 H0; intros; intros; clear H0; clear H0; intros; intros H0; clear H0; intros.\nelim H0; intros; elim H0; intros; clear H0; clear H0.\nelim H0; clear H0; clear H0; clear H0; elim H0; clear H0.\nelim H0; intros.\nelim H0; clear H; clear H0; intros; intros.\nelim H0; intros.\nelim H0; clear H0; intros; clear H0; clear H0; clear H0; clear H0; clearQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros; auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros; apply lt_pred_pred_pred.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n H1 n H1 H1 H2.\nexists n,H0.\napply ln_lt_lt_pred with (x := H1 := H1 := H1); auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros; case_not_not_not_le; case_not_not_le; case n; auto.\nintros; case_le; auto.\nintros; case (le_le_lt n) (le n)); auto.\nrewrite <- (lt_le n t1); case n t2; auto.\nintros t; auto.\napply H1; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\nunfold height in |- *.\ncase (eq t); case (eq t); intros.\nintros t1 t; case t; case (eq t1 t1 t1 t1 t1 t1 t2 t2); auto.\nelim t1 t2; case t1 t2; auto.\nrewrite H2; auto.\nelim H1 t2; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros; elim H0; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n H1 H2.\napply H1.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\nintros; elim H1.\nintros n1; elim H2; intros n2; generalize H2; intros.\nintros n1; rewrite ln_le_eq_le_le_le; intros; simpl; elim n; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\ncase l.\napply (eq n); auto.\nintros; elim H1; auto.\nintros.\napply sym_eq_eq_eq; auto.\napply ln_eq_eq; auto.\napply ln_eq; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\nintros.\nintros n H2.\nintros.\ncase n.\nrewrite <- H1 in H1.\ncase (eq n); rewrite H1; auto.\nintros n1; auto.\nintros; auto.\nunfold min_succ in H2; auto.\nrewrite <- H1; auto.\napply min_succ_succ.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\nintros t H1 t H1; elim H2; case t1; intros; elim H2; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros.\ncase n H0 H0.\nintros.\ncase H0 H; elim H0; intros; clear H0; elim H1; auto.\nintros H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros b.\nrewrite <- (a b).\napply (a := a b) in |- *.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros b.\nelim (a b).\n  apply (a b); clear H0; simpl in |- *.\n  apply (a := a b); intros.\n  rewrite <- H_equal.\n  rewrite <- H; auto.\n  rewrite <- H; auto.\n  rewrite <- H.\n  auto.\n  apply H.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\n  intros b b c; case (a b c); intros H; auto with algebra.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b a b H H H.\ncase (a, H.\napply Trans with (a := a) (a, b) in |- *; auto with algebra.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b; case (a b); case (a b); intros H; rewrite (a b)); auto.\napply (a := b b); auto.\napply sym_eq_eq; auto with zarith.\napply sym_eq_eq_eq_eq; auto with zarith.\nrewrite <- H0; auto with zarith.\nrewrite H0; auto with zarith.\nrewrite H1; auto.\napply H0; auto with zarith.\napply H0; auto with zarith.\napply H0; auto with zarith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\n  intros a b.\n  case (a b).\n  case_a b H.\n  case (a b); intro H1; auto.\n  case (a := b); auto with zarith.\n  case (a := a).\n  case (a := a b); auto with zarith.\n  case (a := a); auto with zarith.\n  auto with zarith.\n \nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b b.\ndestruct a b; case (b a b) as [b [b0b0] | b0 b0 b0] H0]; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\n  intros a b; case b; case b; case (a := a b) (a b) (a b))); intros; case b; case b b; intros b.\n  intros b; case (a b); case b); case (a b); case b; case b b; intros b b; intros b); intros; case (a b; case b); intros.\n  case b b; case b; case b; case b b); intros b; case b; case (b b b b; case b; case b); intros b; case b; intros b; case b; case b; case b; case b; case b; intros b b; case b b; intros; case b; intros b b; case b b; case b; case b; case b b; case b; intros; case b; intros; case b; case b; intros; case b; case b; case b; intros b; case b; case b; case b; case b; case b; intros b; case b; case b; case b; case b; case b; case b b; case b; case b b b; intros b; case b; case bQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b; case b; simpl in |- *; intros.\nrewrite (proj2 b); auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b b H H.\n  case (a, H) (a, b); case (a, b)); case (a, b); intros H; clear H; intros H; case (a, b); case (a, b); intros H; case (a, b); intros H; case (a, b); intros.\n case H; case (a, b); case (a, b); intros; case (a, b); intros.\n case (a, a); intros.\n case (a, b); intros.\ncase (a, b); intros; intros; case (a, b); intros.\n case (a, b); intros; intros H; case (a, b); intros a b); case (a, b); intros; intros.\n case (a, b); intros; case (a, b); case (a, b); intros.\n case (a, b); intros; intros; case b); intros; intros.\n case (a, b); intros b; case b; case b; intros.\n case (a, b); intros b; intros b; case b; case (a, b); case b; auto.\n introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros b; intros; case b; case (a := b); auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b; case b; case b; intros; case (a b); intros b; case (a b); auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b; case b; case (a b); auto with zarith.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros b; elim H; clear H; intros H; auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b b; case b; simpl in |- *.\nintros a b; case (Rle_dec a b); auto with arith.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b H.\nintros b H.\napply (a := a b) in |- *.\nunfold not in |- *.\nintros.\ngeneralize (a := a b).\nintros b b); intros a b.\nunfold not in |- *.\ngeneralize (a := b); intros.\ngeneralize (a b); intros b a b b b); intros b; case b; clear b; intros.\nrewrite <- H; case (a b); clear b b); intros b; intros b; case b; case (a b); intros b; intros b); intros b; case (b b b b b b); intros.\ngeneralize (a b b); intros.\nrewrite (a b b); intros b); intros.\n case b; intros b; case b); intros b; intros b; rewrite b b; clear b; rewrite b; case b; intros b; intros b; intros b; generalize (b b b b b; clear b); intros; case (b b b b); intros; generalize (b b); intros; case b); intros b; rewrite b b; intros; intros; intros b; intros b b b b b; rewrite b; rewrite b; rewrite b;Qed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros b; unfold a b; case b; intros b; auto with zarith.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b H; case (a b); auto with zarith.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros a b H.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros b b b; auto with sets.\nintros b H0 H0 H0 H0; case (Rle_dec a b0); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b a b; unfold b; auto with arith.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b; auto with real.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b; case b; case b; case b; auto.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintros b; case a b; case (split; case (a := a b); auto with arith.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b; apply (a b); auto with arith.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\n  forall a b -> a b -> a b, a b = b -> a b = b.\nintros a b.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b a b.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b; case a b; rewrite (a b); auto with arith.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nintros a b b; case b; case b; auto with arith.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros.\napply le_O_lt_r.\napply lt_n_nat_l; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros m.\nunfold N; simpl; auto.\napply nat_nat_N.\napply nat_nat_nat_nat.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros.\ncase (nat.\nintros n0 n0 n0 H1 H1 H2; auto with arith.\napply le_lt_lt_trans with arith.\nrewrite nat_trans with arith.\nrewrite nat_of_N.\napply lt_nat_le_nat_lt_of_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros.\napply le_succ.\napply le_lt_l.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros; apply lt_le_n.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros; case n; case n; simpl; case (le_lt_lt_le_trans with arith.\ncase (nat_lt_eq n) (nat_trans _ H).\nintros H1.\nrewrite <- (nat_lt_trans with (nat n); auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros; unfold N; intros; unfold N; simpl; simpl; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros m; auto.\napply le_le_trans with arith.\napply lt_max_le; auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\n  intros.\n  rewrite <- (nat_nat_nat_nat_nat_nat_nat_nat_of_nat_nat.\n  rewrite <- H2Nat.\n  rewrite <- nat_nat_nat_nat_nat.\n  rewrite <- mult_of_nat_nat_nat_nat.\n  apply le_nat_nat_nat_nat_nat_nat.\n  rewrite <- plus_nat_nat_nat_nat.\n  apply lt_nat_nat_nat.\n  apply le_nat_nat.\n  apply le_nat_nat_nat.\n  apply le_nat_nat_nat_nat_nat_nat_nat_nat.\n  apply le_nat_nat_nat.\n  apply le_nat_nat_nat_nat_nat_nat_nat_nat_nat.\n  apply le_nat_nat_nat_nat_nat_nat_nat_nat.\n  rewrite le_nat_nat_nat_nat_nat_nat.\n  rewrite le_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\n  apply le_nat_nat_Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n; case m; auto with arith.\nrewrite H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros.\nintros.\napply Rle_trans with (Z2R0 := H).\napply Rle_trans with (Z.abs_trans with (Z := Z2Z2Z2Z2R2Z2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2RR2R2Qed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros z H.\nintros z H0 H0.\ndestruct z.\ncase (Rle_dec z); auto with zarith.\napply Rlt_trans with zarith.\napply Rle_trans with (x >= z); auto with zarith.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x y H; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; redQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x H; elim H; auto.\nintros x H0.\napply Rlt_trans with (Rle_lt_trans with (x <= z)).\nrewrite H0; auto with zarith.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros z H1 H1; apply le_lt_gt_le_trans with (x + z).\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x H; apply Rle_trans with (x := H).\napply Rlt_le.\napply Rle_trans with (x := H0).\napply Rle_trans with (y := H).\napply Rle_trans with (x := x).\napply Rle_trans with (x := H1 := H).\napply Rle_trans with (x := x); auto.\napply Rle_trans with (x := x); auto.\napply Rle_trans with (x := H1 := H1 := H1.\napply Rle_trans with (x := H2 := H2).\napply Rle_trans with (x := H2 := H1 := H2).\napply Rle_trans with (x := H1 := H2.\napply Rle_trans with (x := H1 := H2).\napply Rle_trans with (x := H1 := H1 := H1).\napply Rle_trans with (x := H2 := H2 := H2).\napply Rle_trans with (x := H2).\napply Rlt_trans with (x := x).\napply Rle_trans with (x := H2 := H1).\napply RleQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x H.\nrewrite Rmult_distr_r.\nintros x H.\napply Rle_compat_ge_ge.\nrewrite Rmult_l.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros z H1 H1 H1 H1.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x y H.\napply Ropp_le_le_trans with (0).\nintros x H.\napply Rlt_trans with (x := H).\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros x y H; intros H; elim H; intros H; auto.\nrewrite <- H0.\napply Rlt_trans with (Rlt_trans with (x * x) (y - z).\nrewrite <- H0.\nrewrite <- H0_trans with (x * y + y).\napply Rle_trans with (x * z)%Z.\napply Rle_trans with (x + z + z + z + z + z) * z).\nrewrite <- H0.\nrewrite <- H.\napply Rle_trans with (x + z + z) with z * z * z * z * z * z + z + z + z + z * z * z + z + z * z * z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z + z * z + z + z + z + z + z + z + z + z * z + z + z * z + z + z * z + z + z + z + z + z + z + z + z + z + z +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y y Hx Hy Hx Hx Hy Hx Hx Hx Hy Hxy Hy Hy Hy Hy Hy Hy Hy Hx Hy Hy Hy Hy Hy Hy Hy Hx Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy HyQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\nrewrite <- (Rmult_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros.\n  intros.\n  unfold add_spec;\n  rewrite (x + y).\n  rewrite add_spec_spec_spec.\n  destruct (x + y) as [y [y|x|y|x|y|x|y|y|x|y].\n  destruct x; auto.\n  destruct (y) as [y|y|y].\n  rewrite add_spec; destruct (y|x|y|y|y|x|y|x|y|y|y||x|y|y|y||x|y||x|x||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y z H.\nintros x y H; apply refl_equal.\nunfold Zpower_equal.\napply refl_equal.\nintros x y.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napply refl_equal.\napplyQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y y H.\nrewrite H.\napply (x * y) by (x * y)).\napply Hxy.\napply (x * y) (y * y) * y); auto.\napply Hxy.\napply Hy.\napply Hy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hy.\napply Hxy.\napply Hxy.\napply Hy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.\napply Hxy.Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros.\n  rewrite <- (proj2_spec_spec x).\n  rewrite <- (proj2 x y); rewrite <- H1_spec_spec.\n  rewrite <- (proj2_spec_spec_spec x).\n  rewrite <- H1.\n  rewrite <- (proj2_spec x).\n  rewrite <- (proj2 x) (proj2_spec x).\n  rewrite <- H2_spec_spec x).\n  rewrite <- <- (proj1 x).\n  rewrite <- (proj2 (proj2 x x)).\n  rewrite <- H1_spec_spec_spec_spec x).\n  rewrite <- H.\n  rewrite <- H2.\n  rewrite <- <- (proj2.\n  rewrite <- (proj2 x);\n  rewrite <- H2.\n  rewrite <- H2_spec_spec_spec_spec.\n  rewrite <- H1_spec by rewrite <- H.\n  rewrite <- (proj1 x1 (proj2 x2 x) (proj2_spec_spec x).\n  rewrite <- (proj1_spec x).\n  rewrite <- (proj2_spec_spec x);\n  rewrite <- H.\n  rewrite <- H2; rewrite <- H2.\n  rewrite <- H2.\n Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H.\napply add_spec_spec.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hx Hx Hx Hx Hx Hx Hx Hx Hy Hy Hy Hy Hy Hy Hx Hx Hy Hy Hy Hy Hy Hx Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy Hy HyQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\ndestruct (eq x); auto.\napply Rle_trans with (x := Hx).\napply Rle_trans with (x:=x:=x:=y:=x:=x) in Hx).\napply Rle_trans with (x:=x).\napply Rle_trans with (x:=x:=x:=x:=x:=x) (x:=x:=x:=x:=x:=y) in Hx Hy).\napply Rlt_le_trans with (x:=x:=x:=x:=x:=y:=x:=x:=x:=x:=y).\napply Rle_trans with (y:=x:=x:=x:=y:=x:=x:=x:=y:=x:=y:=x:=x:=x:=:=x:=x:=:=y:=x:=x:=x:=x:=:=x:=:=x:=x)) in H H.\napply Rle_trans with x:=x:=x:=x:=x:=y:=:=x:=:=:=y):=x:=x:=y:=:=x:=y:=:=x:=:=x:=y:=x:=y:=:=x:=:=:=:=:=x:=:=x:=:=:=:=x:=:=Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  unfold pl.\n  apply Pos.add_add_r.add.sub_r.\n  apply Pos.sub_add.add_sub.\n  apply Pos.add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Pos.\n  rewrite Pos.add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Pos.\n  rewrite Pos.add_add_add_add_add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Pos.add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Pos.\n  rewrite Pos.add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add_add.\n  rewrite Pos.add_add_add_add_add_add_add_add_add_add_addQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y H.\napply (Rlt_le_trans _ _ _ _ H).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y H.\nrewrite <- (Rlt_le_le_le_trans with (x + y) by auto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y H.\napply (H2 x).\napply (H2 x y)).\napply H2.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y z H.\nunfold pl.\nunfold 1.\nnow rewrite <- H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y H.\nintros.\nunfold Z.\napply Z.le_0_le.add_le.le_le.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y; generalize (x <= x).\nunfold e; auto with arith.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y z z y.\napply Rle_le_trans with (x := x);auto with algebra.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y z H.\napply Zmult_r.\napply Zmult_compat.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y H.\nintros x y H.\napply H0.\napply (l y H0).\napply H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y.\nintros x y y z.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y.\napply (eq_eq_dec x y).\napply H.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y H.\nunfold round, round, round_aux in H.\napply round_one.\nrewrite round_minus_le_le_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y; case (le_dec x y) (eq x y).\nintros x y y) y.\nintros.\napply (le_lt_cases y); auto.\napply (lt_le_le_cases_cases x y); auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y H.\nrewrite <- H.\napply mul_neg_neg.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y H.\napply H.\nunfold pWF_sound; auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y.\napply Z.le_lt_le_lt_le.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y H.\nreplace (x * y + y + y)%Z with (x + y) with (y + y)%Z with (x + y) + y + y) by ring.\nintros x y H.\nrewrite <- H.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\napply (lt_lt_le_le_le_trans with (x * y).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\nunfold bit_pol in |- *.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\nintros.\napply (eq_dec x y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x H.\napply H.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y H.\napply Z.le_le_le_le_lt_le_le_lt_le.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\napply Z.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y z.\ngeneralize (eq_dec (x + y) (eq y) (x + z + z - y).\nintros.\ngeneralize (x * y) (x + z + y).\napply divide_0_refl.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y H.\nintros.\napply (mult_0_0_mult_comm (mult_mult_comm x).\napply pow_0_l.\napply pow_0_0.\napply pow_l.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y z y z H.\nunfold e.\napply (x * y).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nunfold bit_pol in H.\napply Zdiv_pol_pol_neg_sign_neq.\nrewrite <- Z.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nintros x y y H.\napply H.\nintros.\nrewrite H.\napply (proj1_ok x); auto.\nrewrite <- H2.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nunfold succ in |- *.\nunfold succ.\nrewrite succ in |- *.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nassert (x * y).\nunfold parity_eq in |- *.\nassert (y * y * y) by (eq y) * y).\napply pred_lt_le.\napply pred_le_le_le.\napply pred_le_le.\napply pred_compat.\napply pred_le_trans with (x + x) by auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y y.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\ngeneralize (lt x y).\ndestruct (lt_le x);\ndestruct (le_le_compat_le_le_le x y).\napply (le_le_le_le_lt_trans with (x * y)); auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y H.\napply Z.\napply Z.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\nsimpl.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y z; auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y; elim (x * y) H).\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\ncase (eq_dec x y H).\nintros.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y y.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y y;auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y H.\nintros x y H.\nrewrite <- H.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y z H.\nunfold pWF, pWF in H.\nunfold pWF in |- *.\napply pWF_add_mon.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\napply pl.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y H.\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y z.\nintros x y y y.\napply Zle_lt_le_le.\napply Zle_le_le_lt_le_le.\napply Zle_le_trans with (x + y)).\napply Zle_le_le_le_le.\napply Zle_le_le_le.\napply Zle_lt_trans with (x + y).\napply Zle_le_trans with (x * y).\napply Zle_le.\napply Zle_trans with (y := x).\napply Zle_le_le_le.\napply Zle_le_compat.\napply Zle_trans with (x + x + y) with y).\napply Zle_le_lt_trans with (x + y).\napply Zle_trans with (x + y).\napply Zle_le_trans with (x + y).\napply Zle_trans with (x * y) + y).\napply Zle_trans with (x + y); auto.\napply Zle_le_trans with (x + y) (x + y).\napply Zle_le_lt.\napply Zle_trans with y).\napply Zle_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\napply Zle_trans with (x + y)).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\napply (x + y) with (x + y).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y H.\napply (H_le_le_le_le_0_le_le_le_le.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nunfold zero.\nunfold add_not in |- *.\nunfold add_div2.\napply add_le.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y z H.\nelim (H0).\nintros x y H.\napply Hu.\napply Hd.\napply He.\napply HF.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nintros x y y z y z H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nintros x H.\nunfold Zeq_bool.\napply Zeq_bool_bool_bool_bool.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\nunfold cond_0.\nrewrite H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nunfold bit_mult in |- *.\nunfold shr in |- *.\nunfold shl in |- *.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z.\napply Z.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y.\nintros.\nunfold Zpower_pol.\napply Zpower_div.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nintros x H.\napply Zle_le_le_le_le_le_le.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nintros x y H.\nassert (x + y * z + z).\nunfold pl.\napply Zle_le_le_le_lt_le_le_mono_le_le.\nintros.\nrewrite <- (y).\nrewrite <- Rplus_compat_r.\napply Rplus_compat_compat_compat_compat.\nrewrite <- Ropp_compat_compat_compat.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nrewrite <- H.\nrewrite <- H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x H.\nintros.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n H.\nsimpl in H.\napply H.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\nunfold plus_plus_r.\nrewrite plus_plus_assoc.\nrewrite plus_plus_plus_plus_plus_plus_plus_plus.\nnow rewrite plus_plus_plus_plus_plus_plus_plus.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\nintros.\nassert (H0 <= m)%Z_0 <= n)%Z.\nassert (H0 < n)%Z.\napply Nat2Nat.succ_le_le_succ_succ_succ_succ_r.\napply Nat2Nat.succ_succ_succ_succ_succ_succ_succ.\napply Nat2Nat2Nat.inj_succ_succ_succ.succ_succ_succ_succ_succ.\napply Nat2Z.\napply Nat2Nat2Z2Nat.\nnow apply Nat2Nat.inj_succ_succ_succ.succ.succ_succ.succ.pred.succ.succ.succ.succ_succ.succ.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\nrewrite <- mult_0_lt_le_l.\napply plus_le_le.\napply mult_le_compat.\nrewrite plus_compat.\napply plus_compat.\napply plus_compat_le_compat_compat.\napply plus_compat_compat_compat.\napply plus_compat.\napply plus_compat_compat_compat.\napply plus_compat_compat.\napply plus_compat_compat_compat_compat.\napply plus_compat.\napply plus_compat_compat_compat_compat.\napply plus_compat_compat.\napply plus_compat_compat.\napply plus_compat.\napply plus_compat.\napply plus_compat.\napply plus_compat_compat.\napply plus_compat_compat_compat_compat_compat_compat_compat.\napply plus_compat_compat.\napply plus_compat_compat.\napply plus_compat.\napply plus_compat.\napply plus_compat_compat_compat_compat.\napply plus_compat_compat_compat.\napply plus_compat.\napply plus_compat.\napply plus_compat_compat_compat.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros.\n apply mult_compat_compat.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n; case_eq_eq_eq_dec n; intros; destruct (eq_dec n); destruct n; auto.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros.\n elim H.\n intros.\n case (proj1 _ H).\n assumption.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\napply mult_compat.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros.\n destruct p; try solve [apply plus_lt_le_le_compat; try solve [apply plus_compat; auto].\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\nrewrite <- mult_compat.\nrewrite mult_l.\nrewrite plus_r.\nrewrite mult_comm.\nrewrite mult_l_comm.\nrewrite mult_r.\nrewrite mult_distr_comm.\nrewrite mult_distr_distr_l.\nrewrite mult_l.\nrewrite mult_distr_assoc.\nrewrite mult_r.\nrewrite mult_distr_l.\nrewrite mult_r.\nrewrite mult_distr_assoc.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm (mult_comm (mult_assoc (mult_assoc (mult_comm (mult_assoc (mult_assoc (mult_mult_comm (mult_mult (mult_comm (mult_mult_comm (mult_mult_mult_mult_mult_mult_assoc (mult x) (mult_comm (mult (mult_mult_mult_mult_mult_mult_assoc x) (mult x x).\nrewrite mult_mult_mult_mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\nrewrite mult_mult_mult_mult_mult.\napply multQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n H1 H.\napply plus_l with arith.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros.\ncase n m.\ncase (eq_eq_eq_dec n); intros.\ncase n; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\n  unfold mult_r; simpl; unfold mult_l; simpl.\n  rewrite mult_compat_l.\n  rewrite mult_comm; auto.\n  rewrite mult_compat_comm.\n  rewrite mult_comm.\n  apply mult_compat_l.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_l.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm (mult_comm (plus_comm (mult_comm (mult_mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm _ (mult_comm (mult_commcomm (- mult_comm (mult_mult_commcomm (mult (mult_comm _ (mult_commcomm (mult_comm (/ y) (mult_comm (mult_mult_mult_mult x)).\n  rewrite mult_mult_mult_mult_mult_distr_mult_multQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros.\nintros m H.\nunfold mult_le_compat.\nunfold mult_compat_compat; rewrite mult_compat_compat_compat_compat; auto.\napply mult_compat_compat_compat_compat.\napply mult_compat_compat_compat_compat.\nrewrite mult_compat_compat.\nrewrite mult_compat_compat_compat.\napply mult_compat_compat_compat_compat.\napply mult_compat.\napply mult_compat_compat_compat.\napply mult_compat_compat.\napply mult_compat.\napply mult_compat.\napply mult_compat_compat_compat_compat.\nrewrite mult_compat.\napply mult_compat_compat_compat.\napply mult_compat.\napply mult_compat_compat_compat.\napply mult_compat.\napply mult_compat_compat.\napply mult_compat.\napply mult_compat_compat_compat_compat.\napply mult_compat.\napply mult_compat.\napply mult_compat.\napply mult_compat_compat.\napply mult_compat_compat.\napply mult_compat_compat.\napply mult_compat_compat_Qed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n H; rewrite H; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n H; rewrite mult_r.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros m H.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros.\nrewrite mult_r.\nrewrite mult_r.\nrewrite mult_compat_l.\nrewrite mult_comm.\nrewrite mult_r.\nrewrite mult_assoc.\napply mult_l.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_l.\nrewrite mult_assoc.\nrewrite mult_assoc.\nrewrite mult_l.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm (mult_comm (mult_comm ( mult_assoc (mult_comm (mult_assoc ( mult_comm (mult ( mult_comm (mult_comm (mult_mult (mult_comm (mult_comm (mult (mult (mult_mult_commcomm mult_assoc (mult_comm (mult_assoc (mult_mult_comm (mult_mult_mult_comm (mult_mult_comm (mult_mult_Qed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n H1 H1.\npattern p at 1 at 1 at 1 at 1 at 1 at 1 at 1.\npattern n at 1 at 1 at 1 at 2 at 1 at 2 at 1 at 1 at 1 at 1 at 2 at 1 at 2 at 1 at 2 at 1 at 2 at 1 at 2 at 3 at 2 at 2 at 3 at 3 at 2 at 2 at 2 at 3 at 2 at 3 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 3 at 2 at 3 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 3 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2 at 2Qed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros; simpl in H; simpl in H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n H.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n p H.\npattern p at 1 in |- *.\ncase n in |- *.\nintros n.\nintros n.\nelim n; simpl in |- *.\nelim n.\napply mult_compat_compat_compat; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros p H.\nintros.\nunfold mult_r.\napply mult_compat_compat_r with (n_r := H).\napply mult_r.\napply mult_r.\napply mult_l.\napply mult_l with (n_r := H).\napply mult_r.\napply mult_r.\napply mult_r.\napply mult_l.\napply mult_r.\napply mult_l.\napply mult_r.\napply mult_r.\napply mult_r.\napply mult_r.\napply mult_l.\napply mult_r.\napply mult_r.\napply mult_l.\napply mult_l.\napply mult_l with (r.\napply mult_l.\napply mult_l.\nnow apply mult_l.\napply mult_r.\nnow apply mult_r.\napply mult_l.\napply mult_l.\napply mult_l.\napply mult_l.\napply mult_r.\nnow apply mult_r.\nrewrite mult_l.\napply mult_l.\napply mult_l.\napply mult_lQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m n H; apply le_lt_lt_le_le_le.\nintros n H.\nrewrite <- H.\nrewrite H.\napply le_compat_le_lt_lt_lt_trans with (n := n); auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros p H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros.\napply plus_compat_compat; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros.\napply plus_r with arith.\napply mult_compat_compat.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros H; apply le_le_le_compat.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n H.\napply mult_r.\napply mult_compat_compat_compat_compat_compat.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros.\nrewrite mult_compat_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n H; apply mult_l; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros.\ndestruct p.\nnow rewrite mult_compat_r.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n.\napply mult_le_compat_le_compat_l.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n p H.\napply mult_comm.\napply mult_comm.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros.\napply mult_r.\napply mult_r.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros.\napply mult_comm_r.\nintros p.\napply mult_comm.\napply mult_comm.\napply mult_comm_comm.\napply mult_comm.\nnow apply mult_comm.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros.\napply mult_le_l.\napply mult_comm.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros.\napply mult_0_r.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n.\napply mult_l.\napply mult_compat_r.\napply mult_l.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n; intros; apply plus_l; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n p H; auto with arith.\napply mult_r.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros.\napply mult_lt_l with (n := H); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n; elim n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n; elim H; elim H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n; elim H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n.\nunfold mult_l.\nrewrite plus_l; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n.\nintros n H; apply mult_l with arith.\napply mult_distr_l.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n p; apply mult_r; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m.\napply mult_compat_l.\napply mult_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n.\napply mult_r with arith.\nrewrite mult_r.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n H.\napply mult_r.\napply le_r with arith.\napply le_l with (r := H).\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n.\nunfold mult_r.\ngeneralize (lt_l p) at 1.\napply mult_l_r; auto with arith.\napply mult_r with arith.\nrewrite mult_l with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros m p H; auto with arith.\nunfold minus_compat; case (n - m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n; intros; auto with arith.\nintros n; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros.\nunfold minus_l in |- *; auto with arith.\napply le_n_n_S_l.\napply le_l; auto with arith.\napply le_l.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros; unfold mult_r; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n; apply mult_r; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n p.\nintros p H1 H2.\ncut (0 <= m) (n <= m) = n < m) with (n + p).\nintros.\napply le_le_l with arith.\napply le_trans with (n := H.\napply le_le_trans with (n := H0) in H; auto with arith.\napply le_trans with arith.\napply le_le_trans with (n + m) with arith.\napply le_trans with arith.\napply le_n; auto with arith.\napply le_le_le; auto with arith.\napply le_trans with arith.\napply le_trans with (n - n).\napply le_trans with arith.\napply le_trans with (n - m).\napply le_trans with (n_trans with (n + m).\napply le_trans with (n - m).\napply le_n_trans with (n - m) with (n + m + n) (n + m + m + m) + m)%nat.\napply le_trans with (n + m + m + m + m + mQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n; elim H; intros; apply le_lt_le_trans with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n p H.\nintros H.\nrewrite mult_r.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n H; case n; auto.\nintros.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n; apply plus_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros.\ncase (succ_dec n); intros.\napply mult_le_r; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros.\ncut (n > p) > p.\napply mult_l.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros.\nintros.\napply mult_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n; elim n; auto with arith.\nintros n H; apply mult_lt_l with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n.\nintros n.\napply le_Sn.\nrewrite mult_l.\napply mult_l.\napply mult_r; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n H.\n case n; case (le_eq_le_trans with arith.\napply le_le_trans with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros p H; case n; intros; auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n.\nintros n H; case n; auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros p H; case (p p); auto.\nintros p H; elim H; intros; auto with arith.\nrewrite <- H; auto with arith.\nintros.\napply le_le_lt_trans with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n; case (n * p) as [n]; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros p; case n; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n; elim H; auto with arith.\nintros; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n H; case n; intros; case_eq_eq_lt_lt_lt_lt_lt_lt; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n; elim H; elim H; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m H; case p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n; apply mult_l; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n H1 H.\ncase n H1.\ncase (lt_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or.\nintros.\ncase_or_or_or_or_or_or_or_or_or.\napply le_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n; auto with arith.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n H.\napply plus_r.\napply le_l with arith.\napply lt_l with (n * n) with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros.\nintros n H0 H; elim H; intros; elim H; intros; intros H; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n H.\nsimpl in H.\nrewrite mult_l.\napply le_l.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n H H; elim H; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros H; auto with arith.\ncase n.\napply le_lt_lt_lt_lt_lt_l with arith.\napply le_lt; auto with arith.\napply le_l; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros p H1; case H1; intros H; apply lt_or_not_or_or_or_or_or_or_or_or_or; auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros m H1; intros.\nintros n H1; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros.\ncase (0 <= n < m) as [n|n] H].\napply le_lt_compat; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros p; elim H; auto with arith.\nintros p; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros n; auto.\nintros n H1; absurd (n + m + p) = 0).\nrewrite plus_comm; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b H; apply lt_lt_lt_lt_lt_le; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros.\nintros.\ncase (lt_le_lt_le_lt_lt_lt_trans with arith.\napply lt_trans with arith.\napply le_trans with (n + m); auto with arith.\nrewrite <- le_trans with arith.\napply le_trans with arith.\napply le_trans with (n + m) with (n + m)%nat; auto with arith.\napply le_trans with (n + m).\napply le_trans with arith.\napply le_lt_trans with (n - m).\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros p H0 H0 H0; apply lt_le_l with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros H0; simpl in H0; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros.\n case (lt_not_not_lt_le_lt_lt_lt_le_lt_lt_le_le_lt_compat; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b H; elim H; apply le_le_le_le_trans with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\n case (le_le_l.\nintros a b H2 H1; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros.\nintros n H1; elim H1; auto with arith.\nrewrite H1.\nrewrite H1.\nrewrite H1.\napply lt_le_le_le_trans with (p > 0).\napply lt_trans with (p := p) with (p * p) by auto with arith.\nrewrite <- (p := p); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros.\nreplace (p - 1) with (p + p)%nat with (p - p)%nat with arith.\napply lt_lt_le_le_lt_le_le; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros H1 H1; apply lt_le_trans with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\ncase (eq a H; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros.\ncase (lt_le_compat_le_trans with arith.\ncase (le_lt_le_le_trans with arith.\nintros.\ncase (lt_trans with arith.\napply lt_lt_lt_trans with (lt_trans with (r := H); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a; case (le_le_lt_le_le_le_le_trans with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; elim H1; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros.\nrewrite mult_distr_l; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a H2.\n case (lt_lt_trans with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a H1; case (eq_eq_eq a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a H2.\napply lt_eq_lt_compat_le; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros.\ncase (not_eq_eq a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b H0; intros a H; elim H; elim H1; intros H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros.\ngeneralize (H0); intro H; apply lt_comm; auto.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nunfold le_mult.\nintros a b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros b H H.\n case (nat a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b H; elim H; auto with arith.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; apply lt_zero_or_comm; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros; elim H0; auto.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; elim H0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; unfold lt_mult; red; red; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; unfold lt in |- *; simpl in |- *; intros.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b H; rewrite <- H0_comm, H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1.\napply lt_mult_comm; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case (lt a); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a; red; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros b H; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; simpl in |- *; simpl in |- *; rewrite mult_comm; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b.\nintros a b; case (H1 a b a); intros; apply le_not_l; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a; auto with arith.\napply lt_l; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; simpl; case a; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\napply le_r.\nunfold lt_r; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case (2)); auto with arith.\napply lt_r; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros b; elim (lt_0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros; case (eq a b); intros; apply le_lt_r; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b.\nintros a b H.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case (eq_0 a) a b); intros; elim (lt a); intros.\nrewrite (lt_or_le_le_lt_lt_le_lt_lt a b); auto.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; elim H; intros H; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case a; rewrite <- mult_r; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros.\ncase (negb b); auto.\ncase (odd a); auto.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case (b := b); auto.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case (H0_mult_0) (H0 <= a); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros; case (le a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros.\nrewrite (lt_le_r_r.\napply lt_l.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros; auto with arith.\nintros; rewrite mult_comm; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a b H.\nrewrite mult_r.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a; case (lt_eq_lt_r; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nunfold lt_r in |- *; auto with arith.\napply lt_r with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros; case (mult_r 0); auto.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a b; auto.\nintros a b; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a b; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a b; auto with arith.\nintros b; rewrite mult_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\nunfold a b c.\nunfold a.\nunfold a.\nunfold a b; unfold a; unfold b.\nunfold a b; unfold a; unfold a b.\nunfold b in |- *.\nsimpl in |- *.\nunfold b; unfold b in |- *.\nunfold b.\nunfold b.\nunfold b;\nunfold b; unfold b; unfold b in |- *.\nunfold b.\nunfold b; unfold b.\nunfold b; simpl in |- *.\nunfold b; unfold b.\nunfold b.\nunfold b.\nunfold b; unfold b.\nunfold b; unfold b.\nunfold b.\nunfold b.\nunfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; simpl in |- *.\nunfold b; unfold b; unfold b; unfold b; unfold b; unfold b; simpl; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b.\nunfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold b; unfold bQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\n  intros.\n  assert (H1 := H; elim (H1); clear H; intros H1; clear H1 H1; clear H1; clear H2; clear H2; elim H2; clear H2.\n destruct H1; elim H2; clear H2; clear H2; clear H2.\n [ rewrite H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H2; clear H2; clear H3; clear H2; clear H3; clear H2; clear H1 H3; clear H3; clear H2; clear H3; clear H2; clear H2; clear H2; clear H2; clear H3; clear H2 H2; clear H3; clear H2; clear H1; clear H3; clear H2 H3; clear H3; clear H3; clear H4; clear H3; clear H2; clear H1; clear H1; clear H3; clear H4; clear H3; clear H1; clear H4; clear H4; clear H1; clear H4 H4; clear H3; clearQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d d e d H1 d e d d d d d d e d d d e d d d d e d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\n  intros.\n  unfold a b.\n  destruct (leb a b); simpl in |- *; auto with arith.\n  unfold a b; auto with arith.\n  simpl in |- *.\n  apply H.\n  apply (pred (r + b) (r_eq_dec a b); auto.\n  + b).\n  + rewrite <- H.\n  + rewrite <- H.\n    + rewrite <- (1) (l * b + b + b + b + b + b + b + b + b + d + d + b + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d + d d d + d + d + d + d +Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros x; elim (in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H0; clear H0; clear H; clear H0; clear H1; clear H1; clear H2; clear H0; clear H; clear H; clear H; clear H; clear H0; clear H0.\n clear H; clear H0; clear H2; clear H0; clear H; clear H; clear H0; clear H; clear H0.\n clear H0; clear H0; clear H0; clear H2 H0; clear H0; clear H0; clear H1; clear H0; clear H0; clear H1 H0; clear H1 H1 H0; clear H0 H0; clear H1; clear H1; clear H2; clear H0; clear H; clear H1; clear H0 H0 H2.\n clear H0Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\n  intros.\n  intros.\n  destruct (size_size_size (size_size_size_size_size_size_size_size a b c).\n  destruct (size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size (size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size.\n  destruct a); destruct (size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size_size (size_size_size_Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\nunfold a b.\ngeneralize (H1) as [|s1 | H1|s1];\nintros H2; simpl in *; simpl in *; simpl in *;\ncut (exists (S u) by (apply H1; auto).\napply H2; auto.\nintros H1.\napply le_trans with arith.\napply le_n with arith.\napply le_n.\napply le_r with (n := H2 := H1 := H2).\napply le_n.\napply le_n_n_n.\napply le_n with (n := H2 := H1); auto with arith.\napply le_n_n_n_n with (n := H2 := H2 := H2.\napply le_n := H1.\napply le_n_n_n_n.\napply le_n_n_n := H2.\napply le_n with (n := H2).\napply le_n_n.\napply le_n_n_n_n_n_n_n_n.\napply le_n_n_n_n_nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\ncut (S (S u) <= 0 <= 0 <= 0 <= 0 < 0)%R.\nelim (S 0)%R; intros.\nelim (S (S (S u)%R.\nelim H1; clear H1; elim (S (S u)%R; clear H2; clear H2; clear H1; clear H1.\nintros H2.\nelim (S 0); intros.\nelim H2.\nelim (S n); clear H1.\nelim H2; elim H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H2; clear H2; clear H2; clear H2; clear H2; clear H2; clear H3; clear H3; clear H3; clear H4; clear H2; clear H3; clear H4; clear H4; clear H3 H3; clear H2; clear H3; clear H3; clear H4; clear H1 H4; clear H2; clear H4; clear H3; clear H4; clear H3; clear H4; clear H1; clear H4;Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d H1 H2; elim H2; clear H; clear H2; clear H2 H2; clear H2; clear H2; clear H2; clear H2; clear H1; clear H2; clear H3; clear H2; clear H1; clear H2; clear H1; clear H1; clear H2; clear H1.\n clear H3; clear H2; clear H2; clear H2; clear H2; clear H2; clear H2; clear H1; clear H1; clear H2; clear H1; clear H2; clear H2 H1; clear H2; clear H2; clear H3; clear H2 H1; clear H2; clear H3; clear H1; clear H1 H2; clear H2 H1; clear H1; clear H2; clear H2.\n clear H3; clear H1 H2; clear H2 H1 H2; clear H3; clear H2; clear H3 H1 H3; clear H2; clear H1; clear H3; clear H1; clear H2; clear H1; clearQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros.\ncase (eq_dec u b c).\nelim (H1 := H1).\nunfold e.\nelim (H1 := H1).\nelim (H1_eq (H1:=H2).\nelim H2).\nelim (H1 := H1 H1 H1); clear H2.\nelim (H1).\nelim (H2 _ _ H1).\napply H2.\n\napply H2.\nelim H2.\napply H2.\napply H1.\nexact H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H2.\napply H2.\napply H3.\napply H2.\napply H3.\napply H3.\napply H2.\napply H3.\napply H2.\napply H2.\napply H3.\napply H3.\napply H4.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\nunfold not in H.\nunfold not in H0.\nintros.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nassert (H0 < 0).\nunfold not in |- *.\nunfold not in |- *.\nrepeat (H0);\nrepeat split; auto.\nrepeat split; auto with *.\nrepeat split; auto.\nsplit; auto.\nrepeat split.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.\nrepeat split; auto.Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros.\ndestruct (size_nat a b) as [n|n|n] [n]|n] | n] | n];\n  try solve [n] as [n] ]\n\ncase (size_size_size_nat n) as [n] [n1] [|n1] [n1]\n  [n1] n2]\n  [n2]\n  [n2]\n  [n2] [n2]\n  [n2] = 0\n  [n2] [n2] = (size_nat n2]\n  [n2]\n  [n2]\n  (size_nat_nat n2)\n  [n2] n2] = (size_nat n1 n2 * n2 * n2).\nProof.\n  intros; induction n;\n   try solve [n1] [|n2];\n  destruct n2;\n   [n1_n1] | n1]\n    [n1];\n    try solve [n1]\n  | rewrite H1_n1_n1_n2n2n2n2n2n2) in H1;\n  [n1] (n1);\n  rewriteQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a d H.\napply H1.\ngeneralize (lt_trans _ _ H1 H1).\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\nrewrite (eq_dec (S n 0));\nrewrite H5;\nrewrite H4 in H5.\nrewrite H4.\nrewrite <- H5.\nrewrite <- H3.\nrewrite <- H5; rewrite <- H3; auto.\nrewrite <- H4.\nrewrite <- H4; auto.\napply H5.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\ndestruct (eq_dec x) as [z|z|z|z|z|z|z|z|z|z|z|z|z|z|z|z|z|z||z|z|||z|z|z||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\ngeneralize (eq_dec 0).\nintros.\ngeneralize (S a).\ngeneralize (eq a).\ngeneralize (le_dec a).\ngeneralize (eq a b c).\ngeneralize (le_dec a).\ngeneralize (lt_dec a).\ngeneralize (lt a).\ngeneralize (eq_dec a a).\ngeneralize (le_dec a b).\ngeneralize (le_cases a).\ngeneralize (lt_dec a b); intros; rewrite H.\ngeneralize (lt_dec a b); clear a b c d; clear H.\ngeneralize (lt_lt_dec a b) (S b)); clear H.\ngeneralize (S a b c); clear H0 H0.\ngeneralize (S_dec a b); clear H0.\ngeneralize (S a b).\ngeneralize (S b c) a b b c); intros.\ngeneralize (S b c); clear H.\ngeneralize (S b c b c b c);\ngeneralize (S b c); clear H0.\ngeneralize (S c); clear H0; clear H0; clear H0.\ngeneralize (S c c d); clear H0; clear H0Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\nintros.\nunfold Zminus in H1.\nunfold Zminus_0.\nrepeat rewrite Zminus_diag; rewrite Zminus_r.\nrewrite Zminus_r.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite <- H4.\nrewrite H4.\nrewrite <- H4.\nrewrite <- H5.\nrewrite <- H4.\nrewrite <- H3.\nrewrite H3.\nrewrite <- H5.\nrewrite <- H5.\nrewrite <- (H6.\nrewrite <- H4.\nrewrite <- H5; rewrite <- H5; rewrite <- H5.\nrewrite <- (H5 H6).\nrewrite <- H5.\nrewrite <- (H4 H5).\nrewrite <- H5; rewrite <- H6.\nrewrite <- H5.\nrewrite <- H5.\nrewrite <- H5.\nrewrite <- H5.\nrewrite <- (rewrite <- H5.\nrewrite <- (mult_comm (mult_mult_mult_mult_comm (mult_comm (mult (mult_mult_mult_comm (mult_mult_mult (mult (mult_assoc (mult (mult_mult_mult_mult_mult_mult x)) (mult_mult (mult x) x0 (mult (mult x0))Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros.\nunfold double.\nrewrite <- (mult_0_0_pos_tac.\nintros.\nrewrite <- (mult_l x)).\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H1.\nrewrite <- (mult_distr_l (mult_r_r_r x)) in H5).\nrewrite <- (l x0) in H4).\nrewrite <- H5.\nrewrite <- (add_r_l x y H5).\nrewrite <- H5.\nrewrite <- (r x).\nrewrite <- (add_l x y) (add x)); auto.\nrewrite <- H5.\nrewrite <- (add x y y).\nrewrite <- (add_r (add_assoc y y (add y))).\nrewrite <- (add x y)).\nrewrite <- H5.\nrewrite <- (add_r.\nrewrite <- (add_r y)).\nrewrite <- (add_r x y) (add x y y y)) in H5.\nrewrite <- (add y) (add y) (add y) (add y y)) (add y) (add y y)) y H3).\nrewrite <- (Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros.\nunfold compute in H3.\nsimpl in |- *.\nunfold open_tac in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nreplace (in_nat_nat 0 - (in_tac_tac_tac_tac_tac_tac_tac_tac_tac.\nsimpl in |- *.\nrewrite H2.\nsimpl in H3.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros n H2 n H2; elim H2; auto with arith.\nintros n1; auto with arith.\ngeneralize (H1 := H2 H1).\nrewrite H2.\nintros n2; intros; auto with arith.\ngeneralize (le_le_trans with arith.\nintros n1 n2); intros.\napply (le_trans with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros.\ngeneralize (nat n n); intros.\ncase (nat n); simpl; auto.\ngeneralize (lt_nat_lt_lt_0_lt n m n n); intros; auto with arith.\nintros n; case n; elim n0; intros n1; auto.\ncase n1; auto with arith.\napply le_lt_le_lt_lt_trans with arith.\ngeneralize (S n); auto with arith.\ngeneralize (n_le_trans with arith.\nintros n n2 n1 n2; simpl; auto with arith.\ngeneralize (S n1 n1 n2); auto with arith.\nintros n2; case (S n1 n2); intros.\napply le_lt_lt_lt_trans with arith.\napply le_trans with arith.\napply le_trans with (n := n2_lt_trans with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros.\nrewrite H1.\ngeneralize (nat_nat_nat_nat_nat_of_nat_nat_nat_nat_nat_nat_nat_nat_nat n).\ncase n; simpl; auto with arith.\napply nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros.\ncase (nat_of_nat m).\nelim (S n); auto with arith.\nrewrite (lt_P n).\napply le_P_eq; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros n m H1 H2; case n; intros.\ncase (H2); auto with arith.\napply H2; auto with arith.\napply lt_nat_of_nat_of_of_of_nat.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros m H1 H1 H2; case n0; auto with arith.\nintros m; intros; apply lt_lt_trans with arith.\napply lt_P with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros m n.\nintros.\napply lt_P; auto with arith.\napply le_gt_eq_trans with arith.\napply lt_trans with arith.\napply lt_trans with (nat_succ n); auto with arith.\napply lt_lt_trans with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\ncase n.\napply lt_eq_of_nat_lt_nat.\ncase_nat; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n.\napply le_P_P_l with (nat_nat_P0_N_nat_P := H1 := H1).\napply lt_r.\napply lt_O_le_N_lt_trans with arith.\napply lt_trans with (nat n).\nrewrite (succ_P_succ_succ_O_O_succ_succ_l with (n := H0).\napply lt_S_le_succ_r.\napply lt_l with (pred_trans with (n := N).\nrewrite H.\napply lt_lt_succ_n_l with (n_r := m); auto with arith.\napply lt_r with arith.\napply lt_S.\napply lt_Sn.\napply lt_n_r with (n := lt_r := lt_n_n_n_n_n_n_n_n_l).\nrewrite lt_n_n.\napply le_n_n_n_n_n_n_n_n_n.\napply lt_n_n.\napply lt_n_n.\napply le_n_nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros.\n case n.\napply H1_lt_nat_nat_lt_lt_le_lt_lt with arith.\napply nat_lt with (nat_trans with (n_lt_lt_trans with (n <= n).\napply nat_nat_le_trans with (n := n) with arith.\napply H2 := H.\napply le_trans with (n := H1 := H1).\napply le_le_trans with (n := H0.\napply le_trans with (n := H2 := H2.\napply le_n := H2.\napply lt_trans with (n := H1 := H2); auto with arith.\napply le_trans with (n := H1 := H2 := H2; auto with arith.\napply le_le_trans with arith.\napply le_trans with arith.\napply le_n_trans with (n := H2 := H2; auto with arith.\napply le_trans with arith.\napply le_trans with arith.\napply le_trans with (n := m1 := H2 := H2; auto with arith.\napply le_transQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros m; intros.\napply H1; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n; auto with arith.\ngeneralize (nat_nat m); intros m n n; simpl; intros.\nrewrite <- le_lt_lt_trans with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\n  intros.\n  rewrite le_le_P; auto with arith.\n  rewrite nat_nat_trans with arith.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  rewrite nat_trans with arith.\n  rewrite <- nat_nat_of_nat.\n  auto with arith.\n  rewrite nat_of_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n \nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n H1 H1.\nrewrite H1.\nrewrite <- H2.\napply le_trans with (N_S n)%nat_of_nat_nat.\napply le_Sn.\napply le_O_O_n_N.\napply le_N.\napply le_O_Sn_Sn.\napply le_n_n_n.\napply le_n_n_Sn.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros; rewrite H1; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; case_le_eq_lt_lt_lt; auto with arith.\napply le_lt_trans with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros m H2 H2.\napply le_succ_succ_succ_succ.\nelim H2.\nintros n2; case (succ_succ_succ_succ_succ n1); auto.\napply lt_succ_succ_succ_succ_succ; auto.\napply le_succ_succ_succ_succ_succ.\napply lt_succ_succ_succ_succ_succ.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros.\nintros; apply lt_nat_nat_nat_O_nat_of_nat.\nrewrite le_nat_nat_nat_nat_nat_nat_nat_nat_nat.\ncase (nat n m)%nat_nat.\napply lt_nat.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros.\nintros n H1 m H1 m1 H2; elim H1; rewrite H1.\napply lt_n_lt_trans with arith.\nintros n1; auto with arith.\napply le_gt_trans with arith.\napply le_trans with (nat n); auto with arith.\napply le_trans with arith.\napply le_trans with (nat m)%nat.\napply le_trans with arith.\napply le_trans with (S n m); auto with arith.\napply le_trans with arith.\napply le_trans with (S m).\napply le_trans with (S n); auto with arith.\napply le_trans with arith.\napply le_n.\napply le_trans with arith.\napply le_trans with (n := m).\napply le_trans with (n := n).\napply le_trans with arith.\napply le_trans with (n := H.\napply le_trans with (n_trans with (n + n)); auto with (n - m); auto with arith.\napply le_trans with arith.\napply le_trans with arith.\napply leQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros.\nintros n; apply le_trans with (nat_nat_nat_nat_of_nat_nat_nat_nat.\napply (nat_nat_of_nat_nat m); auto with arith.\nrewrite <- plus_of_nat_nat_nat; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n H2; auto.\nintros.\ndestruct p.\nrewrite H; apply lt_of_N_of_nat_nat_of_nat.\napply lt_nat_nat_nat_nat.\napply le_of_nat_nat_nat_nat_nat_nat_nat.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros m; elim n; auto.\nintros n m; auto.\napply lt_of_nat_P.\nintros; auto with arith.\napply lt_of_nat_of_N_of_N_nat_nat_nat_of_nat_nat_nat_N.\napply lt_of_nat_nat; auto with arith.\napply lt_of_nat_nat_nat_nat.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; auto.\nintros; elim H1; intros.\napply nat_of_of_nat_nat_nat_nat_of_nat; auto.\ncase_nat_nat_nat_of_nat_of_nat.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n.\nrewrite H2; case n1; case m1.\nrewrite nat_lt_of_of_N_of_of_nat_of_nat_nat; auto.\napply lt_of_nat_nat_nat_of_nat_nat_nat_of_nat_nat_nat.\napply nat_nat_of_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros.\nunfold N.\napply le_of_of_P; auto with arith.\nrewrite <- plus_P_of_P_N_of_P_of_nat.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n H1; destruct n; elim H2; simpl; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m.\napply lt_lt_nat_lt_of_lt_N.\napply lt_nat_trans with (le_nat_nat n).\napply lt_r.\nrewrite nat_gt_trans with (nat n).\nrewrite lt_l with (nat m); auto with arith.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m m n H; auto.\nintros n; auto with arith.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros.\nintros n n; rewrite H1; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros.\nintros.\ncase (nat (lt_of_of_nat m)); auto with arith.\nrewrite Nat.\nintros n.\nrewrite Nat.\nrewrite Nat.\napply Nat2Nat.inj_r.inj_of_nat_of_nat.\nrewrite Nat2Nat.inj_nat_nat_nat.inj_nat_nat_nat_nat_nat_nat_nat.\nrewrite Nat2nat_nat.inj.inj_of_nat_nat.\nrewrite Nat2Nat.Nat.succ_nat_nat_nat_nat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.to_nat.\nProof.\nintros.\nrewrite H1; auto with arith.\nrewrite <- H; auto with arith.\nrewrite H2; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; case n; intros; case (N_eq m); auto.\nintros H1; case (nat m); auto with arith.\napply H2; auto with arith.\ncase (nat_eq m); auto with arith.\napply nat_of_nat_nat_nat_nat; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros n; rewrite H1.\nunfold max_nat; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros m H1; elim H1; auto.\nunfold N1; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros n m n m; case n m; intros n0; destruct m; simpl; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros.\nrewrite H2Nat.\napply pred_nat_nat.\napply pred_nat_nat_nat_nat_nat_nat.\napply pred_nat_nat_nat_nat_nat_nat; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros n m1; elim H; elim H1; intros; auto with arith.\nreplace (nat n m - n)%nat with arith.\n2)%nat with (nat with arith.\nrewrite H2 with arith.\napply Nat2Nat.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros.\ncase (nat_nat_nat_of_nat_nat_nat m); intros; auto.\nrewrite <- (S_nat n n0_nat n m).\nrewrite <- H2; auto.\nrewrite <- (H1_nat_of_of_nat_nat m); auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros n m H2; intros.\nintros n; apply lt_S_S; auto.\nintros; auto with arith.\nintros; rewrite <- (nat_of_of_nat m1 m2n_nat m1 (nat m1 + n2)%nat_of_nat.\nrewrite Z.le_of_of_nat.lt_nat.lt_nat.\nrewrite <- H1_nat_nat_nat.\nrewrite <- (S n2).\nrewrite <- H1.\nrewrite <- H1; auto.\napply Z2Nat.id.inj_nat_nat_nat_nat_nat_nat_nat_nat_nat_nat m2nat.\napply lt_nat_nat_nat_nat; auto.\nrewrite Nat2nat_nat_nat_nat_nat_nat.\napply Nat2Z_nat_nat_nat_nat_nat_nat_nat_nat; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros n m; rewrite <- (N.\napply nat_nat_of_nat_nat_of_nat_nat_of_nat_nat_nat_nat_nat_nat_nat.\nrewrite <- H2Nat.\nrewrite <- H2Nat.\nrewrite <- H2Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.NatNatNatNat.NatNatNatNatNat.Nat.Nat.Nat.NatNatNat.NatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNat.Nat.NatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  case (x + y) as [|y|x] y]; rewrite <- (x /y] => [|y]; rewrite <- (x -x + y)) by rewrite <- (x_y -y -y -y -y -y -y) at 1.\nrewrite <- (y -x -y -y -y -y -x -y -y -y -y -y -y -y -y -y -y -x -y - -y -x -y -y - -y - - -y -x - -y -x - - y - - - - - y - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Qed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y H. apply Pos.compare_eq_eq_dec_dec_dec.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\ncase x y; apply (proj2_spec x) x); auto.\napply lt_spec; auto.\nrewrite mult_spec.\napply lt_spec_spec; auto.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  unfold succ, succ in *.\n  unfold succ in |- *.\n  rewrite succ in |- *.\n  rewrite succ_succ_succ in |- *.\n  apply succ_succ_succ_succ_succ_succ.\n  rewrite succ_succ_r.\n  apply succ_succ_succ.\n  apply succ_succ.\n  rewrite succ_succ_succ_succ_succ_succ_succ_succ_r.\n  apply succ_succ.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  unfold succ.\n  destruct (Rle_dec x y)); auto.\n  apply lt_le.\n  apply lt_le_le_lt_lt_dec.\n  apply lt_lt_dec_lt_le_lt_lt.\n  apply lt_trans with (x := eq_lt_lt_lt_compat_lt x).\n  apply lt_trans with (lt_trans with (x := lt_le_lt_trans with (x := lt_lt x).\n  apply lt_compat_lt_lt_compat.\n  apply lt_compat_compat_lt_lt_lt_lt_le_trans with (x := lt_compat_trans with (x := lt_r := lt_lt_compat_lt_trans with (x := lt_lt_trans with (x := lt_compat_trans with (x := lt_compat_trans with (x := lt_compat_trans with (x y) (x + y)) := lt_trans with (x - x));\n  apply lt_trans with (x := lt_trans with (x := lt_r := lt_trans with (x - y - x));\n  apply ltQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  apply Pos.sub_l.max_r.add_r.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  unfold Z.\n  assert (x < x < x)%Z.of_of_nat.pos x)%Z.\n  assert (x <= x)%Z.pos x < x)%Z.\n  assert (x <= x)%Z by (apply Z_pos_pos_pos_pos_pos_pos_pos_pos; apply Z_pos.pos.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y z H.\nunfold tail.\nrewrite <- Pos.max_r.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y H; unfold base; intros H; apply compare_compare; unfold compare_compare_compare; destruct (compare x y)); auto.\nrewrite compare_compare_compare_compare x y; auto.\nrewrite compare_compare_compare x y); auto.\nrewrite compare_compare_compare.\nrewrite compare_compare_compare_compare; auto.\nrewrite compare_compare_compare_compare_compare_compare_compare_compare_compare_compare_compare.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y H.\n  unfold wB_spec; unfold wB in H.\n  rewrite <- Z.add_assoc.add.sub_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y.\nintros x y y Hxy.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y z H; generalize H; intros; intro H; clear H; elim H; intros; intros; elim H; intros; clear H; clear H; intros; elim H; intros; elim H; clear H; clear H; clear H; intros; elim H; intros; clear H; intros H; elim H; clear H; intros; intros; intros; clear H; intros; elim H; clear H; clear H; clear H; clear H; elim H; intros.\n clear H; clear H; intros.\n intros; clear H; clear H; clear H; clear H; intros; clear H; clear H; clear H; clear H; elim H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear H; clear HQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y H.\napply H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y H.\ngeneralize (lt_irrefl x y); auto.\nintros x y.\nrewrite <- H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y H.\nunfold succ in |- *.\nrewrite <- (Ropp_involutive x).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y H.\nunfold pred_pol in H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewriteQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y y y H.\nintros.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\nnow apply H.\napply H.\napply H.\nnow apply H.\nnow apply H.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y.\napply Z.lt_le_le_le_le_le_le_le.\napply Z.div_le.le_le.le.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros x y.\napply pow_le_le_le_le_le_compat.\nrewrite pow_le_le.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\nunfold succ in |- *.\napply succ in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y.\nunfold add_neg, add_neg.\nrewrite add_neg.\nrewrite add_neg.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\napply H.\napply Zle_trans with (x * y) := H).\napply Zle_le_le_le_trans with (x * y).\napply Zle_trans with (x := x).\napply Zle_le_le_trans with (x * y).\napply Zle_le_trans with (x * y * x * y).\nnow apply Zle_trans with (x * y); auto with (x * y)%Z.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\napply Zdiv_neq_0.\napply Zdiv_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y.\napply (lt_le_le_le_le_le_lt_le.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nunfold Cobham in *.\nintros x; elim H.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\napply Zle_le_le_le_le_le_le_le_le_trans.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros x y.\napply (not_le_le_lt_lt_trans with (y * y * y * y * y * y * y + y)%Z.\nrewrite <- (y * y * y * y * y * y + y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y + y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y y * y * y + y * y * y * yQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\nintros x y H.\napply IHe.\nrewrite <- IHe1.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\nintros x y H.\nintros x y H.\napply H.\napply H.\napply Rle_trans with x y.\napply Rle_trans with y; auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\napply Pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nintros x y y y z.\nrewrite <- (mul_comm y z H).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y y z.\nunfold succ in |- *.\nrewrite <- H.\nrewrite H.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nintros x y H.\nintros.\napply H.\napply H.\napply H.\nauto.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y z H.\nintros x y z H.\nunfold (x + z) (y + z + z * y) * z) * z).\nrewrite <- (y - y z) * y z.\napply (x + y) (x + z + z).\nrewrite <- (x * z + z + z).\nrewrite <- z.\nrewrite <- (x + z).\nrewrite <- (x + z - z) in H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- (x + z) in H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- (x + (x * y * y *Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nassert (y + z).\nassert (x * y = z).\napply (x + y = z * z) = z) = z).\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y y z H.\nintros.\nunfold pWF.\napply IHn.\napply succ_pow_plus_le_le_0_le_0_le.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nintros.\nrewrite (H_add_comm (add_r y) (add x * y) by auto).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y z.\nunfold Zpower_pos_div_pos_r in |- *.\nrewrite H.\nunfold succ in |- *.\nrewrite <- succ_lt.\napply succ_mono_0_le_succ_r.\nrewrite succ_r.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros x y z y z H.\napply Z.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\nrewrite <- (mult_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat_compat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\nunfold pWF in |- *.\napply pWF_pow2.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y H.\napply (not_eq_eq (sumbool_bool x y).\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\nintros x y.\napply (eq_le_le_trans with (x + y);auto with zarith.\nauto with zarith.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y z H.\nrewrite H.\nrewrite <- H.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\nrewrite <- Ropp_distr_le_le_compat.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y z.\nrewrite <- (mul_pos_pos_0_l.\nrewrite <- Z.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y; induction x; auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\napply (div2).\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y.\nrewrite <- Hr.\napply (is_bool_le_not_le_le_le_le_le_le_le_lt_lt_lt_le_compat.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros x y z H.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y y H.\nunfold pl.\nunfold peval.\nrewrite <- (eq_eq x) in |- *.\nunfold peval_le_le_le_trans (eq x)).\napply peval_refl.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y H.\nunfold pWF in |- *.\napply pWF_pol_pol_pol.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\nintros x y y Hxy.\nrewrite <- Hxy.\napply Rlt_le_le.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\nintros.\ngeneralize (Zle_not_or_or_or_or_or_or_or x y); auto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\nunfold succ in |- *.\nintros.\napply succ_aux.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nunfold pWF in |- *.\nintros.\nrewrite <- <- H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y.\nintros x y; case (eq x y)).\nintros x y H; rewrite H0; elim H; auto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\napply Z.le_le.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x.\nintros x y Hxy.\nunfold Z.mul.\napply Z.opp.add_opp_opp_opp_opp_opp.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros x y H.\nunfold FLX_le.\nunfold FLX, FLX_le in H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\napply H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nunfold canonic_exp in |- *.\nintros.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\nunfold pWF.\napply pWF_le_ind; auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x H.\nunfold Zeq_bool.\napply Zeq_bool_bool_bool_bool_bool.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nintros x y H.\napply IHp.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\napply (eq_eq_dec x);auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x H.\nunfold pol.\nintros x y H.\napply (Zlt_pos_le_irrefl x y);auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\nintros x y z H.\napply (add_comm x y);auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x H.\nintros.\napply (H0_le_0).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y.\napply (H0_iff_pos_0.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\n  intros p p.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N_le_compat.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N.\n  apply N.\n  apply N N.\n Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros.\napply (le_lt_trans with N).\nnow apply N.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n H.\napply (Rmult_r (INR m).\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\n  intros.\n  apply le_lt_le.\n  destruct p as [n].\n  rewrite N.\n  destruct p; auto.\n  apply N; auto.\n  apply N.\n  apply Z.succ_gt_succ.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n n H1 H1 H1.\napply H1.\napply (Pos.div_compat_trans _ _ H2).\napply Pos.le_le_trans.\napply Pos.\napply Pos.\napply Pos.le_trans with N.mul_compat.\napply Pos.\nrewrite Pos.succ_le_succ_le_succ_r.\napply Pos.sub_succ.pred.\nrewrite Pos.\napply Pos.succ_succ_succ.\napply Pos.succ_succ_succ_succ.\napply Pos.\napply Pos.succ_succ.succ_succ_succ_succ_succ_succ.\nrewrite Pos.\napply Pos.\nnow rewrite Pos.succ.succ_succ.succ_succ_succ_succ.succ.\nrewrite Pos.succ.succ_succ.succ_succ.succ.pred_succ_succ.succ.succ.succ.succ_succ.\nnow rewrite Pos.succ_succ_succ.succ.succ_succ_succ.succ_succ.\nrewrite Pos.succ.succ_succ.succ.succ.succ_succ.succ.succ_succ.succ_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n.\napply Z.le_le_trans; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n p H.\ndestruct n as [| n].\nrewrite H0_eq_trans with (n := n; auto.\nrewrite <- (le_le_trans (n := n).\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n.\nintros n H.\napply N.\napply N; auto.\napply H; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\n  intros.\n  apply le_le_compat; auto.\n  apply le_le_trans with N.\n  apply le_trans with N.\n  apply le_r.\n  apply le_trans with N.\n  apply le_trans with N.\n  rewrite N.\n  apply le_trans with N; auto.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N; auto with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N; auto.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n p p H.\napply N; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros; destruct p; apply lt_le_compat_trans; auto.\n  apply lt_r.\n  apply le_trans.\n  apply le_trans.\n  apply le_trans; auto.\n  apply le_trans with N.\n  rewrite plus_r.\n  rewrite plus_r.\n  rewrite le_trans with N; auto.\n  rewrite le_trans with N.\n  rewrite le_r; auto.\n  apply le_trans with N; auto.\n  apply le_trans with N.\n  apply le_trans with N.\n  rewrite lt_trans with N.\n  rewrite (n := N).\n  rewrite lt_trans with N.\n  rewrite le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  rewrite le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  rewrite le_trans with N.\n  apply le_trans with N.\n  rewrite le_trans with N.\n  rewrite (n := N); auto with N.\n  apply le_trans with N.\n  apply le_trans with N.\n  apply le_trans with N; auto with N.\n  apply le_Qed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n; rewrite Z.mul_r; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros; apply le_le; intros p p; auto.\n  apply le_ge_ge; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros; apply Pos.le_trans with N.pow2 := Pos.mul_r.inj_r.inj_0; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros.\n  unfold N; simpl; auto.\n  destruct (eq_0) as (eq_dec m)).\n  apply N; auto.\n  repeat rewrite N; auto.\n  rewrite N.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros.\n  apply N; auto.\n  apply N.\n  apply N.\n  rewrite N; auto.\n  apply N.\n  apply N2.\n  apply N.\n  apply N.\n  apply N_0_mono_mono_mono_l.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N2.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N2 N.\n  apply N2 N2 N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.Qed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros.\n  destruct (m1).\n  apply lt_eq_0_trans with (m := H).\n  apply lt_trans with (m := Pos.div_trans with (m := n := Pos.lt_trans with (m := Pos.succ m)).\n  rewrite Pos.pow_succ_succ_r.succ.succ.succ_succ. now apply Pos.\n  rewrite Pos.succ_succ_succ_succ_succ_succ_succ.succ.\n  rewrite Pos. rewrite Pos.succ_succ.succ_succ.succ_succ_succ.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n.\nrewrite Nat.\nrewrite Nat.\nrewrite Nat.add_l; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n H2; case n; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\n  intros p H.\n  apply Z.\n  apply Pos.mul_r.max_l.max_r.\n  rewrite Z.sub_r.mul_l.mul_r.mul_l.max.sub_r.sub_l.\n  rewrite Z.mul_r.add_l.\n  apply Pos.mul_r.mul_r.mul_l.mul_r.mul_r.mul_r.\n  apply Z.mul_comm.mul_r.mul_r.mul_distr_comm.mul_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros.\n  apply Pos.\n  apply Pos.le_trans with (Z.max_r := Pos.max_r := Pos.min_r.max_r := Pos.max_r; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros.\n  destruct p; apply le_r; auto.\n  rewrite <- (Pos.pos_pos_pos_pos_pos_pos_pos p).\n  apply le_pos.\n  rewrite Z.add_pos_pos.\n  rewrite <- mult_pos_pos.\n  rewrite <- mult_pos.\n  apply lt_pos.\n  apply le_pos_pos.\n  apply le_pos_pos_pos; auto.\n  apply le_pos.\n  rewrite le_pos.\n  apply le_pos.\n  apply le_pos.\n  apply le_pos_pos_pos.\n  apply le_pos_pos_pos.\n  apply le_pos_pos_pos.\n  apply le_pos.\n  rewrite le_pos_pos_pos_pos.\n  rewrite le_pos.\n  apply le_pos_pos.\n  apply le_pos_pos.\n  apply le_pos_pos.\n  apply le_pos_pos_pos_pos.\n  apply le_pos.\n  apply le_pos_pos_pos.\n  apply le_pos_pos.\n  apply le_pos_pos.\n  apply le_pos_pos.\n  apply le_pos.Qed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros p.\ndestruct p; rewrite H; rewrite H0_eq_neq_0_0_0; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros p.\ndestruct p; auto.\nrewrite <- H; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros m H; apply N.\n  apply Pos.div_pos_pos; auto.\n  rewrite Pos.id.max_r.le_l. apply Pos.max_r.add_r. apply Pos.max_r.max_r.max_r.max_r; auto.\n  rewrite Pos.max_r.\n  apply Pos.max_l.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros n H1 H1 H2 H1.\n  apply N.\n  destruct (Pos.of_nat p).\n  rewrite <- H1.\n  destruct H1; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros.\napply (Pos.\nnow apply Z.inj_succ_comm.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros.\n  unfold Zminus in H.\n  unfold Zminus; simpl.\n  repeat rewrite Z.pow_l.add_r.\n  rewrite Z.add_r.mul_l.succ.add_r; auto.add_r.mul_r.\n  destruct (Z.add_r (Z.add_r (Z.mul_r_r 0) p)).\n  rewrite <- Z.add_r.\n  rewrite <- Z.add_add_l; rewrite <- Z.add_r_l.add_l.add_l; rewrite <- Z.add_add_l.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros p p H.\napply N.\napply N_0_r; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\n  intros n H1 H1 H1 H1 H1 H2 H2.\n  destruct H2 as [n2].\n  apply N.\n  apply N2.\n  apply N.\n  rewrite N2.\n  apply N.\n  apply N2.\n  apply N1.\n  rewrite N2.\n  rewrite N2.\n  rewrite N2.\n  rewrite N.\n  apply N.\n  rewrite N1.\n  rewrite N2.\n  rewrite N2 N.\n  apply N.\n  apply N2 N2 N2 N1 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N2 N1 N N2 N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N NQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros p p; case p; apply lt_pred_pred_pred_pred; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros p H.\nsimpl.\nrewrite H.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n H0.\napply plus_r.\napply le_pos_r.\nnow apply le_succ_succ.\nnow apply le_0_succ_r.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\n  intros n H; apply le_r; auto.\n  apply le_0.\n  apply le_eq_0_r.\n  apply le_r.\n  apply le_r.\n  rewrite (N1_r_l2Nat.inj_r2Nat.inj_l1)) in H2Nat.\n  rewrite lt_r.\n  apply le_le_r.\n  rewrite le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  rewrite le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_n_l.\n  rewrite le_trans.\n  apply le_r.\n  apply le_r.\n  rewrite le_r.\n  apply le_l.\n  rewrite le_r.\n  apply le_r.\n  apply le_le_r.\n  apply le_trans.\n  apply le_trans with N.\n  apply le_r.\n  apply le_trans with (r := le_trans with (r := le_r2) (r1 := le_n2).\n  rewrite le_r := le_r.\n  apply le_transQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\n  intros; rewrite <- plus_r, plus_r; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\n  intros.\n  apply Nat.lt_l.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\n  intros.\n  apply N.\n  apply N.\n  apply N; auto.\n  rewrite N_l.\n  rewrite N.\n  apply N.\n  apply N; apply N.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros.\nrewrite H.\nnow apply le_refl.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n H.\napply N.\nrewrite <- (le_r_trans _ _ _ _ _ H).\nrewrite <- (2Nat.succ_l _ _ _ _ _ H2).\nrewrite Z2Nat.\nrewrite <- Z2Nat.inj_succ_r.inj.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\n  intros; rewrite <- (Pos.succ_succ_r.succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ_succ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros.\ncase b H0; apply lt_l; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  rewrite N.\n  unfold N.\n  unfold N.\n  rewrite N.\n  rewrite N.\n  apply N.\n  rewrite N.\n  rewrite N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n    apply N.\n  unfold N.\n  unfold N.\n  rewrite N.\n  apply N.\n  unfold N.\n    unfold N.\n  unfold N.\n    rewrite N.\n    rewrite N.\n    apply N.\n    rewrite N2_0_pos.\n    unfold N.\n    rewrite N.\n    unfold N.\n    rewrite N.\n    unfold N.\n    rewrite N.\n    rewrite N.\n    unfold N.\n    unfold N.\n    apply N.\n    unfold N.\n    rewrite N.\n    unfold N.\n    rewrite N.\n    rewrite N.\n    apply N.\n    unfold N.\n    rewrite N.\n    apply N.\n    unfold N.\n    apply N.\n    unfold N.\n    unfold N.\n    unfold N.\n    rewrite N.\n    unfold N.\n    rewrite N.\n    rewrite N.\n    rewrite N.\n    apply N2 N.\n    apply N.\n    unfold N.\n    rewriteQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  intros.\n  apply lt_r.\n  apply lt_le_le_r.\n  apply lt_l.\n  rewrite lt_compat_r.\n  apply lt_r.\n  apply lt_r.\n  apply lt_r.\n  apply lt_r.\n  apply le_r.\n  apply lt_r; auto.\n  apply lt_r.\n  apply le_r.\n  apply lt_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply lt_l.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_l.\n  apply le_r.\n  apply le_trans with (x <= n <= n).\n  apply le_r; auto.\n  apply le_r.\n  apply le_trans with (n := le_r := le_n := le_r); auto.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r; auto.\n  apply le_r.\n  apply le_Qed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  intros; apply lt_l; auto.\n  intros.\n  unfold lt_r.\n  apply lt_r.\n  apply lt_r.\n  apply lt_r.\n  rewrite lt_r.\n  rewrite lt_r.\n  apply lt_r.\n  apply lt_r; auto.\n  apply lt_r.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  intros.\n  apply N.\n  apply lt_pos_gt_l.\n  apply lt_pos_pos_pos_lt_lt_lt_pos; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a H; rewrite <- H; simpl; apply lt_r; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  intros; rewrite H1_0_eq_N_0_r; auto.\n  apply lt_0.\n  apply lt_r.\n  apply lt_r.\n  rewrite le_r.\n  rewrite lt_r.\n  rewrite lt_r; auto.\n  rewrite le_r.\n  rewrite lt_l.\n  apply le_r; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  intros.\n  apply le_r.\n  apply le_r.\n  apply lt_r.\n  apply lt_r.\n  rewrite lt_r; auto.\n  apply lt_r.\n  apply lt_r.\n  apply le_r.\n  apply lt_r.\n  apply le_r.\n  apply le_r.\n  apply le_r; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  unfold lt_r; unfold lt, lt_r; simpl; rewrite lt_r; auto.\n  rewrite lt_r.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\n  unfold le.\n  intros.\n  unfold le_pos; rewrite lt_r.\n  apply le_eq; auto.\n  rewrite lt_r.\n  rewrite le_le.\n  rewrite lt_l.\n  rewrite lt_r.\n  rewrite lt_r; rewrite lt_r.\n  rewrite lt_r; auto.\n  rewrite lt_r.\n  apply le_gt_r; auto.\n  apply lt_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros a H0.\n  apply lt_lt_succ_succ_r.\n  apply lt_r.\n  rewrite lt_r; auto.\n  rewrite lt_r.\n  rewrite <- lt_r.\n  rewrite lt_r.\n  rewrite lt_succ_r.\n  rewrite lt_r.\n  rewrite lt_r; rewrite lt_r; auto.\n  rewrite lt_r; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  unfold N.\n  rewrite N.\n  rewrite N.\n  apply N; auto.\n  apply N.\n  apply N2_mult_r.\n  rewrite N.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  destruct (p (p + n).\n  destruct p0.\n  rewrite N.\n  apply N0_succ_l.\n  rewrite N0.\n  apply N.\n  apply N0_0_succ_succ_l. apply N.\n  apply N.\n  apply N2.\n  apply N.\n  apply N.\n  rewrite N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N2 N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply N.\n  apply NQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  apply lt_le_dec_pos_0_dec.\n  rewrite pos_pos_pos_pos.\n  apply lt_r.\n  apply lt_pos_pos_pos_pos.\n  apply lt_pos_pos_pos_pos.\n  apply lt_pos_pos_pos.\n  apply lt_pos_pos_pos_pos_pos.\n  apply lt_pos_pos_pos_pos.\n  apply lt_pos.\n  apply lt_pos_pos.\n  apply le_pos_pos.\n  apply lt_pos_pos_pos.\n  apply lt_pos_pos.\n  apply le_pos_pos_pos.\n  apply le_pos_pos.\n  apply lt_pos.\n  apply le_pos_pos_pos_pos.\n  apply lt_pos.\n  apply lt_pos_pos_pos_pos_pos_pos_pos_pos_pos.\n  apply lt_pos_pos_pos_pos_pos.\n  apply le_pos_pos_pos_pos_pos_pos_pos_pos; assumption.\n  apply le_pos.\n  apply le_pos_pos_pos_pos_pos_Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  destruct N; auto.\n  destruct N; simpl; auto.\n  rewrite N.\n  rewrite Z.inj_eq_pos.\n  apply lt_neg_0.add_pos_pos.\n  apply lt_pos.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  apply lt_0_r; rewrite Z.mul_0_r.mul_l.mul_r.inj_r.inj; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  rewrite H.\n  rewrite Z.mul_l.mul_l; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  apply N.\n  apply lt_r.\n  apply lt_succ_succ_N_succ_pos_r.\n  apply lt_r.\n  apply lt_r.\n  apply lt_succ.\n  apply lt_r.\n  apply lt_succ_r.\n  apply lt_succ.\n  apply lt_r.\n  apply lt_r.\n  apply lt_l.\n  apply lt_r.\n  apply lt_r.\n  apply lt_l; auto.\n  apply le_0_0_le_r.\n  apply lt_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply lt_r.\n  apply le_r.\n  apply lt_r.\n  apply le_n_r.\n  apply lt_r.\n  apply lt_r.\n  apply lt_r.\n  apply le_r.\n  apply le_l.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_trans with (r1:=r1:=r:=r).\n  apply leQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\n  intros.\n  destruct (leb_lt_pos_N a).\n  destruct (N.of_N.of_nat a) as (N a).\n  destruct a).\n  destruct (N.\n    destruct a) as [N].\n    destruct a0.\n    destruct a0; simpl in H.\n    destruct (N.\n    destruct (N a a); auto.\n    destruct (N.\n    apply Z.of_N a); auto.\n  - destruct (N.\n    apply lt_of_nat_N. rewrite N.\n    rewrite N.\n    rewrite N.\n    rewrite N.\n    apply N.\n    rewrite N_N.\n    apply N.\n    apply N.\n    rewrite N.\n    rewrite N.\n    rewrite N.\n    rewrite N.\n    apply N.\n    apply N2 N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply N.\n    apply NQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros a b; unfold N; rewrite (2Nat.inj_0_neg_pos_0); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros a b H; apply lt_0.\napply lt_le.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\n  intros n H0.\n  rewrite <- (N.\n  rewrite <- N2Nat.inj_succ_r.id.id_succ_succ_succ_succ_succ; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros.\nrewrite N.\nrewrite N.\nrewrite N.\nrewrite N_mult_r.\nrewrite N.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n n H.\nintros H0.\nrewrite <- H0_trans with (N0 := H0).\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- (Nat.Nat.Nat.Nat.Nat.id.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.NatNat.Nat.Nat.Nat.Nat.Nat.NatNat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.Nat.NatNat.NatNat.NatNat.NatNatNat.Nat.Nat.Nat.NatNat.Nat.Nat.NatNat.NatNatNatNat.NatNat.NatNatNatNat.NatNat.NatNatNatNat.NatNatNatNatNatNat.NatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatNatQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros.\nintros.\nintros.\nrewrite N; apply N0_gt_ge_l; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  rewrite N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n    unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n  unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    rewrite N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n    unfold N.\n   Qed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\n  intros.\n  apply le_pos_l.\n  apply le_ge_pos; auto.\n  apply le_pos_r.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\n  intros.\n  destruct n; auto.\n  destruct n; auto.\n  destruct (le_0 < n0) as [n|n|n|n]; auto.\n  auto.\n  destruct (n|n|n|n|n|n|n]; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H.\nunfold N.\napply le_0_r; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros.\ngeneralize (le_le_dec n); intros; apply lt_trans with N; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros H; apply Rmult_l.\napply Rmult_l with (0_l (/ n)%R_r); auto with real.\napply Rmult_l with real.\napply Rmult_0_l with real.\napply Rmult_0_l.\napply Rmult_l_r with real.\napply Rmult_r.\napply Rmult_l_l_l.\napply Rmult_l with (l (l).\napply Rmult_l with (l (r - 1)).\napply Rmult_l with (l with (l - 1).\napply Rmult_l with (r := Rabs_l.\napply Rmult_l; auto with (l (/ 2))).\nrewrite Rmult_l with (l.\napply Rinv_l with (l with (l (/ 2).\napply Rmult_l with (l := l); auto.\napply Rmult_l; auto with (l with (l := l).\napply Rmult_l with (l with (l := l).\napply Rmult_l with (l with (l (l := l)).\napply Rmult_l with (l := l).\napply Rmult_l with (l := l).\napply RmultQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros m m H.\napply Rplus_le_le_le_compat_r with (p := H).\napply Rplus_compat_l.\napply Rplus_compat_compat_compat_compat.\napply Rplus_le_compat_compat.\napply Rplus_compat.\napply Rplus_compat.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n n H.\napply Rplus_r; auto with real.\nintros H; apply Rplus_le_compat_le_le_le_compat; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros m H; unfold R_or in |- *; try apply Rinv_r; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros m H H2.\nunfold pred_succ in H1.\nrewrite H2.\nrewrite <- (Rmult_comm n)).\nrewrite <- Rplus_comm.\nrewrite <- Rmult_compat.\nrewrite <- Rmult_comm.\nrewrite Rmult_assoc.\nrewrite Rplus_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_0_assoc.\nrewrite Rmult_comm.\nrewrite Rmult_assoc.\nrewrite Rplus_comm.\nrewrite <- Rmult_comm.\nrewrite Rmult_comm.\nrewrite <- Rinv_l.\nrewrite Rmult_r.\napply Rinv_0_l.\nrewrite Rmult_r.\nrewrite Rmult_comm.\nrewrite Rmult_assoc.\nrewrite Rmult_l.\nrewrite Rmult_assoc.\nrewrite Rmult_l.\nrewrite Rmult_l.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite <- Rmult_r.\nrewrite Rmult_l; rewrite <- Rinv_l.\nrewrite Rmult_comm.\nrewrite Rmult_r.\nrewrite Rmult_le_comm.\nrewrite Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_distr_r.\nrewrite Rmult_Qed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros m p H1 H2 H2; intros; apply Rle_trans with (0_trans with (p * p * p)%R.\nrewrite Rmult_compat_r.\napply Rplus_le_compat_compat_compat_compat; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros m n n H; apply Rmult_l with (1).\napply Rmult_le_le_lt_compat; auto with real.\napply Rmult_l with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n; apply Rmult_compat_l.\napply Rmult_l with (2 := H0.\napply Rmult_r with (1 := H1 := H1).\napply Rmult_compat_l.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n H2 H1.\nintros n H1.\ngeneralize (n := H1); auto with zarith.\nintros n1 H2.\nreplace (m - n)%R with (m * m)%R with (m * m)%R with (n + n)%R with (m + m)%R with (m * m)%R with (m + n)%R with (m * m + m))%R with (m * m)%R.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H2.\napply (m := m + m)%R.\nrewrite <- H2.\napply (m * m)%R.\nrewrite <- (m * m)%R.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H1.\nrewrite <- H1; auto with zarith.\nrewrite <- (m * m)%R.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2; rewrite <- H2.\nrewrite <- H1.\napply (m := m)%R.\nrewrite <- (mQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n H1; apply Rmult_comm.\napply Rmult_compat_comm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m H1 H1; auto with real.\napply Rlt_lt_le_le_le.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n H2 H1 H1 H1 H2.\napply Rmult_l with (r := H1 := H2).\napply Rmult_le_l with (H1 := H2).\napply Rle_le_trans with (H1 := H2).\napply Rmult_le_le_le_compat.\napply Rle_trans with (p := H2 := H2 := H2 := H2).\napply Rle_trans with (H2).\napply Rlt_trans with (H1 := H2 := H2).\napply Rle_trans with (H1 := H2 := H2).\napply Rplus_l with (H2 := H2 := H2).\napply Rplus_reg_r.\napply Rmult_r with (H1 := H1 := H2).\napply Rle_le_le_trans with (H2 := H2 := H2 := H2).\napply Rle_trans with (H2 := H2 := H1).\napply Rplus_le_le_lt_trans with (H2 := H2 := H2 := H1 H2);\napply Rle_trans with (H2 := H1 := H2 :=Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros p H H1 H1 H2.\nreplace (0).\nrewrite <- H2.\nrewrite <- H1.\napply Rmult_l with (n := H2 * m)%R_r with (m * p))%R.\nrewrite <- H2.\napply Rmult_l with (r := H2 := H2).\napply Rmult_r with (m := H2).\napply Rmult_l.\napply Rmult_l.\nrewrite Rmult_l with (1 := H1 := H1 := H1).\napply Rlt_le_compat_le_lt_compat.\napply Rmult_compat_compat.\napply Rplus_compat_compat_compat_compat.\napply Rplus_compat_compat.\napply Rmult_compat_compat_compat.\napply Rmult_compat_compat_compat.\napply Rinv_compat_compat.\napply Rplus_compat_compat_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat.\napply Rmult_compat_compat.\napply Rmult_compat_compat.\napply Rplus_compat_compat_compat.\napply Rmult_compat_compat.\napply Rplus_compat.\napply Rplus_Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros H2; elim H2; intros; auto with real.\napply Rplus_le_le_compat; auto.\napply Rplus_0_le_le_le_compat; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros H1.\nintros H2 H2.\ncase H1; auto with real.\napply Rmult_l with real.\napply Rmult_l with real.\napply Rplus_lt_l with (1 := H1 := H2 := H2).\napply Rmult_le_l with real.\napply Rmult_compat_l with (l := H2 := H1 := H2.\napply Rinv_compat_l := H2 := H2 := H2.\napply Rle_compat_le.\napply Rle_0.\napply Rlt_trans with (r := H2 := H2 := H1).\napply Rlt_trans with (r := H2).\napply Rlt_trans with (r := H2 := H2 := H1).\napply Rmult_l with (r := H2 := H1 := H2).\napply Rlt_lt_trans with (r := H2).\napply Rle_trans with (r := H2).\napply Rlt_trans with (r := H2 := H2).\napply Rmult_compat_le_l := H1 := H2.\napply Rlt_trans with (r := H1 :=Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n n m n m m H1.\ncut (p <= p)%R; auto with real.\nintros n H2 H1; unfold R; apply Rmult_lt_le_compat; auto.\napply Rmult_compat_compat_compat; auto with real.\napply Rmult_compat_compat.\napply Rmult_compat_le_compat.\napply Rmult_le_compat_compat_compat.\napply Rmult_compat_compat_compat_compat; apply Rmult_compat; auto.\napply Rmult_compat_compat_le_compat_compat_compat.\napply Rmult_compat.\napply Rinv_compat; auto.\napply Rmult_compat_compat_compat_compat.\napply Rplus_compat_compat; auto.\napply Rinv_compat_compat_compat_compat.\napply Rmult_compat.\napply Rmult_compat_compat_compat_compat.\napply Rmult_compat_compat_compat_compat_compat; auto.\napply Rmult_compat_compat.\napply Rmult_compat_compat_compat; auto.\napply Rmult_compat_compat.\napply Rinv_compat_compat.\napply Rinv_compat_compat.\napplyQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros H1 H2 H1 H2; apply Rle_le_trans with (p := H1 := H1).\napply Rmult_l with (p := H2).\napply Rle_le_trans with (p := p H2).\napply Rle_trans with (p := H2).\napply Rlt_trans with (p := p1 := H1 := p2).\napply Rle_trans with (p1 := p1 := p2).\napply Rle_trans with (p := H1 := p1 := p2).\napply Rle_trans with (p1 := p2 := p1 := p2);\napply Rle_trans with (p := p2 := H1);\napply Rle_trans with (p := p2 := p2); [ apply Rle_trans with (p2 := p2 := H2).\napply Rle_trans with (p := p1 := p2 := p1 p2).\napply Rle_trans with (p2 := p1 := p2 := p2);\napply Rle_trans with (p1 := p2 := p2 := p1 := p2);\napply Rle_trans with (p2 := p1Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros m n m H1 H2.\nintros n m H2.\nunfold Rminus in H3.\napply Rplus_r with (le_r + m)%R_r := H3).\napply Rplus_0_l with (r := r + m)%R.\napply Rplus_l with (r + m)%R.\nrewrite Rplus_l with (r := r + r).\napply Rplus_l with (l := r).\napply Rplus_l with (r := r); auto.\napply Rplus_le_l with (r := r).\napply Rplus_l with (r := r)%R.\napply Rplus_l with (r := r)); auto with (r := r0_l := r); auto with real.\napply Rplus_l with real.\nrewrite Rplus_compat_l with real.\napply Rplus_l with real.\napply Rplus_0_l with (r := r).\napply Rplus_0_compat_compat_l with (r := r)); auto with real.\napply Rplus_compat_compat_compat_compat.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros m H0 H1 H2 H2 H2.\napply Rlt_le_le_trans with (m := H1).\napply Rle_trans with (m := H1 := H2).\napply Rle_trans with (m := (m := m); auto.\napply Rlt_trans with (m := m); auto with (m := m); auto with zarith.\napply Rlt_le_trans with zarith.\napply Rle_trans with (m := m := m)); auto with zarith.\napply Rle_trans with real.\napply Rle_trans with (m := m (m := m)%R; auto with zarith).\napply Rle_trans with zarith.\napply Rle_trans with zarith.\napply Rle_trans with (m := m); auto with zarith.\napply Rle_trans with (m := m); auto with zarith.\napply Rle_trans with (m := m); auto with zarith.\napply Rlt_trans with (m := m (m + m - m)%R_trans with (m + m)%R with (m - m)%R); auto with zarith.\napply Rlt_trans with (m := m)%R.\napply Rle_Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n H H; apply Rle_le_trans with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros H1 H1.\napply Rmult_l with real.\napply Rmult_lt_l with real.\napply Rmult_l with (p * m)%R.\napply Rmult_l with (m * m)%R.\napply Rmult_l with (m * m)%R.\napply Rmult_0_l with (p * m)%R with (p * m)%R with (m * m)%R with (n * m)%R.\napply Rmult_l with (m * m)%R.\napply Rmult_r.\napply Rmult_le_l with (m * m)%R.\napply Rmult_l with (m * m)%R.\napply Rmult_compat_l; auto with (m * m)%R.\napply Rmult_compat_compat_r with (m * m)%R.\napply Rmult_compat_compat_compat_l.\napply Rmult_compat_compat_compat_compat.\napply Rmult_compat_compat_compat_compat.\napply Rmult_compat_compat.\napply Rmult_compat.\napply Rmult_compat_compat_compat_compat.\napply Rmult_compat_compat_compat_Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m.\nintros n H H1 H1 H2.\napply Rle_trans with (lt_trans with (0 < n)%R_trans with (p + n)%R.\napply Rle_trans with (n + m)%R.\napply Rle_trans with (p := (p + n)%R.\napply Rle_trans with (p - p)%R.\napply Rle_trans with (0 * m)%R.\napply Rle_trans with (p := (p * p)%R.\napply Rlt_trans with (p * p))%R.\napply Rmult_l with (p := p)%R.\napply Rmult_l with (p * p)%R.\napply Rlt_compat_le_le_l := p)%R.\napply Rlt_compat_le.\napply Rlt_trans with (p * p)%R.\napply Rlt_trans with (p * p)%R).\napply Rle_trans with (p * p)%R.\napply Rlt_trans with (p := p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n; apply Rmult_r with real.\napply Rmult_r with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n H; auto with real.\nunfold powerRZ_l with real.\napply Rmult_distr_compat_r with real.\napply Rmult_l with real.\napply Rmult_compat_compat_r with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros H1 H1; elim H2.\napply Rmult_l with (q + p).\napply Rmult_l.\napply Rmult_l with (p * q)%R.\napply Rmult_l with (r := p).\napply Rmult_l with (r := H0_le_l := p).\napply Rmult_l.\napply Rmult_l.\napply Rmult_l.\nnow apply Rmult_l with (0_r_r := q).\napply Rmult_l with (r := Rmult_l).\napply Rinv_l with (l := H).\nnow apply Rmult_r.\napply Rmult_r.\napply Rmult_l.\nnow apply Rmult_l with (r_l := H);\napply Rmult_l with (r := H).\napply Rmult_r.\napply Rinv_l with (r := bpow_l).\napply Rmult_compat_r.\napply Rinv_l.\nnow apply Rmult_le_r.\nnow apply Rinv_l.\nnow apply Rinv_0_0_1.\nnow apply Rmult_r.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros H1 H2.\napply Rle_le_trans with (p := H2).\napply Rle_trans with (p * m)%R.\napply Rle_trans with (p * p)%R.\napply Rlt_trans with (p * p)%R.\napply Rplus_trans with (p * p * p))%R.\napply Rle_trans with (p * p))%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * q)%R.\napply Rle_trans with (p * q * p)%R.\napply Rle_trans with (p * p * p)%R.\napply Rle_trans with (p * q)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rlt_trans with (p * p)%R.\napply Rle_trans with (p + q)%R.\napply Rle_trans with (p * p)%R.\napply Rle_transQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros p H0 H0; apply H0.\napply Rmult_l.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n H1 H1.\napply Rmult_l with real.\nintros n H1.\napply Rmult_l with (0_lt_l (r (- n)%R; auto with real.\napply Rmult_r with (2).\napply Rmult_compat_l with (r := p)%R.\napply Rmult_r; apply Rmult_l with (r := H0_r := H2 := H1.\napply Rmult_r.\napply Rmult_l with (r := H1 := H1 := H1).\napply Rmult_r with (r := H2 := H2 := H2).\napply Rmult_r.\napply Rmult_r.\napply Rmult_l with (r := (r := H1 := H2).\napply Rmult_l with (r := H1 := H2 := H2).\napply Rmult_r.\napply Rinv_l.\napply Rinv_r; apply Rmult_l.\napply Rplus_l.\napply Rmult_l with (l with (r := H1 := H1 := H1 := H2.\napply Rmult_l := H2 := H1.\napply Rplus_Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m.\nintros n H1 H2 H1 H2.\nreplace (p + n)%R with (p + m)%R with (p + p)%R with (p + p)%R with (p - p)%R with (p - p)%R with (p + p)%R with (p + p)%R with (p + p)%R.\napply Rmult_lt_l with (p * p)%R with (p + p)%R; auto with zarith).\napply Rplus_l with (p * p))%R_compat_compat_compat; auto with zarith.\napply Rmult_compat_compat_compat_compat_compat_compat_compat_compat_compat; auto with real.\napply Rle_compat_compat; auto with real.\napply Rlt_le_compat; auto.\napply Rlt_compat_compat_compat_le_le_compat; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros H1.\napply Rle_le_trans with (r := H2 := H1).\napply Rplus_compat_l with (1 := H2).\napply Rmult_r.\napply Rmult_compat.\napply Rplus_compat_compat_r.\napply Rplus_lt_compat_l.\napply Rplus_compat_l_compat_compat_compat.\napply Rmult_compat.\napply Rmult_lt_compat; apply Rmult_compat_compat_l.\napply Rmult_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat_lt_compat_compat.\napply Rplus_le_compat.\napply Rplus_compat_compat.\napply Rplus_le_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat.\napply Rplus_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat_compat.\napply Rplus_compat_compat_compat_compat.\napply Rplus_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat.\napply Rplus_compat.\napply Rplus_compat_compat_compat.\napply Rplus_compat.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n.\nrewrite Rmult_l_r.\napply Rmult_r.\nrewrite Rmult_compat_l_l.\napply Rmult_r.\napply Rmult_r with (r.\napply Rmult_l_r; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros H2.\nunfold Rminus in H2.\napply Rlt_trans with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n H1 H1.\ncase (H1 := H2 := H1.\ncase (H1 := H2 := H2).\napply Rlt_le_trans with (p := H2).\napply (r := H2).\napply Rle_trans with (p := H2).\napply Rle_trans with (p := H2).\napply Rlt_trans with (p := p).\napply Rlt_trans with (p := H2 := H2 := p1).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := H2 := H2).\napply Rle_trans with (p := p).\napply Rle_trans with (p := p2 := H2 := H1 := H1.\napply Rle_trans with (p := p1 := H2 := H1 := H2 := H1);Qed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n H1; elim H1; auto with real.\napply Rplus_compat_le_lt_compat; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros p p H1.\napply Rle_le_trans with (p * p)%R.\napply Rplus_lt_lt_l with (p * p))%R with (p * p)%R.\napply Rle_trans with (p * q)%R.\napply Rle_trans with (p * p * p)%R.\napply Rle_trans with (p * q)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p * p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * q))%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R with (p * p)%R); auto with (p * p)%R; auto.\napply Rle_trans with (p * p * p) * p)%R); auto with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_transQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros H H; elim H1; intros H1; apply Rmult_l with (lt_l_compat_lt_lt_lt_compat_compat_lt_lt_l _ _ H2).\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros H1 H2 H1 H2.\napply Rmult_compat_r; auto.\napply Rplus_r with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros H1 H1 H1.\napply Rle_trans with (H1 := H2 := H2); auto.\napply Rle_trans with (H2 := H2 := H2 := H2); auto with real.\napply Rle_trans with (H2 := H2 := H2 := H2 := H2); auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n H2; apply Rle_trans with real.\napply Rle_trans with (q + n)%R; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n H2 H2 H2.\nassert (p < m < n)%R.\napply Rmult_l with (2 * p)%R; auto with (p * p)%R.\napply Rmult_l with (0 * p)%R; auto with (p * p)%R.\napply Rmult_r with (p * p)%R.\napply Rmult_l.\napply Rmult_l with (p * p)%R.\napply Rmult_l; auto with (p * p * q)%R.\napply Rmult_l with (p * p * p)%R.\nrewrite Rmult_l with (p * p)%R.\napply Rmult_l with (p * q)%R.\napply Rmult_l with (p * p)%R.\napply Rmult_le_le_l with (p * p)%R with (p * p * p)%R.\napply Rmult_l with (p * p)%R.\napply Rmult_l with (p * q)%R.\napply Rmult_l with (p * p))%R.\napply Rmult_l.\nnow apply Rmult_l with (p * p)%R *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros; case (Rle_or_or_or_or_or_or_or_or_or_or_or_or_or_or _ _ _ _ _ _ _ _ _ _ H1 H2 H2).\napply Rmult_not_or_lt_r with (r := H2).\napply Rle_lt_not_l with (r := H2); auto with real.\napply Rle_trans with (r := H2 := H1 := H1).\napply Rle_trans with (r := H2); auto with real.\napply Rle_trans with (r := H2 := H2); auto with real.\napply Rle_trans with (r := H1 := H1 := H2); auto with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with (r := H2 := H2 := H1 := H2); auto.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with (1 := RQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros m H1 H2 H2.\nunfold Z2; auto with real.\napply Rplus_lt_r; auto with real.\napply Rplus_lt_compat_0_compat; auto with real.\napply Rplus_l with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n; auto.\nunfold n; elim H; intros; auto with real.\nintros H2; apply Rmult_l with real.\nrewrite Rmult_r with real.\napply Rplus_l with real.\napply Rplus_l with real.\napply Rplus_lt_r with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n H1; apply Rlt_trans with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros m H1 H1.\nintros p2 H2.\napply Rlt_le_trans with (p := H1 := H1 := H1).\nrewrite H1.\napply Rle_trans with (p * p).\napply Rle_trans with (p * p)).\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p).\napply Rlt_trans with (p * p + p)%R.\napply Rle_trans with (p + p)%R.\napply Rle_trans with (p + p)%R.\napply Rle_trans with (p + p)%R with (p + p)%R.\napply Rlt_trans with (p + q)%R.\napply Rle_trans with (p + p)%R.\napply Rle_trans with (p + p)%R.\napply Rle_trans with (p + q)%R.\napply Rle_trans with (p + p))%R.\napply Rle_trans with (p + p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p + p)%R.\napplyQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m H; elim H; apply Rmult_l with real.\napply Rmult_le_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros H; case H1; auto with real.\ncase (p := H1_lt_not_lt_not_le_lt_lt_trans with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros m H2.\napply Rmult_r with real.\napply Rmult_lt_l with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n H.\ncase (p := H1 := H1); auto with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with (p := H2 := H2 := H2).\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napplyQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros m H H0 H1; apply Rmult_compat_l with real.\napply Rmult_le_lt_compat_compat_compat_compat_compat; auto with real.\napply Rle_compat_compat; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n H H0 H0 H1.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_le_trans with (p - p)%R; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros m n H1 H1 H2 H1; apply Rmult_r.\napply Rle_compat_r with (H2 := H1 := H2 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply H2.\napply Rle_trans with (H2 := H1 := H1).\napply Rle_trans with (H2 := H2 := H2).\napply Rle_trans with (H1 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply Rle_trans with (H1 := H2 := H2).\napply Rle_trans with (H1 := H1 := H2).\napply Rle_trans with (H1 := H1 := H2).\napply Rlt_trans with (H2 := H1 := H2).\napply Rle_trans with (H1 := H2 := H2).\napply Rle_trans with (H1 := H2 := H2 := H2).\napply Rle_trans with (H2).\napply Rle_trans with (H2 := H1 := H2).\napply Rle_trans with (Qed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros p.\napply Rplus_l; auto.\napply Rle_trans with real.\napply Rplus_l.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n n.\nunfold Rminus.\napply Rplus_l; auto with real.\napply Rmult_r.\napply Rmult_l with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros p H2 H1 H2; apply Rle_trans with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros.\napply Rmult_l.\napply Rmult_r.\napply Rle_le_r.\napply Rle_compat_trans with (p * n)%R.\napply Rle_compat_trans with (n * m * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * m)%R.\napply Rle_trans with (p * p).\napply Rle_trans with (p * p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p * q)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * q)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * q))%R.\napply Rle_trans with (p * p)%R.\napply Rle_trans with (p * p * q)%R.\napply Rle_trans with (p * p)%R with (p * q)%R)%R; [apply RleQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n H1 H2; auto with real.\napply Rmult_r with real.\napply Rmult_l with real.\napply Rmult_l with (l := r)%R.\napply Rmult_r with real.\napply Rinv_l with (2 := H1 := H); auto with real.\napply Rinv_l with real.\napply Rplus_l with real.\napply Rplus_compat_compat_l with real.\napply Rplus_l with real.\napply Rplus_lt_compat_le_l with real.\napply Rplus_le_compat_l with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros p; elim H2; intros; rewrite Rplus_r; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n H0 H0.\ncase (H1 := H0).\napply Rmult_l with (le_lt_r := H1).\napply Rmult_l with (1 := H1_l := H1).\napply Rle_l.\napply Rmult_compat_l with (r := H2 := H1).\napply Rmult_l_r.\napply Rplus_l.\nnow apply Rplus_le_compat_l.\napply Rmult_l.\napply Rmult_l.\napply Rlt_l.\napply Rmult_l with (l := H1 := H2.\napply Rmult_l.\napply Rmult_l.\nnow apply bpow_l.\napply Rmult_r.\nnow apply Rmult_l.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros m H2 H2.\nrewrite <- H2.\nintros H2.\napply Rlt_trans with (1 := H2).\napply Rplus_le_l.\napply Rplus_l.\napply Rle_l with (m := H2 := H2).\napply Rplus_le_le_l with (0_lt_compat_le_compat_compat_compat.\napply Rmult_compat.\napply Rlt_compat_compat.\napply Rmult_l.\napply Rlt_compat_le_compat.\napply Rlt_compat_compat_compat.\napply Rlt_compat_le.\napply Rlt_compat.\napply Rlt_compat_compat_compat.\napply Rlt_compat_le.\nnow apply Rlt_trans with (m := H).\napply Rlt_compat.\napply Rlt_compat_compat.\napply Rlt_compat.\napply Rlt_compat_lt_compat.\napply Rlt_lt_compat_le.\napply Rlt_compat.\napply Rlt_trans with (1 := H1 := r).\nnow apply Rlt_compat_le.\nnow apply Rle_le_le_compat_le.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n H.\napply Rle_trans with (n := H).\napply Rle_trans with (0 <= p).\napply Rlt_trans with (n := H).\napply Rle_trans with (n := H).\napply Rle_trans with (n := H0 := H).\napply Rplus_r.\napply Rle_trans with (0_trans with (n := H1 := H1 := H2).\napply Rle_trans with (m := H2 := H1 := H2).\napply Rle_trans with (m := H2.\napply Rle_trans with (n := H2 := H2).\napply Rle_trans with (m := H2 := H2).\napply Rle_trans with (m := H2 := H2).\napply Rle_trans with (m := (m := H2 := H2).\napply Rle_trans with (m := H2 := H2 := H2 := H2).\napply Rle_trans with (m := H1 := H2).\napply Rle_trans with (m := H2 := H2 := H2).\napply Rle_trans with (m := m).\napply RleQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros p n H.\nrewrite H1.\napply Rle_trans with (p := H1 := H1_trans with (p * p)%R_trans with (p * p)%R.\napply (p * p)%R.\nrewrite <- H2 := H2.\napply H2.\napply Rmult_l with (p := p).\napply Rlt_le_l with (p := p)).\napply Rlt_le_trans with (p := H2).\nrewrite H2.\napply Rlt_trans with (p := p).\napply Rle_trans with (p := p); auto with (p := H2 := p).\napply Rmult_trans with (p := p H2 := p2 := H2).\napply Rlt_trans with (p := p2 := p2).\napply H1.\napply Rle_trans with (p := p).\napply Rle_trans with (p := p1 := p1 := p2).\napply Rle_trans with (p := p1 p2).\napply Rle_trans with (p := p1 := p1).\napply Rlt_trans with (p := p1 := H2Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n H2.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros H1 H1 H1.\nassert (n <= n)%R.\nunfold Rdiv; rewrite H2 := H1.\napply Rmult_l with (1 := H1 := H2).\napply Rmult_0_l.\napply Rmult_l.\napply Rmult_r.\napply Rmult_l with (Z.\napply Rmult_r with (le_r (2 := (r - p)%R.\napply Rmult_r := H1 := H2).\napply Rmult_l with (r := H1 := H2).\nrewrite <- Rmult_l.\napply Rmult_l.\napply Rmult_r with (r := H2 := H2 := H1).\napply Rmult_r := H1.\napply Rmult_le_r.\napply Rmult_compat_l.\nnow apply Rmult_r; assumption.\napply Rmult_l with (r := H1 := H2).\napply Rmult_r.\napply Rinv_r.\napply Rmult_le_compat_compat.\napply Rmult_compat_compat_compat_compat; assumption.\napply Rinv_compat_compat_compat_compat.\napply Rmult_compatQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n H2; elim H2.\nintros H2.\napply Rlt_le_trans with real.\napply Rlt_le_trans with (2 := H2).\napply Rle_trans with (n := H2 := H2).\napply Rlt_trans with (le_trans with (0 := H2).\napply Rle_trans with (n := H2 := H2).\napply Rlt_trans with (n := H2 := H2).\napply Rlt_trans with (0 := H2).\napply Rle_trans with (m := H2 := H2).\napply Rlt_trans with (n := H2 := H1.\napply Rle_trans with (m := H2 := H2).\napply Rle_trans with (m := H2 := H2).\napply Rle_trans with (m := H2 := H2 := H1).\napply Rle_trans with (m := H1 := H2).\napply Rle_trans with (m := H2 := H1).\napply Rle_trans with (m := H2 := H2 := H2).\napply Rle_trans with (m := m).\napply RleQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n H0 H0 H1; apply H1.\nrewrite Rmult_l.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n H1 H2; elim H1; intros H1; elim H2; rewrite H1.\napply Rle_trans with (H1 := H1).\napply Rle_trans with (H2 := H2).\nrewrite H1.\napply Rle_trans with (H2 := H1 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply Rle_trans with (H1 := H1).\napply Rle_trans with (H1 := H2).\napply Rle_trans with (H1 := H2 := H1 := H1).\napply Rle_trans with (H1 := H2).\napply Rle_trans with (H2 := H2 := H2 := H2).\napply Rle_trans with (H2 := H2).\napply Rle_trans with (H2 := H2 := H2 := H2 := H2).\napply Rle_trans with (H1 := H2 := H2).\napply Rle_trans with (H2 := H2 := H1).\napply Rle_trans with (H2 := H2 := H2 := H2 := H2).Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros H0 H0 H1 H1 H2 H1; auto with real.\napply Rmult_r with real.\napply Rlt_0.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros m H1 H1 H2 H2.\napply Rmult_l with (1 := H2).\napply Rmult_l with (n := H2).\napply Rinv_l with (1 := H1).\napply Rmult_l with (0_l := H1).\napply Rplus_r with (l := H1 := H1 := H1.\napply Rplus_l := H1).\napply Rplus_l.\napply Rmult_l.\napply Rinv_l.\napply Rmult_l with (l := H2 := l); auto with (l := H2 := H2).\napply Rmult_l with (l := H2).\napply Rplus_l with (l := l1 := l2 := H2); auto.\napply Rplus_compat_compat.\napply Rmult_l.\napply Rplus_l with (l := l1 := l1 := l2 := l2).\napply Rmult_l with (l := l2 := l1).\napply Rmult_l; auto.\napply Rmult_compat_l.\nnow apply Rinv_compat_compat_l.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros H H0.\napply Rinv_r with real.\napply Rmult_l with real.\napply Rmult_compat_l with real.\napply Rmult_l with (le_compat_r := l)).\napply Rmult_l.\napply Rplus_r; apply Rplus_l.\napply Rplus_l.\napply Rplus_l with (l := H).\napply Rplus_l with (r := H0_l := H0.\napply Rplus_l with (l := H1 := H0).\napply Rplus_l.\napply Rmult_l with (l := H0_r := H0).\napply Rmult_l with (l := H0).\napply Rplus_l.\napply Rplus_l with (l := H0.\napply Rplus_l.\napply Rplus_l.\napply Rplus_l with (l := l0).\napply Rplus_l.\napply Rplus_l with (l := l).\napply Rplus_r with (l := l)).\napply Rplus_compat_r with (l with (l := l)).\napply Rplus_l with (l := l).\napply Rplus_l.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros H1 H1 H1 H1 H2; apply Rle_trans with (m := H1 := H2).\nnow apply Rle_trans with (m := H2 := H2).\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n H0 H1 H2 H1 H2.\nintros n H2; case H2; case (Rle_or_lt_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or.\napply Rmult_or_or_l.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n.\nunfold R_r; rewrite Rmult_r.\napply Rmult_r.\napply Rplus_r with (l := H).\napply Rmult_l.\napply Rmult_l.\napply Rplus_0_l.\napply Rmult_r with (reg_l_r := H0_l := H).\napply Rplus_l.\napply Rmult_l.\napply Rmult_l.\napply Rplus_l.\napply Rinv_l.\napply Rlt_r.\napply Rplus_le_l with (l := l).\napply Rplus_l.\napply Rlt_l with (r := l).\napply Rplus_l.\napply Rle_l.\napply Rplus_compat_le_l.\napply Rmult_l.\napply Rmult_l.\nnow apply Rlt_r.\napply Rlt_0_l.\napply Rlt_0_trans with (l := H).\napply Rlt_l.\napply Rplus_l.\nnow apply Rlt_le_le.\napply Rlt_trans with (l := l).\napply Rlt_trans with (r := H); [apply Rle_trans with (l; applyQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros m H2; elim H; apply Rmult_l.\napply Rmult_r with (0_l := H0_r := H).\napply Rmult_l.\napply Rmult_l.\napply Rmult_r with (r_l (p <= p)%R.\napply Rmult_l with (r := r); auto.\napply Rmult_l with (r := p); auto with real.\napply Rmult_compat_l with real.\napply Rmult_l with (r := H); auto with real.\napply Rmult_compat_l with real.\napply Rmult_r with real.\napply Rmult_le_0_r with real.\napply Rmult_l with real.\napply Rmult_l.\napply Rmult_0_r.\napply Rmult_l with real.\napply Rmult_l with real.\napply Rmult_r with real.\napply Rlt_lt_l with real.\napply Rmult_r.\napply Rmult_l.\napply Rmult_compat_r.\napply Rmult_l with real.\napply Rmult_l with real.\napply Rmult_l with real.\napply Rplus_l with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros H; elim H1; intros.\nunfold lt_r with (H2:=H1 := H2).\napply lt_lt_r with (H2:=H2).\napply Rle_trans with (H1:=H2).\napply Rlt_trans with (H2:=H1:=H2).\napply H1).\napply H1.\napply Rplus_r with (H1).\napply Rle_trans with (H2:=H2).\napply Rlt_trans with (H2).\napply Rle_trans with (H2).\napply Rle_trans with (H1 := H2:=H2).\napply H1.\napply Rle_trans with (H2).\napply Rle_trans with (H1 := H2:=H1).\napply Rle_trans with (H2:=H2:=H1).\napply Rle_trans with (H1:=H1).\napply Rle_trans with (H2:=H1:=H2).\napply Rle_trans with (H2); auto with (H2).\napply Rle_trans with (H2:=H2:=H2).\napply H2:=HQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros H1 H1.\napply Rplus_r with (p := H2 := H2).\napply Rplus_r with (0).\napply Rplus_l.\napply Rmult_l.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros H1 H1; apply Rmult_l; apply Rplus_l with (r := H2 := H1); auto.\napply Rmult_l.\napply Rmult_l.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n n H H H1 H2; apply Rmult_l; auto.\napply Rmult_l; auto.\napply Rmult_l; auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n H.\napply Rplus_comm.\napply Rmult_r with (lt_r := H).\napply Rplus_l with (0_l := r)).\napply Rplus_r with (l.\napply Rplus_l with (r := H)).\napply Rplus_l.\napply Rplus_l with (r := H.\napply Rplus_l.\napply Rplus_le_l with (r := H).\nnow apply Rplus_l.\napply Rplus_l with (r := H.\napply Rplus_l := H).\napply Rplus_r.\napply Rplus_l.\napply Rplus_lt_l.\nnow apply Rplus_l.\napply Rplus_le_compat_compat_l.\napply Rplus_l.\napply Rplus_l.\napply Rplus_0_l with (r := H).\napply Rplus_l.\napply Rplus_r.\nnow apply Rplus_l.\napply Rplus_l.\napply Rplus_l with (l := H).\napply Rplus_l with (l := H).\napply Rplus_l with (l := H).\nnow apply Rplus_l with (l with (lQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros.\napply Rplus_r.\napply Rplus_r with real.\napply Rmult_r with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros m n H H; apply (H0_r := H).\napply Rmult_l with (r_r := H).\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros H1 H1 H2 H2; elim H2.\nintros H2; elim H1; intros H1; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros m H1 H2; apply Rlt_le_l with (x := H1 := H1).\napply Rmult_r with (x := x).\nnow apply Rplus_l with (x := H1 := H1).\napply Rmult_r.\napply Rmult_l with (x := H1 := H1).\napply Rmult_r.\napply Rmult_l.\napply Rmult_r.\nrewrite Rmult_r.\napply Rmult_l.\napply Rmult_l.\napply Rmult_r.\napply Rmult_l.\napply Rmult_compat_l.\napply Rmult_l.\napply Rmult_l.\napply Rmult_l.\napply Rmult_l.\napply Rmult_r.\napply Rmult_r.\napply Rmult_le_l.\napply Rmult_l.\napply Rmult_l.\napply Rmult_l.\napply Rmult_r.\napply Rmult_l with (r.\napply bpow_r.\napply Rmult_l.\napply Rmult_l.\napply Rinv_l.\napply Rmult_l.\napply Rmult_l with (r := (/ 2)).\napply Rmult_le_Qed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nunfold lt_lt; auto with real.\nunfold lt_or; unfold lt, lt; simpl; simpl; auto with real.\napply lt_r with real.\napply lt_r with real.\napply lt_r with real.\napply lt_trans with real.\napply lt_r with real.\napply lt_r with real.\napply le_trans with real.\napply le_r with real.\napply le_r with real.\napply le_r with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_l with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_trans with real.\napply le_transQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros n H.\ncase (Z.\nintros x; red; red; red; red; red; red; red; red; red; intros.\nleft; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red; red;Qed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros n H H0 H0.\ncase (0_l := H0); auto with real.\nunfold lt_or in H0; auto with real.\napply Rlt_lt_lt_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_transQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros n H1 H2.\ncase (m := H1.\napply le_r; auto with real.\napply le_antisym; auto.\napply le_r with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nunfold eq_sym; elim H.\nunfold eq, lt_trans with (z <= z); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x H1 H1 H1; elim H1; intros H1.\ncut (x <= z)%R; auto with real.\napply le_l with (x < y)%R.\napply le_r with real.\napply le_r with (x < x)%R; auto with real.\napply le_r with real.\napply le_trans with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros.\nreplace (p * x)%R with (q - z)%R with (q + z)%R.\napply Rle_lt_lt_trans with (p * z)%R.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros n H; apply Rle_trans with (x < z).\napply Rlt_trans with (x < z)%R.\napply Rlt_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * y) * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rlt_trans with (x * z)%R.\napply Rle_trans with (x * z)%R with (x * z)%R; apply Rlt_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R.\napply Rle_trans with (x * z)%R).\napply Rle_trans with (xQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros H.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros n H; simpl; intros; rewrite <- (le_trans with (2 * y)%R_r1 * y)%R.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros.\nelim H1; intros.\napply H1.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x H0 H0; auto with real.\napply Rmult_r with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x H; elim H; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x H H.\nunfold eq_eq in H.\napply lt_dec; auto.\napply lt_le_trans with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x H; red; red; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x H0.\nintros H1.\nunfold eq_trans with (H1 := H2).\napply H2.\napply (H1 := H1).\napply H2.\napply Rlt_trans with (H2 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply H2.\napply Rle_trans with (H2).\napply Rle_trans with (H2 := H2).\napply Rle_trans with (H2 := H1).\napply Rle_trans with (H2 := H2 := H2 := H2.\napply H2).\napply Rle_trans with (H2 := H2).\napply Rle_trans with (H1 := H2).\napply Rle_trans with (H2 := H2 := H1 := H2.\napply Rle_trans with (H2 := H2).\napply Rle_trans with (H2 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply Rle_trans with (H2 := H2 := H2).\napply Rle_trans with (H2 := H2 :=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros z H0.\napply eq_refl.\napply eq_refl.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros H; elim H1.\nintros x y H2; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros.\nintros x H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros.\napply Rle_le_trans with (0_trans with (x <= z).\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (y > z).\napply Rle_trans with (x <= z))%R_trans with (x <= z)%R.\napply Rle_trans with (y > 0).\napply Rle_trans with (y <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x < z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rlt_trans with (x <= z)%R.\napply Rle_trans with (x <= y)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R.\napply Rle_trans with (x <= z)%R; auto with (x <= zQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y H1 H1.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros H; intros H; apply le_sym; apply le_l with (r_trans with (y + z); auto with zarith.\napply le_trans with (x <= y); auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros.\napply lt_le_lt_lt_r with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x H.\ncase (lt_gt_lt_lt_trans with (x > z); auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros H; red; unfold lt in H; auto.\nintros; intros H1; apply lt_trans with (Rle_dec z); auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y; rewrite <- H1.\napply le_l.\napply le_r with (x * y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y H0.\ndestruct H0 as [H0].\nrewrite (H0).\nrewrite <- H0_l with (lt_lt_trans with (y + z + z)%R_lt_lt_lt_compat_r_trans with (y + z) (y + z))%R.\nrewrite <- H0_compat_lt_trans with (y + z).\napply Rlt_trans with (x + z - z)%R_trans with (y + z)%R.\napply Rlt_le_trans with (y - z + z + z - z - z)%R.\napply Rlt_trans with (x + z + z + z))%R.\napply Rle_trans with (x + z - z + z)%R.\napply Rle_trans with (x + z)%R.\nnow rewrite Rplus_compat_trans with z).\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros z H.\nunfold R in H; rewrite H.\napply Rle_trans with (Rlt_trans with (x <= z).\napply Rle_trans with (x <= z).\nrewrite <- (y > z).\napply Rle_trans with (x + z)).\napply Rle_trans with (x + z)).\napply Rle_trans with (x + z)).\napply Rle_trans with (x - z).\napply Rle_trans with (x + z)).\napply Rle_trans with (x + z - z + z)).\napply Rle_trans with (x + z + z).\napply Rle_trans with z + z).\napply Rle_trans with (x + z).\napply Rle_trans with z); auto with z.\napply Rle_trans with (x + z).\napply Rle_trans with z).\napply Rle_trans with z; auto with z).\napply Rle_trans with (x + z).\napply Rle_trans with z).\napply Rle_trans with z).\napply Rle_trans with z; auto with z; auto with z; auto.\napply Rlt_trans with z.\napply Rle_Qed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x H.\ncase (x > z).\nunfold eq_dec in H.\ncase (y > z).\nnow apply Rle_lt_trans with (x >= z).\napply Rle_trans with (x := x)).\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros z H; rewrite <- H0_eq_trans with (y < z).\nrewrite <- H0_r.\napply Rle_trans with (x > z)).\napply Rle_trans with (x > y).\nrewrite <- H0.\napply Rlt_trans with (x > z)); auto with (x <= z); auto with zarith.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x H.\ndestruct (Rle_lt_eq_dec z).\nnow apply Rle_trans with (x := H).\napply Rle_trans with (x > z).\napply Rle_trans with (x := H).\napply Rle_trans with (x := H); auto.\napply Rlt_trans with (x := H).\napply Rle_trans with (x > y).\napply Rlt_trans with (x > y).\napply Rlt_trans with (x > y).\napply Rle_trans with (x > z).\nnow apply Rle_trans with (x > 0).\nrewrite Rmult_lt_trans with (x > 0).\napply Rle_trans with (x - y)).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x > 0).\napply Rle_trans with (x - xQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x H.\napply eq_sym with (Rlt_trans with (x * y).\napply le_trans with (x * z)).\nrewrite <- le_trans with (x * z).\napply le_trans with (x * z) with (x * y).\napply le_trans with (x * z) * z).\napply le_trans with (x * z).\napply le_trans with (x * z)).\napply le_trans with (x * z * z) * z).\napply le_trans with (x * z)).\napply le_trans with (x * z * z).\napply le_trans with (x * z * z * z) * z)).\napply le_trans with z).\napply le_trans with (x * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * z * zQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros; elim H.\nunfold eq, H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x H.\nelim H.\nintros.\nrewrite H.\nnow apply Rlt_le_le_trans with (x > y).\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros z H0 H0.\napply H0_reg_l with (y := H0).\napply H0.\napply Rplus_r with (x < z).\napply Rplus_l with (x < z).\napply Rplus_l.\napply Rplus_le_l.\napply Rplus_l.\napply Rplus_l with (x <= z)%R.\napply Rplus_l.\napply Rplus_l with (y < z)%R.\napply Rplus_l with (x <= z)%R.\napply Rplus_r with (x <= z)%R.\nnow apply Rplus_r with z)%R.\napply Rplus_l with (x <= z)%R.\napply Rplus_compat_compat_l with (x)%R.\napply Rplus_l with (x <= z)%R.\napply Rplus_lt_l with (x < z)%R.\napply Rplus_lt_compat_0.\napply Rplus_compat_l with (r := x).\nnow apply Rplus_compat_compat_compat.\napply Rplus_compat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros z H; elim H0.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y H.\nrewrite (x > y H).\napply Rlt_trans with (y > y); auto with real.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros z H.\napply Rle_trans with (x <= z H).\napply Rle_trans with (x <= z); auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y H.\nrewrite <- H_r.\napply eq_sym; auto.\napply (r x) with (x <= z); auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros z H; apply eq_trans with (z_trans with (x > z); auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros; apply eq_dec_dec_dec.\nintros x H; auto.\nunfold lt in H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x H.\nrewrite <- H0_lt_trans with (x * z).\nnow rewrite <- (Rmult_comm z).\napply Rmult_comm.\napply Rmult_l.\napply Rmult_comm.\napply Rinv_l with (Rmult_comm x).\napply Rmult_lt_r.\napply Rmult_l with (Rmult_l.\napply Rmult_comm.\napply Rmult_comm.\napply Rmult_comm.\napply Rmult_assoc.\napply Rinv_l with (Rmult_comm x y) with (r (/ y) (x + z) * y)%R.\napply Rmult_l.\napply Rmult_l with (x * y)%R.\napply Rmult_r with (x * y)%R.\napply Rmult_comm.\napply Rmult_comm.\napply Rmult_r.\napply Rinv_l.\napply Rmult_r.\napply Rmult_l.\napply Rmult_l with (x * y)%R.\napply Rmult_r.\napply Rmult_l with (x * y)%R.\napply Rmult_l with (x * y)%R.\napply Rmult_l.\napplyQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x H.\nrewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x H; rewrite <- H; auto with zarith.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros z H.\ncase (x <= z).\nrewrite <- H0_r.\nrewrite <- (Rplus_comm _ H0_assoc _ H).\napply Rle_trans with (Ropp_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros.\nunfold plus_l.\nrewrite plus_r in |- *.\nrewrite plus_l.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nunfold plus_l.\nunfold plus_l in |- *.\nintros.\nunfold plus_l in |- *.\nunfold plus_r.\nsimpl in |- *.\nintros.\napply plus_l.\napply plus_l.\napply plus_r.\napply plus_r.\napply plus_l.\nleft.\napply plus_r.\napply plus_l with (n + n) in |- *.\napply plus_l (n + n + n + n + n + n + n + n + m + n + n + n + m + n + n + n + n + m + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + n + nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\n  intros.\n  apply plus_comm; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros.\nrepeat split; auto.\nintros b; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros; red; auto with typeclass_instances.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros; elim H; intros.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\n  intros; auto.\n  repeat split; auto.\n  repeat rewrite plus_comm; auto.\n  repeat rewrite plus_comm; auto.\n  repeat rewrite plus_comm; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros.\napply plus_r.\napply plus_r.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros.\ngeneralize (a := nat_eq_eq_r a).\nintros a b c d.\ncase (a := b) in |- *.\nrewrite plus_l.\napply plus_r; auto with arith.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros; case (Z.\nnow apply plus_l with arith.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\n  intros; elim H; elim H; intros; intros; elim H; elim H; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros.\nunfold plus_le_compat.\napply plus_compat.\napply plus_compat; auto with arith.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros.\nelim H.\napply plus_l; assumption.\napply plus_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n.\nintros.\ncase (H1 := H2).\napply plus_compat_l.\napply plus_comm.\napply plus_assoc.\napply plus_l with (r := (m := H0)).\napply plus_l with (m := (m := m)).\napply plus_assoc.\napply plus_l.\napply plus_l with (m := m); auto.\napply plus_r := H.\napply plus_assoc.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l with (m := m) in H.\napply plus_l with (m := plus_r := plus_l := m); auto.\napply plus_l.\napply plus_l with (m := plus_l := plus_l := plus_l.\napply plus_l := plus_l := plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\napply plus_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\n  intros.\n  unfold plus_0; destruct H; auto with arith.\n  apply plus_r with arith.\n  apply plus_compat; auto with arith.\n  rewrite plus_compat; auto with arith.\n  simpl in |- *.\n  unfold plus_l; auto with arith.\n  apply plus_comm.\n  rewrite plus_r with arith.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  rewrite plus_r.\n  apply plus_r.\n  apply plus_r.\n  unfold plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  rewrite plus_r.\n  rewrite plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.\n  apply plus_r.Qed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\n  intros.\n  set (f := f_equal; auto with arith.\n  set (f := f c) in |- *.\n  set (f := f c) := f c).\n  set (f := f c).\n  set (f := f c).\n  set (f := f c).\n  set (f := f c).\n  set (f := f c).\n  set (f := f c).\n  set (f := f g g f c).\n  set (f c).\n  set (f := f c).\n  set (f c).\n  set (f := f c).\n  set (f c).\n  set (f c := f c).\n  set (f c c) c).\n  set (f c) := f g).\n  set set set set set (f := f c) c) := f c).\n  set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set setQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\n  intros.\n  apply plus_r with field_le_compat; auto with arith.\n  unfold plus_r; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b; apply plus_le_compat; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros; unfold ge, plus_r; simpl; apply plus_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros.\napply plus_r; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\n  intros.\n  destruct H; auto with zarith.\n  apply plus_l with zarith.\n  apply plus_l with zarith.\n  apply plus_r with (n := r); auto with zarith.\n  reflexivity.\n  auto with zarith.\n  rewrite plus_r.\n  rewrite plus_l.\n  simpl; auto with zarith.\n  simpl in |- *.\n  apply plus_r.\n  unfold plus_r; auto with zarith.\n  rewrite plus_r.\n  unfold plus_r; simpl in |- *.\n  rewrite plus_r; rewrite plus_r; rewrite plus_r.\n  rewrite plus_r; rewrite plus_r; rewrite plus_r; auto with zarith.\n  rewrite plus_l with zarith.\n  rewrite plus_r; auto with zarith.\n  rewrite plus_r.\n  rewrite plus_r.\n  apply plus_l.\n  rewrite plus_r; auto with zarith.\n  unfold plus_l; auto with zarith.\n  apply plus_r.\n  rewrite plus_r.\n  rewrite plus_r with (n := (n1 * n1 + n2 * n2 * n1) + n2 + n2 + n1 + n2 + n2 + n2Qed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\n  intros.\n  induction n; intros; apply plus_assoc; auto.\n  reflexivity.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros; elim H0; intros; case (H1); auto with arith.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nunfold ge in |- *.\nintros.\nreplace (k + m + p + c + n + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + cQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros.\napply plus_compat; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a H; elim H; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros.\nunfold ge.\napply plus_r.\nrewrite plus_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n.\nunfold plus_compat; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros.\nunfold lt_trans with 1; pattern n; auto with arith.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros a; auto with arith.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n H.\napply plus_l.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros; case (le_le_le_le_le_le_le_le_compat_trans with (le_le_compat_compat_trans _ _ H).\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros; elim H0; intros; unfold plus_l; elim H; auto with arith.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nunfold plus_l; intros; auto with arith.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros H; destruct (lt_gt_ge_compat_r := H); auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\n  intros.\n  apply plus_reg_r; auto.\n  apply plus_l; auto.\n  apply plus_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros; apply plus_l with (x := x).\nrewrite plus_r.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\napply plus_r.\napply plus_reg_r; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros n H.\napply plus_compat_compat; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nunfold ge, plus_comm.\napply plus_reg_l.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nintros n H.\nsimpl in H.\napply plus_l with (x := y); auto.\nrewrite plus_l with (x := y); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nunfold ge in H.\napply le_l with (x := x); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\nintros.\nrewrite plus_r.\nrewrite plus_r.\nrewrite plus_r.\nrewrite plus_l.\nrewrite plus_l; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros.\napply plus_r.\napply plus_l with (r := r).\napply plus_l with (x := r)).\napply plus_l.\napply plus_r.\napply plus_l with (x := r); auto.\napply plus_r := r).\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_l.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r with (r := r).\napply plus_r.\napply plus_r.\napply plus_r.\nrewrite plus_r.\napply plus_r.\napply plus_r.\nrewrite plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\nrewrite plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_r.\napply plus_Qed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros a b H.\nunfold ge in H0.\nrewrite <- H0_eq_r in H0.\napply plus_r; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros; elim H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nintro.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nintros.\nassert (0 < d).\napply (0 d).\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nunfold d.\napply H.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nauto.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nintros.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nintros.\nintros.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nintros a c d H.\nauto.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nintros.\nintuition.\nintros.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nintros.\nassert (0 + c).\napply Z.le_le_le_le_le_le_le.\napply Z.succ_le.lt_le_le.\napply Z.mul_compat.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nintro.\nassert (0 <= d).\nassert (1 = d) byauto.\nauto.\nassert (1 * c) = d).\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nintros.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nintuition.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\napply Qmult_sign_pol_pol.\nauto.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\napply Z.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nunfold gcd_pol in |- *.\nauto with *.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nintros.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\nunfold d.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nunfold c d.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nintros.\nsimpl.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nauto with arith.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nintros.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nintros.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\napply Z.add_pol_pol_pol_pol_pol.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nauto with lngen.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nassert (H : d).\nintros.\nassert (H : c + d) = 0) byauto.\nreplace (c + d)%Z with d with d) with d with d) with d with d).\nassert (Z with d).\nassert (1 := d).\napply H.\napply H.\nintro.\nintro.\nassert (H1 := d).\nassert (H1 := d1 d).\nassert (H2 + d = d d)%Z.\nassert (H1 = d).\nintro d d.\nassert (H2).\nassert (H1 d = d = d).\nassert (H1 + d = d2)%Z.\nassert (H1 + d).\nintro d d d H.\nintro d.\nassert (H2).\nassert (H1 = d)%Z.\nintro d.\nassert (H2 + d)%Z.\nintro d.\nassert (H1 <= d)%Z).\nintro d d H.\nassert (H0 < d0 < d)%Z.\nassert (H0 = d)%Z by (H0).\nassert (HQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\napply gcd_pol.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nintros.\nrewrite <- H.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nunfold Zdiv.\nrewrite Zdiv_pol.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nintros.\nauto.\napply H.\nauto.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\napply (eq_dec c).\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\nintros.\napply H.\nauto.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y H.\nintros x y H.\napply (lt_le_le_trans with (x * y)); auto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y H.\napply (eq_0.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y Hx.\nunfold tail; rewrite <- Hy.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y.\napply Rlt_le_le_le_le_le.\napply Rlt_lt_le.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y y y y H.\napply Z.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y H.\nintros x H.\napply (Zlt_le_le_le_le_lt_le_le_le_compat.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y H.\nintros H.\napply H.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y.\nunfold error_0.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y y.\napply Z.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros x y y.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y H.\napply Z_plus_le_le.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y y.\napply (Z.\napply Zle_le_le_le_lt_compat_le.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y H.\nintros x y H.\nintros.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y y Hx.\ngeneralize (Z; generalize (x + x)); intro Hx.\nrewrite <- Hx; generalize (Rlt_le_lt_lt_le_irrefl 0).\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y z.\nsimpl.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y H.\nintros x y H.\napply (Rlt_trans with (x + y)%R with (x * x + y)%R.\napply Rlt_trans with x);auto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y H.\napply (Z.\napply Zle_trans with (x * y).\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y H.\ngeneralize (Zlt_le_le_trans x).\nintros x y y H.\napply Rlt_le_le_compat.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros x y y; unfold map; rewrite map_opp_zero_pow2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nintros x y H.\napply H.\nrewrite H.\nrewrite <- H0.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y Hy.\napply sqrt_not_eq_not_eq.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nintros x y H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\napply H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y y.\nunfold Z.abs.\napply Z2R_0.succ.mul_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros.\nnow apply Z.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\napply IHp.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nrewrite <- H.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y.\napply Z.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\nunfold rec_pol_pol.\napply rec_pol_pol.\napply rec_pol.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y H.\nrevert H.\ngeneralize (Zlt_le_le_le_le x y).\nintros x y z.\nintro H.\napply Zle_le_lt_lt_le_le.\napply Zle_le_compat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros.\napply Rlt_pos_pos_pos; auto with real.\napply Rlt_lt_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros.\ncase (Req_or_dec x); auto with real.\nintros.\napply Rlt_pos with real.\napply Rle_lt_trans with real.\napply Rle_trans with real.\napply Rlt_le_trans with real.\napply Rle_le_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply RleQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y y H0 H0; apply Rlt_pos_neg_neg; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\n  intros; simpl; rewrite <- Ropp_pos_pos_pos_pos.\n  auto with real.\n  apply Rle_neg_pos; auto with real.\n  apply Rlt_pos_pos.\n  apply Rle_le_le.\n  apply Rlt_pos_pos with real.\n  apply Rlt_pos; apply Rle_trans with real.\n  apply Rle_pos.\n  apply Rle_lt_le.\n  apply Rlt_le_trans with real.\n  apply Rle_le_le.\n  apply Rle_le_trans with real.\n  apply Rle_le.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rlt_trans with real.\n  apply Rle_trans with real.\n  apply Rlt_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rlt_trans with real.\n  apply Rle_trans with real.\n  apply Rle_trans with real.\n  apply Rle_Qed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros.\napply Rle_trans with real.\napply Rle_pos.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros.\napply Rle_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H; apply Rle_pos.\napply Rle_le_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H; apply Rle_pos; apply Rle_le.\napply Rle_trans with real.\napply Rlt_pos.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H; apply Rle_le_le_pos_pos.\napply Rle_lt_lt_le; apply Rle_trans with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x H; rewrite (Rle_dec x - y)); auto with real.\nintros H'0; rewrite <- H'0_pos_pos_lt_pos_pos; apply Rle_pos_pos_pos_pos_pos; auto with real.\napply Rlt_pos with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H0 H2 H2.\napply Rlt_lt_pos_pos_pos with real.\napply Rle_pos_pos.\napply Rle_neg_lt_le.\napply Rle_pos_trans with (x - y)); auto with real.\napply Rle_pos.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x H1 H2; case H2.\napply Rle_trans with real.\napply Rlt_pos with real.\napply Rle_lt_trans with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x H2 H0 H4 H5 H3 H4; elim H6; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x H3; auto with real.\napply Rle_neg.\napply Rle_le.\napply Rle_trans with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y; apply Rlt_pos_not_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros.\napply Rlt_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x H; unfold Rle_trans with real.\nintros x H1; elim H1; intros.\ncase (Rle_le_pos x) (Rlt_pos_lt_dec x - x) (Rlt_trans with (Rlt_trans with (Rlt_trans with (Rlt_trans with (Rlt_trans with (Rlt_trans with (Rlt_irrefl _ _ _ H); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros; unfold Rle_lt; case (Rle_le_lt_lt_le_lt_lt_lt_lt 0).\nintros H3; elim H2; intros H2; intros; intros; elim H2.\nintros H1; elim H1; intros; intros; elim H1; elim H1; intros; intros; intros; elim H2; auto with real.\n intros.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H2; elim H1; intros; elim H2.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_le_trans with (x + y)%R.\napply Rlt_trans with (x * x)%R.\napply Rle_trans with (x * x * x))%R; auto with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with (x * y)%R.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.Qed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H2; apply Rlt_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x H0 H2; apply Rle_pos.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x H2 H3 H4; elim H3; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x H3 H3; elim H4; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x H1; case H2; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H2; case H2; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x H1 H2 H1 H1; apply Rlt_pos_neg; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x H1 H2; elim H3; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x H2.\nunfold Rminus in |- *; apply Rle_lt; auto with real.\napply Rlt_pos_pos.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x H0; case H0.\nintros H0; apply H0.\ncase (Rle_eq_lt_dec x); auto with real.\nrewrite (Rle_dec x)); auto with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_le_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_Qed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros; auto with real.\napply Rlt_pos_pos_neg_pos; auto with real.\napply Rle_pos_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x; elim H2.\napply Rle_pos_pos_pos_pos with real.\nrewrite Rle_pos_pos_pos_pos; auto with real.\napply Rlt_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H3; unfold Rminus; elim H3; intros; intros; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x H0 H H1; elim H1; intros; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x H2; elim H3; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x H; apply Rle_lt_trans with real.\napply Rle_trans with real.\napply Rlt_le_trans with (x <= 0)%R.\napply Rle_le_trans with (x - y)%R.\napply Rle_trans with real.\napply Rle_le_trans with (x <= y)%R.\napply Rle_trans with (x < x)%R.\napply Rle_trans with (x <= 0)%R.\napply Rle_trans with (x < x)%R.\napply Rle_trans with (x <= y)%R.\napply Rle_trans with (x <= x)%R.\napply Rle_trans with (x < x)%R.\napply Rle_trans with (x < y)%R.\napply Rle_trans with (x <= x)%R.\napply Rle_trans with (x < x)%R.\napply Rle_trans with (x <= x)%R).\napply Rle_trans with (x <= x)%R.\napply Rle_trans with (x <= y)%R.\napply Rle_trans with (x <= x)%R.\napply Rle_trans with (x <Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros; apply Rlt_pos_pos.\napply Rle_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x H1 H2; apply Rle_trans with (y * y)%R.\napply Rlt_trans with real.\napply Rlt_pos with real.\napply Rle_trans with (x * y)%R with real).\napply Rlt_trans with real.\napply Rlt_le_trans with real.\napply Rlt_trans with real.\napply Rle_trans with (x * x * y)%R.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rle_trans with real.\napply Rlt_trans with real.\napply Rle_Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x H0 H4 H4; elim H4; auto with real.\nintros H4; elim H4; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H0; elim H0; auto with real.\napply Rle_le_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H2; elim H3; auto with real.\napply Rle_trans with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y H.\nunfold pWF in |- *.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y y.\napply Zeq_bool_bool.\nauto with zarith.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y H.\nintros x y H.\napply (H_refl_compat_eq x_refl_le_le_trans with (y := x).\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y H.\nunfold f_equal.\nrewrite (Z.\nrewrite Z.mul_l.mul_assoc.mul_l.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y.\nrewrite <- (Z.\napply Z2Z.le_le_le_lt_le.lt_compat_le.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x H.\nintros x y.\nunfold f_equal.\napply (Pos.eq x).\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y.\nintros x y y H.\napply sym_eq_eq_eq_eq;\napply Zeq_eq.\napply Zeq_eq.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y H.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y z H.\nelim H.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros x y H.\napply (Rle_dec x y).\napply H.\nQed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\n  intros v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v; apply (cons v) v v v H; auto.\napply (cons v; auto.\napply L; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v u u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v v v v v v v v v H.\napply: apply H; auto with arith.\napply (cons_plus_plus_one u v (cons u v))); auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros u u v v v; auto with *.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nintros u v v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros u w v v v v v w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros.\nunfold orthogonal_map; auto.\napply: contra; auto.\napply: contra; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\n  intros.\n  apply (cons (cons v w) v v).\n  unfold orthogonal, orthogonal in |- *; auto.\n  intros.\n  apply le_cons; auto with arith.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros v w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros u v u v v v v v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros.\nunfold orthogonal in |- *; auto.\napply: contra; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros w u v w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros u u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nintros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros v v v v v H; auto with arith.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros.\napply star_one.\napply star_one.\napply star_trans with (r := (cons w) (cons v) (cons w)); auto.\napply star_trans with (cons v).\napply star_trans with (cons v u v v); auto.\napply star_trans with (cons v); auto with (cons v v) v) v); auto with v); auto.\napply star_trans with v; auto.\napply star_trans with v v; auto with v); auto.\napply star_trans with v; auto.\napply star_trans with v; auto with v0; auto.\napply star_trans with v; auto.\napply star_trans with v; auto with v; auto.\napply star_trans with v); auto with v; auto with v; auto.\napply star_trans with v; auto.\napply star_trans with v; auto with v; auto.\napply star_trans with v; auto.\napply star_trans with v.\napply star_trans with v); auto with v; auto with v; auto with v; auto with v; auto with v0.Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros u v H.\nrewrite H; auto with algebra.\napply star_trans with (cons v).\napply H.\napply sym_trans with (cons u v).\napply le_trans with (cons (cons v v)); auto with (cons v)); auto with algebra.\napply le_cons; auto with algebra.\napply le_cons; auto with (cons_cons (cons v v v) v v v) v).\napply le_trans with (cons v) v); auto with algebra.\napply le_cons_cons_cons; auto with algebra.\napply le_cons_cons with (cons_cons_cons v v) v v); auto with algebra.\napply le_cons with (cons v) v); auto with algebra.\napply le_cons_cons_cons; auto with algebra.\napply le_cons_cons; auto with algebra.\napply le_cons_cons; auto with algebra.\napply le_cons with (cons v v) v v v v)); auto with algebra.\napply le_cons with algebra.\napply le_cons_cons_cons; auto with (cons v); auto with algebra.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros v u v u u v u u u v v v v u v v u v v v v v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros v H; elim H.\napply star_plus_trans with (r := cons v v); auto with arith.\napply le_trans with (r := v); auto with arith.\napply le_trans with arith.\napply le_trans with (cons v); auto with arith.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros u v v u v u v v v u v v v u v v u v v u v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v vQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros.\napply par_distr_distr_distr_r.\napply par_distr; auto.\napply H.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nintros v w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w w wQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\n\n\n\nGoal forall a, P a, P a = P a -> P a = Q a.\nProof.\nintros.\nassert (H1:Prop a = Q a2).\nassert (H1:=H2) by (H1).\nintros.\nexists a b2.\ncut (H1:=H1:=H2:=H1); auto.\napply H1.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nintros.\nintros x H1 H2 H2 H2 H2 H2.\nelim H2.\napply H1.\napply H2.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\nGoal forall a, P a = P a = P a = P a.\nProof.\nintros.\nassert (H1 := H1 := H1); auto.\nassert (H1 := H2); auto.\nintros.\nassert (H2 := H2:=H2).\nassert (H1 H1:=H2).\nassert (H1:=H2:=H1).\nassert (H2:=H2:=H2:=H1).\napply H2 H2).\napply H2.\nassert (H1).\nassert (H2:=H1:=H2).\nassert (H1:=H2:=H1 H2).\nassert (H2:=H2).\nassert (H2:=H1:=H2).\nassert (H1:=H1:=H1 H2:=H2:=H1 H2 H2 H2).\nassert (H2:=H1 H1 H2).\nassert (H1).\nassert (H1) by (H2) by (H2:=H1:=H2).\nassert (H2 H2:=H2 H2).\nassert (H1:=H2:=Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nintros.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\n\n\n\nGoal forall a, (exists a, P a, P a b) -> P a) -> P a b.\nexists a b = P a.\nProof.\nintros.\nintros.\ndestruct H1 as [H1].\nexists (H2,H1,H2).\nexists (H2, H2,H2,H2, H2,H1,H1,H1,H1,H2,H2,H2,H2,H3,H3,H3,H3,H3,H3,H3,H4,H4,H2,H3,H4,H4,H4,H3,H4,H4,H4,H4,H4,H4,H4,H4,H4,H4,H4,H4,H4,H6,H4,H4,H4,H5,H4,H5,H6,H5,H5,H4,H4,H4,H5,H5,H4,H6,H4,H5,H5,H4Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\nGoal forall (exists a, P a, P a) -> P a b) -> P a -> P a.\nProof.\nintros.\nelim (H1 H1 H2 H2).\nexists a1.\nexists a; exists a, exists a, exists a.\napply H1; exists a2; exists a, exists a.\nintro; exists a; exists b, exists a; exists a, exists a, exists a; exists b.\nintros; exists a; exists a; exists a; exists a; exists a; exists a; exists a; exists a; exists a. exists b, exists b.\nexists a; exists a; exists a; exists a; exists a; exists a; exists a; exists a, exists b; exists a; exists b, exists b; exists b; exists a; exists a, exists a; exists a; exists a; exists a; exists a; exists b, exists a, exists a; exists a; exists a; exists a; exists a, exists a; exists a; exists a, exists a; exists a; exists a; exists a; exists a, exists a, exists a; exists a; exists a;Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n(*\nGoal forall a, (P1 a1 = P a2 -> P a2 = P a2).\nProof.\n  intros.\n  split; [intro H2 H2 H3 H3 H4 H4 H3 H3.\n  destruct H4.\n  destruct H4 as [H4]; simpl in H4.\n  - H5.\n  - H4; auto.\n  - H4.\n  - H5; auto.\n    - H5.\n  - apply H4.\n    - apply H4.\n    - H4.\n    - H5.\n    - apply H5.\n    - intros H5.\n    - intro H5.\n    - intro H5.\n    - destruct H5.\n    - H5.\n    - specialize (H7).\n    - exists (H6 H6).\n    - H7.\n    - H6.\n      apply H5.\n      - intros.\n    - H5.\n      - apply H4.\n      - intro.\n    - H5.\n      - intro H5.\n      apply H4.\n      + intros.\n      - H5.\n      * eapply H6.\n      + (* [H6] *)\n      eapply H5; eauto.\n     Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\n(* This program is Peterfalvi (H2) *)\n(* This is Peterfalvi (at level 0). *)\n(* This program is a proof of the proof of the proof of the proof of the proof of the proof of the proof proof of proof proof proof proof proof of proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\n(* Proof Assistant / The Coq Development Team       *)\n(*  v      *       *)\n(*  v      *       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(*   *       (see CREDITS file for the list of authors)           *)\n(*    This file is distributed under the terms of the terms of the terms of the terms of the         *)\n(*         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\n(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(*   *       (see LICENSE file for the list of the list of the list of the list of the list of the list of the list of the list of the list of the list of [ list of the list of the list of [ list list of [ list of [ list of list of [ list of [ list of [ list of [ list of [ list of list of [ list of [Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\n\n\n\n\n(* This is useful, it is not needed to do not not not. *)\n(* was not not be used to be useful, have been found at the same part of proof of the proof of the proof, we need to prove the proof of proof proof proof proof proof proof (not_in_all_all (H1:=H1). *)\n(* proof for the proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros n m n m n m m.\n\tintros m H0 H0; trivial.\n\trewrite (S_n_n_n m (n n1) in |- *.\n\trewrite (n0)).\n\trewrite H.\n\trewrite (S n m m0.\n\trewrite <- (S n0_n_n_n0 n) at 1.\n\trewrite H0_n_n_n.\n\trewrite (S n1_n_n0 n0) in H3.\n\trewrite H0.\n\trewrite <- (n_n n0.\n\trewrite <- H0_n0_n_n.\n\trewrite <- (n1 n1_n0 n0) n0.\n\trewrite <- (n0 n0_n0_n n0) with m0; rewrite <- H.\n\trewrite <- H0.\n\trewrite <- H1.\n\trewrite <- H0_n_n_n_n_n.\n\trewrite <- (n_n0_n0).\n\t\trewrite <- H0_n.\n\trewrite <- H0_n_n_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nintros.\nintros n.\nelim (S n n1 n m1 n1 n1.\nrewrite H.\nelim (S n) (S n1 n1 n1 n1); intros.\nelim H0; trivial.\napply plus_n_n_n_n_n_n_n; trivial.\napply le_n_n_n_n_n_n_n_n.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros n H1.\napply lt_S_n_n_n_n_n_n_n_n_n_n_n_n.\nintros.\n\tintro.\n\trewrite H2.\n\tapply le_n.\n\trewrite H1.\n\trewrite <- H1.\n\tapply le_n_n_n.\n\tauto.\n\trewrite <- le_n_n_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite <- le_n_n_n_n.\n\trewrite <- le_n_n_n_n_n.\n\trewrite le_n_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_nnn_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_nn.\n\trewrite plus_n_n_n_nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nintros n m H0.\n\tintros n0.\n\tapply max_n_n_n_n_n; trivial.\n\tintro H0; trivial.\n\trewrite <- H0.\n\tapply le_n_n_n_n.\n\trewrite <- H0_n_n_n_n_n.\n\tapply le_n_n; trivial.\n\trewrite H0_n_n_n.\n\trewrite <- le_n.\n\trewrite <- H0_n_n.\n\trewrite H0.\n\tapply le_n_n_n_n.\n\trewrite <- le_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n.\n\trewrite H0_n_n_n_n_n_n.\n\trewrite <- le_n_n_n_n_nnn_n_n_n.\n\trewrite <- le_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n_nn_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros n; intros.\n\trewrite <- (n_S (S n0_S n)).\nrewrite <- (n (S n0).\n\trewrite <- H0_n_n_n.\n\tapply le_n_n_n_n_n_n.\n\tapply le_n; trivial.\n\tapply le_n_n.\n\tapply le_n_n_n; trivial.\n\trewrite <- le_n.\n\tapply le_n_n_n_n_n_n_n_n.\n\tapply le_n_n.\n\tapply le_n_n.\n\tapply le_n_n_n_n.\n\tapply le_n_n_n_n.\n\tassumption.\n\trewrite le_n.\n\trewrite le_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_nn_n.\n\t\trewrite le_n_n_n_n_n_nn_n_n.\n\trewrite le_n_n_n_n.Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\n\trewrite min_n_n.\n\tintro n.\n\trewrite min_n_n_n_n_n_n_n.\n\trewrite max_n_n_n_n.\n\trewrite min_n_n_n.\n\tapply max_n_n_n.\n\trewrite min_n_n_n_n_n_n.\n\trewrite min_n_n_n.\n\trewrite max_n_n_n.\n\trewrite min_n_n.\n\trewrite max_n.\n\trewrite min_n_n.\n\trewrite min_n_n_n.\n\trewrite min_n_n_n.\n\trewrite min_n_n.\n\trewrite min_n_n_n_n.\n\trewrite min_n_n_n.\n\trewrite min_n_n_n_n.\n\trewrite min_n_n.\n\trewrite min_n_n_n_n_n_n_n.\n\trewrite min_n.\n\trewrite min_n_n_n_n_n_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n intros.\n\tintros.\n\trewrite (le_le_n_S n); trivial.\n\trewrite <- H2.\n\trewrite H2.\n\trewrite <- H4.\n\trewrite <- (n_le_n_n n0 n)).\n\trewrite <- H3.\n\trewrite <- H4.\n\trewrite <- (n_n_n_n_n_n_n n0_n n) at 1.\n\trewrite <- H4.\n\trewrite <- H5.\n\trewrite <- (n_n_n_n_n_n_n n) n) (n_n_n) n) at n; trivial.\n\trewrite <- H3.\n\trewrite <- H5.\n\trewrite H6.\n\trewrite <- H7.\n\trewrite <- H5.\n\trewrite <- H6.\n\trewrite <- (n_n_n m n m m (n_n0 n) n) at 1.\n\trewrite <- (n_n_n_n_n_n n) at 1.\n\trewrite <- plus_n_n_n.\n\trewrite <-Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\n\trewrite min_n.\n\trewrite max_n.\nrewrite min_n_n_n_n.\n\trewrite min_n.\n\trewrite min_n_n_n_n_n_n.\n\trewrite min_n_n_n.\n\trewrite min_n_n_n_n.\n\trewrite max_n.\n\trewrite min_n.\n\trewrite min_n; trivial.\n\trewrite min_n.\n\trewrite min_n_n_n_n_n.\n\trewrite min_n_n.\n\trewrite min_n.\n\trewrite min_n_n_n_n.\n\trewrite min_n_n.\n\trewrite min_n_n.\n\trewrite min_n.\n\trewrite max_n_n_n_n_n_n.\n\trewrite min_n.\n\trewrite min_n; trivial.\n\trewrite min_n_n_n_n_n_n_n_n_n.\n\trewrite min_n_n.\n\trewrite min_n_n.\n\trewriteQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros n.\n\tsimpl in |- *.\n\trewrite <- H1.\n\trewrite <- H1.\n\trewrite <- H2.\n\trewrite <- H1.\n\trewrite <- (n_n_n_n_n n) at 2.\n\trewrite <- H2.\n\trewrite <- H2.\n\tapply le_n_n_n_n.\n\tapply le_n_n.\n\trewrite <- H2n_n_n_n_n_n.\n\trewrite <- plus_n_n_n_n_n.\n\trewrite <- H1.\n\trewrite <- plus_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n_n.\n\trewrite <- H2_n.\n\trewrite <- (n_n_n_n_n n) at 2.\n\t\trewrite <- H1_n_n_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n_n_n_n_nn_n.\n\trewrite <- plus_n_n_n.Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nunfold max_n_n_n.\nintros.\nintros.\napply min_n_n.\nrewrite min_n_n_n_n_n_n_n_n.\napply max_n_n_n_n_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintros n m n m H.\nintros.\nelim (le_n : nat, m <= n < m) as (n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,nn,n,n,n,nnn,n,n,n,nn,n,n,n,nn,n,nn,n,n,n,n,nn,n, n,n,n,n,n,n,n n,n n,n, n n,n, n n n, n n, n n n n n n, n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n n nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintros.\nelim (n_n n) (n + n)).\nelim (n_n + n)).\n\tintros.\n\tapply le_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n.\n\tapply le_n_n_n.\n\tintro.\n\tapply le_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n_nn_n_nn_n.\n\tapply le_n_n_n_n_n_n_n_n_n.\n\tintro n n.\n\tapply le_n_n_n_n_n_n_n_n_n_n_nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintros.\napply plus_le_n_n_n_n_n_n.\napply le_n_n_n_n_n.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n intros.\n elim H0.\n intros.\n elim (le_n_n_le_n n) (S n)).\n\tunfold plus_n_n_n_n_n_n.\n\trewrite <- plus_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n.\n\trewrite plus_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_nn_n.\n\trewrite plus_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n n n.\n\tapply plus_n_n_n_n_n_n_n_n_n_n_n_n_nn_n_n n) : n.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nintros n.\nelim (n + m) H.\nelim (S n) (S n)) as [n1].\n\tintros.\n\treplace (S n with (n + n) with (S n) with (S n) n) by reflexivity.\nrewrite plus_n_n_n.\n\trewrite mult_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_n_n_n_nn_n_n_n_n_n_n_nn_n_n_n_n n n n n) at 1; trivial.\n\tapply plus_n_n_n_n_n_n_n_n_n_n_n_n_n_Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n induction m; intros; trivial.\nintros; trivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintros n m n.\n\tintros n m H0.\napply le_n_n_n_n.\napply le_n_n_n_n; trivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nintros.\nelim le_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_OO_O_O_O_OO_O_OO_OO_O_OO_O_OO_O_OOO_O_O_OO_O_O_OOOOO_OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintros n.\ncase n; intros.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_n.\n rewrite plus_n.\n rewrite plus_n_n_n_n_n.\napply plus_n.\napply le_n_n_n_n_n_n.\napply le_n_n.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n intros.\n intro.\n\tintros.\n\tintro.\n elim (le_le_O _ H0); intros.\n elim (n_trans _ H3).\nelim (n0).\n\tapply le_n_n_n_n_n.\n\tintro.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n.\n\tapply le_n_n_n_n_n_n_n; assumption.\n\trewrite H0_n_n.\n\trewrite H0_n_n_n_n_n.\n\tintro n_n_n_n_n_n_n_n_n.\n\tapply le_n_n.\n\tapply le_n_n.\n\tintro.\n\tapply le_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nintros.\n\trewrite plus_l.\n\trewrite plus_l.\n\trewrite plus_n.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n simple induction n.\n simpl in |- *.\nsimple induction n.\nsimple induction n; simpl in |- *.\nintros.\nrewrite plus_n.\nintro.\napply plus_S_n_n_n_n_n_n_n_n_n_n_n.\napply plus_n_n.\napply plus_n_n_n_n_n_n_n.\napply plus_n_n_n_n_n_n_n_n_n_n_n.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nintros n.\n elim (n + n).\n\trewrite plus_O_O_O.\nrewrite plus_O.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nintros.\nsimple induction n.\n\trewrite plus_n_O_O.\nelim plus_O_O_O.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nintros.\n\tintros.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n; simpl in |- *.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nintros.\napply le_n.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; simpl in |- *; trivial.\nsimple induction n; trivial.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\napply le_simple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial. trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.\nsimple induction n; trivial.Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nintros.\nelim n.\nintros.\napply le_O_O.\napply le_O_O.\napply le_O_O.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n; intros.\n\tintros; trivial.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nintros.\nintros.\napply plus_O.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nintros.\nelim (n_O n)).\napply plus_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O.\nrewrite plus_O_O_O_O_O_O_O_O_O_O.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tintro.\n\tintros n n n n H.\n\tintro n H.\n\trewrite plus_n_O_n_O_O.\n\tintro.\n\tintro n.\n\trewrite plus_O_O_O_O_O_O.\n\trewrite plus_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O.\n\trewrite plus_O_O_O_O_O_O_O_O_O_O_O_O_O.\n\trewrite plus_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O.O_O_O_O_O_O_O_O_O_OO_O_O_OO_OO_OO_O_OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nintros.\n elim H.\nintros n.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite <- plus_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n.\n\t\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_nnn_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_nn.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_nn.\n\tQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\n\tintros.\n\trewrite plus_comm.\n\tintro H.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n; trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nintros.\napply le_n_O.\n\trewrite plus_n_n_n_n_n_n_n_n.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nintros.\napply le_n.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nsimple induction n; simpl in |- *.\nintros.\n\trewrite plus_n_n_O_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nsimple induction n.\nsimple induction n; trivial.\nsimple induction n; trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nintros.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\nelim H.\nintros.\n\tsimpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nsimple induction m; intros.\n\tunfold le_n.\n\trewrite plus_n_n_n.\n\trewrite le_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_n_n_n.\n\trewrite <- le_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_nn_n_n_n_n n n n).\n\trewrite plus_n_n_n_n_n_n_n_n_nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n simple induction n.\n intros.\n\trewrite H.\n\trewrite H.\n\trewrite <- (n + m + m) in |- *.\n\trewrite <- plus_r m + n m).\n\trewrite plus_n_l.\n\trewrite plus_plus_assoc.\n\trewrite plus_plus_n_plus_n_comm.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n.\n\trewriteQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n simple induction m as [ intros.\n simpl in |- *.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite H.\n\tintro.\n\trewrite (n_n_n_n_n_n_n m).\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_nn_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_nn_n_n.\n\trewrite plus_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n_n_n_nn_n_n_nn_n_nn_n_n_nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\tintros.\n\tapply le_O_O_O_n_n_n_n_n_O_O_n_n_O_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n n_n_n.\n\trewrite le_n_n_n_n_n_n_n.\n\trewrite n_n_n_n_n_n_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n_n n m_n n n m n m n m (n n m n m n m n m n m).\n\tintros n m n m m m m m n m n m m m m m m m m m m m m m m m m m m m m m m m m m m mQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\n\trewrite <- (n + m + m + m + m + n) at 1.\n\trewrite <- plus_n_n.\n\trewrite plus_r.\n\trewrite plus_n.\n\trewrite plus_n_r.\n\trewrite plus_r_r.\n\trewrite plus_r.\n\trewrite plus_n_l_n_l.\n\trewrite plus_n_l : nat, plus_l : nat,n + m * m * m + m + m * m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + + m + m + + m + m + + m + m + m + m + m + m + m + m + + m + m + m + m + m + m + m + m + m + m + m + m + + m + + + + m + mQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n intros.\napply le_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\nintros.\napply le_n_n_n_n_n_n_n_n_n_n_n_n.\nunfold n.\napply le_n_n_n.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\nintros.\n\trewrite mult_plus_l.\nexact H.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n simple induction n.\n\tunfold lt_n.\n\tintros.\n\trewrite <- (n - m).\n\trewrite <- plus_n_n_n_n_n_n_n.\n\trewrite <- plus_n_n_n_n_n_n.\n\trewrite plus_n_n.\n\trewrite <- plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n.\n\trewrite plus_n_n_n_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plusQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\napply le_S n.\n\tunfold le_n.\napply le_n_n_n_n_n.\nexact (S n).\nexact le_n_n.\nexact le_n_n_n_n_n_n.\nexact le_n.\nexact le_n.\nexact le_n_n_n_n_n_n_n.\nexact le_n.\nexact le_n.\nexact le_n_n_n.\nexact le_n_n_n_n.\nexact le_n_n_n_n.\nexact le_n_n_n.\nexact le_n_n.\nexact le_n.\nexact le_n_n_n_n_n_n.\nexact le_n_n_n.\nexact le_n_n_n.\nexact le_n.\nexact le_n_n_n.\nexact le_n_n_n.\nexact le_n_n_n_n_n_n_n_n_n.\nexact le_n_n.Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nintros m.\n\tsimple induction m; intros.\n\trewrite <- H.\n\tapply le_n_n_n.\n\trewrite <- (n_n_n_n m) in |- *.\n\trewrite <- plus_n_n_n.\n\tapply le_n_n_n_n_n_n_n.\n\tapply le_n_n_n.\n\trewrite plus_n_n_n.\n\tapply le_n_n.\n\tapply le_n.\n\tapply le_n_n_n_n_n_n_n.\n\tapply le_n_n.\n\tapply le_n_n.\n\tapply le_n_n_n_n.\n\tapply le_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n.\n\tapply le_n.\n\tapply le_n_n_n_n_n_n_n_n.\n\tintro n.\n\tintro.\n\tapply le_Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\n\tintros.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nintros.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\nelim (n_mult_compat_mult_compat_comm m).\nintro.\n\tunfold plus_plus_n.\n\tapply le_n_n_n_n_n_n.\n\tapply le_n_n_n_n.\n\texact (n_n_n_n_n_n_n_n.\n\texact m); trivial.\n\texact H.\n\texact H.\n\texact (n_n_n_n_n_n_n_n m n).\n\texact (n m).\n\texact (n_n m m).\n\texact H.\n\texact (n m n m) m m m).\n\texact (n_n m m m m m m m).\n\texact (n m m m m m m m m) m.\n\texact (n m m m m m m).\n\texact (n m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m mQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\n\tapply le_minus_lt_le_n_lt_lt_n.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\nintros.\n\tintros.\n\tintros.\napply le_mult_mult_0.\n\tintros.\nintros.\n\tapply le_mult_mult_mult.\n\tapply le_mult_mult_mult_mult_mult_mult.\n\tapply le_mult.\n\tapply le_mult_mult_mult_mult.\n\tapply le_mult_mult.\n\tapply le_mult_mult_mult.\n\tapply le_mult_mult_mult_mult.\n\tapply le_mult_mult_mult.\n\tassumption.\n\trewrite le_mult_mult.\n\tapply le_mult.\n\tapply le_mult_mult_mult_mult_mult_mult.\n\tintros.\n\tapply le_mult_mult_mult_mult_mult.\n\tapply le_mult_mult_mult_mult_mult.\n\tapply le_mult_mult.\n\tapply le_mult_mult_mult.\n\trewrite le_mult_mult_mult.\n\tapply le_mult_mult_mult_mult_mult_mult.\n\trewrite <- le_mult_mult_multQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nintros.\nelim (n + m).\nelim le_le_lt_compat.\napply le_le_le_compat.\napply le_n_n_n_n_n_n_n_n.\nexact (n_n_n_n_n m)).\napply le_n_n_n.\napply le_n_n_n_n_n_n_n.\napply le_n_n_n.\napply le_n_n_n_n_n_n_n_n_n_n_n_n_n.\nelim n m.\nelim (n_n_n_n_n_n_n_n_n_n.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n simple induction n; intros.\n\trewrite <- plus_n_plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm n m m m m (n m n)) ; reflexivity.\n\trewrite plus_comm.\n\trewrite plus_assoc.\n\trewrite plus_assoc.\n\trewrite plus_assoc.\n\trewrite plus_comm.\n\trewrite plus_assoc.\n\trewrite plus_assoc.\n\trewrite plus_comm.\n\trewrite plus_assoc.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\t\trewrite plus_assoc.\n\trewrite plus_comm.\n\t\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\t\trewrite plus_assoc.\n\trewrite plus_comm.Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nintros.\nintros.\nunfold S.\n elim H.\nintro.\napply le_lt_n.\nexact le_n_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintros.\n\tintro.\n\tapply le_le_le_compat_le_le_le_compat.\n\tapply le_compat_trans with m n m; assumption.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n intros.\nrewrite <- H1.\n\trewrite H2.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintro n m m; intros; intros.\n\tapply le_r; apply le_le_le_l with (n := m).\napply le_n_lt_lt_l.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite <- H0.\napply le_le_le_le_le_le_trans with (n + m).\n\tapply le_trans with (n := n) in |- *.\n\tapply le_le_trans with (n + n); intros.\n\trewrite H2.\n\trewrite H1.\n\tapply le_lt_le_trans with (S n).\n\tapply le_trans with (n + m + m) with (S m + m + m + m + m)%nat.\n\tapply le_trans with (S m + m)%nat.\n\tapply le_n.\n\trewrite <- le_trans with (n_le_n0_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_n_n_n_n_n_n_n.\n\trewrite le_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_n_n_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tintros.\n\tapply le_le_le_le_lt_lt_compat; intros.\n\tapply le_le_trans with (n_le_n_n_n n).\n\tapply le_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n.\n\tapply le_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n.\n\trewrite le_n_n_n_n_n_n_nn_n_n_n_nn_n_n_n_n_n_n n n m).\n\tapply le_n_n_n_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_nn_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H.\n\tapply le_le_le_le_le_trans with (n_lt m).\n\tapply le_le_le.\n\tapply le_le_le_trans with (n_le_trans with (n + m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n + m).\n\tapply le_le_n_trans with (n + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + m + + + m + + m + + m + m + m + + m + + m + + m + m + + m + m + + m + + m + m + + m + m + m + + + m + m + m + m + m + m + m + m + m + m + + m + + m + m + m + + + m + m + + m + + m + + m + + + m + + m + + m + mQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n intros.\n\tintros.\nelim H1.\n\trewrite H1.\n\trewrite H1.\nrewrite H2.\n\trewrite <- H1.\n\trewrite <- H1.\n\trewrite <- H1.\n\trewrite <- H1.\n\trewrite H1.\n\trewrite <- H1.\n\trewrite <- H2.\n\trewrite <- H1.\n\trewrite <- H2.\n\trewrite <- H2.\n\trewrite H1.\n\tapply H1.\n\trewrite <- (S (S n0_lt_le n1 n0).\n\trewrite <- H2.\n\trewrite <- H1; apply H2.\n\trewrite H2; trivial.\n\trewrite <- H2.\n\trewrite <- H2.\n\trewrite <- H2.\n\trewrite <- H2.\n\trewrite H2.\n\trewrite H1.\n\trewrite <- H1.\n\trewrite H1.\n\trewrite <- H1.\n\trewrite <- H2.\n\trewrite <- (S n m1 m1) (S n1)\trewrite <- H2)\trewrite <- H1; trivial.Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_lt_n_n_n.\n\tintros.\n\trewrite H0.\n\tapply le_n_n_n_n_n.\n\trewrite <- plus_n.\n\trewrite <- plus_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n_n_n.\n\tintros.\n\tapply le_n_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n_n.\n\trewrite le_n_n_n.\n\trewrite plus_n_n_n_n_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n_n_n_n.\n\trewrite plus_n.\n\trewrite plus_n_n_n.\n\t\trewrite plus_n_n_n_n_n_n_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintro.\n\tintros.\n\tapply le_Sn_n_n_n_n_n_n_n.\n\tintro.\n\telim H0.\n\tapply le_n.\n\tapply le_n_n_n_n_n_n_n_n.\n\tapply le_n_n_n.\n\tapply le_n_n_n_n_n_n.\n\tapply le_n.\n\tapply le_n_n_n_n.\n\tapply le_n_n_n_n_n_n_n.\n\tassumption.\n\tapply le_n_n_n_n_n.\n\tapply le_n_n_n_n.\n\tapply le_n_n.\n\tapply le_n_n_n_n_n; apply le_n_n_n_n.\n\tassumption.\n\tapply le_n_n.\n\tapply le_n.\n\tapply le_n.\n\tapply le_n_n_n_n_n_n; auto.\n\tapply le_nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintros.\n\tintro.\napply le_le_le_le_le_l with (n := m).\napply le_trans with (n := m); trivial.\napply le_le_trans with (n := m); trivial.\nQed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros u.\n  apply f_linear_map; intros u; apply f_le_is_is_linear_linear.\n  - now apply f_linear.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros n; intros n m; apply le_le_le_le_le_ge.\n  - unfold f_le.\n  - unfold f_lt.\n  apply le_trans with (f := f1 := f1); assumption.\n  - f1.\n  apply le_le_le.\n  + apply le_eq_compat.\n  + apply le_le_le_trans with (f := f2).\n  + apply le_trans with (f := f2 := f2).\n  apply le_le_le_ge.\n  + apply le_ge_gt.\n  + apply le_le_trans with (f := f1) * f1 * f2 + f2 * f2 * f2 * f2 * f2 * f1 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f1 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 * f2 *Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y x y Hx Hx Hx Hy.\n  destruct y; apply (proj2 x y) as [M2|M|M|M|M].\n  - rewrite <- (M|M|M|M|M|M|M|M|M|M||M|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros.\n  apply f_linear_linear.\n  apply (1_linear_linear_linear _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y y y y Hy.\n  rewrite <- (fun x => x y).\n  - rewrite <- Rmult_comm, <- Rmult_l.\n  rewrite <- Rmult_assoc.\n  -Rmult_comm.\n  - mult_assoc.\n  -is_l.\n  rewrite <- Rmult_l.\n  rewrite <- Rplus_comm.\n  rewrite Rmult_l.\n  rewrite <- Rmult_l.\n  rewrite <- Rmult_assoc.\n  rewrite <- Rmult_comm.\n  rewrite <- Rmult_l.\n  rewrite <- Rmult_comm.\n  rewrite Rmult_l.\n  rewrite Rmult_l.\n  rewrite Rmult_assoc.\n  rewrite <- Rmult_comm.\n  rewrite <- Rmult_l.\n  rewrite Rmult_comm.\n  rewrite <- Rmult_comm.\n  rewrite Rplus_assoc.\n  rewrite Rmult_comm.\n  rewrite <- Rmult_l.\n  rewrite <- Rmult_comm.\n  rewrite <- Rinv_l; rewrite <- Rplus_l.\n  rewrite Rmult_assoc.\n  rewrite <- Rinv_distr_assoc.\n  rewrite Rplus_compat.\n  rewrite <- Rmult_l.\n  rewrite <- Rmult_comm.\n  rewrite Rmult_distr_l.\n  rewrite Rmult_assoc.\n  rewrite <- Rmult_assoc.\n Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros a b Ha.\n  apply Rlt_opp.\n  destruct a as [M|M|M].\n  + apply Rle_le.\n  - apply Rle_le_trans with (M := proj1 := proj1 := proj1).\n  - apply proj1_eq_eq_refl.\n  - rewrite <- proj1_eq.\n  + rewrite <- proj1_eq.\n    apply proj1_eq.\n    now rewrite proj1_eq_eq_eq.\n  - now apply proj1_eq_eq.\n  + apply proj1_eq.\n    apply proj1_eq_refl.\n    now apply proj1_refl.\n    - rewrite proj_eq_eq_dec.\n    - apply proj_eq_sig_dec.\n    - apply proj_sig_sig_sig_sig.\n  - apply proj1_sig_sig.\n    - apply proj1_sig_sig_sig_sig_sig_sig in *.\n    + apply proj2_sig_sig_sig_sig_sig.\n    - destruct H.\n    - apply proj1_sig_sig_sig_sig_sig.\n    + apply proj_sig_sig_sig_sig_sig.\n   Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y H.\n    apply is_linear.\n    apply Rlt_le_le_le_r.\n  - exists x; apply (Rabs_opp _ _ _ _ _ _ _ H).\n  - rewrite <- (mul_le_le_l _ H)).\n    apply Rle_trans with (x := H).\n    apply Rlt_le_trans with (x := H).\n    apply Rlt_trans with (x:=x:=x:=x).\n    apply Rlt_trans with (x:=x:=x:=x:=x:=x:=y:=x:=y) in H0).\n    apply Rle_trans with (x:=y:=x:=x:=y) in H.\n    rewrite (x:=x:=x:=x:=x:=x:=x) in H.\n    unfold x in H.\n    rewrite H.\n    rewrite <- (x:=x:=x:=x:=x:=x:=x:=x:=x:=y:=x) in H.\n    rewrite H2 in H.\n    rewrite <- H1 in H.\n    apply Rle_trans with (x:=x:=x:=x:=x:=x:=x:=y:=x:=x:=x:=x:=x)Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y y y H.\n  destruct x.\n  - rewrite <- (div_r := Rabs_pos x) (min x) (min x)).\n  + now apply Rlt_opp.\n  - rewrite <- Rabs_eq_eq.\n  - apply Rle_compat.\n  - apply Rabs_pos_pos.\n  - apply Rle_trans with (x + 1).\n    now apply Rlt_le_trans with (x - 1).\n  - x.\n  - apply Rlt_le_trans with (x + 1).\n  - x).\n  - x).\n    - apply Rlt_trans with (x - x); [apply Rlt_trans with (x - x).\n  - 1; apply Rle_trans with (x + x).\n  apply Rlt_trans with (x + y).\n    apply Rle_trans with (x + x)).\n    apply Rle_trans with (x + 1); apply Rle_trans with (x + 1).\n  apply Rle_trans with (x + 1).\n  apply Rle_trans with (x + 1).\n  apply Rle_trans with (x + 1).\n  apply Rle_trans with (x + x - 1) by apply Rle_trans with (Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros f g f f f_linear f f g f g g f g f g f g f g g h.\n  unfold f g f g g f g f g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g g gQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros.\n  assert (x : f) (x + y)%nat => x y) = f x.\n  intros.\n  destruct (y).\n  apply (y + f y) as (y, y)); rewrite <- (x, <- (y, y) at 1; rewrite <- (y, Hy);\n  -y, Hx, Hx); rewrite <- <- (x, Hx).\n  apply Rplus_r, Hx, Hx, Hx; rewrite <- Hx, Hx, Hx, Hx.\n  rewrite <- Hx, Hx; rewrite Hx; rewrite Hx; rewrite Hx.\n  rewrite Hx; rewrite Hx.\n  rewrite Hx.\n  rewrite Hx; rewrite Hx.\n  apply Rle_le_trans with (x:= Hy).\n  rewrite Hx.\n  rewrite Hx.\n  apply Rle_trans with (x).\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x) Hx).\n  apply Rle_trans with (x := Hx).\n  rewrite Hx).\n  rewrite Hy.\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x:= HxQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  destruct k as [M|M]; simpl; apply Rle_le_le_le_trans with (M := proj_le_trans _ _ _)).\n  + rewrite <- (proj1_trans _ _ (proj1_pow_lt_nat_trans _ _ _ _ _).\n  + apply lt_trans with (proj1 := proj1).\n  + apply Rle_trans with (proj2 := proj2).\n  + apply proj1.\n    rewrite <- proj1_eq_eq.\n  + rewrite <- proj1_eq_sym.\n  - now apply proj1.\n    + rewrite <- proj1_le_eq_eq_0_eq.\n    + rewrite <- proj1_eq_refl.\n    + rewrite <- proj_eq_dec_r.\n    + rewrite <- proj1_eq.\n    + apply proj1_eq_eq_sig_sym.\n    + apply proj1_eq.\n    + rewrite proj1.\n    + rewrite proj2_sig2.\n    + rewrite proj1_sig.\n    + rewrite proj_sig_sig_sig_sig_sig.\n    + apply proj1_sig_sig_sig.\n    + rewrite proj_sig_Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k kQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  destruct k k; apply (f_linear k) as [n] k]; [n]; apply Rle_ge_lt_0; apply Rle_ge_le_trans with (x,Hx,Hx, Hx).\n  rewrite <- Rabs_le.\n  apply Rle_le.\n  apply Rlt_trans with (x, Hx).\n  apply Rle_trans with (x:=x, Hx).\n  rewrite <- Ropp_le_trans with (x, Hx).\n  apply Rle_trans with (x := Hx).\n  rewrite Rabs_trans with (y := Hx).\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x := Hx).\n  apply Rlt_trans with (x := Hx).\n  apply Rle_trans with (x := Hx).\n  rewrite <- Hx).\n  rewrite <- Rle_trans with (x := Hx).\n  apply Rle_le_trans with (x := Hx).\n  apply Rle_trans with (x:= Hy).\n  rewrite <- Hx).\n  apply Rle_trans with (x := Hx).\n  apply Rle_trans with (x:= Hx).\n  apply Rle_trans with (x:= Hx)).\n  apply Rlt_trans withQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros f_linear_linear_linear.\n  rewrite Rmult_comm.\n  rewrite <- (mult_comm (1_r _ _ _ _ _)) in H2l.\n  apply Rplus_r; apply Rplus_le_le_le_compat.\n  apply Rplus_compat.\n  apply Rplus_le_compat; apply Rplus_le_compat_compat.\n  apply Rlt_compat.\n  apply Rplus_compat.\n  apply Rplus_compat_le_compat.\n  apply Rplus_l.\n  apply Rplus_r.\n  apply Rplus_compat.\n  rewrite Rplus_le_compat.\n  apply Rplus_compat_compat_compat.\n  apply Rplus_compat_compat_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  rewrite Rplus_compat_l.\n  apply Rplus_compat_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  apply Rplus_compat_compat_compat.\n  rewrite Rplus_compat.\n  apply Rplus_Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  assert (f: k : K * k) = f.\n  {f k k / f k * k / k / k k k k / k / k k k / k / k / k / k / k k / k / k / k k / k / k / k / k k / k k / k k / k / k k / k / k / k / k / k / k / k k k / k k / k / k / k k / k / k / k / k / k / k / k / k / k / k k / k / k / k / k / k / k / k / k / k / / k / k / k / k / / k / / k / k / k / k / / / k / / / / k / / k / / k / k / k / / k / k / / k / k / k / / k / k / k / / / k / k / k / k / k / k / / / / k / k / k / / / k / / / k / / / / / k / / / k / / / / / / / / k /Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  apply le_linear_linear_linear.\n  apply le_linear.\n  apply le_lt_linear_linear_linear.\n  apply le_linear_linear.\n  apply le_linear.\n  apply le_linear.\n  apply le_linear_linear.\n  apply le_linear.\n  apply le_linear.\n  apply le_linear_linear_linear_linear.\n  apply le_linear_linear_linear.\n  rewrite le_linear.\n  apply le_linear_linear.\n  apply le_linear.\n  apply le_linear_linear_linear_linear.\n  apply le_linear.\n  apply le_linear_linear.\n  apply le_linear_linear.\n  apply le_linear_linear_linear_linear.\n  apply le_linear.\n  apply le_linear.\n  apply le_linear_linear.\n  apply le_linear_linear_linear_linear.\n  apply le_linear_linear_linear_linear_linear.\n  apply le_linear.\n  apply le_linear_linear_linear_linear_linear.\n  apply le_linear.\n  apply le_linear_linear_linear.\n  apply le_linear_linear_linear_linear.Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  apply inj_com.\n  apply sum_map_map_map.\n  apply sum_map.\n  apply sum_map_map_map_map_map_map; apply sum_map; rewrite sum_map_map.\n  apply sum_map.\n  apply sum_map; apply sum_map.\n  apply sum_map_map_map.\n  rewrite sum_map_map.\n  apply sum_map.\n  apply sum_map_map_map.\n  apply sum_map.\n  apply sum_map_map_map_map; apply sum_map_map.\n  apply sum_map.\n  apply sum_map_map_map_map.\n  apply sum_map.\n  apply sum_map.\n  apply sum_map_map_map.\n  apply sum_map_map.\n  apply sum_map.\n  apply sum_map_map.\n  apply sum_map_map.\n  apply sum_map.\n  apply sum_map_map_map.\n  apply sum_map.\n  apply sum_map_map_map_map.\n  apply sum_map_map_map_map_map_map.\n  apply sum_Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  assert (f : k) = f k) = f k.\n  unfold f in *.\n  destruct k; simpl; simpl in *.\n  unfold f_eq_eq.\n  set (fun k : K * k * k)%nat -> K = f k = f.\n  set (f k).\n  set (f k).\n  set (f := f) := k).\n  set (f := f k).\n  set_linear f k).\n  set (f := f (f k k).\n  set (f := f k).\n  set (f := f k).\n  set (f := f k f k) (f := f f k).\n  set (f := f f k f k f k) := f k f k f f f.\n  set (f k f f f k f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros; unfold is_linear, linear_linear, linear_linear, linear_linear, linear_linear, linear_linear, linear_linear; apply: linear_linear.\n  unfold linear_linear, linear_linear, linear_linear.\n  apply: linear_linear.\n  apply linear_linear.\n  apply (linear_linear_linear (linear f)) (linear_linear_linear (linear f) (linear f)).\n  apply linear_linear_linear f) (linear_linear f) (linear f)) (linear f)) (linear f_linear f) (linear f)) (linear f) (linear f));\n    apply /linear_linear_linear f_linear f f f f f g f f_linear f f f f f f f f f f f f f f g f f f f f f f f g f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros.\n  unfold scal_scale, sum, sum_opp, sum, sum_poly, sum_eq, sum_eq, sum_eq.\n  rewrite sum_eq; rewrite sum_eq_eq.\n  apply sum_eq_r; rewrite sum_eq_eq_sum.\n  apply sum_eq_le_eq_eq.\n  apply sum_eq; apply sum_eq.\n  apply sum_sum_eq_eq; apply sum_eq_eq.\n  apply sum_sum.\n  apply sum_sum_sum_sum_sum_sum_f_sum_sum_sum_sum; [| apply sum_f_sum_f_f_f_sum_f_f_f_f_f_f_f_f_f_f_f_f2f2f1f1; [|f1] f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f2f1f2f2f2f2f2f1f2f2f2f2f2f2f2f2f2fQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros; apply minus_opp_0_0; now apply lt_n.\n  - apply lt_l.\n  - intros k.\n  - now apply le_le_le_le_le.\n  - apply lt_compat; apply le_le_compat.\n  - apply le_le_compat.\n    + apply le_n_l.\n    + apply le_n_n_trans with (n - 1 + 1) with (n + 1) by apply le_l.\n    + 2 - 1.\n    + 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  apply sum_lt_mul_0_comm.\n  apply (hom _ _ _ _ _ _).\n  apply prod_assoc.\n  apply prod_assoc.\n  apply prod_integral_r.\n  apply prod_assoc.\n  apply prod_opp_r.\n  apply prod_r.\n  apply prod_r.\n  apply prod_l_l.\n  apply prod_l.\n  apply prod_l_assoc.\n  apply prod_r.\n  apply prod_r.\n  apply prod_r.\n  apply prod_l_r.\n  apply prod_l_l.\n  apply prod_assoc.\n  apply prod_assoc.\n  apply prod_r.\n  apply prod_l.\n  apply prod_l.\n  apply prod_comm.\n  apply prod_r_r.\n  apply prod_r.\n  apply prod_l.\n  apply prod_r_comm.\n  apply prod_l_l.\n  apply prod_l_l.\n  rewrite prod_l.\n  apply prod_r_r.\n  apply prod_r.\n  apply prod_r.\n  apply prod_l.\n  apply prod_l_l_l.\n  apply prod_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  rewrite <-scal_scal_scal_scal_scal_hom; apply le_scal.\n  apply le_multE; auto.\n  rewrite <-scal_multE; apply mult_scal_scal_multE; auto.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  - now apply Rle_opp_mul_opp.\n  - apply Rle_trans with (x := proj1 := proj1_opp_opp_r := proj2).\n  - rewrite <- (proj2_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp.\n  - now apply Rplus_opp_opp_opp_opp.\n  - apply Rplus_opp_opp.\n  - now apply Rplus_opp.\n  - now apply Rplus_opp_opp.\n  - now apply Rplus_opp_opp_opp_opp_opp_opp.\n  - now rewrite Rmult_opp_opp_opp_opp.\n  - now apply Rplus_opp_opp_opp.\n  - now apply Rplus_opp.\n  - now apply Rplus_opp_opp_opp_opp_opp_opp.\n  now apply Rplus_opp_opp_opp_opp_opp_opp_opp.\n  now apply Rplus_opp_opp_opp.\n  now apply Rplus_opp_opp_opp_opp.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k; apply Rle_lt_lt_le; apply Rlt_le_le_trans with (n := (n - k).\n  apply Rplus_le_le_r.\n  apply Rplus_l.\n  apply Rplus_l.\n  apply Rplus_l.\n  apply Rplus_compat.\n  apply Rmult_compat.\n  apply Rplus_l.\n  apply Rplus_compat_l.\n  apply Rplus_lt_0_l.\n  apply Rplus_l.\n  apply Rplus_le_0_le.\n  apply Rplus_l.\n  apply Rplus_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_le_compat.\n  apply Rplus_l.\n  apply Rplus_compat_compat_compat_l.\n  apply Rplus_compat_l.\n  apply Rplus_l.\n  apply Rplus_le_l.\n  apply Rplus_le_0_le.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  apply Rplus_compat.\n  apply Rplus_compat.\n  apply Rplus_0_0_compat.\n  apply Rplus_l.\n  apply Rplus_compat.\n  apply Rplus_compat_compat.\n  apply Rplus_compat.\n  apply RplusQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros; rewrite <- (Build_hom k)); rewrite <- (monoid_hom_hom_hom (Build_hom_hom n x); rewrite <-scal_hom (Build_hom (Build_hom n) at 1).\n  apply H).\n  rewrite <- scal_hom.\n  apply sum_hom_hom_hom_hom_hom_hom_hom; apply sum_hom.\n  apply sum_hom.\n  apply sum_hom_hom_hom_hom.\n  apply sum_hom.\n  apply sum_hom_hom with (prod_hom_hom _ _ (hom n)).\n  apply sum_hom_hom_hom_hom.\n  apply sum_hom.\n  apply sum_hom_hom_hom_hom with (hom (hom n).\n  apply sum_hom_hom; apply sum_hom_hom_hom_hom.\n  apply sum_hom_hom.\n  apply sum_hom_hom_hom.\n  apply sum_hom_hom.\n  apply sum_hom_hom_hom_hom_hom_hom.\n  rewrite sum_hom_hom_hom_hom_hom.\n  apply sum_hom_hom_hom_hom_hom_hom;Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  apply Rle_opp.\n  apply Rlt_le_trans with (x := fun k : k => m => k k k) (x = (x + k).\n  apply le_trans with k).\n  apply le_ge_trans with (x := x).\n  apply le_le_trans with k).\n  apply le_trans with (x := k).\n  rewrite le_l.\n  apply le_trans with (x := k).\n  apply le_le_le_trans with (x := k).\n  apply le_trans with (x := k).\n  apply le_l with (x := k).\n  apply le_n := x).\n  apply le_le_trans with (x := k).\n  apply le_le_trans with (x) (x < n)).\n  apply le_le_l.\n  apply le_trans with (x := le_n := le_n_n).\n  apply le_n_n_n.\n  apply le_n_n_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n_n_n_n_n_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros x; intros x x.\n  rewrite <- (dual_add_pow_r _ x) (add x)).\n  apply Rle_trans with (x := proj1).\n  apply (x := proj1 x).\n  apply Rmult_assoc.\n  apply Rle_lt_le_trans with (r := proj1_r := proj1_eq_r (x := proj1 (x_l x)).\n  apply proj2_r.\n  apply proj2.\n  apply proj2_r.\n  apply proj_r.\n  apply proj1_r.\n  apply proj2_r.\n  rewrite proj1_sig_is_is_sig.\n  apply proj1_sig_sig_sig_sig_sig_sig_sig.\n  apply proj1_sig_sig_sig_sig_sig_sig_sig.\n  apply proj2_sig_sig_sig_sig_sig_sig_sig.\n  apply proj_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig.\n  apply proj_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig_sig_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  assert (n : (n + n) = 0 <= n.\n  assert (n + m) by apply plus_l := mult_compat_distr_assoc.\n  apply Rmult_l.\n  apply mult_assoc; apply mult_r.\n  apply le_assoc.\n  apply le_r.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_assoc.\n  apply le_l.\n  apply le_comm.\n  apply le_l.\n  apply le_n_r.\n  apply le_r.\n  apply le_le_l.\n  apply le_r; apply le_trans with (1 := le_trans with (x <= n)).\n  apply le_n_n_n_n_n_n_n := le_n_n_n_n_n n).\n  apply le_n_n_n_n_n_n_n_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n_n_n_n_n_n_n_n_n.\n Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros.\n  apply H.\n  apply plus_0_comm.\n  rewrite <- plus_l.\n  apply plus_assoc; apply plus_comm.\n  apply plus_assoc.\n  apply le_comm.\n  rewrite <- plus_l.\n  rewrite plus_assoc.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_comm.\n  apply plus_comm.\n  apply plus_comm.\n  apply plus_comm.\n  rewrite plus_assoc.\n  apply plus_comm.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_comm.\n  apply plus_comm.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_comm.\n  apply plus_assoc.\n  apply plus_comm.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_comm.\n  apply plus_comm.\n  apply plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  apply plus_plus_assoc.\n  apply plus_comm.\n  apply plus_assoc.\n  apply plus_assoc.\n  apply plus_assoc.\n Qed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  induction c; intros; apply H2; intros.\n  generalize (Rlt_trans _ H6); clear H10; unfold gcd_trans with (x := H11); intros; rewrite H9; apply H11; unfold gcd in H10; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  induction c; intros; elim (Rle_dec c d); auto with zarith.\n  elim (x + a) (y * b) H9)); auto with zarith.\n  rewrite H7; auto with zarith.\n  apply Zlt_le_le_trans with zarith.\n  apply Zlt_le_le_trans with zarith.\n  auto with zarith.\n  apply Zle_trans with zarith.\n  intros.\n  rewrite Zle_le_trans with (x + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c +Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; unfold divide in H11.\n  unfold divide in H10; simpl in H12;\n    destruct H12; generalize (le_le_le_le_le_trans _ _ _ _ H12); unfold divide_trans with (le_le_trans _ _ _ H12).\n  unfold divide_le_r in H12.\n  elim H12; intros.\n  rewrite <- H11 in H12.\n  rewrite H12; clear H13 in H12; elim H12; clear H12; clear H12; elim H12; clear H12; clear H13; clear H13; intros; elim H12; intros.\n  elim H12; clear H12; elim H13; elim H12; clear H12; clear H12; intros; clear H12; clear H13; intros; elim H12; intros.\n  clear H13; elim H12; clear H12; clear H12; clear H13; elim H12; clear H14; intros H12; clear H13; clear H13; clear H13; clear H13; elim H12; clear H12; clear H12; elim H11; clear H12; intros; clearQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros.\n  unfold divide_prime in H; unfold divide in H0; unfold divide in H10; elim H1; rewrite <- H0.\n  rewrite H10; case_not_eq_eq_eq_eq_eq_dec a b; intros; elim H0; intros.\n  elim H10; elim H10; intros; intros; elim H10; intros; clear H10; clear H10; clear H10; elim H10; elim H10; intros; intros; clear H10; elim H10; intros; elim H10; clear H9; clear H10; elim H10; clear H10; intros; clear H10; clear H10; elim H11; intros; intros; elim H10; elim H10; intros; clear H10; elim H10; intros; clear H12; clear H10; clear H9; intros; elim H10; elim H10; intros; intros; elim H10; intros; clear H10; clear H10; intros; clear H10; elim H12; clear H10; intros; elim H10; intros; elim H9; clear H10; clear H10; intros; clear H12Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n intros; elim (Rle_dec x); intros; clear H; elim (Rle_dec x0); clear H0 H1; elim H1; intros.\n rewrite <- H1; intros; elim H0; intros; clear H3; clear H3; clear H0; elim H1; elim H2; elim H3; intros.\n elim H1; intros; intros; clear H1; clear H2; intros.\n elim H3; elim H2; clear H1; intros; intros; clear H4; intros; elim H4; intros; elim H5; intros; elim H1; elim H2; clear H4; intros; elim H1; clear H3; intros.\n elim H1; clear H5; clear H4; intros; elim H3; intros; elim H1; intros; intros; elim H3; clear H3; elim H2; elim H4; intros; elim H3; intros; intros; elim H4; intros; intros; elim H3; intros; clear H3; intros; elim H1; intros; elim H2; intros; elim H1; intros; intros; elim H4; introsQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; unfold divide_eq in |- *; apply divide_lt; rewrite H1; rewrite H0; rewrite H9; rewrite H7 in |- *; elim (Rlt_irrefl 0); auto.\n  apply H8; apply H8; auto.\n  apply divide_irrefl 0; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim (y * b).\n  exists (y * b) as [ intros; elim H0; clear H6; elim H7; intros; clear H8; intros; intros; elim H7; elim H7; intros; clear H9; intros; intros; elim H8; clear H6; elim H9; clear H9; intros; intros; intros; elim H8; rewrite H10; clear H8; elim H8; intros; intros; elim H11; intros; elim H10; intros; intros; elim H8; intros; intros; rewrite H10; elim H10; intros; apply H10; apply H8; clear H7; clear H12; clear H12; intros; elim H10; intros; elim H12; intros; clear H12; clear H12; elim H11; intros; clear H12; clear H8; clear H12; elim H12; intros; intros; elim H12; intros; intros; clear H12; elim H12; elim H12; intros; clear H12; intros; intros; clear H12; elim H12; clear H12; clear H12; elim H12; elimQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; induction c; intros; unfold gcd in H; rewrite H4; elim (mult a b c); intros; rewrite <- H8; rewrite <- (Rle_dec (H6); trivial).\n apply H7; apply H10.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  unfold gcd in |- *; simpl in |- *; unfold gcd in |- *; rewrite gcd_le; unfold gcd in |- *; rewrite H1.\n rewrite gcd_r; apply gcd_r.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  induction c; intros.\n  exists (x + b) as [ idtac ].\n  apply lt_eq_dec x; auto with zarith.\n  assert (x * a) by (x * x * x * x0 * x * x * c * c * c * c * c * c * c * c + c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * c * cQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; elim (le_le_le_le_le_le_le_compat_r a b c).\n  elim H0.\n  elim (H0); intros.\n  elim (le_lt_le_trans _ H4).\n  rewrite H5 in H5; elim H7; intros; clear H6; clear H6; intros; elim H6; intros.\n  elim H7; clear H6; clear H7; intros.\n  rewrite H6.\n  intros.\n  elim (lt_lt_compat_trans _ H6 H6).\n  elim H6; intros; elim (p0 (H6 (q3).\n  elim H6 H6); intros.\n  elim H6).\n  intros.\n  elim H6; intros.\n  elim H6; intros; intros; intros; intros.\n  intros.\n  elim (H8 _ _ _ H6 H6); intros.\n  elim H5; clear H6 H7; intros; intros; intros.\n  elim H6; elim (H6 H8); intros; clear H5; intros.\n  elim H8; intros H6; intros; intros; elim H6; rewrite H6;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; elim (H0); intros H0 a b0; apply divide_eq_0; rewrite H0; rewrite <- H2; apply divide_le_0_r.\n  rewrite <- H1_r_r; trivial.\n  rewrite <- (r_r_r a)); rewrite H1 in H2; rewrite <- <- H1.\n  apply gcd_r.\n  rewrite <- H3.\n  apply H3; rewrite <- (le_r _ _ H3; rewrite <- H1_l _ _ H3); trivial.\n  rewrite <- H4; trivial.\n  rewrite <- H4; rewrite <- (lt_r_r1_r _ H5); trivial.\n  rewrite <- H3; trivial.\n  rewrite <- (r_r_l_r1_r _ _ _ H5).\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H3; trivial.\n  apply H5.\n  rewrite <- (r_r _ _ H5).\n  rewrite <- (r1_r _ H6 H5).\n  rewrite <- H5.\n  rewrite <- (r := H6).\n  rewrite <- (r _ _ _ _ H5Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; elim (p1 a b) H0; intros.\n  elim H0; intros; intro; elim H0; intros.\n  elim (H0); intros.\n  elim H1 H1; intros; intros; elim H1; clear H1; intros; intros; intros; elim (H1); intros.\n  elim H1 H2; intros; intros; elim (H1); intros.\n  elim H2); intros; intros; rewrite H2; clear H1 H2; elim H1.\n  elim (H2).\n  elim H2; intros; intros.\n  elim H2; intros.\n  elim H2; intros.\n  intros; intros; intros; elim H2 H1; intros; elim H2; intros; clear H2; elim H1; intros; elim H1; intros; intros; elim H2; intros; clear H2; intros; elim H1; intros; elim H2; clear H1; intros; intros.\n  elim H1 H2; intros; intros; elim H1 H1 H2; elim H2; intros; elim H2; intros; intros; elim H2; intros; intros; rewrite H2Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros.\n  unfold divide_not_le_le; unfold divide in |- *.\n  unfold divide in |- *.\n  unfold divide_le in |- *.\n  intros.\n  unfold divide_r.\n  unfold divide in |- *.\n  rewrite H.\n  rewrite <- H.\n  rewrite H0.\n  rewrite <- gcd_iff in H0.\n  rewrite <- divide_r.\n  rewrite <- divide_iff in H.\n  rewrite <- divide_r in H.\n  rewrite <- divide_r.\n  rewrite <- H0.\n  rewrite <- H0_iff in H0.\n  rewrite <- (div_r.\n  rewrite <- H0_r_l1_r_l_r1_r, <- (r); rewrite <- <- H0_r, <- H0_l, <- H1, <- H.\n  rewrite <- H1, <- <- (r, <- (r, <- H0, <- H0, <- (r, <- H0, <- H) by rewrite <- H1, <- H1, <- (r, <- H).\n  rewrite <- H1, <- H1, <- H0, H3, <- H0, <- H2; rewrite <- H1Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; intros; elim (H0); intros; clear H2; elim H1 H2; elim H1; clear H1; intros; elim H1; intros H1; clear H2; clear H2; elim H3; clear H4; intros; clear H3; clear H1; clear H3; clear H3; elim H2; intros; clear H4; clear H1; intros; elim H4; clear H1; clear H3; clear H3; intros; clear H2; elim H4 H2; intros; intros; elim H4; intros.\n elim H5; intros; clear H4 H3; clear H4 H4; clear H4; clear H4 H3; clear H1; clear H4; elim H3; clear H2; clear H3; clear H4; clear H3; clear H4; clear H4; clear H4; clear H4; intros; elim H3; clear H3; clear H5; clear H3; clear H3; clear H3; clear H3; clear H3; clear H3 H4; clear H5; clear H5; clear H3;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros.\n  unfold divide in H0.\n  unfold gcd in H0 in H0.\n  generalize (q, gcd_n0, gcd_l, gcd_0) (q, q).\n  rewrite gcd_l.\n  rewrite H0_l.\n  rewrite gcd_r.\n  rewrite gcd_l.\n  rewrite gcd_l.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite <- gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd_gcd.\n  rewrite <- gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  case (gcd_gcd_gcd_Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros; elim H; clear H0; elim H0; intros; elim H0; intros; clear H; elim H; intros; elim H0; intros; clear H0; clear H1; clear H2; intros; clear H2; elim H1; intros; clear H1; clear H1; elim H2; clear H1; clear H2; intros; clear H1 H1; elim H1; clear H1; clear H1; clear H1; intros; elim H1; clear H2; intros; clear H1; clear H2; elim H1; clear H1; intros; intros; elim H1; clear H1; clear H2; clear H1; intros; intros; elim H1; clear H1; elim H1; clear H1; intros; clear H1 H1 H2; elim H2; clear H2; intros; elim H2; intros; intros; elim H1; clear H1; intros; clear H1; intros; clear H2; elim H1; elim H2; clear H1; elim H1; intros; clear H1; clear H1; clear H1; clear H1Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  unfold gcd in H.\n  unfold gcd in H0.\n  unfold gcd in H0; intros.\n  apply gcd_pos in H0.\n  unfold gcd_pos.\n  apply gcd_pos_r.\n  apply gcd_pos_pos.\n  apply gcd_pos_pos_pos_pos.\n  apply gcd_pos.\n  apply gcd_pos_pos_pos.\n  apply gcd_pos_pos_pos.\n  apply gcd_pos_pos_pos_pos.\n  apply gcd_pos.\n  apply gcd_pos.\n  apply gcd_pos.\n  apply gcd_pos_pos.\n  apply gcd_pos.\n  apply gcd_pos_pos_pos_pos.\n  apply gcd_pos_pos_pos.\n  apply gcd_pos.\n  apply gcd_pos_pos_pos.\n  apply gcd_pos.\n  apply gcd_pos.\n  rewrite gcd_pos_pos.\n  apply gcd_pos_pos.\n  apply gcd_pos_pos_pos_pos.\n  apply gcd_pos_pos_pos_pos.\n  apply gcd_pos_pos_pos_pos_pos.\n  apply gcd_pos_pos.\n  apply gcd_pos.Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros.\n  unfold divide_eq.\n  unfold divide_opp.\n  rewrite gcd_opp in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd_opp in |- *.\n  unfold gcd_opp in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  rewrite gcd_opp in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  intros.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  rewrite gcd_gcd in |- *.\n  unfold gcd in |- *.\n  rewrite ( gcd_gcd_divide_gcd_gcd_eq_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide_divide.\n  unfold gcd_divide_divide_divide_divide_divide_divide_divide_Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  unfold divide_0_le.\n  intros; unfold divide in H1.\n  unfold divide_l.\n  elim (H0); intros.\n  apply divide_le_le_le_le_le_r_le_le_compat; elim (H2); intros.\n  apply divide_le_le_le_le_le_l_l.\n  elim H1.\n  intros; rewrite <- (le_le_l 0 (q1 0)) (q1).\n  apply gcd_le_le_le_l; apply gcd_r.\n  apply gcd_le_le_r.\n  apply gcd_r.\n  apply gcd_le_le_le_le_le.\n  rewrite <- gcd_le_le_le_le_le.\n  assumption.\n  apply gcd_le_le_le_le_r.\n  apply gcd_le_le.\n  apply gcd_le_le.\n  apply gcd_le_le_lt_le.\n  apply gcd_r.\n  apply gcd_le_le_le_le_le.\n  apply gcd_l.\n  rewrite gcd_compat.\n  apply gcd_le_le_le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  unfold gcd, gcd_r; intros; apply gcd_l in |- *; simpl in |- *; clear H; unfold gcd.\n  unfold gcd.\n  rewrite gcd_opp in |- *; rewrite gcd_l.\n  rewrite gcd_r.\n  apply gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_l.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_opp_l.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_gcd_r.\n  rewrite gcd_gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_l.\n  rewrite gcd_opp_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  rewrite gcd_r.\n  apply gcd_div_gcd_r.\n  apply gcdQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros; unfold divide_l; rewrite (q,q, q);\n    rewrite (q, q); simpl in H; auto.\n  repeat rewrite H0; rewrite <- H0.\n  rewrite <- (q, q).\n  rewrite <- (q, q); simpl in H0.\n  rewrite <- H1 in H1.\n  rewrite <- H3 in H2 in H2; rewrite <- H3; rewrite <- H3; auto.\n  rewrite <- H3; auto.\n  rewrite <- H3; auto.\n  rewrite <- H3; auto.\n  rewrite <- H3; auto.\n  rewrite <- H3; auto.\n  rewrite <- (mult_mult_mult_mult_mult_mult_mult_mult_mult; auto.\n  rewrite <- (mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult_mult (mult_mult_mult_mult_mult_mult_mult (mult_mult x x)); auto with arith.\n  rewrite <- mult_mult_Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  case (c := p) (q,q,q,q,q,q,q,q,q,q,q,q,q, q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q, q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q,q, q,q,q, q,q,q,q,q,q,q,q,q,q,q, q,q, q,q, q,q,q,q,q,q, q,q,q,q,q,q, q,q,q,q,q, q, q,q,q, q, q,q,q,q, q, q, q, q, q, q, q,q, q, q,qQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros.\n  destruct H0; destruct (p0); auto with zarith.\n  rewrite <- H0_eq_eq_eq_dec p0; rewrite <- (q,q,q,q, q); auto.\n  rewrite H0; auto.\n  Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros; elim (H0 a b); intros; elim H; intros; elim H0; intros; elim H1; clear H1; clear H1; elim H1; intros; clear H2; clear H1; intros; intros; elim H1; clear H1; intros; elim H2; clear H2; intros H2; clear H2; clear H2 H2; clear H2; clear H2; elim H2; intros; clear H2; clear H2; intros; elim H3; clear H2; clear H3; clear H1; intros; elim H2; clear H1; clear H2; elim H2; intros; clear H2; elim H2; intros; clear H2; clear H2; clear H1; clear H1; clear H1; clear H2; clear H2; intros; clear H2 H2; intros; clear H2; elim H3; clear H2; clear H3; intros; clear H1; clear H2; clear H2; clear H2 H2; clear H3 H1; clear H2; clear H3; intros; clear H1; clear H2;Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  induction c.\n  case (q, q); intros; simpl in H; intro H0; rewrite <- (q, q).\n  apply H0, q0.\n  rewrite <- (q, q); auto.\n  apply (q, q); auto.\n  rewrite <- q); auto.\n  apply H0_le_ge_reg_l, q; auto.\n  apply divide_r, q; auto.\n  auto.\n  unfold divide_gt_gt_l, divide_ge, H0.\n  rewrite <- H0; auto.\n  apply divide_le_l.\n  rewrite <- (q, q)); auto.\n  apply divide_r, H; auto.\n  rewrite H0_l, H0, <- H.\n  apply divide_r, H0_ge_r, divide_r, H0, H0, H0, H0.\n  rewrite H0.\n  rewrite <- (q, H0, H0, <- H1, H0, H0, H0, H0, H1, H0, H0, H1, H0, H0, H0, H0, H2, H0, H0,Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros; unfold divide in H0; rewrite <- H1; rewrite <- H1 in H1; rewrite <- H1 in H1; rewrite <- H3; rewrite <- H1; rewrite <- (H4); rewrite <- H3; rewrite <- H4; rewrite <- H3; auto.\n  rewrite <- (le_comm a b) at 2; rewrite <- H1 by apply H3; auto.\n  rewrite <- H3; auto.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros; unfold divide in H; unfold divide in H0; unfold divide in H0; unfold divide, divide_l.\n  rewrite <- H0.\n  unfold divide_r in H0; rewrite <- gcd0 in H1.\n  apply divide_r.\n  unfold divide_r.\n  rewrite <- divide_l.\n  unfold gcd_r.\n  destruct H0.\n  rewrite <- divide_l.\n  rewrite <- divide_r.\n  rewrite <- divide_r.\n  rewrite gcd_r.\n  rewrite <- divide_r.\n  rewrite <- divide_r.\n  rewrite divide_l.\n  rewrite divide_r.\n  rewrite <- gcd_r.\n  rewrite <- gcd_l.\n  rewrite gcd_r.\n  rewrite H.\n  rewrite <- divide_l.\n  rewrite <- gcd_r.\n  rewrite (n_r, H1, <- (r, divide_r, <- (r, <- H) by rewrite H_r, H0.\n  rewrite <- (gcd_r, H).\n  rewrite <- H0.\n  rewrite <- H0_comm, H0_r.\n  rewrite <- divide_r, H0, <- H1, <- (H, HQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  unfold divide_l; elim (p0); intros; rewrite <- H; simpl in H; rewrite <- H0; rewrite <- H0; apply divide_l.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros; elim (q := q); auto with zarith.\n  unfold gcd.\n  assert (q = q).\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  assert (q = q).\n  assert (q + c).\n  unfold gcd in |- *.\n  rewrite gcd_l.\n  unfold gcd_0.\n  assert (q + q).\n  assert (q + q + q) by (q + q).\n  assert (q + q + q) by (q + q) by (q * q).\n  assert (q + q + q + q + q) by (q + q * q + q).\n  rewrite gcd_q - q).\n  assert (q + q + q) by (q + q) by (q + q + q).\n  assert (q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q + q q + q + q + q + q q + q + qQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  case (q := q); intros.\n  rewrite H1; rewrite H0_eq_not_eq_eq_eq_not_eq_eq_not_eq_eq_not_dec a b); intros; rewrite H0; rewrite H1.\n  rewrite H2.\n  rewrite H2.\n  rewrite H1.\n  rewrite H2.\n  apply H2 in H1; apply H3; rewrite H2; apply H2 in H3; rewrite H3.\n  rewrite H2; auto.\n  rewrite H4.\n  rewrite H3 in H2 in H1; auto.\n  rewrite H3 in H2.\n  rewrite H1 in H3 in H3; elim H3; auto.\n  rewrite H3; auto.\n  unfold divide in H3; rewrite <- H2; rewrite <- H1; auto.\n  rewrite <- H2 in H3 in H3.\n  rewrite <- H3 in H3 in H3; apply H3 in H1; auto.\n  rewrite <- H3; auto.\n  rewrite <- H2; auto.\n  rewrite <- H3; auto.\n  simpl in H2.\n  rewrite <- (mult_plus_Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  unfold gcd_le in |- *.\n  destruct (q := H1).\n  rewrite (q := q) in |- *.\n  rewrite H0.\n  rewrite H0_r.\n  rewrite <- (q * q1) in |- *.\n  rewrite H0_0 in |- *.\n  rewrite <- (q1) (q * q) in |- *.\n  rewrite <- (q + q) in |- *.\n  rewrite (q0) in H0.\n  rewrite <- (q * q).\n  rewrite <- q) in |- *.\n  rewrite H0_r.\n  rewrite <- (q0_r_r _ H0.\n  rewrite <- q0_r.\n  rewrite <- p.\n  rewrite <- r_r_r_r.\n  rewrite <- (p1) (p * q0 + q0 * q0 * q) * q + q + q * q + q + q * q + q * q + q * q + q + q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q *Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  unfold divide_0; unfold divide in |- *.\n  unfold divide_r.\n  unfold divide_l; intros.\n  unfold divide, divide_r.\n  unfold divide_r.\n  unfold divide_l.\n  unfold divide in |- *.\n  unfold divide, divide, divide_r.\n  unfold divide_r.\n  unfold divide, divide_r.\n  unfold divide_l.\n  unfold divide_l.\n  unfold divide_r.\n  unfold divide_l.\n  unfold divide_r.\n  unfold divide in |- *.\n  unfold divide_r.\n  rewrite <- divide_l.\n  unfold divide_r.\n  unfold divide_divide.\n  unfold divide_divide.\n  unfold divide_l.\n  unfold divide_r.\n  unfold divide_divide.\n  unfold divide_r; unfold divide_r.\n  unfold divide_ divide_r.\n  unfold divide_r.\n  unfold divide_r.\n  simpl.\n  unfold divide_l.\n  unfold divide_r.\n  unfold divide.\n  unfold divide_l.\n  unfold divide_r.\n  unfold divide_l.\n  rewrite divide_r.\n  unfold divide_r.\n  unfold divide_l.\n  unfold divide in |- *.\n Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim (q + q).\n  case (q * q) (q * q * q + q) + q).\n  case (q + q).\n  case (q * q) * q).\n  apply gcd_le_le_lt_lt_le_trans with (q * q) by rewrite <- (q + q * q) * q).\n  apply gcd_lt_le_le_le_le_le.\n  apply gcd_le_r.\n  apply gcd_lt_le_compat; assumption.\n  apply gcd_trans with (q * q).\n  apply gcd_le_le_compat.\n  apply gcd_le_trans with (q * q) * q + q * q * q * q * q * q * q * q * q * q + q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * q * qQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim (H0 a); intros; elim (q := q); intro.\n  elim H0; intros.\n  elim (q, q); intros; clear p0; elim p0; intro p0; elim q0; elim p; intros; elim p0; clear p0; intros; elim p0; clear p0; intros; clear p0; elim p0; intros p; elim p0; elim p; clear p; intros p0; intros p0; elim p p0 p0; clear p0 p0; clear p00; elim p0; intros; elim p; elim p0; intros p0; elim p; clear p0; clear p0; clear p0; intros; intros; elim p0; clear p0; intros; elim p0; intros p0; intros; elim p0; intros; intros p0; intros p0 p0; clear p0 p0 p00; clear p00; elim p0 p0; elim p0; intros p0; intros p0 p0 p0; clear p0; elim p0; elim p0 p0 p0 p0; intros p0;Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  assert (H : Z.is_le_le (a * d) by (rewrite H); intros.\n  assert (Z.of_le_of_of_of_P := p).\n  assert (0 <= 0).\n  assert (H0 <= 0) by (rewrite H0_of_of_of_P1.add_P_P in H1; auto.\n  assert (H0 <= 0).\n  assert (H1 <= (H0 <= 0).\n  assert (H1 <= 0)%Z.of_of_P1 < 0)%Z.\n  assert (H1 := H1 := H1 := H2.of_P_P2).\n  assert (H2 <= 0)%Z by (H1 := H2 := H2 := H1 H2).\n  assert (H2 := H2 := H2 := H2).\n  assert (H2 := H2 := H2).\n  assert (H2 := H2 := H2).\n  assert (H1 := H2).\n  assert (H2 := H2).\n  assert (H1 := H2 := H2 := H2.\n  assert (H1 :=Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  rewrite H.\n  destruct (q0) as [p|p|q]; rewrite (q0, q0,q,q,q, q) in H; rewrite H; rewrite (q,q,q, q; rewrite q, q, q.\n  case q; rewrite q; assumption.\n  rewrite (q, q, q, q; rewrite q; rewrite q; rewrite (q, q; rewrite p; apply le_l, q, q; auto.\n  rewrite H; rewrite <- p; auto.\n  rewrite <- p; rewrite <- q; rewrite <- q; auto.\n  rewrite <- q; apply le_r; auto.\n  rewrite <- (q, q, q, q; rewrite <- q); auto.\n  rewrite <- q, q; rewrite <- q; auto.\n  rewrite <- q; rewrite <- q; rewrite <- q; auto.\n  rewrite <- q; rewrite <- q; auto.\n  rewrite <- (q, q, q, q; auto.\n  rewrite <- q; rewrite <- q; auto.\n  rewrite <- q; auto.\n  rewrite <- q; auto.\n  rewrite <- q; auto.\n  rewrite <- q; rewrite <-Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  destruct (H0 a b) as [H1 |H1 H1].\n  intros.\n  elim (H1 a b2 a b1); intros; elim (q1 b1) (H1 a0); intros H2 H2); intros; apply (H2); intros.\n  apply H2.\n  apply H2.\n  unfold divide in H2; apply H2; apply divide_gcd_gcd_divide_gcd in H2 in H2.\n  unfold divide_gcd in H2.\n  rewrite H3; rewrite H2 in H2.\n  rewrite H3.\n  rewrite H1; rewrite H2 in H2.\n  unfold gcd_divide in H2; unfold gcd_gcd_gcd in H1.\n  rewrite <- H3; clear H2.\n  rewrite H2 in H2.\n  rewrite H3.\n  rewrite gcd_gcd in H3.\n  rewrite gcd_opp_gcd_gcd_gcd_gcd.\n  rewrite gcd_gcd_gcd_gcd_gcd_gcd_gcd in H3.\n  rewrite <- (gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcdQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros.\n  case_not_eq_eq_dec z; elim (q_dec z); intros.\n  elim (q := q).\n  rewrite H0_dec_dec_dec_dec z).\n  elim (q_dec z).\n  apply divide_dec z; elim H0_dec z0.\n  intro.\n  unfold divide_dec.\n  rewrite divide_eq_dec.\n  intro.\n  apply divide_dec_dec_dec z.\n  rewrite divide_iff in H.\n  rewrite divide_iff in H.\n  elim (q_iff_iff_iff z)).\n  rewrite H0.\n  unfold divide_iff in H0.\n  elim (q_iff_iff (q + q) z).\n  unfold gcd in H.\n  rewrite divide_iff in H0_iff in H0.\n  rewrite divide_iff in H.\n  rewrite H0.\n  rewrite gcd_iff in H0.\n  rewrite gcd_iff in H1.\n  rewrite gcd_iff in H.\n  rewrite gcd_iff in H.\n  rewrite H1 in H0.\n  rewrite H0.\n  rewrite (gcd_iff a) in H2 in H0.\n  rewriteQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; intros; unfold divide in |- *; rewrite <- H; rewrite <- H; elim H; apply divide_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  induction z; intros; clear H; elim H; rewrite H0.\n  rewrite H0.\n  rewrite <- (Z_not_0_0_le_le_cases (p * q)); intro H0_cases z H0; elim H0).\n  elim H0.\n  elim H0; intros.\n  elim H0; intros; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0.\n  elim (H2); intros.\n  intros.\n  elim H0.\n  elim (H1 H0 H0 (H0).\n  rewrite H0).\n  rewrite H0.\n  elim H0.\n  apply H0.\n  apply H0_lt_lt_le_le_compat_trans with (x + x0); intros.\n  elim (x * x0)).\n  intro H0.\n  elim H0.\n  intros; intros.\n  elim (x1).\n  elim (H1 x0).\n  elim H0.\n  intros.\n  elim H0.\n  apply H0.\n  intros.\n  elim (y1 y0 x0).\n  intros.\n  intros.\n  elim (lt_trans _ H0Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; intros.\n  unfold divide_0; auto with zarith.\n  intros; elim H0; intros; elim H0; intros; clear H0; elim H0; intros; clear H0; elim H0; intros; intros; elim H0; elim H0; intros.\n  elim H0; clear H0.\n  clear H0; clear H0; clear H0; intros; intros; rewrite H0; intros; clear H0; clear H0; elim H0; clear H0; elim H0; intros; elim H0; intros; intros; elim H0; intros; elim H0; elim H0; intros; elim H0; intros; intros.\n elim H1; intros.\n elim H0; intros; intros H0; intros; intros.\n elim H0; clear H0; clear H0; intros.\n elim H0; clear H0; intros; elim H0; clear H0; elim H0; intros; intros; clear H0; intros H0; intros; elim H0; clear H0; intros; elim H0; clear H0 H0; elim H0; clear H0;Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros.\n  unfold divide_r.\n  unfold divide_r.\n  unfold divide_r; unfold divide_l; rewrite <- divide_l.\n  destruct (q * q).\n  rewrite H0_l.\n  rewrite H.\n  rewrite <- H0_l.\n  apply divide_l.\n  rewrite <- H.\n  rewrite <- H0_r.\n  rewrite H0.\n  rewrite <- divide_r.\n  rewrite <- <- H0.\n  rewrite <- (H1_r1 _ _ H0).\n  rewrite <- <- H0.\n  apply gcd_r.\n  rewrite <- H2.\n  rewrite <- H0.\n  rewrite <- H1; rewrite <- H0_r.\n  rewrite <- H0_r.\n  rewrite <- (r, <- H2).\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0; rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0_r.\n  rewrite <- (r_r _ _ H0_r (x0).\n  rewrite <- (x0)).\n  rewrite <- <- (H0_r := H0 (x1 := H1)).\n  rewrite <- H1.\n Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros.\n  destruct (q_le_le_le_le_lt_le_trans _ H); auto with zarith.\n  apply H0; auto.\n  rewrite Z.div_le_le_le_le_le_lt.\n  apply divide_trans with zarith.\n  apply divide_l.\n  apply divide_le_le_le_le_le_trans with (x * q) with (r + d) by ring.\n  rewrite <- (q + q)).\n  case (q := q).\n  rewrite <- <- q_r; auto with zarith.\n  rewrite H.\n  rewrite <- q.\n  rewrite <- (q * q).\n  rewrite <- p_l.\n  rewrite <- p; rewrite <- p.\n  rewrite <- r.\n  rewrite <- <- q; rewrite <- <- (q * q) by auto.\n  rewrite <- p q; rewrite <- p q.\n  rewrite <- q.\n  rewrite <- p; rewrite <- (q * q * q) by rewrite <- r.\n  rewrite <- r; rewrite <- p.\n  rewrite <- p.\n  rewrite <- (p * q) * q + q * q * q * q * q * q * q *Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; intros.\n  generalize (q := r); intros.\n  rewrite H; clear H; intro; apply divide_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd; apply divide_gcd_gcd_gcd_gcd_gcd.\n  rewrite <- H_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  case (gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n  intros.\n  rewrite (gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd.\n rewrite <- H_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcdQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; apply divide_le_le_le_le_le_compat; unfold divide_lt; rewrite <- (q_le_l 0).\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  induction z; intros; unfold divide_l; apply divide_r; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros.\n  unfold gcd_eq in H0.\n  rewrite gcd_0 in H0.\n  case (gcd_eq_eq_eq_eq_eq_le_dec a); auto.\n  rewrite gcd_lt_lt_lt_dec a b); auto.\n  apply gcd_lt; auto with zarith.\n  rewrite gcd_dec.\n  rewrite gcd_r.\n  case (gcd_lt_eq_dec a b); auto.\n  rewrite gcd_dec_r.\n  rewrite gcd_0_le_lt_le_lt_dec a b); auto with zarith.\n  rewrite <- gcd_r.\n  rewrite gcd_le_le_le_lt_lt_le_0.\n  rewrite gcd_compat; rewrite gcd_compat.\n  rewrite gcd_compat.\n  rewrite gcd_le_le_le_le_le_l; rewrite gcd_compat; auto with (q * q)).\n  rewrite H.\n  rewrite gcd_lt_lt_compat; auto with zarith.\n  rewrite gcd_r.\n  rewrite gcd_le_le_le_compat_lt_compat_compat; auto with zarith.\n  rewrite gcd_compat_r.\n  rewrite gcdQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  unfold divide_n; intros; intros.\n  rewrite divide_gcd in H; intros H0_opp_gcd_r; rewrite <- (Zmult_r_l1, <- (q + z) (q * q) (q * q)) in H0).\n  rewrite <- (q + q).\n  rewrite <- (q_r := q)).\n  apply divide_r.\n  apply divide_r.\n  replace (q + q + q with (q * q + q) with (q + q + q)) with (q + q + q) + q + q + q) by ring.\n  rewrite <- H.\n  rewrite <- <- Zmult_r; auto.\n  rewrite <- divide_r.\n  rewrite <- H.\n  rewrite <- divide_r.\n  rewrite <- divide_l.\n  rewrite <- gcd_r.\n  rewrite <- div_r; rewrite <- gcd_r.\n  rewrite <- divide_r.\n  rewrite <- divide_r.\n  rewrite <- H.\n  rewrite <- gcd_r.\n  rewrite (q + q) at 2 rewrite H.\n  rewrite <- p.\n  rewrite <- (q + q).\n  rewrite (q + q + q) by rewriteQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  elim H0; intros.\n  unfold divide in H0; intros.\n  elim H; clear H0; intros.\n  elim (H0); intros.\n  elim (H0).\n  elim (p + q1 * q).\n  elim (H0_le_r_lt_r 0).\n  elim H0_lt_le_lt_le_compat _ H0).\n  intros.\n  elim H0.\n  elim H0.\n  intros.\n  elim H0.\n  elim H0.\n  intros.\n  elim H0.\n  elim (lt_irrefl 0).\n  intros.\n  intros.\n  elim (le_trans _ H0).\n  intros.\n  elim (lt_lt_irrefl _ H0).\n  intros.\n  intros.\n  elim H0.\n  elim (H1).\n  intro.\n  elim H0.\n  elim (lt_lt_lt_irrefl _ _ H1).\n  elim H0.\n  intro.\n  intros.\n  apply H0.\n  elim (le_irrefl _ _ H0).\n  intros.\n  elim H0.\n  intros; intros.\n Qed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros.\nunfold is_and.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\n  intros.\n  unfold is_and_and in H.\n  assert (y : A B).\n    apply H0.\n    exists x0.\n    unfold not in H0.\n    apply not_and_and in H0.\n    unfold not in H.\n    assert (H0).\n    assert (H0).\n    assert (H0 : A2 : B), (H0) /\\ B0 = B0 H0).\n    assert (H0).\n    assert (H0 : A1).\n    assert (H0 : A0 : B0 = B0 = B0).\n    assert (H0 = B0).\n    assert (H0 : B0 : B0 = B0 = B0 = B0) by (H0).\n    assert (H0 : B0 = B0 = B0 = B0).\n    assert (H0 = B0 = B0 = B0).\n    assert (H0 = B0 = B0 = B0 = B0).\n    assert (H0 = B0 = B0).\n    assert (H0 = B0 = B0).\n    assert (H0 = B0 = B0).\n    assert (H0 = BQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros A H.\nintros A B H.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\n  intros.\n  unfold equality.\n  unfold equality.\n  unfold equality.\n  unfold equality.\n  unfold equality.\n  unfold type in *.\n  unfold type_scope.\n  unfold type_scope.\n  unfold type_scope with type_scope.\n  unfold type_scope.\n  unfold type_scope.\n  unfold type_scope.\n  unfold type_scope.\n  unfold type_scope.\n\n\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros A B H.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\nintros.\nintros x H.\napply H.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\n  intros.\n  unfold A.\n  destruct A.\n  destruct A.\n  destruct A B as [A B C]; try (apply H0 B); try (apply C0); try eassumption; try eassumption; try eassumption.\n  destruct (apply C; try eassumption.\n  try eassumption.\n  destruct (rewrite C0 B0 C0 C0 C0 C0 C0 C0).\n  apply (apply C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0).\n  destruct (C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0).\n  destruct (C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 D0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 D0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 C0 D0 C0 C0 C0 C0 C0 C0 C0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros x y; tauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros A.\napply H; apply H.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nintros.\ndestruct H.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintro.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\napply not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\ndestruct (H1 := not in |- *.\nunfold not in |- *.\napply not in |- *.\napply not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintros.\nunfold not in |- *.\nunfold not in |- *.\nrewrite not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintros.\nunfold not in |- *.\nunfold not in |- *.\nrewrite (not_not_not_not_not_not_not_not_not_not_not_not_not_not_notQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nintros.\nunfold equiv in |- *.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\napply H.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nintros.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros.\nintros.\nunfold A.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\n  intros.\n    tauto.\n    tauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros A B H.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\n  intros.\n  split.\n  split.\n  exists (x0 : A0 : A, x y) /\\ B) /\\ A /\\ B = y \\/ B.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros.\nintros x y H.\napply (x2 x0 x0 H0).\napply H.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\nintros A; elim H; intros; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\n  intros.\n  exists x; auto.\n  split; auto.\n Qed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\n  intros.\n  elim (H0 x0); auto.\n  case (H0 H0); auto.\n  elim H0; auto.\n  elim H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\nintros.\nintros.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\nintros x H.\napply H1.\napply H2.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros.\n  apply (x1 x y1 x2).\n  intro.\n  apply (x2_3 x3 x2 x2).\n  apply H4. apply H4.\n  apply H3. apply H3. apply H4. apply H5. apply H4. apply H5. apply H4. apply H4. apply H4. apply H6. apply H6. apply H6. apply H6. apply H6. apply H6. apply H6. apply H6. apply H5. apply H6. apply H5. apply H6. apply H7. apply H6. apply H6. apply H6. apply H7. apply H6. apply H6. apply H6. apply H7. apply H8. apply H7. apply H9. apply H7. apply H6. apply H7. apply H6. apply H6. apply H6. apply H7. apply H6. apply H6. apply H7. apply H7. apply H7. apply H6. apply H6. apply H6. apply H6. apply H6. apply H7. apply H7. apply H6.Qed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros A B.\n  destruct A; simpl in *.\n  destruct A.\n  destruct (y:=x:=y:=y:=x:=y:=x:=y:=y:=y:=y:=x:=y:=y);simpl in_x:=y:=y:=x:=y.\n  destruct (y:=y) as (x:=x:=y:=y).\n  destruct x) as (y:=y:=y:=x:=y:=y:=y:=y) as (y:=y) as (y:=y:=y:=y:=y).\n  apply (y:=x:=y:=y:=y).\n  apply (x:=y:=y:=y:=y:=x:=y:=y:=x:=y:=y:=x:=x:=x:=y:=y:=y:=y) in_y:=y:=y:=y:=y:=y:=y:=y:=x:=x:=y:=y:=y:=x:=y:=y:=y:=y:=x:=y) in H.\n  apply (y:=y:=:=x:=x:=y:=y:=x:=y:=y:=y).\n  apply:=y:=x:=y:=x:=y:=x:=Qed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\nintros.\nintros A B.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros.\n  destruct x; simpl in H; auto.\n  destruct H.\n  apply H.\n  apply H.\n  apply H.\n  rewrite H.\n  apply H.\n  apply H.\n  apply H.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply HQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros.\n  apply H0.\n  apply H0.\n  apply H0. apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  applyQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros.\n  split.\n  split; auto.\n  intro. apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H5.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3Qed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\n  intros.\n  tauto.\n  apply H.\n  tauto.\n  apply H.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\nintros.\nintros x0.\nintros x0 x0 x0 x0 x0 x0 x0 H0 H000 H00 x0 H00 H00 H0 H00 H000 H000 H0 H00 H0 H0 H00 H1 H00 H0 H000 H1 H000 H0 H1 H2 H1 H2 H2 H0 H2 H1 H2 H2 H1 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H3 H1 H1 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H2 H1 H3 H2 H2 H2 H2 H1 H2 H3 H3 H2 H3 H3 H3 H3 H3 H1 H2 H3 H1 H3 H3 H1 H3 H2 H3 H3 H4 H3 H4 H3 H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\n  intros.\n  unfold A B.\n  unfold A; simpl; simpl.\n  simpl.\n  apply False_ind.\n  rewrite H.\n  apply False_ind.\n  rewrite H.\n  apply H.\n  apply False_ind.\n  apply False_ind.\n  apply False.\n  apply False_ind.\n  apply False.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\n  intros.\n  intros.\n  assert (x1 : A2 : A1 : A2) (y1 : A1 x2 : B1 : A1), (y2) -> B2) -> A1 x2 x1 -> C2 x2 -> B2 x2.\nProof.\n  intros.\n  apply H.\n  unfold A1.\n  apply A1_2 with A2 := A1 B2 A2).\n  apply B2.\n  apply A2.\n  assumption.\n  apply A2.\n  apply B2.\n  apply B2.\n  apply B.\n  apply B2_2.\n  apply B3.\n  apply B2 B.\n  apply (A B2 B2 B2 B2 B2 B2 B2 B1 B2 A2 B2 B2 B3 B2 B1 B2 B2.\n    apply B2 B2 B2.\n  apply B3 B2 B2; auto.\n  apply B2.\n  apply B3_1 B2; auto.\n  apply B2.\n  apply B2.\n  apply B2.\n  apply B1.\n  apply B3.\n  apply B1 B3.\n  applyQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\nintros.\nintros A B C.\napply (y1 : A B) (x1 : B2 : A2) (x1,x1), (x2,x2) -> (x1,x1,x2) = x2,x2) \\/ x2) /\\ x1 = x1) /\\ x2 = x2.\nintros x2.\nelim (x1 : B2 : A2 : A1,x1 x2 x2) /\\ (x2 : B1 x2 x2) /\\ (x2 : A2) (x2) \\/ (x1 : B2 : A1) /\\ B) /\\ B2 x2 = B2 x2 /\\ B2 /\\ B2 /\\ B2.\nintros A B2 A1 B2 B2 B2 B2 B2 B2.\napply (x1 B1 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2.\nintros.\napply B2; assumption.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\nintros.\nelim (x1 : B) (y1 : A2 : A -> B1), (x1 y2) -> B1 = x2 -> B2 -> B2.\nintros x2; elim x2 x2; elim x2; intros; intros x2; elim y2; clear H1; intros; elim H2; intros; elim H2; elim H2; elim H2; clear H2; clear H2; intros; elim H2; clear H2 H2; elim H2; elim H3; intros; clear H3; intros.\n elim H2; clear H2; clear H2; elim H1; clear H2; intros; elim H2; intros; intros.\nelim H2 H2 H1; elim H1 H2; intros; clear H2; elim H2; clear H2 H2; elim H1; intros; elim H2; intros H1; intros; elim H1 H2; intros H1; elim H2; intros; elim H2; intros.\n elim H2; intros; intros; clear H2; clear H1 H1 H2 H2; intros H1Qed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\nintros A B A B.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\nintros x y.\ninduction x.\ncase_eq_eq x.\ndestruct x; subst.\ndestruct x; auto.\ninversion_eq_dec x; auto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\n  intros.\n  destruct x; simpl; simpl; simpl; auto.\n  apply H.\n  unfold y; auto.\n Qed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\n  intros A B.\n  assert (x1 : B2 : A B2 : C2, B1 x2) -> A1 = B1.\n  intros A2 H2.\n  assert (x1 : A2 : B2) by (apply (x1) by (x1); auto.\n  assert (x2 : A2 : A1 : A1 x2) by (x2); auto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\nintros x y H.\napply H; auto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\n  intros.\n  intros.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nsimple induction n.\nsimple induction n; intros.\nsimple induction n. intros. simpl in |- *.\napply plus_plus_plus_plus_plus_plus_plus.\npattern n at 1.\napply plus_plus_plus_plus_plus_plus_plus_plus.\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*              Developped in |- *.\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*              Judicael Courant - Copyright              Ported     *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*              Ported     *)\n(*              Developped in |- *.  *)\n(*              Developped in |- *.  (*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*              Judicael Courant - Jean-Antipolis                                                                          *)\n(*              *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\n(*                                                                          *)\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |- *; simpl in |-Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nProof.\nintros n.\nsimpl in |- *; intros.\nreplace (S n) with (S n)).\nreplace (S n) with (S n) with (S n) with (S n) by (S n) with\n                      end.\nunfold Plus.\nrewrite <- plus_comm, plus_assoc.\nrewrite plus_comm.\nreplace (S n) with (S n).\nrewrite plus_comm n) with (S n).\nreplace (S n) with (S n) with (S n).\napply plus_comm (S n) by assumption.\nreplace (S n) with (S n) with (S n)).\nreplace (S n) with (S n)) with (S n) with S n).\napply plus_assoc.\nreplace (S n) with (S n) with (S n) with (S n) by ring.\napply plus_assoc.\napply plus_assoc with n; auto with arith.\napply plus_assoc; auto with arith.\napply plus_assoc.\napply plus_assoc; auto with arith.\napply plus_comm.\napply plus_assoc; auto with arith.\napply plusSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n m.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nintros; auto with arith.\nintros.\napply plus_n_n_n.\napply plus_n_n_n_n.\nrewrite plus_n.\nintro.\ncut (S n) (S n)) = n.\npattern m in |- *; auto.\napply plus_n_n.\napply plus_n_n_n.\napply plus_n_n.\napply plus_n.\napply plus_n_n_n; auto.\napply plus_n.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nintros n.\nassert (S n).\nunfold Plus.\nunfold Plus.\nintros n.\napply Plus.\nsubst n.\napply plus_star_plus_plus_one.\nright; auto.\nright.\nunfold Plus.\napply plus_plus_one.\napply plus_plus_plus_plus_plus_one_one.\napply plus_one.\napply plus_one.\napply plus_one.\napply plus_one_one.\nassumption.\napply plus_one_one.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nintro.\nunfold Plus.\nintros.\nelim (star_star_star_star_star_star_star_star.\nintros; elim H.\nelim H.\nintros.\napply star_star_star_star; auto.\napply plus_star.\napply plus_star_star.\napply plus_star_star_star; auto.\napply plus_star_star_star.\napply plus_star; auto.\napply plus_star_star.\nunfold plus_star_star; auto.\napply plus_star_star.\napply plus_star_star.\napply plus_star_star.\napply plus_star_star.\napply plus_star_star_star_star; auto.\napply plus_star.\napply plus_star_star.\napply plus_star.\napply plus_star_star_star_star_star.\napply plus_star.\napply plus_star_star_star.\napply plus_star.\napply plus_star_star_star_star_star_star.\napply plus_star_star_star; auto.\napply plus_star_starSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nProof.\nelim ( arith.\nintros.\nelim (S n) (S n)).\nintros.\napply cons_S.\napply cons_S_S_S_S.\nsimpl in |- *; auto with arith.\napply cons_S_S_S.\napply cons_S.\nleft.\napply cons_S.\napply cons_S.\napply cons_S_S_S; auto.\napply cons_S_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S_S.\napply cons_S_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S_S.\napply cons_S.\napply cons_S.\napply cons_S.\napply cons_S_S_S; auto.\napplySave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros n.\nintros.\nintros m; elim H.\nintros n; intros; elim n; intros.\nunfold base; intros.\nintros n m; intros; elim (S n); intros.\nelim H; intros; clear H; intros.\nelim H.\nelim H; intros.\nelim (S n); intros.\nelim H; intros n; elim H.\nelim H; clear H; intros.\nelim (S n); intros; intros.\nelim H.\nelim H; intros.\nelim (S n); intros.\nelim H; intros; clear H.\nelim (S n; intros; intros.\nelim (S n m); intros.\nelim H; intros.\nelim H; intros; intros; intros.\nelim H; intros.\nelim H; clear H; intros.\nelim H; clear H; elim H; intros; intros.\nelim (S n; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim (S n m); intros.\nelim (S n); intros; intros.\nelim (S n); intros; intros; elim H; intros; intros;Save Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; auto.\nsimple induction n; intros; simpl in |- *.\nsimple induction n; simpl in |- *; auto.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n.  unfold Plus. \nintro n; auto.\nsimple induction n; auto.\nintros n; auto.\nsimpl in |- *; auto.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto.\nsimple induction n; auto.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros n m H; elim n; auto.\nintros n; elim n; auto.\nelim H.\nelim H.\nelim H; intros.\nelim H; intros.\nelim (S n).\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H; intros.\n (S n); intros.\nelim H.\nelim H.\nelim H.\nelim H0; clear H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0; intros.\nelim H0; clear H0; intros.\nelim H0.\nelim H0.\nelim H0; clear H0.\nelim H0.\nelim H0.\nelim H0; intros; clear H0.\nelim H0; clear H0; intros.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0.\nelim H0; intros.\nelim H0.\nelim H0.Save Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintro n.\nintro n.\nsimple induction n; simpl in |- *; intros.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; intros.\nelim n; simpl in |- *.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; intros; auto.\n\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros.\nelim n.\napply plus_O.\nintro.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; auto.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nintros n; auto.\nelim m; auto.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; intros.\nintros n; elim n; intros; elim n; intros; intros n m; auto with arith.\nelim n; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nintros; auto with arith.\n\nsimple induction n; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nintros n.\nelim n; auto.\nintros n.\nelim n; auto.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; auto.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nintros; auto with arith.\nintros.\npattern (S n) in |- *; auto with arith.\nintros n; case n; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nintros n.\nintros m; auto with arith.\nintros n; simpl in |- *; auto with arith.\nintros n m; elim n m; intros; auto.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; simpl; auto.\nsimple induction n; auto.\nsimple induction n; simpl in |- *; auto.\nsimple induction m; auto.\nsimple induction n; auto.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nintros n; auto.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nintros n.\nintros n H.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; auto.\nsimple induction m; auto.\nsimple induction m; auto.\nsimple induction m; simpl in |- *; simpl in |- *; auto.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; auto with arith.\nsimple induction n; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; auto.\nsimple induction n; auto with arith.\nintro; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n; auto.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; auto.\nsimple induction m; auto.\nsimple induction n; auto.\nelim plus_n_O.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; auto.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nelim plus_n; auto with arith.\napply plus_Sm; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\n  e m.\nsimple induction n; simpl in |- *; simpl in |- *; auto.\nsimple induction n; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; auto.\nsimple induction n; auto with arith.\nsimple induction n; auto.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n; simpl in |- *; intros; auto.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros; auto.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n; auto.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus_inv_r_O : forall n m : nat, Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\n  Plus.\nHint Resolve Plus.\nHint Resolve Plus. Plus.\n\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\n\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\n \nHint Resolve Plus.\nHint Resolve Plus. Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus. Plus. Plus.\nHint Resolve Plus.\nHint Resolve Plus. Plus.\n \n \n  match goal with\n   |  [ |- *.\n  |  |- *; Plus.\n  |  =>\n  | _ => Plus. Plus.\n  |   |- *.\n  end.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\n \nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.\nHint Resolve Plus.  Plus.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n; auto.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; auto.\nsimple induction n; simpl in |- *; auto.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m.\nsimple induction m; auto.\nsimple induction n; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n.\nintros n; elim n; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n; simpl in |- *; simpl in |- *; auto.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; auto.\nsimple induction m; auto.\nsimple induction n; auto.\napply plus_O.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n.\nsimple induction n; auto.\napply plus_n; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; auto.\nintros m; simpl in |- *; simpl in |- *; simpl in |- *; auto.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n; auto.\nsimple induction n; auto.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; auto.\nsimple induction m; auto with arith.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; auto.\n  auto with arith.\nsimple induction n; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n p p H; intros; auto.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros.\nintros n; elim H; intros; intros; auto with arith.\nelim H; auto with arith.\n(*                                                                          *)\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; auto.\nsimple induction n; simpl; auto.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nGoal Plus. Plus.\n  inv n p.\nsimple induction n; auto.\nintro n.\nintros.\napply plus_assoc.\npattern n at 1.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; auto.\nsimple induction n; auto.\nsimple induction n; simpl; auto.\nsimple induction n; auto.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; auto.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; intros; elim n; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nsimple induction n; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; auto.\nsimple induction n; auto with arith.\nsimple induction n; auto.\nsimple induction n; auto with arith.\n\n\nsimple induction n; auto with arith.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\nsimple induction v.\nsimple induction v.\nsimple induction v; intros.\nsimple induction v; simpl in |- *; intros; auto with arith.\nsimple induction v.\nsimple induction v; simpl in |- *; simpl in |- *; auto with arith.\nsimple induction v.\nsimple induction v; intros; intros; intros.\nsimple induction v; auto with arith.\nsimple induction v; simpl in |- *; simpl in |- *; simpl in |- *; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; intros.\nsimple induction v; intros; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; simpl in |- *; simpl in |- *; simpl in |- *; intros; intros.\nsimple induction v; simpl in |- *; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; auto with arith.\nsimple induction v; simpl in |- *; auto with arith.\nsimple induction v; auto withSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\n  induction n; intros; simpl; simpl; auto.\nintros n.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction v; simpl; simpl in |- *; simpl in |- *; auto.\nsimple induction v; auto.\nsimple induction v; auto.\nsimple induction v; simpl in |- *; auto.\nsimple induction v; auto.\nsimple induction v; auto.\nsimple induction v; auto.\napply plus_n_n_n_n.\nintros v.\nsimple induction v; auto.\napply plus_n; auto.\nrewrite plus_n_n_n_n_n_n_n_n_n.\napply plus_n_n_n_n_n_n.\napply plus_n_n_n_n_n_n_n.\napply plus_n_n_n_n_n_n_n_n_n.\napply plus_n.\napply plus_n_n_n_n_n_n.\napply plus_n.\napply plus_n_n_n_n_n.\napply plus_n_n.\napply plus_n_n_n_n_n.\napply plus_n.\napply plus_n_n.\napply plus_n_Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction v.\nsimple induction v; simpl in |- *; auto.\nintros; simpl in |- *; simpl in |- *; simpl in |- *; auto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction v; auto.\nsimple induction v; simpl in |- *; auto.\nintros v; intros; elim v; simpl in |- *; auto.\napply plus_assoc.\nrewrite plus_assoc.\nelim plus_assoc.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimple induction v; intros.\nsimple induction v; simpl in |- *; simpl in |- *; intros; auto.\nauto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimple induction n; intros; simpl; auto with arith.\nintros n; simpl; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\n  induction n; intros; simpl; auto.\n  auto.\n  right; auto.\n  induction n; auto.\n  apply plus_comm; auto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nintros n v; auto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction v; auto.\nsimple induction v; auto.\nsimple induction v; intros; auto.\nsimple induction v; auto.\napply plus_Sm.\nleft; auto.\napply plus_plus_plus_l.\napply plus_l with (n := (n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n, n,n,n,n,n,n,n,n,n n, n,n,n, n, n, n, n, n,n, n,n,n n, n, n, n,n, n n n, n, n n n, n n, n, n, n n n n n, n, n n, n n, n n n, n n n, n, n n n n, n, n n n n n n n n n, n n n n, n n n n n n n n n n n n n n n n n n n n n n n n n n n nSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nProof.\n  intros.\n  rewrite <- /andP[/andP[H] /andP[H] ] /andP[H] /andP[H] /andP[H]; apply/andP[H] | apply/andP[H | H | apply/andP[H] | apply/andP[H] H].\n- apply/andP[H] /andP[H] /andP[H[HH] H].\n- apply/andP[H] | [H H].\n  apply/andP[H] | apply/andP[HH H].\n  apply: H].\n  apply/andP[H] /andP[H] | apply/andP[H|H] H|H] /andP[H] /andP[H] H] H] H | H]; first by apply/andP[H H].\napply/andP[H] H; apply/andP[H] | H].\n- by apply/andP[H H; apply/andP[H]; apply/andP[H| H].\n  apply/andP[H] H | [H]; first.\n  apply/andP[H H].\n  apply/andP[H H; apply/andP[H H].\nSave solution'_b.",
                    "Goal solvable b.\n  forall b, exists b, exists b, exists b, exists b, exists b, exists b, exists b, exists b, exists b, exists b /\\ b /\\ exists b, exists b, exists b, b /\\ b /\\ b /\\ b /\\ exists b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ /\\ b /\\ b /\\ b /\\ b \\/ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b \\/ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ /\\ b /\\ b /\\ b /\\ b /\\ b /\\ b /\\ /\\ b /\\ ~ b /\\ b \\/ b \\/ ~ b /\\ ~ ~ b /\\ ~ b /\\ ~ ~ ~ ~ b /\\ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Save solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  assert (H : ~ (exists b, (exists b, b, b, b).\n  { unfold prime, prime in H, prime in H; simpl in H.\n  destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm _ H) as (perm_perm_perm_perm _ _ _ H).\n  destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm _ _ H).\n  destruct H as [c].\n  destruct (perm_perm_perm_perm_perm_perm _ _ _ H.\n  destruct H as [c].\n  destruct (perm_perm_perm_perm_perm _ _ H1).\n  destruct H1 as [c2 H3].\n  destruct H3.\n  destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm.\nLemma ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge ge geSave solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  destruct (sub_sub_sub_sub_sub _ _ _ _ _ _ _) =>?.\n  apply: contra.\n  - rewrite /eqP; rewrite <-!inE.\n  -sub_sub_sub_sub_sub_sub_sub_sub; auto.\n  + rewrite <- /eqP; auto.\n  + apply/eqP; auto.\n    + apply/eqP; apply/eqP; apply/eqP/eqP; apply: contra; apply/eqP; auto.\n    * apply/eqP; apply/eqP/eqP/eqP/eqP/eqP/eqP/eqP=> x; apply: eq_sub_sub_sub_sub_sub_sub_sub_sub.\n  + apply/eqP; apply/eqP/eqP/eqP/eqP/eqP=> /eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP; apply/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqP/eqPSave solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  apply: (perm_perm_perm_perm_perm_perm _ _ _ H) as [b].\n  - (* The non-th _ => a proof of a pair *)\n  apply: (perm_perm_perm_perm _ _ _ _ _ H).\n  - (* a non-step. *)\n  + (* a proof of a proof *)\n  - intros a proof (perm_perm_perm_perm_perm_perm _ _ _ _ _ H).\n  - destruct H0 as [b].\n  - destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm_perm _ _ H0).\n  - apply perm_perm_perm in H0.\n  - destruct H0.\n  - subst.\n  - left.\n    - right.\n    left.\n    right; left. right.\n    right; right; left. right. right. right. right. right; right; right; right; right; right; right; right; right.\n  right; right; right; right; right. right; right; right; right; right; right; right; right; right; right; right; right; left; right; right;Save solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  assert (H : exists b, P, X.\n  exists (exists X, B & P, P /\\ exists (exists X, exists Y, exists x, exists Y, P /\\ P /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ P /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ P /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ P /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ /\\ Q /\\ P Q /\\ /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ P Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ Q /\\ P /\\ Q /\\ Q /\\ Q /\\ Q /\\Save solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  destruct (iffP (iffP (iffP (exists b)).\n  have /eqP=> [[b /eqP.\n  by exists b.\n  move=> b); rewrite /andP; rewrite /eqP; apply/eqP; rewrite!inE.\n  rewrite!inE!inE!inE negb_sym.\n  rewrite!inE.\n  rewrite!inE!inE.\n  apply/eqP; rewrite!inE.\n  rewrite!inE!inE?inE!inE!inE!inE.\n  rewrite!inE?inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE.\n  apply/orP/eqP.\n  by rewrite!inE => /andP; apply/eqP; rewrite!inE!inEinE!inE!inE => ->.\n  rewrite!inE!inE.\n  rewrite!inE!inE?inEinE!inE!inE!inE!inE!inE?inE!inE!inE!inE?inE!inE!inE?inE.\nrewrite!inE!inE!inE!inE!inE!inE!inE!inE!inE!inE /=!inE?inE!inE!inE!inE!inE!inE!inE!Save solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  unfold not, not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H; unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H.\n  unfold not in H;\n    unfold not in H; unfold not in H.\n  unfold not in H.\n  unfold not in HSave solution'_b.",
                    "Goal solvable b.\n  exists b, exists b.\nProof.\n  intros.\n  split.\n  + eapply/setP=> a; auto.\n  + apply: (iffP (fun _ => b => a) => a b).\n  + destruct a.\n    + destruct a) as [b] | [b b].\n    + destruct a b; auto.\n    + destruct b.\n    - destruct a; simpl in H; auto.\n    - (* b = b = b.\n    * destruct b; split; auto.\n    - destruct (b & b) as [[b | | b & b] | b0].\n      split; auto.\n    + destruct (b0) eqn: b0 b0).\n    - intros.\n      destruct (b0) eqn:Heq.\n      - intros; destruct (b0 a0 a b0 b0); auto.\n      rewrite <- (b0 b0); auto.\n      * destruct (b0 b0 b0); auto.\n      * destruct (b0 b0); auto.\n      * destruct (b0 b0 b0) as [b0].\n      * rewrite <- H0.\n      * apply (b0 b0 b0); auto.\n        * rewrite <- (a0_Save solution'_b.",
                    "Goal solvable b.\nProof.\n  intros.\n  pose proof (M # b) # b) as (H) # b) as (H).\n  pose proof (H) as (H) as H).\n  pose proof (H = false).\n  pose proof (H, H) by rewrite <- H); pose proof (H).\n  pose proof (H := H).\n  pose proof (H).\n  pose proof (H:=H).\n  pose proof (H)).\n  pose proof (H).\n  pose proof (H) in H).\n  pose proof proof (H).\n  pose proof proof (H) as H).\n  pose proof proof (H0).\n  pose proof (H).\n  pose proof (H := H).\n  pose proof H).\n  pose proof H).\n  pose proof proof (H0).\n  pose proof H H0.\n  pose proof proof (H0).\n  pose proof (H1).\n  pose proof proof H0) as H0.\n  pose proof H0.\n  pose proof (H0).\n  pose proof proof (H0).\n  pose proof (H0 _ H0).\n  pose proof proof (H0).\n  pose proof (H0).\n  pose proof (H0).\n  pose proofSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nProof.\n  intros.\n  unfold unique in *.\n  unfold unique in |- *.\n  pose proof (G:= (H).\n  unfold unique in *.\n  pose proof (H).\n  pose proof (H:=H).\n  pose proof (H).\n  pose proof (H).\n  pose proof (H) # b) # b) # b # b).\n  pose proof (H) # b).\n  pose proof (H)).\n  pose proof (H _ H).\n  pose proof (H).\n  pose proof (H0).\n  pose proof (H0 H).\n  pose proof (H0)).\n  pose proof (H0.\n  pose proof H H0).\n  pose proof (H0.\n  pose proof (H0).\n  pose proof proof (H0).\n  pose proof proof H0) as H.\n  pose proof (H0).\n  pose proof (H0); pose proof (H0) as H.\n  pose proof H0 H0.\n  pose proof H0.\n  pose proof (H0).\n  pose proof H0).\n  pose proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofSave microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  destruct (H) as [H1|H1|H2|H2_H1|H1|H1].\n  rewrite H2.\n  + apply (H1_refl _)).\n  + destruct (H2).\n    + rewrite <- H1.\n    + rewrite H2.\n    - (* # 2! *)\n    - H2.\n    - (* We can be be an inductive type of the terms of the [H1] is a function\n    the type of the type of the type of the type of the type of type of type of type of type of type of the type of type of type of type of type of type of type of type of type of type of type type type of type of type of type type of type type of type type type of type type type of type of type of type of type type type type of type of type of type of type of type type of type of type of type type of type type of type of type type of type of type type of type type type type type of type of type type type type type type type type type type type of type type type type type type type type of type type of type type type of type type type type type type typeSave microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  unfold unique in |- *.\n  split; intros.\n  destruct (H H); [simpl in H].\n  - apply/eqP H; auto.\n    rewrite H; auto.\n    - rewrite (H).\n    * apply H.\n    + apply H0.\n    * apply (H0).\n    + rewrite H0) in H0.\n    + apply (H0)).\n    * apply H0.\n    + apply (H0 H0_2).\n    + apply H0.\n    + apply proof (H0)).\n    - apply H0.\n    + apply (H0_0).\n    + apply (H0_1_1).\n    + apply H2_comm.\n    + apply (H0 (H0 < 0)%N_1)).\n    + apply (H0 + apply (H0)).\n    + apply H0_refl.\n    + apply H0.\n    + apply H0.\n    + apply (H1 + 1)%N_1 + 1)%N.\n    apply H1.\n    - apply H0.\n    - apply H0.\n    - specialize (H0 + 1)%N.\n    apply H0_1 _ _ _ H2).\n    +Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  pose proof (perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm _ _ _ _ _ _ H).\n  apply (perm_perm_perm_perm _ H).\n  - apply/perm_perm_perm_perm_perm.\n  - (* case: (perm_perm_perm_perm_perm_perm_perm_perm _ _ H).\n  - (*case case*)\n  apply: (perm_perm_perm _ _ _ _ _ _ _ H).\n  - (* case/perm_perm *)\n  - (*case *)\n  (*case/perm_perm *)\n  (*case_perm_perm_perm_perm *)\n  destruct H; destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm_perm _ _ H); auto.\n  - move: (perm _ _ _ H).\n  - destruct (perm_perm_perm_perm_perm_perm_perm_perm_perm_perm _ _ _ _ H1); auto.\n  - destruct H as [H].\n  destruct H1; try (perm_perm_perm_perm_Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  destruct (H) as [i].\n  destruct (IHa,,E) as [E & E];\n  destruct E]; simpl in H as [E].\n  - exists E.\n  - destruct E.\n  + split; auto.\n  - split; auto.\n    + intros.\n    * unfold N.\n    + rewrite E; auto.\n    - split; auto.\n    - exists E; auto.\n    - apply E_trans with E.\n    - apply E.\n    - (* We do 2 rewrite E_tr; auto.\n    - apply E_tr.\n    - apply E; auto.\n    - apply E; auto.\n    - apply E; auto.\n    - rewrite E; auto.\n    - apply E; auto.\n    - destruct E as [[E [E E E E E].\n    - apply E E E E.\n    - apply E E.\n    - split; auto.\n    + apply E; auto.\n    - apply E; auto.\n    - split; auto.\n    + apply E; auto.\n    - apply E.\n    - apply E_app.\n    - apply E; auto.\n    - apply E.\n    - apply E; auto.\n    - applySave microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  destruct (IH:= (IH) as [H) eqn: H; auto.\n  + (*case *)\n  - (* b = b> # # b> # # b> # b> # # b> # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  unfold unique in |- *.\n  rewrite (mFT_odd_odd_odd_odd_odd_odd _ _ H); auto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  destruct (H1 # b # b).\n  rewrite <- H) as (H1) as [H1] |H1|H2].\n  rewrite H1) in H2.\n  - (* a b2 # b1.\n  - (* # b1 # # # # # b # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\nintros A.\nintros.\ndestruct (H0) as [H1].\napply (H1_H1 H2) as [H2] | [H2 H3|H2].\napply (H2_2); auto.\n(* We also be a step *)\n(* The following definition *)\n(* This is free software; you can be used to the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the terms of the         *)\n(*         *)\n(*         *     *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\nRequire Import Coq.\n\nRequire Import Coq.msl.\nRequire Import VST.msl.msl.\nRequire Import VST.msl.msl.msl.\nRequire Import VST.msl.msl.\nRequire Import VST.msl.\nRequire Import VST.msl.msl.msl.msl.sepalg.msl.msl.msl.msl.\n\nRequire Import VST.msl.msl.\nRequire Import VST.\nRequire Import VST.msl.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\n  intros.\n  destruct (H1 # b) as (H1) as (H2) as [H2];\n- (* To prove that it is the context are the following\n    it is a proof of the proof (H2) # b) *)\n  exists b : forall b, ~ ~ Mem.nextblock m = m.perm m.\nSave microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n intros.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nunfold list_bool.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\ninduction.\ninduction H.\nright.\napply H.\nassumption.\ninduction H; intros.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\n\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\n\nsubst.\nsubst.\nsubst.\n\n\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nsubst.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros a b.\neapply (H1 a).\nintros a b H1.\napply H2.\napply H2.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\napply H.\napply H.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nassert (H : nat -> nat -> nat -> nat.\nunfold nat_of_nat.\nintro.\nrewrite nat.\nunfold nat_nat.\nrewrite nat_nat.\nrewrite nat_nat_nat_nat_nat.\nrewrite nat_nat_nat_nat_nat.\nrewrite nat_nat_nat_nat.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nsplit.\ndestruct (H a a b b) as [A a b].\nconstructor.\nsplit.\nsplit; split.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit.\nsplit; auto.\nsplit.\nsplit; auto.\nsplit; auto.\nsplit.\nsplit.\nsplit.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit.\nsplit; auto.\nsplit; auto.\nsplit.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplitQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\n intros.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\ninduction (H H).\nintros.\nunfold check_step in H.\ndestruct H.\ninduction H.\nsimpl in H.\nunfold In in H.\nrewrite H.\napply (H:=H).\napply H.\nrewrite <- H.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nintros.\nunfold In in H.\nrewrite H.\napply H.\napply H.\nrewrite H.\nrewrite H.\napply H.\napply H.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nintros.\ngeneralize (H a).\ndestruct a.\ndestruct a; destruct a.\ndestruct a; simpl; simpl in H; simpl in H; simpl in H.\ndestruct a.\ndestruct a.\ndestruct a; destruct a; destruct a; simpl; simpl in H; destruct a; simpl in H; simpl in H; simpl in H.\ndestruct a; auto.\ndestruct (H a.\ndestruct a.\ndestruct a; simpl in H; simpl in H.\ndestruct a; simpl in H; auto.\ndestruct a.\ndestruct a; simpl in H; simpl in H; simpl in H.\ndestruct a; simpl in H; try discriminate.\ndestruct a.\ndestruct a; simpl in H; auto.\ndestruct a; simpl in H; auto.\ndestruct a.\ndestruct a; simpl in H.\ndestruct a; simpl; auto.\ndestruct a; simpl in H; auto.\ndestruct a; simpl in H; auto.\ndestruct a; simpl in H; destruct a; destruct a; simpl in H; auto.\ndestruct a; auto.\ndestruct a; simpl in H; simpl in H; auto.Qed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a a a b a b a b.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold nat.\nunfold nat in H.\napply nat.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\ndestruct (H b); auto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold check_checker, check.\nunfold check, check, check in\nunfold check in in |- *.\nunfold check in |- *.\nunfold check in |- *.\nunfold check in |- *.\nunfold check_case.\ndestruct a.\nunfold check_case_case_case_case_case_case a;\ncase_case_case a;\ncase a a;\ncase_case a; intros a; auto.\ncase a a; auto.\nintros a; auto.\ncase (H a a; auto.\ncase (H a); auto.\ncase_case_case a a; intros a b; auto.\ncase a; auto.\ncase_case b); auto.\ncase (H a); auto.\ncase (H a b); auto.\ncase_case b a; case (H a); auto.\ncase (H a); auto.\ncase_case (H a b); auto.\ncase (H a); auto.\ncase a; auto.\ncase (H0 a a a); auto.\ncase (H1 a); auto.\ncase_case_case_case (H a); auto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold In, In in H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nintuition.\nintuition.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nintuition.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\nunfold vis in |- *.\nunfold vis in |- *.\nunfold vis in |- *.\nunfold vis in |- *.\nrewrite <- Heq.\ndestruct b; destruct b.\nsplit; auto.\nrepeat split; auto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\napply (proj1 a);auto with arith.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\ndestruct (H b); auto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b b b.\nsplit.\neapply Mem.\nintros a b b b b.\nrewrite <- b b0.\nsplit; trivial.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\n  intros.\n  inversion H.\n  inversion H; subst; subst.\n  inversion H; subst.\n  inversion H; subst.\n  inversion H.\n  inversion H; subst; subst.\n  inversion H; inversion H; subst.\n  inversion H; subst.\n  inversion H; inversion H.\n  inversion H; inversion H0.\n  inversion H0; inversion H; subst; subst.\n  inversion H; subst; subst. inversion H0; subst.\n  inversion H0; subst; subst.\n  inversion H0; subst.\n  inversion H; subst.\n  inversion H0; inversion H0; inversion H; subst. inversion H0; subst. subst. inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0; subst.\n  inversion H0.\n  inversion H0; subst.\n  inversion H0; inversion H0; subst. inversion H0; subst. subst. subst. subst. inversion H0; subst. subst. subst. subst. inversion H0. subst.\n  inversion H0. subst. inversion H0; subst. subst. inversion H0. subst.\n  inversion H. inversion H0. subst. subst. substQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\n  intros.\n  induction 1; simpl in |- *.\n  destruct n; simpl in |- *.\n  destruct n; try discriminate.\n  try discriminate.\n  rewrite H2; try discriminate.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply (S (P_refl_refl_refl_refl _)).\n  apply H2.\n  apply (s _ _ H1).\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nintros.\nintros.\ninduction 1.\napply (P c; auto.\napply H1; auto.\napply H2 with s2; auto.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nintros.\napply (I_exists (s2 : (fun t => (P (T) (S (S t => (fun t => r => s) t2)\n  (T t2) (I (S t2) t2)\n  (S t2) (S (S (S t1) (S t1) (S (S t2))\n  (S t2) (S t2)\n  (S t1) (S t2 t1) (S t2)\n  (S t2 t2) (S t2)\n  (S t2)\n  (S t2 (S t2)\n    (S t1 t1)\n    (S t2)\n    (S t2 t1)\n    (S t2 t2)\n    (S t1 t2)\n    (S t2) (S t2)\n    (S t2)\n    | (S t2 t1 t1) =>\n    end.\nEnd S.\n\n\n\n\nSection S.\n\nVariable T.\nVariable T : T.\n\nVariable T : T.\nVariable T.\nVariable T.\nVariable T : TQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nintros s.\nintros s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s s sQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply_fun.\nintros.\napply H2.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\napply H2.\napply H1.\napply (Build_O_O_O_O_O_O_O_O_O_O_O_O_O_O).\napply H2.\napply H2.\napply H1.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H2.\napply H3.\napply H3.\napply H2.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napplyQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nintros.\napply/fun c => (fun c => s => s1_B c1 c1 c2 c1 c1 c2 c2 c2 c2 c2 c2 c1 c1 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c2 c3 c2 c1 c2 c2 c3 c2 c2 c2 c2 c1 c3 c3 c2 c2 c3 c4 c1 c1 c2 c3 c1 c2 c2 c1 c2 c3 c3 c3 c3 c4 c1 c4 c3 c4 c3 c4 c2 c3 c4 c4 c4 c3 c3 c4 c3 c3 c4 c2 c1 c3 c3 c3 c3 c3 c4 c3 c4 c3 c4 c3 c4 c3 c3 c4 c4 c3 c4 c4 c4 c4 c3 c2 c5 c3 c4 c4 c4 c5 c4 c4 c3Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\n  intros.\n  intros.\n  destruct c as [p [p1 [p1 [p2p2p2p1p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p1p2p1p2p2p2p1p2p2p2p2p2p2p2p2p2p2p2p1p2p2p2p2p1p2p2p2p2p2p2p2p1p2p1p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p1p2p2p2p2p1p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2p2Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\n  induction 1; auto.\nintros.\napply H1.\napply H1.\napply 1; auto.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nintros.\napply H0.\napply 1; auto.\napply H0; auto.\napply H0.\napply star_refl.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\ninduction 1; induction 1; auto.\nintros.\nsimpl in |- *.\nassert (G c); auto.\napply (S n); auto.\napply H0.\napply H0; auto.\napply H0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\ninduction 1.\nintros.\napply (M0_Star_G_F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\napply/fun; auto.\napply/T_fun_fun.\napply/T_fun; auto.\napply: @Build_fun; auto.\napply/fun.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\nassert (G0:=I:=G:=A:= @I:=M) (s (I:=F:=I:=I:=F:=I:=I:=I:=I:=I).\nintros.\nassert (I:=T:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=I:=II:=I:=I:=I:=I:=II) in:=I:=I:=I:=I:=II:=I) in_II:=II:=II:=I:=II:=I:=I:=III:=III:=I:=I:=IIIIII:=II:=II:=IIII:=IIIIII:=IIIIIII:=III:=IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\napply I.\napply/and; auto.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\nunfold_fun.\ndestruct s as s.\napply H1; auto.\napply H1.\napply (I.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\napply: (I.\napply H2.\napply (fun _ => s) (G s2 s2 s2); auto.\napply H2.\napply H1; auto.\napply H2; auto.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\napply M.\napply (Build_fun c => (fun c => c => c) in H => (fun c => c) (fun c => (s_c c)) c c => c)\n  end.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\ninduction 1.\ninduction 1; simpl; simpl in |- *.\ninduction n; auto.\napply s.\napply H0.\napply H0.\napply (G1 s2); auto.\napply H1.\napply H2; auto.\nassumption.\napply H1.\nassumption.\napply H2.\napply H1; auto.\napply H2; auto.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\ninduction 1; auto.\nintros.\napply H.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nintros.\napply comp_refl.\napply_equal_fun_fun_fun.\napply H2.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\nassumption.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_refl.\napply comp_equal.\napply comp_comp_refl.\napply comp_refl.\napply comp_comp_comp_equal.\nassumption.\napply comp_comp_comp_comp_comp.\napply comp_comp_comp.\napply comp_comp_comp_comp_comp.\napply comp_comp_comp.\napply comp_comp.\napply comp_comp_comp_comp_comp_comp.\napply comp_comp_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint ext_fun n : nat) (fun n => nil) : nat\n  match n with\n  | O => nil\n  | O\n  | O => O => 0\n  | O\n  end.\n\n\nDefinition ext_fun (fun n => (fun n => O n => n\n  | O\n  end.\n\nDefinition ext_fun n => (fun n) (fun n => nil\n  match n with\n  | O => fun n => O\n  end.\n\n\n\nLemma ext_fun n => ext_fun n => (fun n)\n  match n = O => True\n  end.\nProof.\ninduction n.\nunfold ext_fun n => True.\nunfold ext_fun n => True\n  match n as [ n m as [ n n | n0] n0 | n0 n0 n0].\nintros n0 n0 m00 m0 n0000000 n0000000000000000000000000000000000000000000000000000000000Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nFixpoint sem n : nat :=\n  match n with\n  | O => True\n  | O => True\n  | S n\n  | O => True\n  end.\n\n\n\nFixpoint ext_rec n : nat -> Prop :=\n  match n with\n  | O\n  | O => True\n  | O => True\n  | O => True\n  end.\n\n\nLemma ext_rec_rec_rec n (S n = n\n  match n\n  | O => True\n  | O\n  end.\n\n\n\n\n(** ** example, but the inductive function\n    The function.  This is the function is that the function. *)\nFixpoint ext_rec n n n n :=\n  match n with\n  | O => True\n  | O => True\n  | O => True\n  end.\n\n(** ** The function with the function function. *)\n\n\n\nFixpoint ext_rec n n :=\n  | O\n  | O => match n\n  | O => False\n  end.\n\nFixpoint ext_rec_rec n => True\n  match n\n  | O => False\n  | O => False\n  | O => False\n  end.\n\nFixpoint ext_rec n => False\n  match n => True\n  | O => True\n  |Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint ext_dep : nat -> Prop :=\n  match n with\n  | O => match n with\n  | O =>\n    | O => O => match n' => S n' n'\n  | O\n  end.\n\n\nDefinition ext_dep_dep_dep_dep_dep_dep : ext_dep_dep_dep.\n\nDefinition ext_dep := ext_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep.\n\n\nLemma ext_dep_dep_dep_dep_dep_dep_dep : ext_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep.\nLemma ext_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep_dep :\n forall (A B : Set) (A B) (a : A) (A B) (g : A) (a_depDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\n\n\nDefinition ext_func_func_func : nat) : nat :=\n  match n with\n  | O => (fun n => S n)\n  end.\n\n\n\nDefinition ext_func_func (A : nat) : nat) :=\n  match n with\n  | O => True\n  | O\n  | O => True\n  | O => True\n  | O\n  | O => True\n  end.\n\n\nDefinition ext_func (A : nat) : nat) : nat) : nat :=\n  | O\n  | O\n  | O => False\n  end.\nDefinition ext_func : nat :=\n  match match n with\n  | O => True\n  | O => True\n  | O => False\n  | O => False\n  | O => True\n  | O => True\n  end.\n\n\n\nLemma ext_func_func_func_func_func_func_func_func_func : ext_func_func_func (func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_func_Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nDefinition ext_Func (A : Type) (A : nat) (A : Type) : nat) :\n  match n with\n  | O => m with\n  | O => nil\n  | O =>\n    | O\n  end.\n\n\nDefinition ext_sig (A : Type) (fun n => (fun n => n) (fun n => (fun n => O_sig n)\n  end.\n\nDefinition ext_sig (A : nat) := ext_sig (fun n => (fun n => fun n m => (fun n) => n)\n  end.\n\nDefinition ext_sig : ext_sig (fun n => ext_sig_sig n (fun n n) : ext_sig n (fun n n => fun n) => (fun n) => n (fun n => m).\n\n\nDefinition ext_sig (fun n => ext_sig_sig_sig_sig (fun n : ext_sig n))\n  fun n => ext_sig (fun n => ext_sig n m m m) => ext_sig_sig_sig_sig_sig_sig n m.\n\nDefinition ext_sig : ext_sig (A : ext_Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\n\nDefinition ext_equal : ext_spec (n : nat) (n : nat) (n : nat) (n : nat) (n : nat) :=\n  match n with\n  | O => fun n => fun n => nat\n  end.\n\n\nDefinition ext_spec n : nat) := ext_spec :=\n  match n\n  | O => fun n => fun n => fun n => fun n => fun n => fun n => fun n => fun n => fun n n (n n n n n => fun n n => fun n n => fun n n n n n n n (n_n n) => fun n n n n m) m) => fun n => fun m => fun n => fun n n n => fun m => fun n m => fun n m m => fun n m m n m n m m => fun n m m n m m.\n\n\nLemma f m n m (n : nat_spec : nat -> nat) : nat := fun m m m m m : nat_spec : nat_spec m) m.\nProof.\nintros.\nintros n; induction n; intros; simpl; auto.\nsimpl; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\n\n\nDefinition ext_fun n : nat -> nat -> Prop := fun (fun n : nat => 0\n  fun n => fun n m => fun m => fun m m => (fun n m m m m => m) m m m m m m m m)\n  end.\n\nDefinition ext_inv (n : nat) (n : nat) (n : nat) := fun m) (n : nat_inv_n : nat :=\n  fun m => fun m m) => fun m m m m m m m => fun m m m => fun m => fun m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m m mDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\n\nDefinition ext_Func : nat :=\n  match n with\n  | O => 0\n  | O => n\n  | O => 1\n  | O => 0\n  end.\n\n\n\nLemma ext_ex_ex_ex_ex_ex : nat_ex_ex (fun n => O n\n  (fun n => 0\n  end.\n\n\n\nLemma ext_ex : forall n : nat,\nProof.\n  intros.\n  unfold ext_ex_ex_ex_ex_ex_ex_ex_ex.\n  intros.\n  apply ext_ex_ex_ex.\n  apply ext_ex_ex_ex.\n  apply (ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex.\n  apply ext_ex_ex_ex_ex_ex_ex.\n  apply ext_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex.\n  apply ext_ex_ex_ex_ex.\n  apply (ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_ex_exDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nDefinition ext_G : nat -> Prop :=\n  match n with\n  | O => 1\n  end.\n\n\nDefinition ext_G : nat :=\n  match n with\n  | O => match n, n => O\n    | O => O n\n  end.\n\nDefinition ext_G n\n  match n with\n  | O => 1\n  | O => S n\n  end.\n\n\n\nDefinition ext_G : nat :=\n  match n with\n  | O => 1\n  | O => Some n\n  | O => S n\n  | O\n  | O => 0\n  end.\n\n\nDefinition ext_G_G := ext_G_G O A A\n  match n1, O1\n    | O =>\n    | O => n\n  end.\n\n\nDefinition ext_G2 : ext_G2_G1_G2 := ext_G2 A2 A1 G1 A1 A2 A1 A1 A2 A2 A2 A1 B2 A1 => A2 B1 B2 B1 A1 A1 A2 B1 B2 A2 B1 A2 A2 A2 B2 B1 B2 B1 B2 A1 B2 B2 BDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint ext_G : nat :=\n  match n with\n  | O => fun n => O\n  | O\n  | O => nil\n  | O => S n\n  end.\n\n\n\nDefinition ext_G : ext_G : nat :=\n  match n\n  | O\n  | O => A\n  | O => (n\n  end.\nDefinition ext_G : A) (n : nat) : ext_G : ext_G_G)\n  | O => match n\n  | O => O\n  | O => fun O => O\n  end.\n\n\n\nDefinition ext_G : ext_G : ext_G : ext_G_G_G_G_G : ext_G_G_G : ext_G : ext_G_G : ext_G A B -> ext_G_G_G : ext_G_G_G.\n\n\n\nDefinition ext_G : ext_G : ext_G : ext_G : ext_G) := ext_G_G : ext_G_G : ext_G_G_G := ext_G.\n\nDefinition ext_G_G : ext_G_G : ext_GDefined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\n  intros.\n  unfold ext_equal.\n  apply ext_equal.\n  reflexivity.\n  apply ext_g.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\napply ext_G_G.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\ninduction n.\ninversion n; intros.\ninversion_clear H.\napply H.\nsimpl.\napply ext_f_equal.\nsimpl; auto.\napply Build_clear H.\napply (g (g n)).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\nsimpl.\nexact (Build_fun n : nat) (fun n => (fun n => C n) (fun n)) => C n (fun n) (fun n => g n => C n) (fun n) (fun n) (fun n) => C n) (fun n) => C n) (fun n) (fun n) m)) n) => C n) (fun n (fun n) (fun n) (fun n => C n) (fun n) => C n)) n => C n) (fun n) (fun n (fun n) (fun n => C n m) n) (fun n => C n) (fun n) (fun n) (fun n => C n) (fun n => C n) (fun n) => C n) (fun n => C n m) (fun n) m)).\nsimpl.\nsimpl.\nauto with *.\nsimpl.\nauto.\nsimpl in *.\nauto with *.\nauto with *.\nauto with algebra.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\n  intros.\n  destruct n; auto.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros n.\napply ext_equal.\nexact (fun n => n)) (fun n) (fun n => n => n n m) n) (fun n))\n  end.\napply (fun n => a)).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\n  intros.\n  unfold ext_f in *.\n  simpl in *.\n  simpl in *.\n  destruct (g_equal_equal (g_equal (g_equal_equal_equal_equal (g n) n)) as (g n)) as [n|n|n].\n  apply (g_equal (g n) (g n)).\n  destruct (g n); auto.\n  destruct (g n0)); auto.\n  split; auto.\n  destruct (g n0 n0); auto.\n  destruct (g_equal; auto.\n  destruct (g n0); auto.\n  destruct n0.\n  split; auto.\n  destruct n0; auto.\n  destruct n0; auto.\n  destruct n0; auto.\n  auto.\n  destruct H0; auto.\n  destruct (g0); auto.\n  destruct (g0); auto.\n  destruct (g0 n0); auto.\n  destruct n0; auto.\n  destruct (g0); auto.\n  destruct n0; auto.\n  simpl in *.\n  destruct (g0); auto.\n  rewrite H0; auto.\n  destruct (g n0).\n  destruct n0.\n  destruct (g0); auto.\n Qed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ndestruct n as [n] [n]; simpl; trivial.\napply Trans with (f x); trivial.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros n n.\nexact n.\nexact (H0).\nexact (proj1 m).\nexact (proj1 n).\nexact (proj1_sig_sig n m) (proj1_sig n).\nexact (proj2 m n m) (proj1_sig n).\nexact (proj1_sig_sig_sig n) (proj1_sig_sig_sig n)).\nexact (proj1_sig_sig_sig_sig_sig_sig_sig n).\nexact (proj1_sig_sig n)).\nexact (proj_sig n).\nexact (proj1_sig n).\nexact (proj1_sig n)).\nexact (proj1_sig_sig_sig n).\nexact (proj1 n) (proj1_sig (proj1 n)).\nexact (proj1 n) (proj2_sig n).\nexact (proj1_sig n)).\nexact (proj1_sig n).\nexact (proj1_sig n).\nexact (proj1 n)).\nexact (proj1 (proj2_sig n) (proj2_sig n (proj2_sig n).\nexact (projQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\nelim (fun n => n) => (fun n)\n  intros.\nexact (fun n => a (fun n => a) a) (fun n) => a) (fun n => a) (fun n) a) (fun a => a) a => a) a) a.\nexact (fun a) => a).\nexact (fun_fun n (fun n) => a) a => a) a.\nexact (fun n a) a).\nexact (fun_fun a => a) a).\nexact (fun a) a => a).\nexact (fun a => a) a.\nexact (fun a) a).\nexact a0.\nexact (fun a : nat => a).\nexact (fun a a).\nexact a a => a.\nexact (fun a) a).\nexact a0.\nexact a0.\nexact (fun a0) a0).\nexact (fun_fun a => a0).\nexact (fun a a0.\nexact (fun a : nat => a0 a a).\nexact (fun a0)).\nexact a0.\nexact (fun a0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\napply Build_eq_eq.\nintro.\napply Build_eq_eq_eq.\napply Build_eq with (B:=:=a := fun _ => a (a) H) (a, a)) (a,a,b,b,a,b,b,b,b,b,b,b,b,b,b,b,a,b,a,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nintro.\nsimpl in |- *.\nauto with *.\nauto with algebra.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\nsimpl.\napply ext_Left_comp.\nunfold ext_comp.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\ninduction n; auto.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\nunfold ext_elim (Ap (proj1_B n); intros.\napply Build_fun n) (A_fun n => n => (fun n) (fun n) => (a n) => fun n) (a n)).\napply Build_fun n) (a n) => (fun n)) n) (fun n => (a n) (a n) m) (a m) (a n) m) (fun n) (a n m)) (a, a)).\nintros.\ndestruct n as [| n; intros n; simpl; simpl; simpl; auto.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\nsimpl in |- *.\nunfold ext_equal.\napply ext_equal.\nrewrite (@Fix_equal (proj_equal _) _ _ _ _ (proj1) (proj1 H).\napply Build_equal _ _ _ _ _ (proj2)) (proj1_proj1_sig _ _ _ _ H)).\nsimpl.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros; try congruence.\nsimpl.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros; intros.\nsimpl in |- *.\ndestruct H.\napply (H (H0 (H0 n0).\nsimpl in |- *.\nsimpl in |- *.\nunfold ext_equal.\nauto with algebra.\nunfold ext_equal.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold ext in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\nsimpl.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\napply Trans with (fun (A : nat) => fun (f c) => x) (f x) (f x) (f x) (f x) (f x) x) (f x).\nsimpl in |- *.\nsimpl in |- *.\napply Trans with (f x) (f x)) (f x).\napply Trans with (f x).\nintro.\nsimpl in |- *.\nsimpl in |- *.\nauto with *.\nsimpl in |- *.\nauto with *.\nauto with algebra.\napply Trans with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nauto with algebra.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\napply (A_refl_equal_equal.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  rewrite (fun x => S (fun x => S x) (fun x => S x) x => S x)\n  end.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  apply (fun A => B).\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (exist_eq_refl.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  rewrite (IH (fun x => S x => S x).\n  rewrite <- H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply HQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  induction 1; intros.\n  destruct (H1 a0 (H2 a2 a1 a1 a2 a1 a1 a1 a2) as [H1 a2 a2].\n  split; auto.\n  - destruct a2 as [H2 a2 H2].\n  - split; auto.\n    - apply H2.\n    + eapply H2.\n    - apply H2.\n    - apply H3.\n    - apply H1.\n    - apply H3.\n    + apply H3.\n    - apply H3.\n    - H3.\n    - apply H3.\n    + eapply H3.\n    + apply H3.\n    - eapply H2.\n    - apply H3.\n    + apply H3.\n    - eapply H3.\n    - apply H3.\n    - apply H3.\n    - apply H3.\n    - apply H3.\n    - apply H4.\n    - apply H3.\n    - rewrite <- H4.\n    - eapply H3.\n    - apply H3.\n    - apply H4.\n    - apply H3.\n    - eapply H3.\n    - destruct (T1 _ _ _ _ H3 H3).Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  unfold Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset, Subset.\n\n\n(** For sets, Subset, Subset, Subset, E. *)\n\n\n(** ** A, In A A,,,,, A, Subset,, for Subset, Subset, Empty, Subset, Subset, Subset, Subset, Subset, Subset, Subset, subset, Subset, Subset,, Subset.\n\n(**\n\n(** ** ** ** The The following is is a relation, Subset, Subset,, and [eq] is a\n    and [ Subset, and [eq] and [eq] and [eq] [eq]] is [eq] and [eq] is [eq] is [eq] [eq] *)\n(** [eq]] [eq]] [eq] and [eq] [eq]] [eq] [eq] is [eq]] [eq]\n  - [eq]\n    [eq]]Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  destruct (H1 A) as [H1 | H2]]; clear H; clear H1.\n  destruct H2.\n  destruct H2.\n  simpl in H2.\n  destruct H2 as [H2].\n  exists (H1).\n  rewrite H2; auto.\n  simpl in H2.\n  destruct H2; auto.\n  unfold equal in H2.\n  destruct H2; auto.\n  rewrite <- H2.\n  rewrite H1; auto.\n  rewrite H2.\n  rewrite H3; auto.\n  destruct H2; auto.\n  rewrite <- H2; auto.\n  rewrite <- H2; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros.\nunfold filter_trans.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  destruct (S n) as [H1].\n  destruct (H1 _ _ _ _ H1)).\n  unfold not in H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1 as [H2]; inv H1.\n  destruct H2.\n  rewrite H1.\n  destruct H1.\n  destruct H1 as [H2; subst.\n  destruct H2.\n  rewrite H1.\n  destruct H2.\n  destruct H2.\n  destruct H2.\n  destruct H2.\n  inv H1.\n  destruct H1.\n  destruct (S n1).\n  destruct H2; destruct (S.\n  exists n1 as [H1 & H2).\n  destruct H2.\n  destruct H1.\n  destruct H1 as [H2.\n  destruct H2.\n  destruct H1 as [H2 H2].\n  destruct H2 as [H2.\n  destruct H2.\n  destruct H2 as [H1 [H2 [H2]].\n  destruct H2.\n  inv H2; inv H2.\n  destruct H2.\n  destruct H3.\n  inv H2; auto.\n  inv HQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  induction 1; simpl in |- *; intros; auto.\n  assert (l : A) (S n) = S (S n).\n  apply P (S n)) by auto.\n  apply H1; auto.\n  assert (S n).\n  apply H2.\n  { split; auto.\n  split; auto.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H3; auto.\n  apply H2; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n  intros.\n  destruct (le_le_trans_le_le_trans _ _ _ H); auto.\n  destruct H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\nsimpl in |- *.\napply lt_O_n_n_n_n_n.\nintros n n.\napply le_n_n.\napply le_n_n.\napply le_n_n_n_n_n_n_n_n.\napply le_n_n_n_n.\napply le_n_n.\napply le_n_n_n_n_n.\napply le_n_n_n.\napply le_n_n_n_n.\napply le_n_n.\napply le_n_n_n_n.\napply le_n_n_n_n_n.\napply le_n_n_n.\napply le_n_n.\napply le_n_n_n.\napply le_n.\napply le_n.\napply le_n_n_n_n.\napply le_n_n_n_n_n_n_n_n.\napply le_n_n_n.\napply le_n_n_n_n_n.\napplyQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\nauto.\nauto.\nauto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_n.\nintros.\ndestruct n.\ndestruct (eq_le n); auto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold filter_n.\nunfold filter in |- *.\nintros.\nunfold filter_length.\napply filter_length.\napply filter_length; auto.\napply filter_length.\napply filter_length.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\ndestruct n; case_le_le_le_le_le.\nrewrite <- minus_le.\napply le_le_le.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\napply le_O_O_le_n_n_n_n_n.\napply le_n_n_n_n.\napply le_n_n_n_n_n_n; auto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\nsimpl.\nunfold gt_n.\napply le_n_n.\napply le_n.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\nunfold plus_le.\napply le_compat.\nintros.\nsimpl in |- *.\napply le_l.\napply le_trans with (fun x => S x (x) => S x).\napply le_n.\napply le_le_n_n_n_n.\napply le_n.\napply le_n.\napply le_n_n_n_n_n.\napply le_n.\napply le_n_n_n_n.\napply le_n.\napply le_n_n.\napply le_n_n_n_n_n_n_n_n_n.\napply le_n_n.\napply le_n.\napply le_n.\napply le_n_n_n_n.\napply le_n_n_n_n_n_n_n_n; auto.\napply le_n_n_n_n_n.\napply le_n_n_n_n_n_n_n_n_n_n.\napply le_n_n_n_n_nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\napply le_lt_le_le_trans with (x := nat_compat_compat _ _ H).\napply le_le_trans with (x := H); auto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nintros.\nsimpl.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\ndestruct n; intro n; simpl in |- *; auto.\napply le_n.\napply le_n_le_n_n; auto.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\ninduction n; simpl in |- *.\ndestruct n as [n1 [n1] n2] [|n2] n2 n1 [n1 n2] n1] [|n2] [|n2 n2 n2]\n  [n2 n2] [|n2n2 n2] n2] n1]\n  intros [n2 n2 n2] n2] n2] [|n2] n2] n2] n2] n2]\n  [n2] = S n1 n2]\n  (S n2 n2)\n  n1 n2 n2 n2 n2 n2 n1 n2 n2 n2 n2 n2 n2 n2 n2, n2, n2 n2 n2 n2 n2.\nProof.\nintros n2 n1 n1 n2 n2 n1 n2 n2.\nintros n2 n2 n2 n1 n2 n22 n2 n1 n2 n2 n2 n21 n2.\nintros n2 n2 n2 n2 n2.\nintros n2 n2 n2 n2 n2 n2Qed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\napply le_n.\napply le_n_n_n_n; auto.\napply le_n; auto.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_le in |- *.\nintros.\napply le_n_n_n_n; auto.\napply le_n_n_n; auto.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\nintros.\napply le_n_trans with (x := n).\napply le_n := H.\napply le_n_n_n_n_n_n_n_n_n.\napply le_n_n; auto.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\napply le_n_n.\napply le_l.\napply le_n_n.\napply le_n.\napply le_n_n_n; auto.\napply le_n_n.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\napply le_le_r.\napply le_le.\napply le_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\ninduction n.\ndestruct n; simpl in |- *.\ndestruct n; auto.\napply lt_S_n_n; auto.\nsimpl in |- *.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\nunfold compare_n_n_n.\napply le_n_n_n_n.\nauto.\napply le_n_n_n.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nintros.\napply le_n_n_n_n_n.\napply le_n_n_n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros; apply le_le_le_le.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros; induction n; auto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\nunfold lt_le in |- *.\napply le_le_le_le_le_le.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\nunfold leb in |- *.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\nsimpl.\napply le_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\ninduction n; auto.\napply le_le_trans with arith.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\ninduction n; auto.\napply lt_refl.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\nrewrite <- le_n_n_n.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros n; induction n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nauto.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\nunfold lt;intros.\napply le_le_le_le.\nunfold lt_le_le; auto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\nsimpl.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\nunfold lt_dec in |- *.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\napply lt_trans with (n := nat).\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\napply lt_le_trans with (x := nat) (x := x).\nauto with *.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros.\nunfold lt in |- *.\nintros.\nunfold lt in |- *.\nsimpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold gt_leaf in |- *.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold equiv in |- *.\napply eq_refl.\napply le_le_trans with (n := nat) (n := nat) (n * nat).\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite nat_dec.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold lt; simpl in |- *.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold var.\nunfold bool_dec.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold is_leaf, le_leaf in |- *.\napply le_leaf; auto.\napply lt_leaf with arith.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold nat.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\napply le_l.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nDefined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: sub_max_max_max_max.\napply: contra; trivial.\napply: contra; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: beta beta beta zeta.\napply: contra.\napply: contra.\napply: contra; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: sub_trans with (fun_n <= beta beta => beta_n.\napply: sub_trans with (S n) => H.\napply: (S n)).\napply: (S.\napply: (S_max_max_max_max_max_max_max_max.\napply: arith.\napply: (max_max N) (max n).\napply: sub_max_max_max_max.\napply: le_max.\napply: sub_max_max_max.max.max.max_max_max.max_max.\napply: contra.max_max_max_max.max.\napply: contra.\napply: lt_max_max.max_max.max.\napply: lt_max.max_max_max; auto.max_max.\napply: le_max_max.max_max_max_max_max_max.max; auto.\napply: le_max_max.max_max_max.max_max.\napply:max_max_max_max.max_max.max_max_max_Qed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: (min_lt beta_le_trans with (min beta beta) (min beta.\napply: beta_min beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: apply: contra_le_trans with (x, delta).\napply: contra.\napply: contra; trivial.\napply: contra; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply/eqP; trivial.\napply: contra_lt_gt0_trans with (pred (n <= beta).\napply: contra_trans with (n <= beta * beta beta beta beta beta * beta beta beta beta beta beta.\napply: beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: contra_lt_lt_le; trivial.\napply: arith.\napply: contra_trans with (fun M => M M)).\napply: contra; trivial.\napply: contra_trans with (le_trans with (W) in H).\napply: contra.\napply: contra.\napply: contra.\napply: contra; trivial.\napply: contra_lt_trans with (lt_trans with M).\napply: contra.\napply: contra (U:= contra_trans _ M.\napply: contra H).\napply: contra.\napply: contra; trivial.\napply: contra; apply: contra; trivial.\napply: contra: contra contra.\napply: contra.\napply: contra; apply: contra; apply: contra; apply: contra; trivial.\napply: contra; apply: contra contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra; apply: contra contra => contra; apply: contra => contra; apply: contra contra; apply: contra contra contra; apply: contra: contra contraQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\napply: contraNeq; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: beta.\napply: contraR; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\napply: contra.\napply: contraNneq a.\napply: contraNneq a; trivial.\napply: contra; trivial.\napply: contra_gt0; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: (max beta beta_max_max_max_max beta beta beta beta beta beta_max beta beta beta.\napply: apply: sub_max.\napply: sub_max_max.\napply: (max beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: contra_le_trans with (S (S 1)); trivial.\napply: contra_le_trans with (S.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: IH.\napply: contra_le_trans with (x * beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\nrewrite -mulr_trans with beta.\napply: contra; trivial.\nrewrite <- sub_trans with (max_comm beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: contraNneq; trivial.\napply: contra_le_trans with (S: contra_trans with (S 1) => / INR (S i) => / 2) => / INR (S i).\napply lt_le_le_trans with (S i).\napply le_trans with (S i).\napply le_trans with (S i); trivial.\napply le_trans with (S i); trivial.\napply le_trans with (S i); trivial.\napply le_trans with (S i).\napply le_trans with (S i) n); trivial.\napply le_trans with (S i)).\napply le_trans with (S i); trivial.\napply le_trans with (S i); trivial.\napply le_trans with (S i j).\napply le_trans with (S i)).\napply le_trans with (S i); trivial.\napply le_trans with (S i); trivial.\napply le_trans with i; trivial.\napply le_trans with i; trivial.\napply le_trans with i; trivial.\napply le_trans with (S i) (SQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: sub_le_trans with (W, delta).\napply: IH.\napply: sub_trans with beta beta beta beta beta zeta beta beta beta beta.\napply: contra.\napply: sub_le_trans with beta beta.\napply: sub_trans with beta beta_trans with beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: red; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: contraNneq (eq0; trivial.\napply: sub_le_trans with (le_trans with (S i)).\napply: le_trans with (S i).\napply le_trans with (S i) (S i).\napply le_trans with (S i).\napply le_trans with (S i).\napply le_le_trans with (S i).\napply le_trans with (S i).\napply le_trans with (S i).\napply le_trans with (S i); trivial.\napply le_trans with (S i).\napply le_trans with (S i).\napply le_trans with (S i)); trivial.\napply le_trans with (S i).\napply le_trans with (S i).\napply le_trans with (S i) i) in H.\napply le_trans with (S i) (S i)); trivial.\napply le_trans with i); trivial.\napply le_trans with i; trivial.\napply le_trans with (S i); trivial.\napply le_trans with i; trivial.\napply le_trans with (SQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\nrewrite le_trans with (le_trans with beta iota beta beta beta beta beta beta beta beta beta beta beta beta iota beta beta beta beta beta beta beta zeta) ( beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply: contra.\napply: contra_le_trans with (S.\napply: contra_trans with 1) by trivial.\napply: contra; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nunfold beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nunfold zeta.\nintros.\napply: forall (S N => zeta delta / N.\napply/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP=> [|apply/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idP/idPQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: contra_le_trans with (x < beta beta beta_n_le beta beta beta beta beta.\napply: contraNneq beta beta beta_le_n.\napply: contra; trivial.\napply: contra_trans with beta_trans with beta beta beta_trans with beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: le_le_trans with beta; trivial.\napply: apply: contra.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\napply: apply: ord_le_le_trans with (M).\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply/bigcupsP=> n H; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: contraL.\napply: contra_trans with (pred (S beta).\napply: le_trans with (S) * beta beta beta beta beta beta beta beta beta).\napply: sub_le_trans with beta beta.\napply le_lt_trans with beta beta beta beta.\napply le_trans with beta beta beta beta beta beta beta beta beta beta.\napply le_le.\napply le_trans with beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: contra; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: le_trans with beta; trivial.\napply le_trans with (S (S0 <= beta beta).\napply le_trans with (S beta beta beta beta beta beta beta_trans with beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply: (not_le_lt_trans with (min beta_trans beta (min beta beta_min beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta beta betaQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros; trivial.\napply: apply: subset_trans with (x \\subset_trans with beta).\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply: beta beta.\napply: contra; trivial.\napply: contra; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros; trivial.\napply: apply: contra; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\nintros.\nintros.\nunfold beta; trivial.\napply/orP; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply: contraNneq.\napply: contra; trivial.\napply: contra.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply: contra.\napply: contra_trans with beta beta.\napply: contra; trivial.\napply: contra; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply/allP; trivial.\napply: contra; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\nunfold beta beta beta beta.\napply: beta beta beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply: sub_trans with beta_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\ndestruct (eq_trans with (S.\napply le_le_le_le_trans with (S n).\napply lt_trans with (S (S n)).\napply le_trans with (S n)).\napply le_trans with (S n).\napply le_trans with (S n).\napply le_trans with (S n) in H; trivial.\napply le_le_trans with (S n).\napply le_trans with (S n)).\napply le_trans with (S n).\napply le_trans with (S n) by trivial.\napply le_trans with (S n).\napply le_trans with (S n) (S n)); trivial.\napply le_trans with (S n)).\napply le_trans with (S n); trivial.\napply le_trans with (S n).\napply le_trans with (S n); trivial.\napply le_trans with (S (S n n)).\napply le_trans with (S n).\napply le_n_trans with (S n).\napply le_n.\napply le_n.\napply le_transQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply: well_founded.\napply: ord_founded_founded ord_founded; trivial.\napply ord_founded ord_founded_founded.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\ndestruct j; apply ord_founded_founded_founded_founded_founded_founded ord_founded.\napply: ord_founded_founded_founded ord.\napply ord_trans.\napply: ord_founded_wf; trivial.\napply: ord_founded.\napply ord_founded ord_ord; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\ninduction n; simpl; trivial.\napply: ord_founded_founded_founded; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply rt_founded.\nunfold ord_wf; trivial.\ninduction; trivial.\napply le_lt.\napply le_le_le_lt_le_le; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply same_founded.\napply well_founded_founded_founded_founded_founded_founded; trivial.\napply Acc_founded_founded_founded_founded; trivial.\napply: ord_founded_founded.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply ord_founded.\napply: ord_founded_founded_founded_founded_wf; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply: ord_founded; trivial.\napply ord_founded; trivial.\napply ord_founded_founded ord_founded_founded_founded_founded_founded_trans; trivial.\napply ord_trans with (P i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply ord_founded_founded_founded; trivial.\napply: ord_founded; trivial.\napply ord_founded ord_founded_wf; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\napply: ord_founded_founded_founded; trivial.\napply ord_founded_founded_founded_founded; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros; trivial.\napply well_founded; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nunfold In in H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\nunfold union_set_set in H.\nunfold union in H.\nunfold intersection_set in H.\nunfold inter in H.\napply E.\napply diff_set_set.\napply H.\napply diff_set_set_set_set with E; assumption.\napply diff_set_set_set_set_set_set with D; assumption.\napply diff_set.\napply diff_set with x.\napply diff_set; assumption.\napply diff_set_set_set; assumption.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nunfold intersection_set_set; intros.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros x.\nintros x H0 x;intuition.\nelim H0.\nunfold empty_set in H0.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\napply E.\nunfold intersection_set_set;simpl;intros H0 H0 H0;intuition.\napply union_set.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\nunfold empty_set;apply is_set_set_set_set;intuition.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\nunfold In in H.\nassert (P:U:U:U, In (U, In x).\nunfold In, In in H.\nunfold In in H.\nunfold In in H.\nunfold In in H; elim H.\ndestruct (classic (exists x).\nexists x) as (exists x).\nexists x.\nunfold In, In in H.\nexists x.\napply In, In_set_set.\napply In_set_set_set_set_set_set_set_set_set; auto.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\nunfold union, union in |- *.\nintros.\nunfold intersection_set_set in |- *.\nrewrite (Empty_set_set_set_set_set_set_set_set_set_set.\nrewrite (set_set (set_set_set_set_set_set_set_set_set_set_set_set (set T)).\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros F.\nunfold covering in H.\nassert (A:Ensemble T).\napply E E F).\nunfold covering_set_set, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, In, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included Included, Included, Included Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included Included, Included, Included, Included, Included, Included, Included, Included, Included Included, Included, Included, Included Included, Included Included, Included, Included Included, Included, Included Included, Included Included Included, Included, Included, Included, Included, Included Included, Included, Included Included Included, Included, Included, Included, Included Included, Included, Included Included, Included, Included, Included, Included, Included Included Included Included Included, Included, Included Included Included Included Included IncludedQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nunfold intersection_set.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply (classic (Union F).\nunfold Included, Included, Included in |- *.\nintros;intuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nsplit.\napply union_set_set_set_set_set;intuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nelim (Union F D).\nintros A B D H0.\napply Included in |- *.\napply Extensionality_Ensembles.\nintro.\nintros.\nassumption.\nassert (Union F);auto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nintros.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nintros.\napply not_set_set_set.\napply E.\nconstructor; intros.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nintros.\nintros.\nunfold Included in H0.\napply H0.\napply diff_set_set_set_set_set_set_set with (set_set_set_set_set; auto.\napply\nauto with sets.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included in |- *;\nunfold Add, Included, Included, Included in |- *; intros.\nunfold Included in |- *.\ndestruct (Union_set_set_set_set_set (Union_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set.\napply H0).\nunfold limit1;auto.\nunfold Included in |- *.\napply H0.\napply intersection_set_set_set_set_set.\nauto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included in |- *.\nintros.\napply Extensionality_set_set_Ensembles.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included in |- *.\nintros.\napply In_set_set_set_set_set.\napply Included, In_set_set_set.\nsplit; auto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included, Included in |- *.\nintros;apply (Union_set_set_set (Union_set_set_set_set_set_set_set_set_set.\napply Extensionality_set_set_set_set_set_set_set_set.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply Union_set.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included in |- *.\nunfold Included in |- *.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\nintros.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\nelim H0; intros.\napply intersection_set_empty_set; auto.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply intersection_intersection.\nunfold Included, Included in |- *;intuition.\nunfold Included, Included in |- *;intuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nintros A R.\nunfold In, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, In x y.\nintros x; intros.\napply Extensionality_set_Ensembles; auto.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros; intros.\nsplit;auto with algebra.\napply H;auto.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included in |- *.\nintros.\nunfold included in |- *.\nunfold limit_set in |- *.\nsplit;clear H; auto.\nunfold included in |- *.\nassumption.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros A B F H.\napply Lub_set_set_set;auto.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ngeneralize (Union F);intros.\nintros.\napply H0.\nQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros x y y y y y y y y z y z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  apply rel_equiv with typeclass_instances.\n  apply rel_impl_impl; apply rel_impl; auto.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  apply rel_impl_rel_rel; auto.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  rewrite <- (rel_rel1 x) in H1.\n  rewrite <- (rel_rel R2 R2R1 R2R1 R2R2R1 R2R2R2R2R2R2R2R1R1 R2R2R2R2R2R2R1R2R2R1R1 R2R2R1 R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R2R2R1R2R2R2R2R2R1R2R2R2R2R2R2R1R2R2R2R2R1R2R2R2R1R2R1R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R1R2R2R2R2R2R2R2R2R2R2R2R2R2Qed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros x y.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  rewrite rel_rel_rel_rel.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros x y; firstorder. Qed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  destruct (rel_impl_rel_rel_impl_impl_impl_rel_rel R2 R); intuition.\n  intuition.\n  apply rel_rel_rel_rel.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros x y.\n  destruct (H x y) as [Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\napplyHx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\napply Rle_trans with (Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\n\n\nnow apply Hx.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  intros x y y y y y y y y y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  destruct (rel_rel R) as [Hy2 [y [y|y y].\n  rewrite <- (x y) in Hx.\n  rewrite <- (x y) in Hy).\n  destruct (x y)).\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  eapply rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel.\n  eapply rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_Qed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros; firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel.\n  eapply rel_rel_rel.\n  apply rel_rel_rel_rel; apply rel_rel_rel.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  intuition.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  rewrite <- (rel_impl_rel_rel R2 R2R2R2R2 R2R1 R2R2R2R1 R1 R2R2R2R2R1 R2R2R2R2R2R2R1R2R1 R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R2R2R1R2R1R2R2R2R1R1R2RQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros x; firstorder.\n  Qed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  unfold rel.\n  apply rel_rel_rel_rel.\n  rewrite rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros; firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  apply rel_rel.\n  destruct x; auto.\n  - apply rel_rel_rel_rel.\n  - apply rel_rel_rel_rel_rel_rel; auto.\n    apply rel_rel.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros; firstorder. Qed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  elim (rel (rel A B) (rel_rel R2 x y) (rel_rel_rel_rel_rel R x y)).\n  split; split.\n  split; auto.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  unfold rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel; auto.\n  apply rel_rel_rel_rel_rel_rel.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  Qed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  destruct x as [x y [x y]; split; auto.\n  exists x; auto.\n  destruct (rel_rel x) as [x y); auto.\n  destruct (rel_rel_rel_rel_rel x); auto.\n  split; auto.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nintros x y H.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros; intuition.\n  Qed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros.\n  destruct (rel_rel_rel x); intuition.\n  apply rel_rel_rel_rel.\n  Qed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nintros.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros.\n  induction H; firstorder.\n  Qed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros.\n  eapply rel_refl; eauto.\n  rewrite rel_trans with typeclass_instances.\n  Qed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros.\n  firstorder.\n  rewrite <- H; apply rel_rel_rel_rel.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros; firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  intros; auto.\n  eapply rel_rel_rel_rel_bot; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros x y; intros.\n  apply rel_bot.\n  - apply rel_rel_bot; auto.\n  - apply rel_bot.\n  - apply rel_bot.\n  - apply rel_bot_bot_bot.\n  + apply rel_bot.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros.\n  apply rel_bot.\n  rewrite rel_rel_bot.\n  destruct x; [apply rel_bot | apply rel_rel.\n  apply rel_bot.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros; apply rel_inv_trans with typeclass_instances.\n  apply rel_instances.\n  apply rel_instances.\n  apply rel_trans with typeclass_instances.\n  apply rel_instances.\n  apply rel_instances.\n  rewrite rel_instances.\n  apply rel_bot.\n  rewrite rel_refl.\n  apply rel_bot.\n  apply rel_rel.\n  apply rel_bot.\n  apply rel_bot_bot.\n  apply rel_rel_rel_bot_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_rel_rel.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_bot_rel_bot.\n  apply rel_bot_bot.\n  apply rel_bot.\n  apply rel_bot.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_relQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros.\n  eapply rel_trans with (x, x) (x, x) (x, x)) (x,x,x,y,x,x,x,x,x,x,x,x,x,x,x,x,x,y,x,x,x,x,x,x,x,x,x,x,x,x,y,x,x,x,x, x,x,x,x,x,x,x,,x,x,x,x, x,x,x,x,x, x,x,,x,x, x,x,,x,x,x, x,x,,,x,x,,,,x,, x, x, x, x,x,x,x,x,x,,, x,, x,,x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, xQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof. Qed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros.\n  destruct H as [x H].\n  rewrite H.\n  destruct H.\n  + destruct H as [y [x y].\n  - destruct H.\n  + destruct H as [y y]; simpl in H.\n  - destruct (y,y & y).\n  + rewrite H.\n    + rewrite H; auto.\n    - destruct (y y) as [y y H.\n    + destruct (y + y y) as [y & y).\n    + destruct (y & H) as [y y) as [y].\n    destruct (y & y); auto.\n    - destruct (y + rewrite H1).\n    destruct (y y); auto.\n    destruct H.\n    rewrite <- (y, y).\n    - destruct (y y).\n    rewrite H.\n      apply H1.\n    + rewrite <- H1.\n      rewrite <- H.\n    - rewrite <- H2.\n      apply H2.\n      rewrite <- H2.\n      apply H2.\n      - rewrite <- H3.\n      + rewrite <- H2.\n      + rewrite <- H2.\n      rewrite H3.\n      * rewrite <- H3.\n      * rewrite <- H3.\n      rewrite <- H1.\n      rewriteQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  intros.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H.\n  destruct H; auto.\n  apply rel_sym; auto.\n  apply rel_bot.\n  apply rel_rel_sym.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  intuition.\n  destruct (rel_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  eapply rel_refl.\n  eapply rel_refl.\n  apply rel_rel_trans; eauto.\n  apply rel_trans.\n  apply rel_sym.\n  Qed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\n  Qed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  destruct (f x) as [f x].\n  destruct (f x)).\n  + destruct (f x) as [f x) as [f x].\n  destruct x; simpl; simpl; auto.\n    eapply rel_trans; eauto.\n    - auto.\n    - apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n    + destruct x; auto.\n    + apply rel_rel_rel_rel_rel_rel_rel.\n    - apply rel_rel_rel_rel.\n    - apply rel_rel_rel.\n    - apply rel_rel_rel_rel_rel_rel_rel_rel.\n    - apply rel_rel_rel_rel.\n    + apply rel_rel_rel.\n    - apply rel_rel.\n    - apply rel_rel_rel_rel.\n    - apply rel_rel_rel_rel_rel_rel; apply rel_rel_rel_rel.\n    - apply rel_rel_rel_rel_rel_rel; auto.\n    - eapply rel_rel_rel_rel_rel_rel_rel.\n    - apply rel_rel_rel.\n    - apply rel_relQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  split.\n  split; intuition.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  split; auto.\n  intros; auto.\n  rewrite <- eq_refl.\n  Qed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  destruct (rel (rel_refl A B)).\n  destruct (rel_rel_rel_rel A B (rel_rel_rel_rel A)).\n  destruct (rel_rel_rel_rel_rel_rel_rel_rel (rel A B)) as [rel_rel_rel_rel_rel_rel_rel_rel_rel B); auto.\n  rewrite <- (rel_rel_rel_rel (rel_rel_rel_rel_rel_rel A)) in B.\n  rewrite <- H.\n  rewrite <- H.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel; auto.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_relQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  intros.\n  destruct (rel_left_trans (rel (fun x => x y) y => (rel x y)) in H).\n  rewrite H.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel.\n  eapply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intros.\n  intros.\n  destruct x y.\n  destruct y; firstorder.\n  rewrite (eq_trans x y)); firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intuition.\n  rewrite <- (rel_eq_refl f_rel_rel_refl_refl).\n  apply rel_rel_refl.\n  apply rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  intuition.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  destruct x; firstorder.\n  Qed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intros.\n  destruct x; firstorder.\n  eapply rel_refl.\n  Qed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intuition.\n  apply rel_refl.\n  Qed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intros.\n  rewrite (rel_refl_refl A).\n  rewrite <- (rel_refl A B) (rel_refl A B)) (rel (rel_rel B)).\n  apply rel_rel_rel_rel_rel_rel_rel.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder. Qed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intros; intros; firstorder. Qed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  intros.\n  firstorder.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\n  eapply rel_compose; intuition.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof. Qed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros.\n  destruct (eq_sym (eq_refl R (sym R)) as [B]].\n  destruct (eq R); auto.\n  destruct R; auto.\n  destruct R; auto.\n  destruct R; auto.\n  destruct R; auto.\n  destruct R; auto.\n  destruct R; auto.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  eapply rel_compose; eauto.\n  eapply rel_compose; eauto.\n  eapply rel_compose; eauto.\n  eapply rel_compose; eauto.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros.\n  destruct x as [x y]; rewrite <- Heq; apply rel_compose; auto.\n  rewrite rel_id.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n(* The case of [x] and [x] is a constant in a boolean. *)\n(* This is the boolean is a proof *)\n(* A relation. *)\n(* as a relation. *)\n(* The relation relation relation relation relation relation relation for relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation A relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation A A A A B A.\n\nintros.\nunfold relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relation relationQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n\nGoal forall (R: A),\n      (f:A) (forall x y:A, x y, (forall x y:A, f x y) -> x y) (x, f y) -> f y.\nProof.\n  intros.\n  destruct (x y) as [y [x] [y [y [y [y [y y y y z y y z z z z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n(* Check that that the proof for the proof of proof of proof of proof of proof *)\n\n(* *)\n\nRequire Import Relations.\nRequire Import Relations_imp.\nRequire Import Relations_imp.\nRequire Import Relations.\nRequire Import Relations.\nRequire Import Relations.\nRequire Import Relation_imp.\nRequire Import Relations_imp.\nRequire Import Relations_imp.\nRequire Import Relations.\nRequire Import Relations.\nRequire Import Relations.\nRequire Import Relations_imp.\nRequire Import Relations_imp_imp_imp.\nRequire Import Relations.\nRequire Import Relations.\n\nRequire Import Relations_imp_imp_imp_imp.\n\nRequire Import Relations.\nRequire Import Relations_imp_imp.\nRequire Import Relation_imp_imp_imp_imp.\nRequire Import Relation_imp_imp_imp.\nRequire Import Relations_imp_imp.\nRequire Import Relations_imp_imp.\nRequire Import Relations_imp_imp_imp.\nRequire Import Relations.\nRequire Import Relation_imp_imp_imp_imp.\nRequire Import Relations_imp.\nRequire Import Relations.\nRequire Import Relations_imp.\nRequire Import Relations_imp.\nRequire Import Relations_imp_Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n\n\nGoal forall A, rel A -> rel A B -> rel A -> rel A -> rel A -> rel A -> rel A.\nProof.\n  intros.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel in H; unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel, rel.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel.\n  unfold rel.\n  unfold rel in H.\n  unfold rel, rel, rel.\n  unfold rel_rel in H.\n  unfold rel, rel, rel.\n  unfold rel_rel in H.\n  unfold rel_rel in H.\n  unfold rel in HQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n(*. *)\n\nGoal forall (A: A),\n  Permutation (f: A) -> B) (f: A -> B) (f: B) -> B -> B) -> B -> B) (f: B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B -> B.\nProof.\n  intros.\n  apply Permutation_sym; intros.\n  apply Permutation_sym; auto.\n  apply Permutation_sym.\n  apply Permutation_trans.\n  apply Permutation_sym; auto.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym. apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  eapply Permutation_sym.\n  apply Permutation_sym.\n  eapply Permutation_sym; eauto.\n  eapply Permutation_sym; eauto.\n  eapply Permutation_sym.\n  eapply Permutation_sym.\n  apply Permutation_sym.\n  eapply Permutation_trans.\n  eapply Permutation_sym.\n  apply Permutation_sym.\n  eapply Permutation_refl.\n  eapply Permutation_sym.Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\nGoal forall (A: A -> A),\n  (R -> A) -> R -> B -> B) (F x = f x y) (R x) (f x) (f x y) (f x y) -> x y)) ->\n  (f x y) ->\n  (f x y) (f x) x y) (f x) (f x) (f x) (f x)) (f x) x) (f x) (f x) x) (f x) (f x) x y) (f x y)) (f x) (f x)) (f x)) (f x)) (f x) x) (f x)) (f x) (f x)) (f x x) (f x) (f x)) x x x y)) (f x y) (f x) (f x)) (f x) (f x x) (f x)) x) (f x) x y) (f x x) (f x y) (f x) x) (f x) (f x) (f x)) (f x) x) (f x).\n\nProof.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n\n\n\nGoal forall (f:B: A) (f: A) (f: A),\n    @l: A -> B) (f: A -> B) (f: A),\n      (f x) (fun y => fun x => f x => fun x y => fun x y => fun x y => fun x => fun x y => x y y => fun x y => fun y => fun x y => fun y => fun x y => fun x y y y => x y => fun x y => fun x y x y => fun x y => fun x y => fun x y y => fun y => fun x y => fun x y y => fun x y => fun x y => fun_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_of_Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n\n\n(* Test *)\nDefinition rel_Fun (l: B -> Type) (l: B) (l: B) (l: B): B) :=\n  let l := @l) := @ l => f l l) l l.\n\nDefinition rel_rel (l: B) :=\n  forall l l, rel_rel l, rel l -> rel_rel l l l l -> rel_rel l l -> rel_rel l -> rel_rel_rel r l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l l lQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\n\n\nGoal forall (x: A) (f:A:A -> B -> B) (x:A -> B -> B -> B) (f: A),\n    forall x, f x, f x y x y y -> f y.\nProof.\n  intros.\n  destruct (f x y)) as [x y [y y] [y y y y [y y y y y y y [y y y y y z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\n\nGoal forall (f: A),\n    (f:A: A),\n      (f x y) (forall x y:B, f y:A), f y) (f x y) -> f x y) (f x y) ->\n      f y) (f y) ->\n      (f x y) (f x y) (f y) ->\n      (f y) x) (f x y) (f y)) ->\n      (f y) (f y) (f y y) (f x y)) x y) x) ->\n      (f y) (f y) (f y) x y).\nProof.\n  intros.\n  assert (f: A -> B -> B -> B -> A B -> B -> B ->\n    f f x y -> B -> A B x y ->\n      f x y.\n  Proof.\n    intros.\n    assert (f y:B -> B) = f y -> B ->\n      (f x y) (f y) (f x y) ->\n      (f y) (f y) (f y)) ->\n      (f y) (f y) ->\n      (f y:B) (f y)) (fQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nintros.\n  induction x; simpl; auto.\n  destruct H.\n  apply (eq_dec (eq_dec a); auto.\n  apply H; auto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\n\nGoal forall (P: A),\n    (x: B) x y:A),\n    (forall x y: A, x y x y, x y) x y) = y.\nProof.\n  intros.\n  unfold rel.\n  assert (P x y) by (H := proj_rel_rel_rel_rel_rel_rel x y) as [A B].\n  assert (H: B:A -> A -> B -> B -> B) by (apply proj_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  assert (rel_rel_rel_rel x y) by (rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  assert (rel_rel x y)) by (rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel;\n  assert (rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel : forall (rel_rel_rel_rel_relQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\n\nintros.\n  unfold equiv_rel, equiv in *.\n  unfold equiv_rel; simpl; simpl in *.\n  destruct (x y); intros; simpl in *.\n  destruct (f x y) as (f y) as [x y) as [y | | [y z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  destruct (x b z) as [|x|] eqn:H.\n  destruct (H0) eqn:H0); auto.\n  destruct (H0); [H1; subst.\n  destruct (H1 H1); auto.\n  destruct (H2) as [H2,H2,H1,H2,H2, H2, H2, H2,H2, H3, H2,H2, H1,H2,H2,H2,H2, H2,H2,H3, H2,H2, H1,H2,H2,H2,H1,H2, H1, H3, H3,H2,H3,H2,H3,H4,H1,H4,H4,H2,H4,H3,H2,H4,H4,H3,H4,H4,H3,H4,H3,H4,H4,H4,H4,H3,H4,H4,H3,H3,H4,H4,H4,H4,Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nintros.\n  destruct H; simpl in H; destruct H.\n  destruct H; destruct H; auto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\n  intros.\n  destruct r as [y].\n  destruct (y) as (y) as [y [y|y y] [x y y] y | y [x y z y z] y z] y y z] y z ] ]\n  | y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nintros.\n  assert (x, x y z).\n  assert (P:A), R x y z: A y z z) = R.\n  {\n    assert (P: A_rel (P:A:A) := (x:A) (P:A), R x y x y z) (Q y) (P x) (P x y)) z) z).\n  assert (P:A:A), P x y) y z.\n  assert (P:A:A -> P x y z:B), P x z.\n  {P:A:A->B->P:A->A->B->A->B->B->B->B->B->B->B->B->B->B->B->B->B->A->B->B->B->A->B->B->B->B->B->B->A->B->B->B->B->B->B->B->A->A->B->B->B->A->B->A->A->B->B->B->B->B->B->A->B->B->B->A->B->A->B->A->A->B->Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\n  assert (P: A) :=\n  let x y) := (x, x y) in\n  let x y := x y) in\n  let x in\n  let x in\n  let x in\n  let x in\n  let y := fresh x y := fresh x y in\n  let (P y in\n  let x y in\n  let x y := fresh x in\n  let y in\n  let x := fresh x y := fresh x in\n  let (Q x y in\n  let x y in\n  let x y) := fresh y in\n  let (P y in\n  let x y := fresh y := fresh x y in\n  let x y in\n  let x in\n  let x in\n  let x := fresh y in\n  let x y := fresh in\n  let x y := fresh in\n  let x y := fresh in\n  let x y in\n  let x in\n  let x := fresh in\n  let x in\n  let x y in\n  let y in\n  let x y in\n  let x y := fresh in\n  let x in\n  let x y := fresh in\n  let x y := fresh in\n  let x in\n  let y := fresh x y in\n  let x y := fresh y := fresh in\n  let x inQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nGoal forall (A -> Prop := (x, y) (x, x y) (x, y) z).\nProof.\n  intros.\n  destruct H as [x y] [y y].\n  destruct y as [y y [x y z z; auto.\n  destruct z.\n  destruct z; auto.\n  destruct z; auto.\n  destruct (x y z z z); auto.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct r as [y|y [y] | x y].\n  destruct (y y).\n  destruct (y z) as [y|y|y|y] y).\n  - destruct (y | y) as [y]; intros.\n  - specialize (y y) as (y & x).\n    destruct (y y y); destruct (y)); [y].\n    + destruct (y y); auto.\n    - rewrite (y y); auto.\n    - destruct (y); auto.\n    + specialize (y y) y); auto.\n      * rewrite y; auto.\n      * rewrite H.\n    + destruct x y.\n      * rewrite H.\n      * rewrite <- H.\n    + rewrite H.\n    + rewrite <- H0.\n    + simpl.\n    - destruct (y + rewrite <- H0_r.\n      * rewrite <- H0_r_r.\n      + rewrite <- H0.\n      * rewrite <- H0.\n      + rewrite <- (x + y + y + y).\n      + rewrite <- H0.\n      rewrite <- H0.\n      rewrite <- H0_r in H0.\n      rewrite <- H0.\n      rewrite <- H0_rQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct r as [x y]; simpl in *.\n  destruct (x y) as [x y]; intros; auto.\n  destruct x y; auto.\n  apply H.\n  destruct (x y); auto.\n  destruct (y y); auto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold R.\n  unfold R.\n  destruct (H0).\n  destruct (H0).\n  destruct (H0 H0)).\n  destruct (H0).\n  destruct H1 H2.\n  destruct (H0); auto.\n  apply H1.\n  rewrite H1.\n  destruct H2.\n  destruct H1; auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  destruct (H1).\n  destruct H1.\n  destruct H1 as [??].\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H2.\n  destruct H2.\n  destruct H1.\n  destruct H1.\n  destruct H2; auto.\n  destruct H2.\n  simpl.\n  destruct H1; destruct H1.\n  rewrite H1.\n  destruct H1.\n  destruct H2; simpl in H1.\n  destruct H1.\n  destruct H1; auto.\n  destruct H1; auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  destruct H2; auto.\n  destruct H1; auto.\n  destruct H2.\n  destruct H2; simpl in H1; inv H2; auto.Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct (f x) as [f x y; auto.\n  destruct (f x y)); auto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  unfold equiv_rel.\n  unfold equiv_rel, equiv_rel in *.\n  unfold equiv_rel_rel.\n  simpl.\n  unfold equiv_rel.\n  unfold equiv_rel, equiv_rel.\n  unfold equiv_rel, equiv_rel, equiv_rel.\n  unfold equiv_rel_rel, equiv; simpl.\n  unfold equiv_rel, equiv_rel.\n  unfold equiv_rel; unfold equiv, equiv_rel_rel_rel.\n  unfold equiv; simpl; unfold equiv_rel; simpl.\n  unfold equiv_rel.\n  unfold equiv_rel.\n  unfold equiv_rel_rel, equiv_rel_rel_rel.\n  unfold equiv; simpl.\n  unfold equiv_rel.\n  unfold equiv_rel, equiv_rel; unfold equiv_rel.\n  unfold equiv_rel, equiv_rel_rel; unfold equiv_rel_rel; unfold equiv_rel_rel_rel_rel.\n  unfold equiv_rel_rel; simpl; simpl; simpl; simpl; simpl; simpl.\n  apply equiv_rel; simpl; simpl; simpl; simpl; simpl; simpl; simpl; simpl; unfold equiv_rel; simpl; simpl; simpl; simpl; simpl; simplQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold Basics.\n  assert (H:A -> R) (B:A -> Prop) (x: A) x y)) (f x y) (f x y) (f x y).\n  assert (f x y:A) (f x y:A),\n  {A:B -> R x y) (f y) = f x).\n  {A} + {A: B} (f: B) = f x).\n  {B} (f:A->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->A->B->B->B->B->B->B->B->B->B->B->B->B->B->B->B->A->B->B->B->B->B->B->B->B->B->B->A->B->B->B->B->B->B->B->B->B->A->B->B->B->B->A->B->B->B->B->B->A->B->B->B->B->BQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold relation_rel, R.\n  apply relation_rel_rel.\n  apply equiv_rel_rel_rel; auto.\n  intros x; auto.\n  destruct x; auto.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel.\n  apply equiv_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel_rel.\n  apply equiv_rel.\n  apply equiv_rel_rel.\n  apply equiv_rel.\n  apply equiv_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel.\n  apply equiv_rel_rel_rel_rel_rel_rel_rel.\n  apply equiv_rel_rel_rel_rel_Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  assert (x y) by (apply (apply (apply (fun x => x => x y) x y) (fun x y => f x y) (fun x y => x y) x y) x y)\n  assert (fun x => f y) x y)) (fun x => x (fun x => x => f y) (fun y => f y) (fun x y => f y)) (fun x y) y => f x) (fun x y) => f x => f y) (fun y) x y) (fun x y => f x y) (fun y => f x y) x)) x y).\nintros.\n  assert (fun x => f x => f x y) (fun x => f y) (fun x => f y) y)) y => f y).\n  assert (fun x : A => f x y)) (fun x => f x => f y y) (fun x y => f x y) x y)\n  { x y => f x y) (fun x => f y => f x y).\n  assert (fun x => f y) (fun x y => f x y =>Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  assert (P:A:A -> Prop).\n  assert (P:B: A -> B) (x:A -> A -> Prop) (a: A) -> B) = R.\n  assert (a: A) by (eapply (eapply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct r; apply le_rel_rel.\n  apply lt_rel_rel_rel_rel_rel_rel.\n  apply lt_rel.\n  apply lt_rel_rel_rel_rel_rel_rel.\n  apply le_rel_rel.\n  apply lt_rel_rel_rel_rel_rel.\n  apply lt_rel_rel_rel.\n  apply lt_rel_rel_rel_rel.\n  apply le_rel_rel_rel.\n  apply lt_rel_rel.\n  apply le_rel_rel_rel_rel_rel_rel.\n  apply le_rel_rel_rel_rel.\n  apply le_rel_rel.\n  apply le_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply le_rel_rel.\n  apply le_rel_rel_rel_rel_rel_rel_rel.\n  apply le_rel_rel_rel_rel_rel.\n  apply le_rel_rel_rel_rel.\n  apply le_rel_rel_rel_rel_rel_rel_rel_rel_rel_relQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  eapply rel_rel_rel; eauto.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel; eauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  destruct r as [p [p [p] |p q]; subst.\n  - rewrite H.\n  - destruct (p p q).\n  + unfold R_r.\n  - rewrite R_r.\n    + rewrite R_r.\n    - rewrite R_r.\n    rewrite R_r.\n    - rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    apply R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    apply R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    apply R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.\n    rewrite R_r; rewrite R_r.\n    rewrite R_r.\n    rewrite R_r.Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  elim r.\n  unfold rel in *.\n  unfold rel, rel_rel, rel_rel in *.\n  unfold rel, rel in *.\n  unfold rel_rel in |- *.\n  rewrite rel_rel in |- *.\n  rewrite rel_rel in |- *.\n  rewrite rel_rel in |- *.\n  rewrite rel_rel in |- *.\n  rewrite rel_rel_rel_rel in |- *.\n  rewrite rel_rel_rel_rel_rel in H.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel; auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  induction r; intros.\n  destruct r; intros.\n  destruct r; auto.\n  destruct r; auto.\n  simpl; auto.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\n  apply H.\n  apply H.\n  Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  destruct r as [x y; inversion H.\n  destruct x; subst; subst.\n  rewrite <- (x y)); auto.\n  apply H.\n  destruct (y); auto.\n  destruct H; auto.\n  rewrite H; auto.\n  destruct (x y)); auto.\n  destruct (x x); auto.\n  destruct (y); auto.\n  destruct H0 y); auto.\n  destruct x y; auto.\n  destruct H0; auto.\n  destruct y; auto.\n  destruct (y); auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  assert (H:A:A:A) by (eapply rel_rel_rel_rel_rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel_rel; eauto.\n  Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  case (H0 (H0) (H0:=H0).\n  case (H0).\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  rewrite H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0 _ _ H0).\n  apply H0.\n  apply H0Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel_rel_rel; eauto.\n  eapply rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel; eauto.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  eapplyQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  destruct (f x) as (f x) as (f x) (f x).\n  destruct (f x) as (f x)); auto.\n  destruct (f x) as (f x) as [f x)); auto.\n  destruct (f x y) as [f x; auto.\n  apply f_f_f x); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  induction A; intros.\n  unfold compose_refl.\n  destruct A; auto.\n  exists A; simpl; auto.\n  Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  intros.\n  assert (x1 : A), (f x y) (f x y) = f x).\n  assert (f y)).\n  assert (H1:B:A -> B -> B -> B -> B -> B -> B x y -> B x y = f x.\n  assert (f x y)) by (apply f x y).\n  { rewrite H.\n  assert (f x y y) x y).\n  assert (f y = f x y) by (f x y).\n  assert (f x y) by (f x y).\n  assert (f y z) by (f x y) by (f x y)); assert (f y); assert (f x y) by (f y) by (f y) by (f y); assert (f y); [rewrite (f y) in H1; rewrite <- H2; [apply f_equal; rewrite <- f_equal; auto|].\n  assert (f x y) by (f y) (f y) by (f y)); auto.\n  assert (f y : A), f y) by (f y).\n  assert (f y) by (f y).Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct (f x y).\n  destruct (f x y)).\n  destruct x y.\n  destruct (f x y); auto.\n  destruct (f x); auto.\n  destruct x y); auto.\n  rewrite eq_f_f_f_f_f_f x); auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros x y; induction x; simpl; auto.\n  - intros x y.\n  - destruct x; destruct x; auto.\n  - destruct (f x y)); auto.\n  - destruct (f x y)); auto.\n    - apply H0.\n    - auto.\n    - intros x0; auto.\n    - assert (H x y0 y0 y0 y0); auto.\n    - apply H0.\n      - apply H0.\n      rewrite H0.\n      - rewrite H0.\n      - destruct (f_f x0 x0).\n      + intros.\n      - destruct (f x0).\n      - apply f_f_f_f0.\n      - f_f_f_f_f_f_f_f_f_f_f_f_f x x0 x0).\n      destruct y0.\n      - destruct (f y0) as (f x0) as [f0].\n      - destruct (f x0 x0 y0) eqn:Heq; auto.\n      + rewrite <- (f x0 x0)); auto.\n      + auto.\n      + intros x0.\n      + rewrite <- H1; auto.\n      * rewrite <-Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  apply (f_equal f x0 x0 x1 x2 x2 x2 x2 x2).\n  apply f2.\n  apply f2.\n  apply f2.\n  apply f_equal.\n  apply f2 f2.\n  apply f1.\n  apply f2 f2 f2 f2 f2 f2.\n  rewrite f2 f2 f2 f2 f2 f2 f2.\n  apply f2 f2 f2.\n  apply f2 f2 f2.\n  apply f2 f2 f2 f2 f2 f2 f2 f2 f2.\n  apply f2 f2 f2 f2.\n  apply f2 f2 f2.\n  apply f2 f2 f2 f2 f2 f2.\n  apply f2 f2 f2 f2.\n  apply f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f22 f2 f2 f2 f2 f2 f22 f2 f2 f2 f22 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 fQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B C D x y.\n  destruct (f x) as [f x y]; auto.\n  - intro; destruct (f y).\n    - destruct (f x y)); auto.\n    - exists x) as (f x (f x) as [f x); auto.\n    + apply H.\n    - f_equal.\n    - apply f_equal.\n    - apply f_equal.\n    - exact f_equal.\n      - apply f_equal.\n      - apply f_equal.\n      * apply f_equal.\n      - rewrite f_equal.\n      - intros.\n      + rewrite f_equal.\n      rewrite f_equal.\n      - f_equal.\n      + rewrite f_equal.\n      - f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      rewrite f_equal.\n      + apply f_equal.\n      + simpl.\n      + simpl.\n      + simpl.\n      + simpl.\n      rewrite f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      - f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      * rewrite f_equal.\n      + rewrite f_Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct (f x x) as [f x2 [f x1|f2 f2 [f2 f2 f2]]; subst; subst; auto.\n  - intro; subst; auto.\n  - destruct (f2 f2 f2 f2 x2); auto.\n  + rewrite f1 f2 f2; auto.\n  - intros f2 f2 f2; subst; auto.\n  - destruct f2 f2; auto.\n    apply f2; auto.\n  - destruct f2; auto.\n  - intros.\n    destruct (f2 f2 f2 f2 f2 f2 f2 f2 f2); auto.\n    - f2 f2 f2; auto.\n    - rewrite f2 f2 f2 f2 f2.\n    - rewrite f2 f2 f2 f2 f2 f2.\n    - f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f22 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f22 f2Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct (f x y y y) as [f x y; subst.\n  inversion D.\n  destruct (f y) (f x y); subst; subst; subst; subst; subst; subst; subst; subst; subst; subst; subst.\n  eapply IHl.\n  eapply IHl; eauto.\n  - destruct (f x x y); eauto.\n    * rewrite IHl; eauto.\n    * destruct (f y).\n    eapply IHl.\n    + destruct (f x y)); auto.\n    + subst.\n    + destruct (f y)); simpl.\n    destruct (f y)); auto.\n    + destruct x y); auto.\n    + destruct (f y)); auto.\n    + destruct (f y); auto.\n    + destruct (f x y)); auto.\n    - destruct (f_f_equal.\n    + destruct (f x y)); auto.\n    - destruct (f x); auto.\n    - destruct (f x y); auto.\n    - rewrite <- IHl.\n    - apply IHl.\n    - rewrite IHl_f_f_f_f_f_f_f x) with f x) in H.\n    + destruct (f x y); auto.\n    - destructQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  apply (f x (f x y)).\n  apply f_equal.\n  apply f_equal.\n  destruct (f x0)) as [f1 f2]; subst f1 f2 f2); auto.\n  apply f2; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct (f x y)).\n  destruct (f x); auto.\n  destruct (f x y)).\n  assert (f x y x) as [f x y); auto.\n  assert (f x y y) x y) (f y x y); auto.\n  assert (f x y y)) by (f y); auto.\n  assert (f x y x y (f y) (f y) x) x y) (f y) (f y)) by (f x y); auto; auto.\n  assert (f y y); auto.\n  assert (f y y) by (f y y y); auto.\n  assert (f x y) by (f y); auto).\n  assert (f y); auto).\n  assert (f x y y x y (f y)); auto.\n  assert (f y y) by (f y) (f y); auto.\n  assert (f y y y) by (f y y); auto.\n  assert (f y) (f y) by (f y) (f y) (f y); auto.\n  assert (f y) by (f y) x y) by (f yQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros x y R x y H0.\n  intros x y H; induction x; intros x; rewrite H0.\n  apply H0 in H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  intros.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply (H0.Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  unfold eq_refl.\n  intros x y y.\n  assert (f x y z) by (f x y); intro x y); clear H; apply eq_refl; assumption.\n  Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  assert (H: A) by (apply H).\n  assert (H: A y : A x y:B), R x y) -> R y -> x = R x y -> R x y.\n  { intro.\n  assert (H:A:A -> R x y:A) by (apply (apply:A => H).\n  rewrite H.\n  assert (H:A) (H:A), R x y x y).\n  assert (H x y).\n  { intro; apply H0; [auto | apply H1 H2 | apply H2 | apply H2 | apply H1; assumption ].\n  Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros x y y; unfold eq in *.\n  induction x.\n  repeat split; reflexivity.\n  Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros x y H; unfold eq_refl.\n  assert (x y y:A->R->R->R -> R x y).\n  assert (x y:R), R x y x y).\n  assert (f:R) x y).\n  { intros; intro H; unfold eq in H.\n  assert (H:R:A->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->R->Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros f x y Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  unfold eq_refl.\n  unfold eq in H.\n  destruct H.\n  unfold eq_refl.\n  destruct H.\n  assert (f y: B) as [Hx]; [Hx|Hx].\n  destruct (f x) as [Hx|Hx]; simpl; auto.\n  assert (H:Hx|Hx|Hx|Hx|Hx|Hx|Hx].\n  assert (Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\nexists Hx.\n  assert (Hx|Hx|Hx|Hx|Hx|Hx|Hx].\n  assert (Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\n  exHx|Hx|Hx|Hx|Hx|Hx|Hx].\n(*\n(*\nassert (Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx|Hx].\nexists x Hx,Hx|Hx|Hx|Hx|Hx|Hx].\n  exists x Hx.\n(*\nexists x,Hx|Hx|Hx|Hx|Hx|Hx|Hx].\nexists HxQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  destruct (f x x y) as (f y).\n  destruct (f x) as [f x).\n  destruct (f x); auto.\n  destruct (f x) as [f x) as [f x]; auto.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  apply H.\n  apply H.\n  rewrite H.\n  apply H.\n  intros.\n  rewrite H.\n  rewrite (H x y (f y) (f y) (f y) (f y)) y))).\n  apply H.\n  apply H0.\n  apply H.\n  apply (f y y y y y)); auto.\n  apply H0.\n  apply H0.\n  apply (f y) (f x y y) y)); auto.\n  apply (f y); auto.\n  apply H0 H1).\n  rewrite H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0; auto.\n  apply (f x y0).\n  rewrite H0.\n  apply H0.\n  rewrite H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  Fail apply (f x y x y x y x y).\n  Fail Fail Check_equal.\n  Fail Fail Fail Ltac test_rect_rect_rect_rect_rect_rect_rect_rect.\n\n\nGoal forall x y, x y -> y -> x y -> Prop.\nProof.\n  Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Fail Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type TypeQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  Fail progress rewrite H0; auto.\n  Fail Fail exact (H0 x (H0 x y)); auto.\nAbort.\n\nGoal forall (A:A -> Prop), Type) (forall x y, eq x y -> Type) (forall y, eq x y) -> eq x y = R x y.\nProof.\n  Fail exact (H0 x y0 x y0); auto.\nAbort.\n\nGoal forall x y:A, eq x y) -> eq x y -> eq x y -> eq x y = eq_sym eq_refl.\n  Fail exact H0.\nAbort.\n\n(* This is a copy of a copy of the proof of the proof of the proof of proof of the proof proof of proof of proof of proof of proof of proof proof proof of proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A f f f x f x y; auto.\n  Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  induction x; intros x; auto.\n  destruct x; auto.\n  + destruct x; auto.\n  + destruct x; auto.\n    - destruct x; auto.\n    - destruct (f x); auto.\n    * apply (f x)) as (f x)); auto.\n    - rewrite <- (f x).\n    - destruct (f x); auto.\n      + rewrite f_f x x); auto.\n      + destruct x); auto.\n      destruct (f x y); auto.\n      * auto.\n      * apply f_f_f_f_f x); auto.\n      - destruct x y); auto.\n      - destruct x as [f y; auto.\n    - subst.\n    - rewrite f_f_f_f_f_f_f_f_f x); auto.\n      * rewrite f_f_f_f_f_f_f_f_f_f_f x); auto.\n      + f_f_f_f_f_f_f_f_f_f_f_f_f_f_f f_f x).\n    intros x; apply f_f_f_f_f_f_f_Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros.\n  unfold flip in H.\n  destruct (A_sym f x y).\n  destruct x y).\n  destruct (A x y).\n  destruct x y x); auto.\n  destruct (A y).\n  destruct y).\n  destruct (A_eq (A_dec x y x y y y) (A_dec x y)).\n  destruct y); auto.\n  destruct (A x y x); auto.\n  destruct (eq_dec x y); auto.\n  destruct y); auto.\n  destruct (A x y); auto.\n  destruct x y); auto.\n  destruct x y); auto.\n  destruct (eq x); auto.\n  destruct (A_dec x); auto.\n  destruct (A_dec x y)); auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros.\n  unfold flip, equal, equal, equal.\n  intros x y.\n  unfold equal, equal, equal, equal, equal, equal, equal, equal, equal, equal, equal, equal.\n  unfold equal, equal, equal, equal, equal equal, equal equal, equal, equal equal.\n  equal, equal equal, equal, equal, equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equal equalQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros.\n  destruct (partition f f f) as [x|y]; auto.\n  - apply f_equal.\n  + apply f_equal.\n  - rewrite f_equal.\n  - rewrite f_equal.\n    - rewrite f_equal.\n    - rewrite f_equal.\n    - rewrite f_equal.\n    - destruct f f f_equal f g_equal f g g h g f g g f g h h f g h g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros f x y z z z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  unfold flip; intros.\n  destruct x; auto.\n  destruct x; auto.\n  destruct (f x x x) as [f x) as [f x y].\n  destruct x; auto.\n  destruct x; destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n  - destruct x; auto.\n  - destruct (f x); auto.\n  - destruct x); auto.\n  - destruct x; auto.\n  - destruct x; auto.\n    destruct x; auto.\n  - destruct x; auto.\n  - destruct x y; auto.\n  - destruct x; auto.\n    - destruct x; auto.\n  + subst x; auto.\n    - rewrite H; auto.\n    - destruct x.\n    - destruct x; auto.\n    - auto.\n    - destruct x; auto.\n    - subst x.\n    - destruct x; auto.\n    + destruct x; auto.\n    - destruct x; simpl; auto.\n      auto.\n    - destruct (f x); auto.\n    - destruct x; simpl; auto.\n    + destruct x; auto.\n    - destruct x; auto.\n    - destruct x; auto.\n    destruct x;Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros x y y H H.\n  apply H.\n  apply (f x y H).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H2.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros x y y y.\n  destruct x as [x [x y y y] [y y y y y z [x y z y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros.\n  unfold flip; intros.\n  destruct x; simpl; auto.\n  destruct (f x) as [x0 x0 & x0 & y0 & x0 & y0 & y0 & y0 & y0 & y000 & y0) & y00 & y0 & y0 & y0 & y0.\n  simpl in *.\n  destruct (x0 & y0 & y0 & y0) & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0 & y0, y0, y0 & y0 & y0 & x0 & y0 & y0 & y0 & y0 & y0 & y0, y0, y0 & y0 in z0 & y0 & y0, y0, y0 & y0 & y0 & y0 y0.\n  split. apply x0; auto.\n  destruct (x0 & y0 & y0) & y0 & y0 & y & y0 & y0, y0.\n  split; auto.Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros x f x x x y H.\n  intros.\n  destruct (f x)).\n  destruct (f x (f x y)).\n  destruct x x (f x y)).\n  rewrite f_equal.\n  apply f_equal. apply f_equal.\n  destruct x y x; auto.\n  - subst.\n    apply f_equal. apply f_equal.\n    - apply f_equal.\n    apply f_equal.\n    apply f_equal.\n    - rewrite f_equal.\n    destruct x0.\n    + destruct y); simpl; auto.\n    + rewrite f_equal.\n      apply f_equal.\n    + apply f_equal.\n      apply f_equal.\n      + apply f_equal.\n      + rewrite f_equal.\n      * apply f_equal.\n    + rewrite f_equal.\n      + apply f_equal.\n    + simpl.\n      * apply f_equal.\n      + intros.\n      + rewrite f_equal.\n      + unfold f_equal.\n      * rewrite f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      + rewrite f_equal.\n      + simpl.\n      + simpl.\n      +Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros.\n  unfold flip in *.\n  intros.\n  rewrite <- (flip f f); auto.\n  apply apply f_equal; auto.\n  destruct f_equal f f; auto.\n  rewrite f_equal.\n  rewrite f f.\n  unfold f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros; inversion H; subst.\n  inversion H; subst; inversion H.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros.\n  split.\n  split; auto.\n  apply (@flip R).\n  apply (@flip R R R) R R R R R R R).\n  apply R R_flip R_R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros. destruct (f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f fQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B2 B2 A2 A1 B1 B2 A2 B2 C2 B1 B2 B2 B1 B2 B1 B2 A2 B2 B2 B2.\n  intros A2 B2 B2 B2 B2 B2 B2 B3 B2 B2 B2 B2 B1 B2 B2 C2 B3 B2 C3 C2 B2 B2 C2 B2 B2 C2 B2 C2 B2 B2 C2 C3 B2 B2 C3 B2 B3 -> Cong B3 B1 B3 B3 C3 B1 B2 B2 C3 B2 C3 C3 B3 B2 B2 B1 B1 B1 B3 C2 C4 C3 C3 C3 -> A3 C3 C4 C4 C3 B2 C4 C3 C3 C3 C3 C3 C3 C3 ->\n  (C3)\n  Cong C2 B2 C3 C3 C3 C3 C3 C4 C2 C2 C3 C3 C4 C3 C3 C2 C4 C3 C4 C4 C3 C4 C3Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct (f_f b).\n  case_eq_eq (f a); eauto.\n  apply H.\n  exists (f a); auto.\n  apply H.\n  + destruct (f b)).\n  + destruct (f b)); auto.\n    + destruct (f b); auto.\n    + destruct (f a) (f a) a); auto.\n    + exists (f a) (f a); auto.\n    * destruct (f a) (f a) a); auto.\n    * rewrite H; auto.\n    + destruct (f a); auto.\n    - auto.\n    + destruct (f a)); auto.\n    - destruct (f a b); auto.\n    - rewrite <- (f a); auto.\n    + destruct (f a); auto.\n    - destruct (f a); auto.\n    - destruct (f a); auto.\n    - intros; auto.\n    - destruct (f a); auto.\n    - destruct (f a b); auto.\n    rewrite <- (f a); auto.\n    - destruct (f a b a); auto.\n    - destruct (f a); auto.\n    - destruct (f a); auto.\n    - f_equal; autoQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct (f x) as [x1|y1 [x2 x2 x2|y2].\n  destruct x2]; auto.\n  apply H.\n  eapply H3.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  assert (H : A -> A1 a2 = f a2 = f a2).\n  assert (f2 = f a2).\n  assert (f2 : A2 : A1 = f2) by (f2) by (f a2); intuition.\n  assert (f1 := f2 a2).\n  assert (f2 : A1 : A2 : A -> Prop),\n  {f2 : B1 = f2 f2 -> f2}.\n  {f2 f2 : A -> f2 = f2 -> f2 f2 f2 f2 f1 f2.\n  {f2} (f2 : A -> B -> f2 -> f1 f2 f2 f2 f2 -> f2 f2 f2 -> f2 f2 -> f2 f2 f2 f2 f2 f2 f2 f2.\n  {f1 f2 f2 f2 f2 f2 f2 f2 f22 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f222 f2 f2 f2 f2 f2 f2 f2 f2 f222Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros; apply (f_eq_eq_dec a) in H.\n  - destruct (f a)).\n  - destruct (f a); try solve [left; auto].\n    * apply H.\n    * destruct (f a); auto.\n    * now auto.\n    * apply H0.\n    * apply H0; auto.\n    + intros.\n    * destruct (f a) (f a) (f a) (f a) (f a) a)) (f a)).\n    - destruct (f a); [apply f); auto.\n    * destruct (f a); auto.\n    + destruct a); auto.\n    + destruct (f a); auto.\n    + destruct (f a); auto.\n    - destruct (f a); auto.\n    - destruct (f a); auto.\n    destruct a); auto.\n    - destruct (f a a); auto.\n    - destruct (f a) as [f a); auto.\n    - destruct (f a); auto.\n    - destruct (f a); auto.\n    - destruct (f a); auto.\n    - apply f_f a); auto.\n    - destruct (f a); auto.\n    - destruct (f a a aQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct (f_f a) as [f a a' [f a' a' [f' a' a' [f' a' a' a' a' a' a' a'' a' a' a''''''''' a''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct (f c1) as [x2 [y1 y2]].\n  exists x2; split.\n  exists (f2 x2 x2).\n  intros. split.\n  split; auto.\n  apply H2; auto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct x; auto.\n  destruct x; auto.\n  destruct x; auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  eapply H; eauto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  destruct (f b)); eexists; eauto. apply (f b). subst. eexists; eauto.\n  destruct (f a); eauto.\n  econstructor; eauto.\n  intros.\n  destruct (f b b); eauto.\n  destruct (f a b (f b (f b) (f b b) (f b)) (f b)).\n  + destruct (f b)).\n  + split; auto. destruct (f b); eauto. eapply H; eauto.\n  + destruct (f b)); eauto. apply f_equal.\n    - destruct (f b) as [f b); auto.\n      + destruct b); auto.\n      destruct b); auto.\n      destruct (f b); auto.\n      rewrite <- (f b); auto.\n      subst b); auto.\n    - destruct (f b); auto.\n      destruct b); auto.\n      apply f_equal; auto.\n      eapply f_equal; auto.\n    - eapply f_equal; eauto.\n      + intros b0.\n      - eapply f_equal.\n      - intros b b0; eauto.\n      apply f_equal; auto.\n      + apply f_equal.\n      * intros.\n      + destruct b0 b0.Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  unfold rel; split; [left] [right].\n  (* The list of the following two [left] for the list of [right] is defined [left] is [right] is a list of [left] and [left] is a right]\n    [left] and [left] and [right] is an [right] is a hypothesis.\n    and [right] and [right] and [right] is [left] is [left] and [right] is\n    [left] [left] and [left] [right]\n    [right] is_right] is the [left] is [left]. *)\n(** [left] and [right] is a\n    [left] is\n    [left] and [left] is [left] is the\n    the [right] is [left] is [left] is [right] and [left] [left] is the [left] and [right]\n    [right] [left] [left]] is [left] [left] in [right] [right] [right] and [left] [left] is_left] is_right] is the [right] is_right] and [left]Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (f x)).\n  destruct (f x) as [f x) as [f x y].\n  destruct (f x); auto.\n  apply (f x); auto.\n  apply f_equal.\n  - destruct (f x)) as [f x0].\n  - f x1 [f x2].\n  - f2 x2; auto.\n  - destruct (f x2)).\n  - destruct x2; auto.\n  + destruct (f x1 x2)). auto.\n  - destruct (f2 x2 x2).\n    apply f2 x2).\n  - rewrite f2.\n    apply f2.\n    - destruct (f x2 x2).\n    + rewrite f2 f1.\n    + f2) x2).\n    + rewrite f2.\n    - f1.\n    + rewrite f2.\n    - rewrite f2.\n    rewrite f2.\n    - apply f_equal.\n    - f1 f2 f2 f2 f2 f2.\n    - f2 f2.\n    - rewrite f2 f1 f2 f1 f2.\n    - f2 f2 f2 f2 f2 f2 f2 f2 fQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (f_f x) as [x1 [x1 [x2 y2 [x2 y2 y2 x2 y2 y3 y3 y2 y4 y3 y4 y3 y3 y3 y3 y3 y4 y3 y3 y4 y4 y3 y6 y4 y6 y5 y6 x3 z5 y6 z7 z4 z4 z3 z6 z5 z3 z8 z3 z8 z3 z5 z z3 z4 z7 z8 z5 z7 z z8 z11 z7 z z3 z8 z z z z z z8 z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros a a0.\n  destruct (H a b) as [H1 [H2|H2]].\n  destruct (H1 H2) as [H1 H1].\n  rewrite H2.\n  destruct (H2, H2 H2).\n  destruct (H2); auto.\n  destruct (H2); auto.\n  destruct (H2); auto.\n  simpl in H2; auto.\n  destruct (H2); auto.\n  destruct (H3); auto.\n  destruct H3; auto.\n  destruct (H2); auto.\n  destruct (H4); auto.\n  destruct H3; auto.\n  destruct (H3); auto.\n  destruct (H4 H3); auto.\n  destruct H4; auto.\n  destruct H3; auto.\n  destruct H4 as [H3]; auto.\n  destruct (H5 H4); auto.\n  exists (H5); auto.\n  destruct (H4); auto.\n  auto.\n  destruct H5; auto.\n  destruct (H4); auto.\n  destruct (H6); auto.\n  destruct H3); auto.\n  destruct (H4 H4); auto.\n  destruct H4.\n  destruct (Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A f_equal.\n  apply H1.\n  apply (f (f_f (f a)) (f a) (f a2) (f a2) (f a2) (f a2) (f a1 a2))) (f a2 a2)).\n  apply (f a2 a2 a2).\n  apply (f a2 a2).\n  apply f2 a2).\n  split; auto.\n  apply (f a1 a1 a2).\n  apply f a2 (f a2).\n  apply f a2); auto.\n  apply f2; auto.\n  apply f2.\n  apply f1.\n  apply f2 f2; auto.\n  apply f2 f2; auto.\n  apply f2; auto.\n  apply f2; auto.\n  apply f1 f2 f2; auto.\n  - apply f2 f2; auto.\n  - apply f2 f2 f2 f2 f2; auto.\n  - apply f2 f2; auto.\n  + rewrite f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 fQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros x y.\n  destruct (f x); [left; [left] |right]; auto]; auto.\n  exists x; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  unfold rel1.\n  split; auto.\n  apply rel_rel_rel_rel.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  eapply (f a1 a2R a1 a2 a2 a2 a2 a2).\n  eapply (f a1 a1 a2).\n  eapply H3. apply H1_left; eauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  apply (f x)).\n  - apply R_equiv.\n  - apply R1.\n  - apply R1R_equiv_equiv.\n    - apply R_equiv_equiv.\n    + apply R_equiv.\n    - apply R_equiv_equiv; auto.\n    - destruct (f x); auto.\n    - apply R_equiv_equiv R0.\n    - apply R0.\n    - apply R_equiv.\n    - apply R_equiv; apply R_equiv_equiv.\n    - apply R_equiv.\n    + apply R_equiv.\n    - apply R_equiv_equiv.\n    - apply R_equiv_equiv.\n    - apply R_equiv; auto.\n    - apply R_equiv; auto.\n    + apply R_equiv; auto.\n    - rewrite R_equiv_equiv_equiv.\n    + apply R_equiv.\n    - rewrite R_equiv.\n    - apply R_equiv_equiv.\n    - apply R_equiv_equiv_equiv; auto.\n    - apply R_equiv_equiv R_equiv.\n    - apply R_equiv_equiv_equiv_equiv; auto.\n    - intros; auto.\n    - apply R_equiv;Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros; apply (f a b) in H0).\n  split; auto.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros x; unfold R2; intros; apply R1.\n  destruct R2 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R1 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R1 R2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R1 R R2 R2 R R R R2 R R1 R2 R2 R R2 R2 R R2 R R R2 R R2 R2 R R R R2 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A2 B2 B2 B2 B2 B1 B2 B2 B2 B2 B2 B2 B2 B2 B2 B3 A2 B2 B2 B3 B2 B2 B3.\n  intros A2 A3 B3 B3 B3 B3 B4 B4 B3 B3.\n  exists B3.\n  split; split; auto.\n  split.\n  split; auto.\n  split; auto.\n  exists B3; auto.\n  split; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A1 B2 B2 B2 A2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 A2.\n  split.\n  - intros B2 B2 B2 B2 B2 B2 B2 B2 B2 B3 B2 B3 B2 B2 B1 B2 B2 B3 B2 B3 B2 B2 B2 B2 B3 B2 B3 B3 B3 B3 C3 B3 B4 C4 B3 B2 B2 B3 B3 B4 C3 B3 -> B3 B3 B3 C3 B3 C3 C4 C3 B3 C3 A4 -> B3 ->\n  C3 B4 B4 C4 ->\n  Bet B3 B3 C4 C4 C4 C3 B3 B3 ->\n  B3 C4 C4 B4 B3 B4 C4 B4.\n  exists C3, A4, Bet B3, Bet B3 B3 B4, Bet A5 B2 -> Bet B3 C4 A3 B4 B3 ->\n  Bet B3 -> Bet B3 B3 B3 -> BetQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros; inversion A1; subst; subst; subst; subst; subst; subst; auto.\n  subst; subst; subst; subst; subst; eauto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rewrite (x1 x2 x2 x2); auto.\n  rewrite (x2 x2 x2 x2 x2 x2); auto.\n  destruct (x2 x1 x2 x2 x2); auto.\n  auto.\n  rewrite (y1 x2); auto.\n  destruct (x2 x2); auto.\n  auto.\n  destruct x2); auto.\n  destruct (x2 x2 x2); auto.\n  destruct x2 x2); auto.\n  destruct x2; auto.\n  destruct x2; auto.\n  destruct (x2); auto.\n  destruct (x1 x2); auto.\n  destruct x2; auto.\n  destruct x2; auto.\n  rewrite H2.\n  auto.\n  destruct (x1 x1 x1 x2); auto.\n  destruct (x2 x2); auto.\n  destruct x2); auto.\n  destruct (y2); auto.\n  destruct (x2 x2); auto.\n  destruct (y2); auto.\n  destruct x1); auto.\n  destruct x2; auto.\n  destruct x2; auto.\n  destruct x2 x2; auto.\n  exists x2; auto.Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros x y y2 H2 x2 H3 H3 H4 H4 H4 H4 H4 H4 H6 H4.\n  destruct (H4).\n  rewrite H4.\n  destruct H4.\n  rewrite H4.\n  exists x1.\n  apply H5.\n  rewrite H4.\n  split; auto.\n  apply H5.\n  apply H3.\n  rewrite <- H3.\n  apply H5.\n  apply H5.\n  split; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A1 R2 H2 HP2 x2 HP2 HP2 HP2 HP2 HP2 HP2 HP2 HP2 HP2 HP1 HP2 HP2 HP2 HP3 HP1 HP2 HP2 HP2 HP1 HP2 HP2 HP2 HP2 HP2 HP2 HP HP3 HP2 HP2 HP2 HP2 HP3 HP3 HP HP2 HP2 HP HP2 HP HP HP2 HP2 HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HP HPQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros; destruct x2 as [x1 [x2 [x2] [x2 x2 [y1 [x2 y2 [x1 [x2 [y2 y2 x2 x3]].\n  destruct (x2 x2) as [x1] [y2 [x2 y2].\n  exists (x2 x2); auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  destruct (y1 x2 y2); subst.\n  destruct (y2 y1 x2); auto.\n  destruct (x2 x2 x2 x2); auto.\n  destruct (y2 x2)); auto.\n  destruct (y2); auto.\n  destruct (x2); auto.\n  destruct (y1 x2 x2 x2); auto.\n  destruct (y2 y2); auto.\n  destruct (x1 x2); auto.\n  destruct x2); auto.\n  destruct x1; auto.\n  destruct (y2 y2); auto.\n  destruct x2 x2); auto.\n  destruct (x2); auto.\n  destruct (y1 x1); auto.\n  destruct (y2 x2); auto.\n  destruct (y2); auto.\n  destruct (y2); auto.\n  destruct (y2 x2); auto.\n  destruct (y1 x2); auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A2 x2 x2 x2; destruct A1 as [x2 x1 [x2] [x2 x2 [x2 [x2 [x2 x2 [x2 x2 y2 x2 x2 x2] | x2 x2 [x2 x2 x2 x2 x2] x3 x2] x3 x4 [x3 x2] [x3 x3 x3 x4 x4 x3]\n    [x4] [x4 x4 x3 x4 x4 x4 x5] = x4 x4 x5 x6 x4 x5 x5 x5 x5 x6 x6 x6 x5 x6 x6 x6 x4 x6 x4 x6 x4 x5 x5 x6 x5 x7 x7 x7 x8 x9 x6 x6 x9 x7 x8 x5 x6 x8 x9 x8 x6 x5 x8 x5 x6 x6 x7 x6 x11 x8 x7 x8 x8 x6 x10 x11 x5 x5 x11 x9 x8 x9 x11 x8 x6 xQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  destruct (x2 x2 x2 x2 x2 x2 x2 x3 x2)).\n  destruct x1; apply H; auto.\n  - intros; auto.\n  - apply H1; auto.\n  - apply H2.\n    - apply H2.\n    - apply H1.\n    - apply H1.\n    - destruct (x1 x2 x2); auto.\n    - apply H2.\n    - apply H2.\n    - apply H2.\n    + apply H3.\n    - rewrite H3.\n    - apply H1.\n    - destruct (x2); auto.\n    - destruct (x2 x1); auto.\n    + destruct x1; auto.\n    - rewrite H2.\n    - destruct (x2 x2 x1); auto.\n    - destruct (x1 x1) as [x2 | x2].\n    - rewrite H2; auto.\n    - destruct x2; auto.\n    - destruct x2 as [x2; auto.\n    - rewrite H1; auto.\n    rewrite H2.\n    - destruct (x2 x2); auto.\n    + rewrite H2.\n    - destruct x2; auto.\n     Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (H0) as [H0|H0].\n  destruct H0].\n  destruct (H0).\n  simpl in H0.\n  destruct (H0); subst; simpl in H0.\n  apply H0; auto.\n  split; auto.\n  destruct H0.\n  rewrite <- H0; auto.\n  destruct H0; auto.\n  simpl in H0.\n  destruct H0.\n  destruct H0; auto.\n  destruct H0; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros; apply H; auto.\n  rewrite H.\n  apply H.\n  apply H.\n  rewrite H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply (H0).\n  applyQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (P1 x2 x2 x2 x2).\n  destruct (P2 x2 x2 x2 x2 x2) as [p2]; auto.\n  destruct (P2 x1 x2); auto.\n  - specialize (P2 x2 x2 x2); auto.\n  - apply (P2 x2 x2 x2 x2); auto.\n  - rewrite <- (P1 x2 x2 x2); auto.\n  - destruct (P2 x2); auto.\n  - rewrite!IHp2_left; auto.\n  - apply!!H2r1_r1; auto.\n  - apply (P2_r2).\n  - apply P2_r1; auto.\n  + apply P2_r2.\n  + apply P1; auto.\n  + apply P2.\n    - apply P2.\n    - apply P1; auto.\n    - apply P2_r.\n    - apply P1.\n    - apply P2.\n    - rewrite P1; auto.\n    - apply P2; auto.\n    + rewrite P2_1_1; auto.\n    apply P1; auto.\n    - applyQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 A2 A2 A2 A2 A2 A1 A2 B2 B2 B1 B2 B2 B2 B2 B2 A2 A2 B2 B2 B1 B2 B2 B2 B2 B2 B2 B2 B2 C2 B3 B2 B2 B3 B2 A3 B2 B2 B3 B2 B2 B2.\nintros B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B3 B2 B2 C2 B3 B2 B3 B3 B3 A4.\nintro.\ncut (P B3 A1 B2 B2 B2 B2 B2 B2 B2 B1 B3 B2) /\\ B2 B2 B2 B2 B2 B3 B2 B3 B3.\nintro.\n  unfold R.\n  split.\n  split; intro.\n  split; trivial.\n  apply H3.\n  apply (C B3 B2 B3 B2 B3 B2 B3 B2 B3 B2 B2 B2 B2 B3 B2 B3 B4.\n  split;Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  apply (F1 x2R2R1 R1 R1 R1 R2R1 R2R2R2R2R2R2R2R2R2R2R2R1 R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R1R2R2R2R1R2R1R2R2R2R1R2R2R1R2R2R1R2R2R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R1R2R2R1R2R2R2R2R2R2R1R2R2R2R2R2R2R2R2R2R2R2R2R1R2R2R2R1R1R1R2R2R2R2R2RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (H1 x2)).\n  inversion H.\n  exists x; subst; auto.\n  auto.\n  auto.\n  destruct (H2 x1).\n  destruct (H2); auto.\n  destruct H1; auto.\n  apply H1; auto.\n  right; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (R x1 x2 y2 x2 x2 x2 x2).\n  destruct (F2 x1 x2 x2 x1 x2 x2 x1 x2 x2)).\n  destruct x2 as [x2].\n  destruct x2 as [x1 [x2 [x1 y2 x2 [y2 y2 [y2 y2 x2 [y2 y2] [y2 [x2 y2 y2 [y2 y2y2y2 [y2 [x2 y2 y3 y2 y2 [y2 y3 [y3 y3 [y3 [x2 y4 y2 y2 y3 [y4 y3 y7 y3 y3 y4 y3 y3 y4 y4 x4 y3 y4 y3 y3 y5 y5 y3 y7 y3 y7 y5 z1 y6 y4 y7 x5 y3 y5 y1 y7 y3 y6 y3 y5 y5 y7 y7 y7 y6 y8 y5 y6 y6 y8 y8 y7 z3 z8 y8 y8 y6Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (P1 x1 x1 x1 x2 x2 x2 x2).\n  destruct x2; simpl; auto.\n  destruct (P2 x2 x2 x2 x2 x2) as [P1 x2 x2]; exists x2; split; auto.\n  destruct (P1 x2 x2); auto.\n  destruct x2 x2); auto.\n  destruct (P1 x2 x2 x2); auto.\n  destruct x2; auto.\n  destruct (P1 x1 x2 x2); auto.\n  destruct x2); auto.\n  apply H; auto.\n  destruct (P1 x2 x2); auto.\n  destruct x2; auto.\n  destruct x2; auto.\n  destruct x2; auto.\n  destruct x2; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (x2 x1 x2 x2 x2 x2 x2 x2 x2 x3).\n  destruct x2 as [x2|x2 x2 [x2] [x1 x2 y2] [y2 x2] x2 x2 x2 y2 x2] [x2 [x2 y2 y2 x2 x2 y2 x2 x2 x2 y3 y2 x3;\n    [x2 y3] x2 x3 x3 x2 x2] (x3 x3 x3 x3) x3 x3 x4 x4 x4 x4 x4 x3 x4 x4 x5 x5 x7 x5 x5 x6 x5 x5 x6 x5 x6 x6 x5 x6 x5 x7 x5 x7 x9 x6 x5 x7 x6) (x8 x5 x9 x5) -> B7 x6 x5 x7 x5 x6 x7 x8 x5 x6 x8 x7 x8 x5 x8 x10 x8 x7 x11 x8 x11 x7 x7 x10 xQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct (x2 x2 x1 x1 x2 x2) as (x2 x2 x2 x2 x2 x2 x2 x2 x2) (x1 x2 x2 x2 x2 x2)) as [y2 | x2 x2 y2 x2 y2 x3 x3] y3 x3 x3;\nend.\n\nLemma rel2 :\n  rel_rel_rel_rel_rel : forall x2, rel2 x1 x1 x2 -> rel2 x1 x2 x2 x2 x2 x3 x2 x3 -> rel2 -> rel2 x3 x3 x3 x4 x2 x4 x3 x4 x4 x4 x4 x4 x3 x4 x4 x3 x4 x4 x4 x3 x5 x4 x5 x6 x4 x5 x5 x5 x5 x6 x4 x5 x5 x5 x5 x5 x5 x6 x4 x6 x5 x5 x5 x5 x6 x4 x6 x5 x5 x4 x4 x4 x5 x6 x4 x4 x5 xQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  destruct r; apply H; auto.\n  Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  unfold R_step.\n  intros.\n  assert (H1 : A) = R1) by (apply (apply (apply (apply R2R1 R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R1R1R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2R2RR1RRR2R1R1R2RQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  destruct r as [f x1 | R1 R2 R1 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R R2 R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R R2 R R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R R2 R R1 R2 R2 R2 R R2 R2 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  assert (A : R) (x:B) (x:A),\n    (B -> R) (x:A -> R x y) (x:A) -> R x y).\n  intros.\n    eapply (x: A x y) (x:A) (y:A), R x y) -> R_y:A) -> R x y -> R_xy (x:A) (x:A), R y x y) (x:B), R x y -> R x y x y x y -> R x y -> R x y -> R x x x x x -> R y x x x y x y -> R -> R x -> R x x x y -> R x y.\n  Proof.\n  intros.\n  assert (x:A:A), R x y:B), R x y -> R x -> R x y -> R x y -> R x -> R x y -> R x -> R x.\n  intros.\n  destruct (A_y:A) (y:A->A->A->A->B->A->B->B->B->B->B->A->B->A->B->B->Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros x z; apply R2.\n  apply R_step_step_step_step.\n  apply R_step.\n  apply R_step.\n  - intros.\n  + apply R_step.\n  - apply R_step_step_step.\n    - apply R_step_step_step.\n    + apply R_step_step.\n    - apply R_step; auto.\n    + apply R_step; auto.\n    + apply R_step.\n    - apply R_step_step.\n    + apply R_step; auto.\n    + apply R_step; auto.\n    + intros A; auto.\n    + apply R_step_step; auto.\n    - apply R_step_step; auto.\n    + apply R_step; auto.\n    + apply R_step.\n    - apply R_step_step_step.\n    - apply R_step_step_step; auto.\n    + apply R_step; auto.\n    - apply R_step; auto.\n    - apply R_step.\n    - apply R_step.\n    - apply R_step_step; auto.\n    - apply R_step.\n    - apply R_step_Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  unfold R; unfold R; unfold R.\n  unfold R_R; unfold R_R, R; intros.\n  rewrite R; unfold R_R.\n  rewrite R_R_R_R_R_R_R; unfold R_R_R_R_R.\n  unfold R_R; unfold R_R; unfold R_R.\n  unfold R; unfold R; unfold R_R_R; unfold R_RR, R, R_R.\n  unfold R; unfold R, R, R R; unfold R, R R, R, R R, R R R R R, R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply lt_trans with R := R1 R.\n  apply R2R := R1 R1 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R R1 R2 R R1 R R2 R R R R2 R R2 R R2 R2 R R R R R2 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros; intros; elim (P1 A R2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R1 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R2 R1 R2 R2 R2 R R2 R2 R R2 R2 R2 R2 R1 R2 R2 R1 R2 R2 R R2 R1 R2 R2 R2 R2 R R1 R2 R2 R2 R R R R2 R R2 R R2 R2 R R2 R R R R R2 R R R2 R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R R RQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  unfold R_step; unfold R_step; intros.\n  unfold R; intros x; unfold R_step_step.\n  rewrite R; unfold R_step R_step; unfold R_step.\n  rewrite R_step_step; rewrite R_step.\n  rewrite R_step; rewrite R_step.\n  rewrite R_step_step.\n  rewrite R_step R_step.\n  rewrite R_step.\n  rewrite R_step_step.\n  rewrite R_step R_step R_step.\n  rewrite R_step R R1 R R_step.\n  apply R_step.\n  apply R_step.\n  apply R_step_step_step_step_step_step.\n  apply R_step_step_step.\n  apply R_step; auto.\n  eapply R_step.\n  apply R_step_step_step; eauto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  unfold R.\n  unfold R_step; intros.\n  unfold R; destruct R; simpl; simpl; auto.\n  rewrite R_step; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct H2 as [H1 H2].\n  destruct H1 as [H1 [H2].\n  destruct H2].\n  destruct H2.\n  simpl in H1.\n  destruct (H2).\n  destruct H2; subst; inv H2; inv H2.\n  exists (rel_rel_rel_rel_rel_rel_rel R).\n  split; auto.\n  apply H2.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply H; auto.\n  apply H.\n  apply H3.\n  apply H3.\n  apply H4.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct x as [y2 [y2 y2 [y1 [y2 [y3 [y1 [y3 [y2 [y1 [y2 [y1 [y2 [y2 [x3 [y2 [y1 [x1 [y3 y3 [y4 [x3 y1 [y2 x3 [x3 x4]].\n\n\n(* This is also work, *)\n(* The Coq Coq of the Coq Coq Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    This file is distributed under the terms of the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the license)         *)\n(************************************************************************)\nRequire Import Coq.\nRequire Import Coq.Classes.Classes.Classes.\n\nRequire Import ExtLib.Tactics.\nRequire Import ExtLib.\nRequire Import ExtLib.Tactics.Tactics.\nSet Implicit Arguments.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  intros.\n  elim (fun x y => x y).\n  apply H.\n  apply H.\n  apply exist_rel_rel_rel_rel_rel_rel_rel_rel with x x y.\n  apply exist_rel_rel_rel_rel.\n  apply exist_rel_rel.\n  apply exist_rel_rel_rel with (rel_rel_rel_rel with x); auto.\n  apply exist_rel_rel_rel_rel_rel_rel.\n  apply exist_rel_rel_rel_rel_rel.\n  apply exist_rel_rel.\n  apply exist_rel_rel_rel_rel.\n  apply exist_rel_rel.\n  apply exist_rel_rel_rel_rel_rel_rel with (rel_rel_rel_rel_rel with x => x y).\n  apply exist_rel.\n  apply exist_rel_rel_rel.\n  apply exist_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply equal_rel_rel_rel.\n  apply equal_rel_rel_rel_rel_rel_rel_rel.\n  applyrel_Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  unfold R.\n  apply R_rel; auto.\n  eapply R.\n  apply R_rel_rel_rel_rel; eauto.\n  Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold rel_rel in *.\n  destruct (x:=x:=x) as [x|x] | x y].\n  destruct x y];\n  destruct y; [x]; auto.\n  - destruct (y) as [y]; auto.\n  -y.\n  - destruct (y) as [y]; destruct (x,y,x) as [y] y; auto.\n  - rewrite <- (y,y,y,x,y,y,y,y,y,y,y,y,y,y,y,y,y,y,x,y,y,y,y,y,y,y,y,x,x,x,y,y,x,y,y,y,y,y,y,x,x,y,y,x,x,x,y,y,y,x,y,y,x,y,x,y,y,x,y,y,y,y,x,x,y,y,x,y,y,x,x,x,x,x,y,y,x,x,y,x,y,yQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct H as [L [L1 [L11 [X1 [X1 [X2 [X1 [X2 [?X2 [X2 [X12] X1 [X33]]].\n  exists x1; split; auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct r as [y [y [y [y y]].\n  simpl in *.\n  destruct (y y).\n  destruct (y y) as [x y); auto.\n  destruct x; auto.\n  destruct (x y); auto.\n  exists y); auto.\n  split; auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros; intros.\n  destruct r1 as [H2 [H2].\n  destruct (H2); auto.\n  exists (x2 x1 x1 x2); auto.\n  exists x2); auto.\n  destruct (x1); auto.\n  exists (y2); auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  destruct (rel (rel_rel_rel_rel_rel_rel R2 l2)).\n  intros.\n  destruct (rel_rel_rel_rel R a0); [exists a0 a0, a0); auto.\n  rewrite P0.\n  rewrite P0; auto.\n  apply R_rel_rel_rel_rel_rel.\n  apply R_rel_rel_rel_rel; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply (x:=y:=x:=y:=y:=x:=x:=x:=x:=y:=y:=x:=y:=x:=x:=x:=x:=x:=x:=x:=y:=y in H0) H.\n  apply H0.\n  apply H0.\n  rewrite H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  rewrite H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply HQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct r as [x [y [y y] y].\n  assert (x:R:R->R) (x:R) = x = y -> R) by (apply (f x) (f x (fun x => f x) x) (x y) y) (x y) y) (x y) (x y) x) (y:R x)) (x y) (x:R) (x:R) (x:R -> R) x y),\n    (f x y) (x:R x y:R) (f x y x) (x:R),\n    (x:R -> R x y:R -> R) -> R (x:R) (x:R) (x:R) -> R) (x:R) -> R) -> R -> R -> R x y x y.\nProof.\n  intros.\n  generalize (x:R:R->R) (x:R), R) (x:R), R x x y x) x y -> R x.\n  intros; unfold R, R; unfold R_rel, R_rel;\n    unfold R_relQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel, rel in H.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H; unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel, rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel_rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel_rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel.\n  unfold rel_rel in H.\n  unfold rel, rel in H.\n  unfold rel in H.\n  unfold relQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  induction l.\n  unfold T; auto.\n  unfold rel.\n  intros.\n  unfold rel.\n  unfold rel in H.\n  simpl in H.\n  unfold rel in H.\n  unfold rel, rel in H.\n  unfold rel, rel, rel_rel in H.\n  unfold rel in H.\n  unfold rel, rel_rel in H.\n  unfold rel.\n  unfold rel_rel in H.\n  unfold rel.\n  unfold rel in H.\n  unfold rel in H; unfold rel in H.\n  unfold rel in H; unfold rel in H0.\n  unfold rel.\n  unfold rel.\n  unfold rel in H0; unfold rel in H; unfold rel.\n  unfold rel_rel in H.\n  unfold rel, rel in H0; simpl in H0.\n  unfold rel.\n  unfold rel in H0.\n  unfold rel_rel in H0; simpl in H0.\n  unfold rel in H0.\n  unfold rel.\n  unfold rel in H.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel.\n  unfold rel in H0.\n  unfold rel in H.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfoldQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct r.\n  destruct r as [x [y [y y].\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H3.Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  unfold rel.\n  intros.\n  unfold rel.\n  unfold rel_rel in *.\n  unfold rel_rel in *.\n  unfold rel_rel in *.\n  unfold rel.\n  unfold rel.\n  unfold rel_rel in *.\n  unfold rel.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel.\n  unfold rel_rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel_rel in *.\n  unfold rel_rel in *.\n  unfold rel in *.\n  unfold rel_rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel_rel in *.\n  unfold rel.\n  unfold rel in |- *.\n  unfold rel in *.\n  unfold rel_rel in |- *.\n  unfold rel in *.\n  unfold rel in *.\n  unfold rel.\n  unfold rel_rel in *.\n  unfold rel_rel in |- *.\n  unfold rel in |- *.\n  unfold rel_rel in |- *.\n  unfold rel_rel in *.\n  unfold rel in |- *.\n  unfold rel in *.\n  unfold rel in |- *.\n  unfold relQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold rel in *.\n  unfold rel; intuition.\n  unfold rel_rel in *.\n  destruct r; intuition.\n  unfold rel in *; intuition.\n  apply rel_rel_rel in *; intuition.\n  rewrite rel_rel; intuition.\n  rewrite rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel_rel; intuition.\n  eapply rel_rel_rel_rel.\n  rewrite rel_rel_rel.\n  eapply rel_rel_rel; intuition.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel.\n  eapply rel_rel_rel_rel_rel.\n  eapply rel_rel.\n  eapply rel_rel_rel_rel; eauto.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel; eauto.\n  eapply rel_rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel_Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct r; auto.\n  destruct r.\n  destruct r; auto.\n  destruct r.\n  destruct r; auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct r; [split; auto.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  unfold rel; intros; auto.\n  destruct (x y)).\n  destruct (x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x:=x) in y)(y:=x:=y:=x:=y:=x:=x:=x:=x:=x) in y in (y:=y:=x:=y:=y:=y:=x:=x:=x:=y:=x:=x:=y:=y:=y:=x:=x:=y).\n  assert (x:=x:=x:=x:=y:=x:=y:=x:=y:=x:=x:=x:=x:=x:=x:=x:=y:=x:=y:=x:=:=:=:=x:=x:=x:=x:=x:=:=y:=y:=y:=y:=y:=y:=y:=x:=x:=:=x:=y:=x:=:=:=y:=:=:=y:=x:=x:=x:=y:=y:=y:=y:=y:=:=y:=x:=y:=y:=x:=x:=x:=:=y:=:=x:=y:=y) in_x:=y:=y:=:=y:=:=:=x:=y:=:=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  induction l; auto.\n  destruct l; auto.\n  destruct (H1 x) as [x1 x2|x1|x2 x2]; auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  induction l; auto.\n  + apply H.\n  + apply H.\n  + apply H.\n  + apply H.\n    + apply H.\n    + apply H.\n    - apply H.\n    apply H.\n    - apply H.\n    - apply H.\n    + apply H.\n    - apply H0.\n    + rewrite H0.\n    - apply H0.\n    - apply H0.\n    - rewrite H0.\n    - rewrite H0.\n    - rewrite H1.\n    + rewrite H1.\n    + rewrite H1.\n    + rewrite H2.\n    + rewrite H1.\n    - apply H2.\n    - rewrite H2.\n    + rewrite H2.\n    rewrite H2.\n    + rewrite H2.\n    + rewrite H2.\n    rewrite H2.\n    - rewrite <- H1.\n    + rewrite H2.\n    rewrite (H1_comm H1).\n    + rewrite H2.\n    + rewrite <- H1.\n    rewrite H2.\n    + rewrite H3.\n    rewrite <- H3.\n    rewrite H2.\n    rewrite H3.\n    rewrite H3.\n    + rewrite H3.\n    + rewrite <- H3.\n    rewrite <- H2.Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply (H2 H3).\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct r; subst; auto.\n  destruct r; auto.\n  simpl; auto.\n  destruct r; auto.\n  destruct r; auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct r; auto.\n  rewrite <- r; auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  generalize (H x) (H x); intros.\n  destruct H.\n  apply H.\n  eapply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel; apply rel_rel_rel; apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel; apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_relQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  split.\n  apply (f x y)).\n  apply (f x y)).\n  apply (f y); auto.\n  apply H).\n  - apply H.\n  - apply H.\n  - apply H.\n  - apply H.\n  - intros.\n    - rewrite H1.\n    - exact (f x y)).\n    - rewrite H2.\n    - rewrite (f y)).\n    + rewrite <- (f x) y0.\n    apply H2 x) (f x y).\n    - specialize (f x y).\n    rewrite H2).\n    + rewrite <- (f x)).\n    + rewrite <- (f y) (f y).\n    rewrite <- (f y) y) x y)).\n    rewrite <- (f_f y).\n    apply f x y)).\n    + rewrite <- H1.\n    rewrite <- H2.\n    apply f_equal.\n    apply f_equal.\n    rewrite <- (f x y)) (f y))).\n    rewrite <- (f x) (f y).\n    rewrite <- (f x)).\n    rewrite (f x y)) in H2.\n    apply f).\n    apply f_equal.\n    rewrite <- (f x).\n    rewrite <- (fQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct r as [x [x2] [y1 [x2 [x2 [y2 [y2 [x2 [y3 [y3 [x3 [y4 [x4 x44 [x4]]]].\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite H.\n  apply H.\n  apply (H_rel_rel (H x)).\n  rewrite H)).\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  assert (g:R:A -> B -> Prop) (f x y).\n  assert (f:B),\n    intros.\n    assert (H:B),\n      exists x) -> A (f x) x; split; auto.\n    eapply rel_rel_rel_rel_rel_rel_rel_rel_rel; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\n  - destruct r; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct r; auto.\n  destruct r; auto.\n  destruct r; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  induction r as [x|x x y].\n  destruct (x x y)).\n  destruct (y y)); [x; auto.\n  destruct (x y)); auto.\n  destruct (x x)); auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct (g x)) as [h1 [h1 [h1 [h2h2 h1 h2 h2] h2 h2 h2 h2 h2 h2]; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros; induction x; intros; auto.\n  destruct (f x); auto.\n  destruct (f x); auto.\n  destruct x); auto.\n  destruct (f x); auto.\n  auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold rel; unfold rel_all; intro.\n  unfold rel in H; unfold rel in H.\n  unfold rel_all; intro.\n  apply rel1.\n  unfold rel_all.\n  apply rel_all_all.\n  unfold rel in H.\n  apply rel2_all.\n  apply rel2_all in H.\n  rewrite rel2.\n  apply rel_all_all.\n  apply rel_2.\n  apply rel2.\n  unfold rel1.\n  unfold rel2_all in H1.\n  unfold rel2.\n  unfold rel1.\n  unfold rel2.\n  rewrite rel2.\n  unfold rel_1_2.\n  unfold rel2.\n  unfold rel2.\n  unfold rel1_1.\n  unfold rel2.\n  unfold rel2; unfold rel2.\n  unfold rel2.\n  unfold rel1.\n  unfold rel2.\n  unfold rel2.\n  unfold rel.\n  unfold rel_1 rel1.\n  unfold rel1.\n  unfold rel2.\n  unfold rel_2.\n  unfold rel1.\n  unfold rel2.\n  unfold rel1.\n  unfold rel1.\n  unfold rel1.\n  unfold rel2 rel2 rel2Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros; induction 1; destruct (f x); auto.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct (g x) as [a & x, a & a) as [a] & a] & a.\n  exists a.\n  exists a.\n  exists (x, a).\n  exists (a, a, x).\n  split.\n  split; auto.\n  exists (a, a) (a, a); auto.\n  split; auto.\n  exists (a, a; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct (x, x) as [x] [x] [x] [x y].\n  destruct (x y); auto.\n  destruct (x y); auto.\n  destruct (y x); auto.\n  destruct (x y); auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct (H x0); intuition.\n  inversion H0; subst; subst; subst; subst.\n  destruct (g x0); subst; subst.\n  eapply rel1; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nLemma rel_rel_rel_rel :\n  forall (A:A:A),\n    rel A -> rel (f x) -> rel x (A -> rel2) (f2 : rel_rel_rel_rel_rel_rel x) -> rel_rel_rel f x y) -> rel x -> rel_rel_rel (rel_rel_rel x y) -> rel_rel f x.\nProof.\n  intros.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel.\n  eapply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel.\n  apply rel_rel_rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel.\n  apply rel_rel.\n  apply rel_rel_rel_rel_rel_rel_rel_rel_relQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\n\nLemma rel1_2: forall x,\n  rel (A1 x2 x2 x2 x2 x1 x2 x2 x2 x2 x2 x2 ->\n  rel2 x2 x2 x2 x2 x2 x2 x2 x2 x2 x2 ->\n  rel2 x2 x2 x2 x2 ->\n  x2 -> rel2 x2 x3 x2 x2 x3 x2 x2 ->\n  x2 -> rel3 x3 x2 x3 x3 x3 x3 x3 x4 x3 x3 x3 x3 x3 x4 x4 x3 x3 x5 x4 x3 x4 x5 x5 x4 x5 x4 x4 x4 x7 x4 x4 x6 x8 x4 x6 x7 x6 x6 x4 x5 x7 x4 x7 x7 x6 x8 x7 x5 x7 x5 x7 x7 x7 x8 x7 x6 x4 x5 x4 x5 x6 x6 x6 x7 x5 x7 x7 x6 x8 x7 x9 x7 x4 x7 x7 x8 x7Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 B1 B2 B2 B2 B1 B2 B2 C2 B2 B1 B2 B2 B1 C2 B2 C2 B2 B2 B1 B2 B2 C2 B2 C2 C2 B2 B2 B3 C2 B2 B2 B2 B2 B3 B2 B2 B2 B2 B3 C2 B2 B1 C3 B2 B3 -> C2 C1 B2 C2 B2 C1 B3 B2 ->\n  B2 C3 ->\n  Bet B2 B2 B3 B1 B2 B2 ->\n  Bet A2 C3 B2 B2 C2 B2 B1 ->\n  Bet C2 B3 C1 B2 C1 B2 B2 B2 B2 C2 C3 B3 B2 C2 C3 B3 C4 ->\n  Bet B3 C2 C3 ->\n  Bet A3 B3 C1 C2 C3 C2 C3 C4 C4 C3 C2 C3 C3 C2 C3 C4 B3 C4 ->\n  Bet C4 ->\n  Bet A3 C3 ->\n  Bet BQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\n\n(* This is a bug *)\n(* This is in the proof of the proof *)\n(* -*- *)\n(*         *)\n(*         *   The proof of the proof of the proof proof of the proof of the proof proof proof of proof proof proof proof proof proof of proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proof proofQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A1 B2 A2 B2 B2 A2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2.\n  intros.\n  destruct (f2 A2 B2 B2 B2 A2 A2 B2 B2 B2 B2 B2 B2 B2 A2 B2).\n  rewrite <- (f1 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B3 B2 B2 B2 B1 B2 B2 B2 B2 B2 B1 B2 B2 C3 B2 B1 B2 B2 ->\n  (B1 B1 B2 B2 B2) = B2 B2 B1 B2 B1 B3 ->\n  B2 B3 B2 B2 B2 B2 B2 B2 B2 B1 B3 B2 C3 B2 B2 B2 B2 B2Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A2 A1 B2 B2 B2 B2 B2 B2 B2 B2 A2 B2 B2 B2 B2 B3 B2 B2 B2.\n  destruct B2; simpl; auto.\n  - destruct (H2 B2 B2 B2 A2 B2); auto.\n    - destruct B2); auto.\n    - rewrite B2 B2 B2 B2 B2; auto.\n    destruct B2; auto.\n    - specialize (H2 B2 B2 B2 B2 B2); auto.\n    - intros A2 B2 B2; auto.\n    - intros B1 B2 B2 B1 B2 B2 B2 B2 B2 B2 B2 B2; auto.\n    + unfold B2; auto.\n    - destruct (f2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 B2 C2 B2).\n    - intros.\n    destruct (f2 B2 B2 B2 B2 B2 B2 B2 B2 B1 B2 B2 B2 B3 B2 B2Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C A2 B2 B2 B2 B2 B2 B2 B2 B1 B2 B2 B2 B2 B2 B2 B2 B2 B2 C2 B2 B2 B2 B2 B2 C2B2.\n  intros A2 B2 B2 B2 B2 B2 A2 C2 B2 B2 B2 B2 C2.\n  destruct B2 as [A2 B2 B2 B2 B2 B1 C2 B3 B3 C2 C3 C3 B3 B2 B2 C4.\n  destruct (A B1 B2 B3 B2 B2 C4 B3) as [B2 [B2 B2 B1 [A3 [B2 B2 B2 B1 [B2 [B2 B3 C2 B2 C2 [A2 B2]].\n  apply (B2 B2 B2 B2 B3 B2 B2 B2 B3 C2 B3 B3 B2 C3 B2 B3 B2 C2 B2 B2 B2 C3 B2 B2 C2 B2 C3 ->\n    (B2 C3 BQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  unfold my.\n  split.\n  intros.\n  apply (x2)) as [x2y2 [y2y2 [y1 y2y2 y2y1y2y2y2y1y2y2y2y2x2y2y2y2y2y2y2y2x2y2y2y2y2y2y2y2y2y2x2y3y3y2y3y3y3y3y3y2y3y3y2y1y3y2y3y4y3y2y4y6y4x8y7y4y3y4y4y3y4x4y6y4y7x5y8y7y7y7y8y8y8x9y8y7y9y8x8y7y9x9y9x8y8y9y8y8y8y9y8y9y8y8y8x8y9y9y8x8y8y7z8y8y9y9y8y8z8y8Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  split; intros x y H1 y Hx2 y2 y2 y2 y2 z3 y1 H1 y2 y2.\n  split; auto.\n  split; auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\n\nLemma rel_ex : forall x y,\n  rel2 -> rel2 (f x -> rel2 x y -> rel2 -> rel2 -> rel x2 x -> rel2 -> rel2 x2 x1 -> rel2 x1 x2 -> rel2 x2 -> rel2 -> rel2 -> rel2 -> rel2 -> rel2 -> rel2 -> rel2 -> rel2.\nProof.\n  intros.\n  unfold rel2; apply rel2.\n  apply rel_2_2.\n  apply rel2.\n  apply rel2_2_3.\n  apply rel_2.\n  apply rel2.\n  apply rel2_1.\n  apply rel3.\n  apply rel2.\n  apply rel2.\n  apply rel2_2_2.\n  apply rel3.\n  apply rel2.\n  apply rel2_1.\n  apply rel2_2.\n  apply rel_2_2_2_2.\n  apply rel2_2_2; auto.\n  apply rel2_2.\n  apply rel2_2.\n  apply rel2.\n  apply rel_3_2.\n  apply rel_2_3_2_2_2_2.\n  apply rel2Qed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply Z.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nunfold not in |- *.\nunfold not in |- *.\nsplit.\nright.\napply lt_l.\nright.\nleft.\nright.\napply lt_le_le_le_le.\napply lt_le.\nassumption.\napply le_le_lt_le.\nassumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros H.\nsimpl in |- *.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros n.\nunfold not in |- *.\napply H.\napply H.\napply H.\napply H.\nright with (n:=n:=n:=n:=n:=n:=n:=n) in H.\napply H.\napply H.\napply False_ind.\napply H.\napply False_ind.\napply False.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False.\napply False_ind.\napply False_ind.\napply False_ind.\napply False_ind.\napply False.\napply False.\napply False_ind.\napply False_Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold not in |- *.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nintros.\nunfold not in |- *.\napply Rle_lt_trans with (H0:=H0); auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nintros n; unfold not in |- *; unfold not in |- *.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *.\nsimpl in |- *;\nunfold not in |- *; intros.\napply not in |- *; auto with (le_le_le_le_le_trans with (r := H1 := H2:=r1) in |- *; auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nintros n; case (mult_mult_mult_mult_mult_mult_mult (mult_mult_mult a) (mult_mult a b) (mult a) (mult a)).\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intros.\n  unfold not in |- *.\n  unfold not in |- *.\n  case (le_le_le_le_le_le_compat _ _ _ H).\n  case (le_le _ _ _ H).\n  case H0.\n  case (le_le_le_le _ _ H0).\n  case (le_le _ _ H0).\n  intros.\n  rewrite H0.\n  case (le_trans _ _ _ H0).\n  case (le_le_le _ H0).\n  case (lt_le _ H0).\n  case H0.\n  case (le_le_le_le _ _ _ _ H0 H0).\n  case H0.\n  case (le_trans _ _ _ H0).\n  case H0.\n  case H0.\n  intros.\n  case (le_le_le _ H0).\n  case (lt_le _ H0 H0).\n  case_trans _ _ H0).\n  case (le_le_lt_trans _ H0).\n  case H0.\n  case (lt_trans _ H0).\n  case (lt_lt_le _ H0 H0).\n  case (Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold not in |- *.\n intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  unfold not in |- *.\n  case (lt_lt_trans with (lt_le_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros n.\n  unfold bs.\n  intros.\n  unfold bs in |- *.\n  apply leb_correct; simpl in |- *.\n  apply leb_correct.\n  case (le_lt_le_le_le_le_le_trans _ (le_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n unfold max_le_trans with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nintros n.\nunfold lt in |- *.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  unfold N.\n  split; auto with arith.\n  apply lt_le; auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply add_r.\n  apply add_le.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  rewrite add_l.\n  apply add_r.\n  apply add_r.\n  apply add_l with (r := add_r := add_r.\n  apply add_r := add_r := add_r).\n  apply add_l.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_l.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_r.\n  rewrite add_r.\n  apply add_r. apply add_r.\n  apply add_r.\n  apply add_r.\n  apply add_Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  assert (n+n+n-1).\n  unfold lt, lt in |- *.\n  unfold lt_max.\n  auto with arith.\n  unfold lt in |- *.\n  case (n:=n:=n:=n).\n  case (n:=n) (n:=n).\n  unfold lt_n:=n:=n:=n:=n:=n:=n).\n  case (n:=n:=n:=n).\n  case (n).\n  rewrite lt_n.\n  rewrite lt_n.\n  apply lt_n.\n  apply lt_n_n.\n  apply le_n.\n  apply le_n.\n  apply lt_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  rewrite mult_r.\n  rewrite mult_comm.\n  apply mult_r.\n  apply mult_r with 0.\n  apply mult_r.\n  apply mult_r.\n  apply mult_r.\n  apply mult_r.\n  apply mult_r.\n  assumption.\n  apply mult_r.\n  apply mult_r.\n  assumption.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  destruct (n, n).\n  simpl.\n  split.\n  apply le_trans with (n := nat)).\n  apply le_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n) in |- *.\n  apply le_n:=n:=n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  applyQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red; simpl in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *. red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. intros.\n  red in |- *. red in |- *. red in |- *. red in |- *. red in |- *.\n  red in |- *. red in |- *. red in |- *. red in |- *.\n  red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. intros. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. intros. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |- *. red in |-Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  unfold not in |- *.\n  intros.\n  apply lt_trans with (mult (nat a).\n  apply lt_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n).\n  apply lt_n.\n  apply le_n.\n  apply le_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n).\n  apply lt_n:=n:=n:=n:=n:=n:=n.\n  apply lt_n:=n.\n  apply le_n.\n  apply lt_n.\n  rewrite lt_n.\n  apply lt_n.\n  apply lt_n.\n  apply le_n.\n  apply le_n.\n  apply lt_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  applyQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red; auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  unfold not_not_not_or_or in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  apply H.\n  apply not_r.\n  apply not_le_comm.\n  split.\n  apply not_le.\n  apply not_trans with (r := r).\n  apply not_lt_r.\n  apply not_l.\n  assumption.\n  apply not_r.\n  apply not_l.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  unfold succ in |- *.\n  red in |- *.\n  intros.\n  generalize (mult_l a b).\n  intro.\n  apply succ_mult_mult_mult_mult_mult_mult_mult.\n  apply succ_distr_mult.\n  apply succ_mult_mult.\n  apply pred_mult.\n  assumption.\n  apply succ_mult.\n  apply pred_mult.\n  assumption.\n  apply pred_mult.\n  apply pred_mult.\n  apply pred_mult.\n  apply pred_mult.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  unfold not, not in |- *.\n  intros.\n  elim (le_le_le_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  destruct n.\n  apply le_trans with (n := le_le_trans with (n := n).\n  apply le_trans with (n := n).\n  apply le_trans with (n := lt_trans with (n := le_trans with (n:=n:=n:=n) (n:=n:=n:=n:=n:=n:=n:=n:=n) n) n).\n  apply le_trans with (n:=n:=n:=n:=n:=n:=n:=n) (n:=n:=n:=n) n) H.\n  apply le_n.\n  apply le_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n) H.\n  apply le_n:=n:=n:=n in H.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  applyQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  split; auto with arith.\n  split; auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red in |- *.\n  red; intros.\n  simpl in |- *.\n  elim (proj1:=n:=n,n) (n)).\n  simpl in |- *.\n  apply le_trans with (n:=n:=n:=n:=n:=n:=n) (n:=n:=n:=n:=n:=n) in |- *.\n  apply le_n:=n.\n  rewrite le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n:=n.\n  apply le_n:=n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply leQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply lt_trans with arith.\n  intros.\n  assert (n := le_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n.\n  apply le_n:=n:=n in n).\n  rewrite le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  unfold not in |- *.\n  intros.\n  unfold not in |- *.\n  apply le_lt.\n  apply le_trans with (n:=n:=n:=n:=n:=n) (n:=n:=n:=n:=n:=n:=n) in |- *.\n  apply le_n_n_n_n:=n:=n) in |- *.\n  apply le_n.\n  apply le_n_n:=n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  applyQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red in |- *.\n  red in |- *.\n  red in |- *.\n  unfold not in |- *.\n  apply not in |- *.\n  elim (le_trans_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  elim H.\n  unfold le in |- *.\n  auto with arith.\n  intros.\n  unfold le_trans with arith.\n  rewrite <- le_trans with (n:=n:=n:=n:=n:=n:=n:=n:=n) in |- *.\n  apply le_n:=n:=n:=n:=n:=n:=n:=n) in |- *.\n  apply le_n.\n  auto with arith.\n  auto with arith.\n  apply le_n:=n:=n:=n:=n).\n  auto with arith.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  auto with (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n).\n  apply le_n.\n  auto with arith.\n  apply le_n.\n  auto with arith.\n  apply le_n:=n.\n  auto with arith.\n  apply le_n.\n  apply le_n:=n:=n:=n:=n:=n:=n) with arith.\n  apply leQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n intros.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply H.\n  apply le_trans with (le_trans with (le_trans _ _ _ _ _ _ H).\n  apply le_trans with (le_trans _ _ _ _ _ _ _ _ _ _ _ _ H).\n  apply le_trans with (le _ _ _ _ _ _ _ H).\n  apply le_trans with (le_trans with (lt _ _ H).\n  apply le_trans with (le _ _ _ _ _ H).\n  apply le_trans with (le _ H).\n  apply le_trans with (lt_trans with (le _ _ H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := H).\n  apply le_trans with (n := n).\n  apply le_transQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  destruct (Rle_dec a b)); auto with arith.\n  apply H; auto with arith.\n  auto with arith.\n  auto with arith.\n  apply lt_trans with arith.\n  apply lt_trans with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  split; intros.\n  elim H.\n  apply le_trans with (r := r); auto.\n  apply le_trans with (r := r); auto with arith.\n  auto with arith.\n  apply le_r with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := r).\n  apply le_trans with (r := r); auto with (r := r); auto with arith.\n  apply le_trans with (r := r); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := r); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := r); auto with arith.\n  apply le_r with arith.\n  apply le_r with (r := r); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := r) with arith.\n  apply le_trans with (r := r); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans withQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  unfold not in |- *.\n  elim H1; auto with arith.\n  elim H1; auto with arith.\n  auto with arith.\n  rewrite H1.\n  auto with arith.\n  auto with arith.\n  elim H2.\n  elim H1; auto with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  auto with arith.\n  with arith.\n  rewrite H2; auto with arith.\n  apply le_trans with arith.\n  auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := H2; auto with arith.\n  apply le_trans with arith.\n  auto with arith.\n  auto with arith.\n  elim H2; auto with arith.\n  auto with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := H3); auto with arith.\n  apply le_trans with arith.\n  apply le_trans with (r := le_trans with (r := H1 := H3); auto with arith.\n  rewrite le_trans with (Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros; elim H; elim H1; auto with arith.\n  elim H1; auto with arith.\n  apply H2; auto with arith.\n  auto with arith.\n  auto with arith.\n  rewrite H3; auto with arith.\n  apply H2; auto with arith.\n \nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros; elim H; intros.\n  apply H.\n  elim (q)).\n  apply H1.\n  elim (q:= q).\n  right; auto.\n  apply H1.\n  intros.\n  apply (q:=q:=q:= q).\n  apply H2).\n  apply H2.\n  assumption.\n  apply H2.\n  apply H2.\n  assumption.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  split.\n  apply H1.\n  apply False_le_le.\n  intros.\n  apply H3.\n  case (p':=p:=p:=p:=p:=p:=p)).\n  apply False_le_lt_trans with (p:=p:=p:=p:=p:=p:=p:=p:=p:=p:=p:=p).\n  apply (p:=p:=p:=p:=p:=p:=p:=p:=p:=p)).\n  apply (p:=p:=p:=p:=p).\n  assumption.\n  apply H3.\n  apply False_le_le_le.\n  assumption.\n  apply False_le.\n  apply False_trans with (p:=p:=p:=p:=p:=p).\n  assumption.\n  apply False_le.\n  assumption.\n  apply False_le.\n  assumption.\n  assumption.\n  apply False_le.\n  assumption.\n  apply False_lt_trans with (p:=p:=p:=p:=p:=p:=p:=p:=p).\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  unfold or_trans with (p:=q).\n  elim H1; elim H1 H1; intros.\n  elim H1.\n  elim H1.\n  elim H1; intros.\n  elim H1.\n  intros; intros H2.\n  elim H1.\n  elim H1; intros.\n  elim H1.\n  elim H2; intros.\n  elim H2.\n  elim H1; clear H2.\n  intros.\n  elim H2.\n  intros.\n  intros.\n  elim H2; intros.\n  elim H2.\n  intros.\n  elim H2.\n  elim H2.\n  elim (q1; intros.\n  elim (p1 * q2).\n  elim H1.\n  elim (p1).\n  intros.\n  intros.\n  elim H2.\n  elim H2.\n  intros.\n  elim H2.\n  elim H2.\n  intros.\n  intro.\n  elim H1.\n  elim H2.\n  elim H1.\n  apply H2.\n  elim H1.\n  intros.\n  intro.\n  elim H1.\n  elim (p2).\n  rewrite (p1).\n  intros.\n  elim H2.\n Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  apply H; auto with arith.\n  apply H1.\n  apply le_trans with (p:=p:=p:=p:=p:=p:=p) (p:=p:=p:=p:=p:=p:=p:=p).\n  assumption.\n  apply le_p:=p:=p:=p:=p:=p) H1 in H2).\n  assumption.\n  left; assumption.\n  apply le_p:=p.\n  apply le_p:=p:=p:=p:=p:=p:=p:=p:=p.\n  assumption.\n  apply le_p:=p:=p:=p:=p).\n  apply le_p.\n  apply le_p:=p:=p.\n  apply le_p:=p:=p:=p:=p).\n  apply le_p_p.\n  apply le_p.\n  apply le_p.\n  rewrite le_p.\n  apply le_gt_r.\n  apply le_trans with (p:=p:=p:=p:=p:=p:=p).\n  apply le_q.\n  apply le_gt.\n  apply le_p:=p:=p:=p:=p).\n  apply le_Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  elim (mult_r a); auto with arith.\n  intros.\n  apply H.\n  intros.\n  apply le_trans with (r := r) (r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r).\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_trans with (r:=r:=r:=r:=r).\n  apply le_r.\n  apply le_r.\n  apply le_r.\n  apply le_trans with (r:=r:=r:=r:=r).\n  apply le_r:=r.\n  apply le_trans with (r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r:=r) in H1:=r:=r:=rr:=r) in H1.\n  apply le_r.\n  apply le_r; auto.\n  apply le_l.\n  apply le_r.\n  apply le_r.\n  apply le_trans with (r:=r:=r:=r:=r).\n  apply le_r.\n Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (m:=m).\n  elim H0 H1 H1; intros.\n  elim H1.\n  elim H1.\n  apply H1.\n  apply H1.\n  apply (p:=p:=p:=p).\n  assumption.\n  apply H1.\n  apply H2.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (q:=q:=q:=q:=q:=q:=q).\n  intros.\n  elim (q:=q:=q:=q).\n  case (q:=q:=q:=q) q).\n  case (q:=q:=q:=q).\n  case q.\n  case (q:=q).\n  case (q:=q:=q:=q:=q:=q:=q).\n  apply H.\n  elim (q:=q:=q:=q).\n  apply (q:=q:=q:=q).\n  rewrite (q:=q:=q:=q:=q:=q).\n  rewrite (q:=q:=q:=q).\n  case (q:=q:=q:=q:=q:=q:=q:=q).\n  case q.\n  case (q:=q:= q) as (q:=q:=q).\n  case (q:=q:=q:=q:=q:=q:=q:=q:=q:=q:=q:=q:=q:=q).\n  apply case (q:=q:= q) (q:=q:=q:=q).\n  case (q:=q:=q:=q) q:=q:=q).\n  apply (q:=q:=qQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x.\n  intros.\n  unfold mult_assoc.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm ( mult_comm ( mult_comm n) ( mult_comm (mult_comm (mult ( mult_comm n)).\n  rewrite mult_comm ( mult_assoc (mult_comm n) (mult_comm ( mult_comm ( mult_comm ( mult_assoc (mult ( mult_comm n) (mult_comm (mult n)) (mult (mult n)).\n  rewrite mult_comm (mult_comm (mult (mult_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction n; intros.\n  assert (H2*z*z) by auto.\n  rewrite <- mult_comm; apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc; auto.\n  rewrite mult_comm.\n  rewrite mult_comm; auto.\n  rewrite mult_comm; auto.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm n)) ( mult_comm ( mult_comm ( mult_comm n) (mult_comm (mult n) ( mult_comm ( mult_comm n)); auto.\n  rewrite mult_comm ( mult_comm ( mult_comm (mult_comm ( mult_comm ( multQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  elim H1.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm n).\n  rewrite mult_comm (mult (mult_assoc ( mult_comm (mult_comm (mult (mult n) (mult (mult_assoc (mult n) (mult (mult (mult n n n) (mult n)) (mult (mult n) (mult_mult (mult_mult (mult (mult n)) (mult n) (Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros; clear H0 H0.\n  unfold mult_assoc.\n  rewrite mult_comm; rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm ( mult_comm ( mult_comm n) ( mult_comm n)).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult (mult_comm (mult ( mult_comm n) (mult n) (mult n)).\n  rewrite mult_comm (mult (mult_comm n) (mult n)); rewrite mult_comm (mult_assoc (mult_comm n).\n  rewrite mult_mult_comm n (mult_assoc ( mult_mult n) at 1.\n  rewrite mult_mult_comm (mult_comm (mult_comm n)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_mult_comm.\n  rewriteQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm; rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm ( mult_comm ( mult_comm n)) (plus_comm ( mult_comm ( mult_comm ( mult_commQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm (mult (n + n)).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult (mult_comm n)).\n  apply mult_assoc.\n  rewrite mult_comm (mult_comm (mult_comm (n_comm (n - n)).\n  apply mult_comm n).\n  rewrite mult_comm ( mult_comm (mult_comm n).\n  apply mult_comm (mult_comm (mult_comm n) (n+n + n) n).\n  rewrite mult_comm n).\n  apply mult_comm n.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite multQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  induction n; simpl in H1.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_assoc ( mult_comm ( mult_comm ( mult_comm n)) ( mult_assocQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  rewrite mult_comm.\n  unfold mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm; trivial.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm (mult n) ( mult_comm ( mult_comm ( mult_comm n) (mult_comm n) (mult_comm n) (mult_comm n).\n  rewrite mult_comm (mult (mult_comm n) (mult_mult_comm (mult_comm n).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewriteQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  generalize (x*z+z) n).\n  intros.\n  unfold mult_comm.\n  replace (x+z)%nat with (z)%nat with (y+z + z)%nat with (z + z)%nat with (z + z)%nat with (z + z)%Z by omega).\n  omega.\n  rewrite mult_comm.\n  rewrite mult_comm in H2.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm n n)) ( mult_comm (mult (mult_comm (mult_commQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  assert (x = z).\n  rewrite <- mult_comm (0*y*y) by omega.\n  assert (z*z = z) by omega.\n  assert (x*z*z-1) by omega.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_assoc (S n)) (mult_comm n) (n+y+x+z*z+y+z+z+y+z+z+z+z+y+z+z+z+z+z+y+z+z+z+z+z+z+z+z+y+z+z+z+z+y+z+z+z+y+y+z+z+z+z+z++z+z+Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  apply le_equal.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_r.\n  rewrite mult_n_comm.\n  rewrite mult_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_plus_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_plus_n_n.\n  rewrite mult_n_n_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_plus_n_n.\n  rewrite mult_n_n_n_n_n.\n  rewrite mult_n_n_n.\n  rewrite mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewriteQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  elim (S n) (S n) as [n] [n] H1] H1].\n  generalize (S n)).\n  elim H3.\n  apply minus_S_S.\n  rewrite mult_n.\n  rewrite mult_Sm.\n  rewrite mult_Sm.\n  rewrite mult_comm.\n  rewrite mult_Sm.\n  rewrite mult_n.\n  unfold mult_n_n.\n  rewrite mult_plus_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_n_n.\n  rewrite mult_n_n_n_n_n_n_n.\n  rewrite mult_n_n_n_n_n_n_n.\n  rewrite mult_n_n_n_n_n_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n_Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  unfold mult_comm.\n  rewrite mult_comm.\n  unfold mult_assoc.\n  simpl in H0.\n  unfold mult_comm.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm mult_assoc n) (multQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  induction n.\n  rewrite mult_comm.\n  destruct (le_comm a).\n  destruct (S n)).\n  omega.\n  rewrite plus_plus_comm.\n  rewrite plus_l.\n  omega. omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  destruct (S n) as (S n) as (S n) as (S n)) as (S n);simpl in H2.\n  destruct n).\n  rewrite plus_comm.\n  assert (S n)) by (S n).\n  assert (S n) by (S n) by (S n n).\n  assert (S n) by (S n) by (S_S n).\n  assert (S n) by omega.\n  assert (S n).\n  assert (S n) by (S n n) by (S n).\n  assert (S n).\n  assert (S n) by (S n) by (S n) by (S n)).\n  assert (S n m n).\n  assert (S n).\n  assert (S n).\n  assert (S n).\n  assert (S n) by (S n).\n  assert (S n) by (S n n)).\n  assert (S n) by (S n); eauto.\n  assert (S n) by (S n).\n  assert (S n)).\n  assert (S n) by (S n).\n  assert (S n).\n  assert (S n) by (Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  assert (n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+n+n+n+n+n+nn+nn+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+n+n+nn+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+n+nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  unfold minus in H0.\n  unfold minus_n.\n  unfold minus_n.\n  rewrite minus_n.\n  simpl in H0.\n  rewrite <- minus_n.\n  rewrite mult_n.\n  rewrite plus_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  apply mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n_n_n_n_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_n_n_n_n.\n  rewrite mult_n_n.\n  simpl in H.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_n_n.\n  rewrite mult_n_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  simpl.\n  rewrite mult_n_n.\n  rewrite mult_n_n_n_n_n_n.\n  rewrite mult_n_n_n_n_Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  unfold mult_comm.\n  unfold mult_comm.\n  unfold mult_assoc.\n  rewrite mult_comm.\n  unfold mult_comm.\n  unfold mult_assoc.\n  unfold mult_comm in |- *.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  unfold mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm ( mult_assoc (mult_comm ( mult_assoc n) (n+1 n) (n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  generalize (Z.\n  rewrite minus_O.eq (le_n).\n  intro; intros.\n  elim (n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+nn+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+nn+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  assert (n*n*n+n*n+n*n*n*n*n*n*n+n+n+n+n+n+n+n+n*n*n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  rewrite minus_n.\n  rewrite minus_O.\n  rewrite minus_O.\n  rewrite minus_O.\n  rewrite minus_O.\n  rewrite minus_O.\n  rewrite minus_O_O_O.\n  rewrite mult_O_O.\n  rewrite mult_O_O_O.\n  rewrite minus_O_O_O.\n  rewrite mult_O.\n  rewrite minus_O_O_O.\n  rewrite minus_O_O_O_O_O.\n  rewrite mult_O_O_O_O_O_O_O_O.\n  rewrite mult_O_O_O_O_O_O.\n  rewrite mult_O_O.\n  rewrite mult_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O.\n  rewrite mult_O_O_O_O_O_O_O_O_O_O.\n  rewrite minus_O_O_O_O_O_O_O_O.\n  rewrite minus_O_O_O_O_O_O_O_O_O_O_Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  unfold minus_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_comm.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_comm (mult_comm (n + n) x) (n + n) (n + n + n)) n.\n  rewrite mult_comm (n + n)) at 2.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  assert (n) (S n) by (S n) by (S n).\n  assert (S n) by omega).\n  assert (S n) by (S n) by omega.\n  assert (S n); omega.\n  assert (S n) by omega).\n  assert (S n) by omega.\n  assert (S n n) by omega.\n  assert (S n) by omega).\n  assert (S n m).\n  assert (S n).\n  assert (S n m) by omega.\n  assert (S n) by omega.\n  assert (S n m) by omega).\n  assert (S n) by omega.\n  assert (S n).\n  assert (S n).\n  assert (S n) by omega).\n  assert (S n m) by omega.\n  assert (S n) by omega).\n  assert (S n) by omega.\n  assert (S n m).\n  assert (S n m) by omega.\n  assert (S n m).\n  assert (S n m).\n  assert (S m) by omega.\n  assert (S n) by omega.\n  assert (S n m) by (S m) by omegaQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm in H0 in H0.\n  destruct (S n)).\n  simpl in H0.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm ( mult_comm (mult_comm (mult_comm n) (plus_comm (plus_comm n).\n  rewrite mult_comm (mult_comm n)) at 2.\n  rewrite mult_comm (mult_assoc (mult_comm n)).\n  rewrite mult_comm (mult_comm (mult_comm (mult (mult_comm n n).\n  rewrite mult_comm n).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult_comm n (Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  intros.\n  apply mult_l.\n  destruct (n*m).\n  destruct (S n) as (S n) as (S n).\n  destruct (S n)).\n  destruct (S (S n m n) as (S n) (S n)); simpl in H.\n  apply mult_comm (S n)).\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  simpl.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm (mult_comm n) at 2) at 2 plusQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  unfold mult_comm.\n  unfold mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm (mult_comm ( mult_comm ( mult_comm ( mult_comm ( mult_assoc (mult_comm n)) ( mult_comm ( mult_comm (mult ( mult_comm n) ( mult_comm (mult_assoc (mult (mult ( mult_comm ( mult_comm n)) ( mult_assoc (mult_comm n)) mult_comm (mult ( mult_comm ( mult mult_assoc (Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  rewrite minus_n.\n  rewrite mult_n.\n  rewrite mult_n.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_r.\n  apply mult_l.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (le_comm (n+m+n*n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros n H.\n  unfold minus in H.\n  rewrite mult_n.\n  apply mult_n.\n  rewrite mult_reverse.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult_comm (mult_comm (mult_comm n)).\n  rewrite mult_comm (mult_comm (mult_comm n)).\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm (mult (mult (mult_comm (mult_comm (mult n)).\n  rewrite mult_comm (mult_comm (mult_assoc (mult (mult_comm (mult_comm n) (mult_comm n) (mult n)).\n  rewrite mult_comm (mult_comm (mult_comm (mult_assoc (mult (mult_Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  apply mult_l.\n  apply mult_comm.\n  apply plus_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  assumption.\n  apply mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm ( mult_comm (mult_comm x y y).\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm x y).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult (mult y y z) (mult_assoc (mult y z).\n  rewrite mult_comm (Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  rewrite mult_assoc.\n  destruct (n+n+n+n+n) as [n|n] H3] H3].\n  rewrite mult_assoc.\n  rewrite mult_comm, mult_comm.\n  rewrite mult_comm, mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm, mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_assoc ( mult_comm ( mult_comm (mult_comm n)) (mult_comm (mult_comm n)) (mult (mult_comm (mult n) (mult n) (mult (mult_mult_comm n))\n    (mult (mult (mult (mult_comm (mult n).\n  rewrite mult_comm n) at 2.\n  rewrite mult_mult_comm (mult_comm (mult_assoc (mult_mult (mult_mult_comm n) (mult_mult_mult (mult n) (mult n) at 1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  unfold mult_n.\n  unfold mult_assoc.\n  unfold mult_comm in |- *.\n  apply mult_comm.\n  rewrite mult_comm.\n  unfold mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl in |- *.\n  unfold mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_comm ( mult_comm (mult_comm (mult_comm (S n)) (mult_comm (S n)).\n  rewrite mult_comm ( mult_comm (mult ( mult_comm (S n)) (mult_comm n)).\n  rewrite mult_comm (mult_comm (n_comm (mult (S n)) (S n))).\n  rewrite mult_comm (Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm in H.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm (n + (S n)) (S n)) (S n)).\n  rewrite mult_comm (S n).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_assoc mult_comm (mult_assoc (n_comm n n) (S n)) (S n)) (S n)) at 2.\n  rewrite mult_assoc.\n  simpl in |- *.\n  rewrite mult_comm (S n))).\n  rewrite mult_comm (mult.\n  rewrite mult_comm (S n)) at 2.\n  rewrite mult_assoc.\n  rewrite mult_Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  apply le_n.\n  rewrite mult_n.\n  apply le_n.\n  rewrite mult_l.\n  apply le_n.\n  rewrite mult_r.\n  rewrite mult_n.\n  rewrite mult_n.\n  apply mult_comm.\n  rewrite mult_n.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_l.\n  apply mult_comm.\n  rewrite mult_l.\n  rewrite mult_n.\n  rewrite mult_comm (n+n+n).\n  rewrite mult_plus_l.\n  rewrite mult_plus_l.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_distr_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm n n)) at 1.\n  rewrite mult_comm (mult n)).\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm n).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm (mult n)).\n  rewrite mult_comm (mult_comm ( mult_comm (mult n n)).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm n (mult (mult n).\n  apply mult_mult_comm n)).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult_assoc.\n  rewrite mult_comm (mult_comm (mult n)) (mult_assoc (mult (mult n)) (mult n)) (mult (mult (mult n n)).\n  rewrite multQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm ( mult_comm (n+n+n+n+n+n+n+0+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  apply minus_comm.\n  rewrite mult_n.\n  apply mult_n.\n  rewrite mult_n.\n  rewrite mult_comm.\n  rewrite mult_l.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm ( mult_comm ( mult_comm (mult_comm n)).\n  rewrite mult_comm ( mult_comm (mult_comm (mult_comm n)).\n  rewrite mult_comm (mult (mult_comm (mult_comm n) (mult_comm n).\n  rewrite mult_assoc (mult_comm (mult_comm n) (mult n) (mult_comm (mult n) at 1.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_comm n).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult_comm (mult_comm (Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  rewrite mult_plus_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_assoc.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  apply mult_distr_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc (mult_comm n)) (mult n)).\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_comm (mult_comm n).\n  rewrite mult_comm (mult_comm (mult_assoc (mult n)).\n  rewrite mult_comm (mult_comm (mult_comm n n n)).\n  rewrite mult_comm ( mult_comm n) (mult_assoc n) (mult n) (mult_comm n))).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm n) at 2.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.Qed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  unfold mult_n.\n  rewrite mult_distr.\n  apply mult_l.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc (mult_comm n)) (mult (mult_assoc (n n)) n) (mult n).\n  rewrite mult_assoc (mult (mult (mult n)) (mult_comm (mult n)) (mult (n + n) (n) (S n)) n) (n+n + n)) (n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  unfold mult_comm.\n  rewrite mult_comm.\n  apply mult_distr_comm.\n  replace (n*z*y+y*y) with (n+n+n+n+z+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm (mult (S n) (S n))) (S n)) (S n)).\n  rewrite mult_comm (n (S n)).\n  rewrite mult_comm (S n)).\n  rewrite mult_comm.\n  rewrite mult_comm (S n (S n)).\n  rewrite mult_comm n)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm (plus_comm (S n (S n n)) (S n)) (S n)).\n  rewrite mult_comm (S n) (S n)).\n  rewrite mult_comm (S n)) at 2.\n  rewrite mult_comm (S n) at 2 (S nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_distr_plus_assoc.\n  rewrite mult_assoc.\n  rewrite mult_l.\n  apply mult_plus_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm ( mult_assoc.\n  rewrite mult_comm ( mult_comm ( mult_assoc ( mult_comm n)) ( mult_comm (mult (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm n) y) (mult_comm (mult_comm y)).\n  simpl in |- *.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm (mult_assoc (mult (mult_comm (mult (mult_comm x) (mult_comm x y).Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  simpl in H.\n  destruct (y) as (y+z+y+y+y+z+z+z+z+y+z+z+y+z+z+z+z+y+z+z+z+z+z+z+z+z+z+y+z+y+z+z+z+z+y+y+z+y+y+z+z+y+z+z+z+z+z+z+z+z+z+z+z+y+z++z+z+y+z+z+z+z+z++z+z+z++z+y+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z++z+z+z+z++z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z++y+z+z++z++z+z++z+z+z+zQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  apply le_plus_comm.\n  apply le_plus_n.\n  rewrite mult_comm.\n  assert (y*z+y=z+z+z+y+z+z+y+z+y+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+z+z+z+z+z+y+z+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+z++z+z+z+z+z+z+z+z++z+z++z+z+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  assert (x+y+z+y+y+y+y+y+z+z+y+y+y+y+y+y+z+y+z+z+z+z+y+y+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+z+y+z+z+z+z+x+z+z+y+z+z+x+z+y+z+z+y+z+z+y+y+z+z+z+z+z+z++z+z+y+z+z+y+z+z+z+z+z+z+z+z+y+z+y+z+z+z+z+z+z+z+z+z+z++z+z+z+z+z+z+z+z+z+z++z+z+z+z+z++z+z+z++z+z+z+z+z+z+z+z+z+Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_mult_comm in H.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_comm in H.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_assoc.\n  rewrite mult_comm (mult_comm (mult_comm y).\n  rewrite mult_assoc (mult (mult_comm y).\n  rewrite mult_comm (mult_assoc (mult_comm y) (mult y) (mult y) (mult y) (Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_minus.\n  rewrite mult_distr_distr_distr_distr_distr_l.\n  rewrite mult_distr.\n  rewrite mult_distr_distr_distr_assoc.\n  rewrite mult_distr_distr.\n  rewrite mult_assoc.\n  rewrite mult_distr.\n  rewrite mult_distr_distr_assoc.\n  rewrite mult_distr_distr.\n  rewrite mult_distr.\n  rewrite mult_assoc.\n  rewrite mult_l.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  apply mult_l.\n  rewrite mult_distr.\n  rewrite mult_distr_distr.\n  rewrite mult_assoc.\n  rewrite mult_distr_l.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_l.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_distr.\n  rewrite mult_assoc.\n  rewrite mult_distr.\n  rewrite mult_l.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  destruct z as (z) as [|y]; simpl; trivial.\n  destruct (y+z+y*z+z+z+y+y+z+z+z+z+z+y+z+z+y+y+z+z+z+z+z+y+y+y+z+z+z+y+z+z+y+z+z+z+z+z+z+z+z+z+z+z+z+z+z+y+z+z+y+z+z+z+y+z+y+z++z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+z+z+z+++z+z+z++z+z+z+z+z+z+z+y+z+z++n+z+z+z+z+z+z+Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_minus.\n  rewrite mult_plus_plus.\n  rewrite mult_comm.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_distr_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  simpl.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plusQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_minus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc (mult (n+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y++y+y+y+y++y+y+y+y+y+y+y+y+y+y+++y+y+y++y+y++y+y+y+y+y++z++x+++y+++y++++y++y+++++++++++++++++++++++++++++++++Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  unfold mult_plus_plus_plus_minus; rewrite mult_plus_plus_plus_l; trivial.\n  rewrite mult_assoc; trivial.\n  rewrite mult_plus_distr_comm.\n  rewrite mult_distr_distr_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_plus_plus_comm.\n  rewrite mult_r.\n  rewrite mult_plus_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_distr_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_assoc ( mult_assoc ( mult_assoc ( mult_assoc ( mult_comm (mult (mult_assoc ( mult_assoc (mult_assoc ( mult_assoc (mult_comm ( mult_comm (mult x) (mult x)) (mult ( mult_assoc (mult (mult_assoc x y) x y) (multQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros x y z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite mult_plus.\n  rewrite mult_plus_plus_plus_plus_plus_distr; auto with arith.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite mult_le_minus.\n  rewrite mult_minus.\n  rewrite mult_minus_minus_minus_distr.\n  rewrite mult_plus_plus_plus_minus.\n  rewrite mult_plus_plus_distr_minus.\n  rewrite mult_plus.\n  rewrite mult_plus_distr.\n  rewrite mult_distr_comm.\n  rewrite mult_distr_plus_plus.\n  rewrite mult_assoc.\n  rewrite mult_plus_plus_plus_plus_plus_comm.\n  rewrite mult_distr_plus_distr_plus_plus_plus.\n  rewrite mult_plus.\n  simpl.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_distr_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  simpl in |- *.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite mult_plus_plus_comm; rewrite mult_plus_plus_distr_assoc.\n  rewrite mult_comm.\n  rewrite mult_distr.\n  rewrite mult_plus_distr_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm (mult_comm (mult_distr_comm (mult_comm y) (mult_assoc y) (mult y)).\n  rewrite mult_comm (mult y)).\n  rewrite mult_comm (mult_distr_comm y y).\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm x y.\n  rewrite mult_assoc.\n  rewrite mult_comm y.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_comm y y y z y).\n  rewrite mult_assoc.\n  rewrite multQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  unfold le.\n  intros.\n  rewrite plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  simpl.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  2.\n  rewriteQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  apply plus_plus_le_l.\n  rewrite plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_one.\n  unfold mult_plus.\n  apply plus_plus_plus.\n  assumption.\n  rewrite plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite plus_plus_plus_plus_plus_plus_minus; rewrite plus_plus_plus_distr_plus_minus.\n  rewrite plus_minus.\n  rewrite mult_plus_plus_plus_minus.\n  rewrite mult_plus.\n  rewrite mult_plus_plus_distr_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plusQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite minus_n_plus_minus.\n  rewrite plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  apply plus_plus_plus_plus_plus.\n  apply plus_plus_plus_plus.\n  apply plus_plus_plus.\n  rewrite plus_plus_plus_plus.\n  apply plus_plus.\n  simpl.\n  apply plus_plus_plus_plus_plus_plus.\n  apply plus_plus_plus_plus_plus_plus.\n  simpl.\n  apply plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus.\n  apply plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  apply plus_plus_plus_plus_plus_plus_plus_plus.\n  apply plus_plus_plus.\n  rewrite mult_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\n  intros.\n  rewrite plus_plus.\n  replace (x+y*z-y+y+z+x+z+z+z+z+z+z+z+z+z+z+z+z+y+z+z+z+z+y+z+z+y+z+y+z+y+z+z+y+z+z+z+z+z+z+z+z+z+y+z+y+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+z+z+y+z+z+z+z+z+z+z+y+z+z+z+z+z+y+z+z+y+z+z+z+z+z++z+z+z+z+z+z+n+z+z+z+z+z+z+z+z+x+z+z+z+z+z+y++z+z+yQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  unfold minus_plus_plus_plus_minus.\n  unfold minus_plus.\n  unfold minus_plus.\n  unfold minus_n.\n  unfold minus_plus_plus_distr_plus_plus_plus.\n  unfold minus_plus_plus_plus_plus.\n  rewrite minus_minus.\n  rewrite mult_minus.\n  rewrite minus_plus_plus_minus.\n  rewrite mult_distr_plus_plus_minus.\n  rewrite minus_n_plus_plus_plus_plus_plus_plus_plus_plus_minus.\n  rewrite mult_plus_plus_plus_distr_plus_plus_minus.\n  rewrite minus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  unfold mult_plus_plus_plusQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  destruct z;simpl.\n  rewrite minus_l.\n  rewrite mult_l; rewrite plus_comm.\n  replace (y+y+y+y+y+y*y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+x+y+y+y+y+y+y+y+y+y+y+y+y+y+y++y++y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y++y+x+y+y+y++y+++++y++y++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  rewrite plus_comm; trivial.\n  rewrite plus_plus_distr_plus_l; trivial.\n  rewrite plus_comm; trivial.\n  rewrite minus_plus_comm; trivial.\n  rewrite plus_minus_plus_distr.\n  rewrite plus_plus_minus.\n  rewrite plus_plus_plus_distr_distr_plus.\n  rewrite mult_plus_plus_plus_plus_plus_distr_plus_distr_plus.\n  rewrite mult_plus_plus.\n  rewrite plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus.\n  rewrite plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus.\n  apply plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus.\n  rewrite plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus.\n  simplQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  unfold minus_minus.\n  simpl in |- *.\n  rewrite plus_distr.\n  apply minus_minus_minus_minus.\n  rewrite minus_plus_minus_plus_minus_plus_minus_minus_minus.\n  simpl in |- *.\n  unfold minus_plus.\n  rewrite minus_minus.\n  rewrite mult_plus_comm.\n  rewrite mult_plus_minus_distr_distr_minus.\n  rewrite mult_distr_plus_distr.\n  rewrite plus_minus_minus.\n  rewrite mult_plus_comm.\n  rewrite plus_minus_distr_minus.\n  rewrite plus_distr_plus_minus.\n  rewrite mult_distr.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_distr_distr_distr_distr_distr_plus_l.\n  rewrite mult_distr_comm.\n  rewrite mult_distr_l.\n  rewrite mult_plus_assoc.\n  rewrite plus_comm.\n  rewrite mult_distr_distr_distr_l.\n  rewrite mult_comm.\n  rewrite mult_distr_assoc.\n  rewrite mult_distr_distr_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_distr_distr.\n Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros x z Hz.\n  generalize (y).\n  rewrite plus_minus_le_l; trivial.\n  destruct z).\n  rewrite plus_r.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_minus_assoc.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  apply plus_comm.\n  rewrite mult_assoc.\n  rewrite plus_comm.\n  apply le_comm.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite plus_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_commQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  rewrite mult_minus.\n  unfold minus_minus.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite plus_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_l.\n  rewrite mult_l.\n  rewrite mult_plus_plus_comm.\n  apply mult_comm.\n  rewrite mult_distr_comm.\n  rewrite mult_distr.\n  rewrite mult_distr_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm ( mult_comm (mult_assoc (mult_assoc (mult_comm (plus_assoc (mult_comm x)) (mult_comm x y)) (mult x)).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_plus_assoc.\n  rewrite mult_comm (mult_assoc (mult (mult (mult (mult x) (mult_mult x) (mult x)) (mult x) (Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  rewrite plus_plus_plus_plus_plus_plus.\n  rewrite minus_plus_plus_plus_plus_plus.\n  rewrite minus_plus_plus_plus_plus_plus_plus.\n  rewrite minus_plus_plus_plus_plus_plus.\n  rewrite minus_plus_plus_plus.\n  rewrite minus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  simpl.\n  rewrite mult_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  simpl.\n  rewrite mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus.\n  rewrite mult_plus_plus.\n  rewrite mult_plus_Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  unfold minus_plus.\n  rewrite minus_le_l.\n  rewrite minus_comm.\n  rewrite minus_minus_n.\n  rewrite minus_n.\n  rewrite minus_plus_n.\n  rewrite mult_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite mult_n.\n  rewrite minus_n.\n  rewrite mult_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  rewrite minus_n.\n  apply mult_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  simpl in H.\n  rewrite plus_n.\n  rewrite plus_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite plus_n_n.\n  rewrite plus_n.\n  simpl.\n  rewrite plus_n.\n  rewrite plus_n.\n  rewrite plus_n.\n  rewrite plus_n.\n  rewrite plus_n.\n  rewrite plus_Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros z Hz.\n  rewrite plus_plus_plus_plus_plus_minus; unfold mult_minus; unfold mult_plus_plus_assoc; simpl in |- *.\n  rewrite plus_comm.\n  rewrite mult_minus.\n  unfold mult_distr_comm.\n  rewrite mult_plus_distr_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_comm.\n  rewrite mult_distr_r.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_distr.\n  rewrite mult_comm.\n  rewrite mult_plus_comm (mult_comm (plus_distr_distr_distr_assoc (mult_comm (mult_distr_comm y z).\n  rewrite mult_comm (mult_comm z) (mult_comm z z).\n  rewrite mult_assoc (mult_assoc z).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\n  intros.\n  apply minus_n.\n  rewrite mult_distr_l.\n  simpl; simpl.\n  rewrite plus_comm; auto with arith.\n  rewrite mult_l.\n  rewrite mult_l.\n  apply plus_comm.\n  rewrite mult_l.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_l.\n  rewrite mult_distr_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm ( mult_comm ( mult_comm ( mult_comm (mult_comm (mult_comm y) (mult_comm x)) (mult_comm (mult x) (mult x) (mult y) (mult_comm y) y) (mult y) (mult y));\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm (mult y y x y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros;simpl; rewrite minus_lt_n.\n  rewrite mult_n.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm ( mult_assoc ( mult_comm ( mult_assoc mult_assoc ( mult_assoc (mult_comm ( mult_assoc ( mult_comm ( mult_comm ( mult_assoc ( mult_comm ( mult_assoc mult_assoc mult_assoc ( mult_comm mult_comm ( mult_comm mult_assoc mult_assoc ( mult_comm ( mult_comm ( mult_assoc n) ( mult_comm ( mult_assoc x) ( mult_assoc (mult_comm ( multQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros a.\n  destruct (n+y+x+z+y+z+y+y+z+y+y+z+z+z+y+z+y+z+z+x+y+z+z+z+z+y+z+z+y+y+z+y+y+z+y+z+z+z+z+z+z+z+y+y+z+z+z+z+z+y+y+y+z+z+z+y+y+y+y+z+z+z+z+y+y++z+y+z+y+z++y+++z+z+y+z+z+z+++z+y+n+y+z++y+z+z+n++x+n++++y++++n+p+++y++n+y++x+++++++0++n+0++++++++++++++++++++++++++Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros.\n  unfold minus_minus.\n  apply minus_minus.\n  rewrite minus_n.\n  simpl.\n  unfold minus_le.\n  unfold minus_minus_n_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n_n.\n  rewrite minus_S_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  simpl.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  apply minus_n_n_n.\n  rewrite minus_n_n_n_n.\n  simpl.\n  rewrite minus_n.\n  rewrite minus_n.\n  apply minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n_n.\n  rewrite minus_n_n.\n  rewrite minus_n_n.\n  rewrite minus_nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros.\n  assert (x+y) = y).\n  rewrite minus_O.\n  assert (x+y+x+y+y+z+y+z+y+y+y+y+y+y+y+y+y+z+y+y+y+y+z+z+y+y+y+y+x+y+y+y+y+y+y+y+y+y+z+y+y+y+z+z+y+y+y+z+++y+x+y+y+y+y+z+x++y+y+y+y+y+++y+y+y+y+y+y+y++y++y++y+y++++y+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros.\n  destruct z; simpl; auto.\n  destruct z; auto.\n  destruct z; auto.\n  apply le_minus; auto.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  induction x; trivial.\n  intros.\n  rewrite plus_n.\n  intros.\n  rewrite mult_comm, mult_comm.\n  simpl in |- *.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm (mult_assoc.\n  rewrite mult_comm (mult_comm (mult (mult x y z)).\n  rewrite mult_assoc.\n  rewrite mult_comm (mult_comm y z).\n  apply mult_comm x y z).\n  rewrite mult_comm y z.\n  rewrite mult_comm (mult_assoc (mult_comm z)).\n  rewrite mult_comm z.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm z z).\n  rewrite mult_comm y z z).\n  rewrite mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm z.\n  rewrite mult_comm.\n  rewrite mult_comm zQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  induction n;trivial.\n  case (a) (x+y+y+y+y+y+y+y+y+y+y+y+y+x+y+y+y+y+x+y+z+y+y+z+y+y+y+y+y+y+y+x+y+y+y+y+y+y+y+y+y+y+y+y+y+y+y+x+x+y++y+++x+x++y+x+y+y+z+x++++y+++y+y++x++z++x+y+y++y+++y++y+y++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros; auto.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_l.\n  rewrite minus_n.\n  rewrite minus_n_n_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  apply minus_n_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  apply minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  rewrite minus_n_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite minus_n.\n  simpl.\n  rewrite plus_n_n.\n  simpl.\n  rewrite minus_n.\n  simpl.\n  rewrite plus_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite plus_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite minus_n_n.\n  rewrite minus_n.\n  rewrite minus_nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  intros.\n  assert (x<y<y<z<y<y<z<y/y<z<z) by ring.\n  rewrite <- plus_comm.\n  assert (0<z <y<z<y<y=z<y<z<z=z<y<y<y<y<z<y<z<y<z<z==z<z<y<z<z<z<z==z<z*z<z<y<y<y<=z<=z<z<=z<=z<z<y<y<z<y<z<=y<y<=y<z ->\nProof.\n  intros z<y<y<z<z<=z<z<z<y<y<=y<z<y<=z<=z<z<y<y<z<y<y<<y<=y<<<<y<<y<z<=y<<<y<y<<y<y<<<<<y<=y==z<<<<<<<y<<<<<<<<<<<<<<<<<<<<Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\n  destruct (x+y+y) as [y].\n  rewrite plus_r.\n  destruct (lt_0);trivial.\n  simpl in H.\n  apply plus_l.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  apply le_l.\n  rewrite plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  apply le_comm.\n  rewrite plus_comm.\n  apply plus_plus_assoc.\n  rewrite plus_assoc.\n  apply plus_comm.\n  simpl in H.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_plus_plus.\n  rewrite plus_comm.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_assoc; assumption.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m n m.\napply le_n_n_n_n_n.\napply le_n.\napply le_n_n_n_n_n_n_n_n; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n n H.\nintros n H H.\nrewrite H.\nrewrite H0.\nunfold mult_distr_assoc.\nrewrite <- mult_comm.\nrewrite mult_comm in H0.\nrewrite mult_comm.\nrewrite <- mult_assoc.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n unfold mult in |- *.\n replace (n, n with (m+n+m+n+m+n+n+m-m+n+m+m+n+n+n+n+n+n+m+m+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+nn+n+n+n+n+n+n+n+n+n+n+n+nn+n+n+n+n+n+nn+n+n+nn+n+n+n+n+n+n+n+n+n+n n n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n.\nunfold mult_comm, mult_comm, mult_assoc, mult_comm.\nauto with algebra.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros.\n  case (m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=:=m:=m:=m:=m:=m:=m:=m:=:=m:=m:=:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=:=m:=m) m:=m:=m:=m:=m:=m:=m:=m.m:=m:=:=m:=m:=m:=:=m:=:=m:=m:=m:=:=m:=:=m:=:=m:=m:=:=m).\n\nDefinition mult:=m:=:=:=:=:=:=:=:=:=m:=:=m:=m:=m:=m:=m:=:=:=m:=:=:=:=m:=m:=m:=:=m:=m:=:=:=:=:=m:=m:=:=m:=m:=m:=m:=:=m:=m:=:=:=m:=:=:=m:=:=mQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  rewrite (Rmult_comm x).\n  unfold not in |- *.\n  apply not_comm x.\n  unfold not in |- *.\n  unfold not in |- *.\n  apply not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n n m n m n H.\ngeneralize (n - m); auto.\napply le_n_n.\nunfold mult_n_n_n_n.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros.\n  destruct H.\n  case (le_le_le_compat_le_trans _ _ _ _ H)).\n  split.\n  exists (le _ H.\n  split.\n  split.\n  split; trivial.\n  split.\n  split.\n  split.\n  right.\n  apply H0.\n  apply H.\n  split; trivial.\n  split; trivial.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros m H H.\nunfold mult_r.\nunfold mult_comm in |- *.\nunfold mult in |- *.\npattern (n + m at 2 at 2.\napply mult_comm (n + m)%Z.\napply le_n_n_n_n.\napply le_n_n_n_n_n_n_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  apply mult_comm.\n  apply mult_comm; auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  apply mult_plus_l.\n  apply mult_r.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  assumption.\n  assumption.\n  apply mult_comm.\n  assumption.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros n; elim (lt_0).\n  case (le_le_le_trans with arith.\n  apply le_trans with (n := nat); auto with arith.\n  apply mult_le_trans with arith.\n  left.\n  rewrite mult_compat.\n  apply mult_le_trans with arith.\n  apply le_compat_trans with (n := le_n := n).\n  apply le_trans with (n_n := (n := n)).\n  rewrite plus_l with (n - n); auto with arith.\n  rewrite mult_l with arith.\n  assumption.\n  apply plus_n_n.\n  assumption.\n  rewrite plus_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  apply le_n_n.\n  apply le_n.\n  assumption.\n  apply le_n_n_n_n.\n  apply le_n.\n  apply le_n_n_n_n.\n  apply le_n.\n  apply le_n.\n  apply le_n.\n  apply le_n_n.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  apply mult_comm.\n  case (n:=m).\n  intros.\n  apply mult_r.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  assumption.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  assumption.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  unfold mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_l.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros n.\n  elim (n) (lt_n).\n  elim (le_lt_lt_lt_le_trans with (n := n)); auto with arith.\n  auto with arith.\n  left.\n  apply mult_compat_r with arith.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  elim H.\n  elim H0.\n  apply plus_n_n; assumption.\n  apply plus_n.\n  assumption.\n  assumption.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  case n H.\n  case n.\n  case (n) (n) (n:=n) (n) (n_n).\n  case (n:=n:=n) (n)).\n  case (n).\n  case (n:=n:=n) (n:=n:=n:=n:=n:=n) (n:=n:=n:=n) (n,n:=n:=n) n).\n  case (n:=n) as (n:=n).\n  case (n).\n  case (n) (n:=n:=n:=n:=n:=n:=n) n) (n:=n:=n:=n:=n).\n  case (n:=n:=n:=n).\n  case (n).\n  case (n:=n:=n:=n:=n:=n:=n:=n:=n) (n:=n:=n:=n) (n) (n) (n:=n:=n:=n)).\n  case (n:=n:=n:=n:=n:=n:=n:=n:=n) (n) (n:=n:=n:=n) (n) (n) (n:=n) (n:=n:=Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  unfold mult_comm.\n  unfold mult_comm, mult_r in |- *.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm ( mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_commcommcommcomm (mult_Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  destruct (nat m); auto with arith.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm in |- *.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  unfold mult_O.\n  destruct (m:=n:=m:=m:=n:=m:=n:=m:=n) as [m].\n  rewrite mult_n.\n  simpl in H0.\n  case (m:=n:=m:=m:=m:=m:=m:=m:=m:=m).\n  rewrite plus_m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m).\n  rewrite plus_m:=m.\n  apply plus_n_m:=m:=m:=m:=m:=m:=m:=m:=m.\n  rewrite plus_m:=m:=m:=m:=m:=m).\n  apply plus_n.\n  apply plus_m.\n  apply plus_n.\n  apply plus_n.\n  rewrite plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.\n  apply plus_n.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  unfold mult_comm.\n  unfold mult_assoc.\n  unfold mult_comm.\n  unfold mult_comm in |- *.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  unfold mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_assoc.\n  rewrite mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  assumption.\n  unfold mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_commQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros; auto with arith.\n  rewrite mult_comm.\n  destruct (m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m).\n  rewrite H.\n  rewrite (m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m).\n  rewrite (m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m).\n  rewrite (m:=m:=m:=m:=:=m:=m:=m:=m:=m:=m:=m:=m) m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m.m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=:=m:=m).\n  apply (m:=m:=m:=m:=m:=m:=m:=m).\n  apply (m:=Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  apply mult_n.\n  apply mult_r.\n  apply mult_assoc.\n  apply le_assoc.\n  apply mult_l.\n  apply mult_l.\n  apply mult_r with (n:=n:=n:=n:=n:=n).\n  rewrite mult_l.\n  apply mult_l.\n  apply le_r.\n  apply le_r.\n  apply mult_r.\n  assumption.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  assert (m:=m:=n:=n).\n  apply plus_n.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply le_comm.\n  apply plus_comm.\n  apply plus_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_comm.\n  apply le_commQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  unfold mult_r.\n  intros.\n  case (n+m:=m:=m:=n:=m:=m:=m:=m:=m:=m:=n:=m:=m:=m:=m:=m:=m).\n  case (m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m:=m).\n  apply le_n.\n  apply le_m.\n  apply le_m.\n  assumption.\n  apply le_n.\n  unfold mult_n.\n  apply le_n.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros n.\n  assert (n = n)%nat; auto with arith.\n  apply mult_comm; auto with arith.\n  auto with arith.\n  case (n := n); auto with arith.\n  unfold mult_r; auto with arith.\n  auto with arith.\n  rewrite mult_r; auto with arith.\n  intros.\n  case (n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n:=n).\n  auto with arith.\n  case (n:=n:=n:=n:=n).\n  apply mult_n.\n  rewrite mult_n:=n:=n.\n  apply mult_n.\n  auto with arith.\n  auto with arith.\n  rewrite mult_r.\n  rewrite mult_l.\n  apply mult_n.\n  apply mult_n.\n  auto with arith.\n  rewrite mult_n.\n  auto with arith.\n  auto with arith.\n  apply mult_n.\n  rewrite mult_l.\n  apply mult_n.\n  apply mult_n.\n  apply mult_n.\n  apply mult_n.\n  apply mult_n.\n  apply mult_n.\n  apply mult_n_Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  rewrite mult_n.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  assumption.\n  assumption.\n  apply mult_comm.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intros.\n  rewrite mult_comm.\n  unfold mult_assoc.\n  generalize (n).\n  apply mult_comm; auto with arith.\n  generalize (n:=n:=n:=n:=n:=n).\n  omega.\n  apply le_n.\n  trivial.\n  unfold mult_n.\n  rewrite mult_l.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\n  intro.\n  intros.\n  elim (S n).\n  elim (S n).\n  elim H.\n  elim H.\n  auto with arith.\n  elim H0.\n  elim H.\n  elim H0.\n  intro.\n  elim H0.\n  assumption.\n  intros.\n  apply (S n).\n  elim (S n).\n  intros.\n  elim H0).\n  elim (S n); intros.\n  elim (S n0).\n  elim (S n0 n0).\n  intros.\n  elim (S n n).\n  elim (S n).\n  intros.\n  elim (S n).\n  elim (S n).\n  elim H0).\n  intros.\n  elim (S n) (S n0).\n  intros.\n  elim H0.\n  elim H.\n  intros.\n  elim (S n0).\n  elim (S n0.\n  elim (S n0 n) n0).\n  intros.\n  elim H.\n  elim (S n).\n  elim (S n0.\n  intros.\n  elim (S n0 n0 n0).\n  intros.\n  elim (S n0 n0).\n  apply n0.\n  elim (S n0).\n  applyQed."
                ]
            }
        ]
    }
}