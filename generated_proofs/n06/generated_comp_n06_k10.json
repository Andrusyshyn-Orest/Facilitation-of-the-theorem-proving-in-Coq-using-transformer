{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 8,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "32c2695d0f5f0b6117529f2eaa7f240b95cc42eb",
        "torch_seed": 77
    },

    "projects": {
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply (Build_Map (Ap:=fun x : S => G (Add x y)) (G Add x y)); auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply (Build_Map_eq _ (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W) (W:=W) (W:=W) (W:=W) (W) (W:=W) (W:=W) (W:=W) (W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W:=W) (W) (W:=W) (W:=WQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply Extensionality.\nunfold Add.\nsplit; intros.\napply Extensionality.\nunfold Add.\nsplit; intros.\napply Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.\nunfold Add in H.\nrewrite Extensionality.Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  apply eq_sym.\n  apply (H _ H).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  apply H.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H.\n  apply H.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H4; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros; apply H.\nintros; apply H0.\nintros; apply H1; apply H2; apply H1; apply H2; apply H2; apply H0; apply H2; apply H0; apply H0; apply H1; apply H2; apply H1; apply H2; apply H0; apply H1; apply H; apply H1; apply H0; apply H0; apply H1; apply H1; apply H1; apply H; apply H1; apply H1; apply H0; apply H; apply H0; apply H1; apply H0; apply H; apply H1; apply H1; apply H1; apply H1; apply H; apply H; apply H1; apply H; apply H0; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H;Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nintros x y z; apply Extensionality.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in |- *.\nrewrite <- H1 in H2.\napply H1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 y H1); intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 y1); intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H6; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H10;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H9 x H9); intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H11Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H2 y H1); intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H5 y H0); intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H11; intros; elim H10; intros; elim H12; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x H2); intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\napply (add_assoc _ _ _ _ _ _ _ _ H0).\nrewrite <- (add_assoc _ _ _ _ _ _ H1).\nrewrite <- (add_assoc _ _ _ _ _ _ H1).\nrewrite <- (add_assoc _ _ _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H1).\nrewrite <- (add_assoc _ _ _ _ _ H1).\nrewrite <- (add_assoc _ _ _ _ H1).\nrewrite <- (add_assoc _ _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewrite <- (add_assoc _ _ _ _ H2).\nrewriteQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H3 x y); intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H10;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x H2); intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8;\n clear H4 H8 H9.\n(* use of the same set *)\nelim (H9 x H2); intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n clear H9 H9.\n(* use of the same set *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the same set *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the same set *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the same set *)\nelimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H9 x H2); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n clear H9 H9 H10.\n(* use of the complement *)\nelim (H9 x H2); intros; elim H8; intros; elim H9; intros; elim H9;\n clear H9 H9.\n(* use of the set of the complement *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9; intros; elim H9; intros; elim H10; intros; elim H9Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (ass (Add x y) x y); elim (ass (Add x1 y) x2); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x H1); intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (Add x1 y) x).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass x1 y).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass x1 y).\nrewrite (ass x1 y).\nrewrite (ass x1 y).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass x1 y).\nrewrite (ass x1 y).\nrewrite (ass x1 y).\nrewrite (ass x2 y).\nrewrite (ass x2 y).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass (Add x2 y) y).\nrewrite (ass x1 y).\nrewrite (ass x1 y).\nrewrite (ass x2 y).\nrewrite (ass (Add x1 y) x2 y).\nrewrite (ass x1 y).\nrewrite (ass x2 y).\nrewrite (ass x1 y).\nrewrite (ass x2 y).\nrewrite (ass x1 y).\nrewrite (ass (AddQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H1 y H2); intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H8;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H11; intros; elim H11; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12;\n intros; elim H12; intros; elim H13; intros; elim H12; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H13;\n intros; elim H12; intros; elim H13; intros; elim H12; intros; elim H13;\n intros; elim H13; intros; elim H13; intros; elim HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x H); intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; unfold is_group, Add; simpl.\nrewrite (opp_comm (Add x1 y) x2 y); elim (ass x1 y2); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H1 x H2); intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n clear H4 H5 H6 H7 H8.\n(* use of the opposite *)\nelim (H6 x H2); intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n clear H4 H5 H7 H8.\n(* use of the opposite *)\nelim (H6 x H2); intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n clear H4 H8.\n(* use of the opposite *)\nelim (H6 x H2); intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8.\n(* use of the opposite *)\nelim (H6 x H2); intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n clear HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x H); intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite <- (add_comm x y); rewrite (ass (Add x1 y) x2 y1); elim (ass (Add x1 y1 x2);\n elim (ass (Add x1 y2) y2); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold not in |- *; intro; intro; apply (conj H0 x H).\n(* [x+y] *)\nelim (H3 (Opp x) x y); intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H6; intros; elim H8;\n intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (diff_opp x); assumption.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\n(* [G y] *)\nelim H; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H12; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H11; intros; elim H12; intros; elim H10;\n intros; elim H12; intros; elim H12; intros; elim H13; intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H3; intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold not in |- *; intro; elim H; intros.\n(* [x+y] *)\nelim (H0 (Opp x) x y); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n(* [y = 0] *)\nelim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n (* [y = 0] *)\nelim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n (* [y = 0] *)\nelim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n (* [y = 0] *)\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n (* [y = 0] *)\nelim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n (* [y = 0] *)\nelim H5; intros; elim H6; introsQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Opp x)).\nrewrite <- (Ropp_involutive (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": ". \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold not in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim (H0 x); intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_Fzero in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n clear H2 H2 H3 H4 H5 H6 H7.\n(*  (x-x)+y=x *)\nelim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n elim H3; intros; elim H4; intros; elim H2; intros; elim H4; intros; elim H3;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold not in |- *; split.\nelim H; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim (H x y); intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H9; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elimQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n rewrite H4; rewrite H5.\nrewrite (opp_opp H0 H1).\nrewrite (opp_opp H0).\nrewrite (opp_opp H0).\nrewrite (opp_opp H0).\nrewrite (opp_opp H0).\nrewrite (opp_opp H0).\nrewrite (opp_opp H).\nrewrite (opp_opp H0).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H0).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H0).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).\nrewrite (opp_opp H).Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero_r.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (O:=O)).\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj; apply opp_inj;Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nunfold is_group, Opp, Opp, Sum, Sum, Ar2, Ar2, Sum, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,2, Ar2, Ar2,2, Ar2, Ar2,2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,2, Ar2, Ar2, Ar2, Ar2,2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2, MA2, Ar2, Ar2, Ar2, Ar2, Ar2, Ar2,2, Ar2, Ar2, ArQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_1.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napply opp_eq_0.\napplyQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (Add x) (Add x) (Add y)).\nunfold opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp;\n unfold opp, opp, opp, opp, opp, opp, opp,Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_opp_opp; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n",
                "context_tokens": 44,
                "proof_start_offset": 215,
                "proof_end_offset": 725,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct (Z_zerop b); trivial.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n destruct (Z_lt_dec a b); trivial.\n apply Zle_bool_true.\n apply (Zlt_is_gcd Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_mod Z_modQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n destruct (Z_lt_dec c d).\n left. assumption.\n right. intro. apply H.\n apply Zgt_not_eq. apply Z.lt_gt.\n apply Zgt_not_eq. apply Z.lt_gt.\n apply Zgt_not_eq. apply Z.lt_gt.\n apply Zgt_not_eq. apply Z.lt_gt.\n apply Zgt_not_eq. apply Z.lt_gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq. apply Z.gt.\n apply Zgt_not_eq.\n apply Z.gt.\n apply Zgt_not_eq.\n apply Z.gt.\n apply Zgt_not_eq.\n apply Z.gt.\n apply Zgt_not_eq.\n apply Z.gt.\n apply Zgt_not_eq.\n apply Z.Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d e H0 H1.\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\n apply Z.le_trans with (Zabs (c - d)).\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n destruct (Z_zerop d) as [Ha|Ha].\n rewrite Z.mul_comm.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.quot_pos.\n apply Z.rem_pos.\n apply Z.quot_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_pos.\n apply Z.rem_posQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct (Z_zerop d).\n apply Z.le_lt_dec.\n apply Zgt_not_eq.\n apply (Zlt_le_weak _ _ H).\n apply Zle_not_eq.\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ _ HQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct (Z_zerop b).\n  apply (Z_zerop b).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  apply (Z_zerop d).\n  applyQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n case (Z_zerop b); intro H;\n  [ Falsum | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | idtac ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  | idtac ];\n  [ idtac | Falsum ];\n  | Falsum ];\n  [ idtac | Falsum ];\n  | idtac ];\n  [ idtac | Falsum ];Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H_eq_dec.\n destruct (Z_zerop d).\n   subst.\n   reflexivity.\n   apply gcd_unique with (b := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (b := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcd_unique with (c := (- a)%Z).\n   apply gcdQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct a, b, c, d; simpl; intros.\n destruct (Z_zerop b); simpl; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\nLemma gcd_unicity_apart_sign :\n forall a b c d : Z,\n is_gcd Z IdZ Zmult 0%Z a b c ->\n is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\n",
                "context_tokens": 238,
                "proof_start_offset": 727,
                "proof_end_offset": 1860,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (Z_le_gt_dec 0 b); intros.\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nintros; exact H0.\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nright.\nsplit; auto with zarith.\nexists (-1)%Z; split.\nexact I.\nauto with zarith.\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (- x)%Z.\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\nelim (gcd_unique _ _ H).\n intro.\nleft. elim H1; intros; elim H2; intros; elim H2; intros.\nright; elim H2; intros; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright;Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (gcd_dec Z IdZ (Zabs b) 0); intros.\nleft. elim H1; intros. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H1; intros.\nrewrite H2; auto with zarith.\nright. elim H1; intros; elim H1; intros.\nrewrite H2; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (div_unique Z IdZ (Zabs b) (Zabs b)); intros.\nleft. elim H1; intros; elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nleft. elim H2; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (gcd_unique b); intros.\nleft. elim H1; intros. rewrite H1; auto with zarith.\nright. elim H1; intros. rewrite H2; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H1; intros.\nleft; elim H1; intros; elim H2; intros.\nleft; elim H1; intros.\nleft; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nleft; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H2; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H2; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nright; elim H2; intros.\nright; elim H1; intros.\nright; elim H1; intros.\nrightQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nright.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop b); intros.\nleft.\nelim (gcd_dec Z_zerop bQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (inversibleZ x); intros.\nleft. elim H0; intros; elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nleft. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elim H3; introsQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; introsQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (inversibleZ x); intros.\nright. elim H1; intros; elim H1; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H5; intros.\nright; elim H5; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; intros.\nright; elim H4; introsQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (gcd_dec Z IdZ (Zabs b) (Zabs b)).\nintros.\nleft. elim (inversibleZ y); intros.\nleft. elim (inversibleZ y); intros.\nleft. elim H1; intros; elim H1; intros.\nleft; elim (inversibleZ y); intros.\nleft. elim H1; intros.\nright. elim (inversibleZ y); intros.\nright. elim H1; intros; elim H1; intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nleft. elim H1; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H1; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 2271,
                "proof_end_offset": 2745,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros.\ncase (Z_zerop n); intro.\nunfold P in |- *.\nintro.\nsplit with (Zabs b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (Zdiv_eucl_extended n0 b).\nintro p; elim p; intros q r H0; elim H0; clear p H0; intros.\ncut (Zabs r < Zabs n)%Z; intros.\nelim (H r H2 n).\nintros.\nsplit with x.\napply gcd_mod with q r; trivial.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n; elim (Zabs_nat m); intros.\n apply False_ind; apply H; apply H0.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n m H H0.\nelim H; intros m H1.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nright.\nelim (Zle_or_lt 0 n); intros.\nleft.\nelim (Zle_or_lt 0 n); intros.\nright.\nelim (Zle_or_lt 0 n); intros.\nright.\nelim (Zlt_or_lt 0 n); intros.\nleft.\nelim (Zlt_or_lt 0 n); intros.\nright.\nelim (Zlt_or_lt 0 n); intros.\nright.\nelim (Zlt_or_lt 0 n); intros.\nright.\nelim (Zlt_or_lt 0 n); intros.\nright.\nelim (Zlt_or_lt 0 n); introsQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n m H; generalize (Zabs_eq m); intro.\n generalize (Zabs_eq m); intro.\n case (Z_zerop d); intro.\n intro.\n apply False_ind.\n apply H.\n apply Zlt_trans with (Zabs (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs n) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs m) * Zabs n)%Z.\n apply Zle_trans with (Zabs mQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n; elim (le_gt_dec (Zabs m) 0); intros.\nelim (le_gt_dec (Zabs m) 0); intros.\napply H.\napply False_ind.\napply H.\napply H.\napply H.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n m H; pattern n at 2; case m; auto.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n.\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (lt_trans _ _ (Zabs m)).\n apply (Zabs m).\n apply (lt_trans _ _ (Zabs m)).\n apply (Zabs m).\n apply (lt_trans _ _ (Zabs m)).\n apply (Zabs m).\n apply (lt_trans _ _ (Zabs m)).\n apply (Zabs m).\n apply (lt_trans _ _ (Zabs m)).\n apply Zabs2.\n apply (ltQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n m.\ninduction n.\nsimpl in |- *.\nintros.\nunfold Zabs in |- *.\nrewrite Zabs_eq; auto with zarith.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m - Zabs n)%Z.\napply Zle_trans with (Zabs m -Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n H.\nelim H.\nintros m H H.\napply (fun m H1 m H2 m H3 H4).\napply (fun m H3 H1 m H4 m H4 m H5 H6 H7).\napply (fun m H3 H1 m H4 m H6 H7 m H7 m H7 H8 m H9 H10 m' H10 H11 H12 H12 H13 H13 H15 H15 H15 H16 H17 H17 H18 H19 H20 H21 H22 H22 H23 H23 H24 H24 H25 H25 H24 H26 H26 H27 H26 H28 H27 H29 H29 H30 H29 H28 H29 H29 H29 H29 H31 H31 H31 H31 H31 H31 H33 H34 H34 H35 H35 H35 H35 H35 H35 H35 H35 H36 H35 H37 H36 H35 H37 H35 H35 H35 H35 H37 H37 H35 H37 H35 H35 H36 H35 H37 H35 H35 H37 H37 H37 H37 H37 HQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n H.\napply (fun m : Z => let m := (Z.of_nat m) in n).\napply (fun m : Z => let m := (Z.of_nat m) in n).\napply (fun m : Z => let m := (Z.of_nat m) in n).\napply (fun m : Z => let m := (Z.of_nat m) in n).\napply (fun m : Z => let m' := (Z.of_nat m) in n).\napply (fun m : Z => let m' := (Z.of_nat m') in m).\napply (fun m : Z => let m' := (Z.of_nat m') in n).\napply (fun m : Z => let m' := (Z.of_nat m') in n).\napply (fun m : Z => let m' := (Z.of_nat m') in n).\napply (fun m : Z => let m' := (Z.of_nat m') in n).\napply (fun m : Z => let m' := (Z.of_nat m') in nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n.\ninduction n.\n simpl in |- *.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Qed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2747,
                "proof_end_offset": 2841,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  rewrite e.\n  rewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  case (Z_zerop b); intro.\n  rewrite e.\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_sgn_pos a b).\n  apply (gcd_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  rewrite e. apply (gcd_sgn a b).\n  unfold Z.succ in |- *; intro.\n  elim (Z_zerop b); intro.\n  rewrite e. apply (gcd_sgn a b).\n  intro p; elim p; intros q r H0; elim H0; clear H0; intros.\n  unfold P in |- *; intro.\n  elim (Z_zerop b); intro.\n  rewrite e.\n  apply (gcd_sgn a b).\n  intro p; elim H0; intros q r H0; elim H0; clear H0; intros.\n  unfold P in |- *; intro.\n  elim (Z_zerop b); intro.\n  rewrite e.\n  apply (gcd_sgn a b).\n  intro p; elim H1; intros q r H1; elim H1; clear H1; intros.\n  split with q r H0; auto.\n  split; auto with zarith.\n  unfold P in |- *; intro.\n  elim (Z_zerop b); intro.\n  rewrite e.\n  apply (gcd_sgn a b).\n  intro p; elim H1; intros q r H0; elim HQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  caseQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop a); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_zerop d); intro.\n  rewrite e.\n  split with (Zabs b); [ reflexivity | intros; discriminate ].\n  case (Z_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  rewrite e.\n  apply (gcd_bezout a b a b).\n  intro p; elim p; intros q r H0; elim H0; intros.\n  apply H; assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  apply False_ind.\n  apply (H a).\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  rewrite\n      (Zsgn_16 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n        _ _ _ H1); intros; discriminate.\n  intro H.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d);Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop b); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop b); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop b); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop b); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  (* p = 0 *)\n  intro.\n  case (Z_zerop d); intro.\n  case (Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop a); intro.\n  elim (Z_zerop b); intro.\n  elim H1; intros.\n  rewrite e.\n  apply (gcd_bezout a b c d); auto with zarith.\n  apply (gcd_bezout a b c d); auto with zarith.\n  apply (gcd_bezout a b c d); auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop b); intro.\n  rewrite e.\n  unfold Z.pos.\n  split with (Zabs b).\n  rewrite Zabs_eq; auto with zarith.\n  intro.\n  case (Z_zerop b); intro.\n  rewrite e.\n  unfold Z.pos.\n  split.\n  rewrite Zabs_eq; auto with zarith.\n  intro.\n  rewrite e.\n  unfold Z.pos.\n  split.\n  unfold Zabs in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2843,
                "proof_end_offset": 3586,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros.\nelim H.\nintros.\napply (gcd_OZ_absZ b0).\nclear H a b d; intros.\nunfold is_gcd in |- *.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nsplit.\nexact H4.\nsplit.\nrewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4.\nexact I.\nexact H3.\nintros.\napply (H5 q0).\ncut (r = (a - b * q)%Z); intros.\nrewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  elim (Z_zerop d); intro.\n  elim H0; intros; split.\n  apply (Z_zerop d); intro.\n  elim (Z_zerop d); intro.\n  elim H1; intros; split.\n  apply (Z_zerop d); intro.\n  elim H0; intros; split.\n  apply (Z_zerop d); intro.\n  elim H1; intros; split.\n  apply (Z_zerop d); intro.\n  elim H1; intros; split.\n  apply (Z_zerop d); intro.\n  elim H1; intros; split.\n  apply (Z_zerop d); intro.\n  elim H2; intros; split.\n  apply (Z_zerop d); intro.\n  elim H1; intros; split.\n  apply (Z_zerop d); intro.\n  elim H2; intros; split.\n  apply (Z_zerop d); intro.\n  elim H2; intros; split.\n  apply (Z_zerop d); intro.\n  elim H2; intros; split.\n  apply (Z_zerop d); intro.\n  applyQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d H; case (Z_zerop d); intro.\n  intro; absurd (0 < a)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro; absurd (0 < d)%Z; trivial.\n  intro;Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  [ case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_abs_rec _ _ _ (Z_le_abs_pred _ _ _ H)).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop b); intro. unfold P in |- *. intro.\n  case (Z_zerop d); intro.  unfold P in |- *; intro.\n  apply (Z_zerop d); intro.\n  case (Z_zerop d); intro.  unfold Z_zerop in |- *; intro.\n  rewrite e in H1.\n  case (Z_zerop d); intro.  unfold Z_zerop in |- *; intro.\n  rewrite e in H1.\n  case (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro; rewrite e in H1.\n  case (Z_zerop d); intro.\n  intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.\n  apply (Z_zerop d); intro.Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop b); intro.\n  rewrite e. apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcd_sgn a b).\n  apply (gcdQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  intro.\n  caseQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop a); intro. unfold Z.zerop in |- *.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewriteQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  rewrite e.\n  case (Z_zerop b); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  intro.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  case (Z_zerop d); intro.\n  rewrite e.\n  intro.\n  case (Z_zerop d); intro.\n  rewrite e.Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. apply gcd_nonneg_is_gcd.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3657,
                "proof_end_offset": 3793,
                "proof": "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nelim H. intros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn b); trivial.\nintros.\napply (gcd_sgn b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a); trivial.\nintros.\napply (gcd_sgn b); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nintros.\napply (gcd_sgn a); trivial.\nintros.\napply (gcd_sgn a b); trivial.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nrewrite (gcd_comm a b).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm b a).\nrewrite (gcd_comm bQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nelim H; intros.\napply (gcd_sgn a); auto.\napply gcd_neg.\napply gcd_pos.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.\napply gcd_nonneg.Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop d); intro.\n  rewrite (Z_zerop b); intro.\n  rewrite (Z_zerop b); intro.Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nrewrite <- (gcd_abs_pos a b).\nrewrite (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a b).\nrewrite <- (gcd_abs_pos a bQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout b).\napply (gcd_bezout b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout a b).\napply (gcd_bezout b).\napply (Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nelim H. intros.\nrewrite <- (Z_le_0_r 0).\napply (div_add Z IdZ Zplus Z.abs_nat b).\nexact (Z_le_0_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_l 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexact (Z_le_0_r 0).\nexact (Z_le_r 0).\nexactQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  intros. unfold is_gcd in |- *.\n  elim H. intros. apply (gcd_bezout a b) (gcdZ_for_euclid a b).\n  intro p; elim p; intros q r H0; elim H0; intros.\n  cut (0 < q)%Z; intros.\n  apply (gcd_bezout a b (gcdZ_for_euclid a b) (gcdZ_for_euclid a b) (gcdZ_for_euclid a b)).\n  intro q; elim q; intros q r H0; elim H0; intros.\n  cut (q = (q * r)%Z); [ intros; exists r; intros; auto with zarith | rewrite <- H1; auto with zarith ].\n  rewrite <- (gcd_bezout a b (gcdZ_for_euclid a b) (gcdZ_for_euclid a b) (gcdZ_for_euclid a b)).\n  intro q; elim q; intros q r H0; elim H0; intros.\n  cut (q = (q * r)%Z); intros.\n  apply (gcd_bezout a b (gcdZ_for_euclid a b) (gcdZ_for_euclid a bQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply gcd_Z_is_gcd.\napply gcd_pos.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_0_is_gcd.\napply gcd_Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\ncut (0 < a)%Z; intro.\n2: apply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ H).\napply (gcd_greatest Z_le_abs_rec _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": ",\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3795,
                "proof_end_offset": 3912,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\n intros.\n apply (fun a b : Z => pi2 Z a b) (gcd_Z a b) (gcd_Z a b) (gcd_Z a b)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\ncut (0 <= d)%Z.\nintros.\napply (gcd_bezout a b d H H0).\napply (gcd_bezout a b d H0).\napply (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout a b d H0 H1).\nexact (gcd_bezout b d H0 H1).\nexact (gcdQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H.\nelim H; intros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).\nelim H.\nintros.\napply (gcd_bezout a b d).Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nunfold is_gcd in |- *.\nelim H; clear H; intros.\napply (gcd_bezout a b d); auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (fun a b : Z => a * b)%Z (is_gcd Z a b) (gcdZ_exists a b)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z b d) (gcd_is_gcd Z a b)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z a b) (gcd_is_gcd Z a b) (gcd_is_gcd Z b d)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z b d).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z a b) (gcd_is_gcd Z b d)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z b d) (gcd_is_gcd Z a b)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z b d) (gcd_is_gcd Z b d)).\nrewrite (fun a b : Z => a * b)%Z (is_gcd Z b d) (gcd_is_gcdQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.le_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.le_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.le_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.lt_le_0_compat.\napply Z.le_le_0_Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nexact (fun a b : Z => pi2 Z a (is_gcdZ a b) (gcdZ_exists a b)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (fun a b : Z => a = b); trivial.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (fun p q => p * q * q)%Z).\napply (fun p q => p * q * p)%Z).\napply (fun p q => q * p * q)%Z).\napply (fun p q => q * p * q)%Z).\napply (fun p q => p * q * q)%Z).\napply (fun p q => p * q * q)%Z).\napply (fun p q => q * p * q)%Z).\napply (fun p q => q * p * q)%Z).\napply (fun p q => p * q * q)%Z).\napply (fun p q => p * q * q)%Z).\napply (fun p q => p * q * q)%Z).\napply (fun p q => q * q)%Z).\napply (fun p q => q * q * q)%Z).\napply (fun p q => q * q * p)%Z).\napply (fun p q => q * p * q)%Z).\napply (fun p q => q * q * q)%Z).\napply (fun p q => q * p * qQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\n intros.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n apply (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n assumption.\n intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n apply (Z_zerop d); intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n intro.\n rewrite e.\n case (Z_zerop d); intro.\n rewrite e.\n intro.\n apply (H1 k).\n rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 3914,
                "proof_end_offset": 4352,
                "proof": "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b d H; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b d; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b d H; elim H; intros.\nabsurd (0 <= d)%Z; trivial.\ngeneralize (Z_lt_O_eq (a - b) (c - d)) H0); intro H1.\nrewrite H1; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 4354,
                "proof_end_offset": 4506,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_refl a b d (gcdZ_is_gcd a b d H)).\nintros; apply gcdZ_is_gcd_Z.\nexact (fun a b : Z => gcd a b d (gcdZ_is_gcd a b d H)).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_dec a b d (gcd_Z a b d H) (gcd_Z_is_gcd a b d H0)).\nintros; apply H.\nrewrite <- (gcd_0_l d).\napply (gcd_is_gcd a b d H) in H.\napply gcd_is_gcd_Z.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_sym a b d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd a b d H)).\nintros; exact H0.\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq; rewrite eq; rewrite eq; rewrite eq; rewrite eq; rewrite eq;\n rewrite eq; rewrite eq; rewrite eq; rewrite eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nrewrite <- (gcd_Zabs_eq _ _ H).\nrewrite <- (gcd_Zabs_eq _ _ H).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).\napply (gcd_is_gcd_Z a b d H0).Qed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nintros; absurd (0 <= d)%Z; auto with zarith.\napply (gcd_is_gcdZ a b d H0 H0).\napply (gcd_is_gcdZ a b d H0 H1).\napply (gcd_is_gcd_Z a b d H H0).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d H0 H1).\napply (gcd_is_gcd_Z a b d HQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_bezout a b d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd a b d H)).\nintros; rewrite H0; rewrite <- gcdZ_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_is_gcd.\nrepeat rewrite <- gcd_Z_isQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_unique_apart_sign a b d (gcdZ_is_gcd a b d H) (gcd_Z_is_gcd a b d H)).\nintros; apply gcd_0; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply gcd_nonneg; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 4508,
                "proof_end_offset": 4744,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim\n (gcd_bezout a b c d (gcdZ_is_gcd a b c d H) (gcd_Z_is_gcd a b c d H)).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H H0).\nintros; apply (unique_is_gcd_Z a b c d H H).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros; apply (unique_is_gcd_Z a b c d H0).\nintros;Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H0 H1 H2; elim H1; intros.\napply (gcd_antisym a b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (gcd_antisym b b); trivial.\napply (Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nunfold gcd in |- *.\nelim H; intros.\ngeneralize (gcd_bezout a b c d (gcd_Z a b) (gcd_Z_is_gcd a b c H0)).\nintros; rewrite <- H1; auto with zarith.\nintros.\nunfold gcd in |- *.\nelim H0; intros.\ngeneralize (gcd_bezout a b c d (gcd_Z_is_gcd a b c H0) (gcd_Z_is_gcd a b c H0)).\nintros; rewrite <- H1; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim (gcd_unique_apart_sign a b c d (gcdZ_is_gcd a b d H) (gcd_Z_is_gcd a b d H)).\nintros H1.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H1).\nexact H1.\nintros H2 H3.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H2).\nexact H1.\nintros H3.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H2).\nexact H2.\nintros H3.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H3).\nexact H3.\nintros H4.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H3).\nexact H4.\nintros H4.\napply (gcd_greatest_apart_sign a b c d (gcd_Z a b) H2).\nexact H4.\nintros H5.Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nrewrite (abs_pos b) in H.\nelim (gcd_dec a b q).\nintros; apply (Zabs_pos b); auto with zarith.\nintros; apply (Zabs_pos b); auto with zarith.\nintros; apply (Zabs_pos b); auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H0 H1 H2; case (gcd_dec a b q); intros H3;\n [ idtac | exists (a - q)%Z; auto with zarith ].\nrewrite (gcd_1 _ H2) in H3; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\napply (gcd_unique b q r); auto with zarith.\nintros.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; auto with zarith.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H; auto with zarith.\napply gcd_sym.\napply gcd_sym.\nrewrite H0; auto with zarith.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; auto with zarith.\nintros.\nelim H0; auto with zarith.\nintros.\nelim H0; auto with zarith.\nintros.\nelim H1; auto with zarith.\nintros.\nelim H1; auto with zarith.\nintros.\nelim H1; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H1; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H1; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros.\nelim H2; auto with zarith.\nintros; elim H2; auto with zarith.\nintros; elim H2; auto with zarith.\nintros.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unicity_is_gcdZ b (gcd a b) q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd a b q r H0).\napply (unicity_is_gcd b q r H0).\napply (unicity_is_gcd b q r H0).\napply (unicity_is_gcd a q r H0).\napply (unicity_is_gcd aQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4939,
                "proof_end_offset": 5677,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros q f.\nelim (Z_zerop q); intro e.\nunfold Q in |- *; intro b.\nsplit with 1%Z (Zsgn b).\nrewrite e.\nsimpl in |- *.\nrewrite (Zsgn_Zabs b).\napply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (Zdiv_eucl_extended e b).\nintro p; elim p; clear p.\nintros div r; intros.\ncut (Zabs r < Zabs q)%Z; intros.\nelim (f r H q).\nintros.\nsplit with (v + - (div * u))%Z u.\nelim p.\nintros.\nelim H1.\nintros.\nintros.\npattern b at 1 in |- *.\nrewrite H0; auto with zarith.\nrewrite <- (gcd_modZ b q div r); auto with zarith.\nrewrite <- e0.\nring.\nelim p; intros; elim H0; intros.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (K:=K)).\napply (Build_G (KQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ndestruct (non_gcd_Z a b) as [q|q].\nintros m; unfold Q; unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold Q; simpl in |- *;\n  unfold QQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nelim H; intros m H0; intros m H1.\nelim H1; intros m H2.\nelim H2; intros m H3; intros m H4; elim H3; intros m H4.\nelim H3; intros m H4; elim H4; intros m H5.\nelim H5; intros m H5; elim H5; intros m H5.\nelim H6; intros m H6; elim H7; intros m H6.\nelim H7; intros m H6; elim H7; intros m H7.\nelim H8; intros m H7; elim H8; intros m H8.\nelim H9; intros m H8; elim H8; intros m H9.\nelim H9; intros m H9; elim H9; intros m H9.\nelim H9; intros m H9; elim H9; intros m' H10.\nelim H9; intros m' H10; elim H10; intros m' H11.\nelim H11; intros m' H11; elim H11; intros m' H11.\nelim H11; intros mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ndestruct n; destruct n; destruct n; destruct m; simpl in *; trivial.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nassert (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q m).\nintros.\nassert (forall m : Z, (Zabs m < Zabs m)%Z -> Q m).\nintro.\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : Z => (m * q + r)%Z)).\napply (Build_K (fun m : ZQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (Build_A:=fun n m : Z => forall q : Z, (m <= q)%Z -> Q m) -> Q m.\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m) -> Q m.\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m) -> Q m.\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m).\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m) -> Q m.\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m) -> Q m.\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (m <= q)%Z -> Q m).\nintros.\napply (Build_A:=fun m : Z => forall q : Z, (mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q in |- *.\nunfold Q inQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (Build_F _ _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q m.\nintros.\napply (Build_F _ _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q m).\nintros.\napply (Build_F _ _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q m).\nintros.\napply (Build_F _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q m).\nintros.\napply (Build_F _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m)).\nintros.\napply (Build_F _ _ (fun m : Z => forall m : Z, (Zabs m <= Zabs m)%Z -> Q m).\nintros.\napply (Build_F _ _ (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m) ->Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nassert (forall m : Z, (m < Zabs n)%Z -> Q m) by (intros; elim H; clear H; intros m H0; elim H0; clear H0; intros m H1; elim H1; clear H1;\n intros m H2; elim H2; clear H2; intros m H3; elim H3; clear H2; intros m H4; elim H3; clear H3;\n intros m H4; elim H4; clear H4; intros m H4; elim H4; clear H4;\n intros m H5; elim H4; clear H4; intros m H4; elim H4; clear H4;\n intros m H5; elim H4; clear H4; intros m H4; elim H5; clear H5;\n intros m H5; elim H4; clear H4; intros m H5; elim H5; clear H5;\n intros m H5; elim H5; clear H5; intros m H5; elim H5; clear H5;\n intros m H5; elim H5; clear H5; intros m H5; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5679,
                "proof_end_offset": 5780,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros; apply (Build_K (a * b)).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros.\n apply (Build_ Check_8_10_10_11_11_11_11_11_10_11_11_11_12_13_14\n  (Build_ Check_8_11_11_13_11_13_14_14_15_16_16_16_16_16_17_16_16_16_17_17_16_16_16_17_16_16_16_17_16_17_16_16_16_16_16_16_16_17_18_17_16_16_16_17_17_17_16_18_16_16_16_18_16_16_16_17_16_17_18_16_16_18_16_16_16_18_16_17_18_16_17_18_16_16_16_16_18_19_16_17_16_19_16_16_16_17_18_18_16_19_16_18_16_16_18_16_18_18_19_16_19_16_20_16_Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros.\n apply (Build_extensionnalite; intro; intro; discriminate.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b.\n destruct a as [b|b]; trivial.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros; unfold Q in |- *; intro b.\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (Build_K (K := K_is_gcd a b)).\n  apply (BuildQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b.\n elim (Zgcd_div_mod a b); intro e.\n exists (Zabs a * b)%Z.\n intros. elim (Zgcd_div_mod a b); intro e.\n exists (Zabs b * b)%Z.\n intros.\n elim H. intros.\n split with (Zabs b * a).\n apply H1.\n rewrite (Zabs_eq a).\n apply Z_is_gcd_Zdiv.\n rewrite <- e. simpl in |- *. rewrite (Zsgn_Zabs b).\n apply (gcd_is_gcd_Z 0 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1 b).\n apply (gcd_is_gcd_Z 1Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros a b.\n elim (gcd_mod a b). intro p; elim (gcd_mod a b). intro p; elim p; clear p.\n intros. pattern b at 1 in |- *.\n apply (gcd_mod a b); auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros a b.\nelim (Zgcd_is_gcd_is_gcd a b); intro e.\nelim e.\n intros.\n elim H; intros.\n rewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b.\n elim (star_prime_dec a b).\n intro eq; rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq in H; rewrite eq in H;\n  rewrite eq in H; rewrite eq in H; rewrite eq inQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  elim (Zgcd_is_gcd_Z a b). intro p; elim p; clear p.\n  intros.\n  elim (Zgcd_is_gcd_Z a b); intro p; elim p; clear p.\n  intros.\n  elim (Zgcd_is_gcd_Z a b); intro p; elim p; clear p.\n  intros.\n  elim (Zgcd_is_gcd_Z a b); intro p; elim p; clear p.\n  intros.\n  elim H1; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (gcd_is_gcd_Z b); auto with zarith.\n  apply (gcd_is_gcd_Z a b); auto with zarith.\n  apply (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 5858,
                "proof_end_offset": 6105,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_le_abs_rec _ _ (Z_abs_rec _ _ (Z_le_abs_rec _ _ (Z_abs_rec _ _ (Z_le_abs_rec _ _ (Z_abs_rec _ (Z_abs_rec _ _ (Z_abs_rec _ _ (Z_abs_rec _ _ (Z_le_abs_aux _ _ (Z_abs_rec _ _ (Z_abs_aux _ (Z_abs_rec _ _ (Z_abs_aux _ (Z_abs_rec _ (Z_abs_rec _ _ (Z_abs_aux _ (ZQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ x).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ _ H).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ H).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n  exact (Z_lt_abs_rec _ _ x).\n Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ H).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_self.\napply divide_Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_le_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_le_abs_aux _ _ _ (Z_le_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_le_abs_aux _ _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ _ (Z_Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_rec _ _ (Z_abs_rec _ _ _ _ (Z_lt_abs_rec _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ (Z_lt_abs_aux _ _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ (Z_lt_abs_aux _ _ (Z_abs_aux _ _ (Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  apply (Z_lt_is_gcd_pos x (Z_of_nat x) (Z_of_nat y)).\n  rewrite <- (Z_is_gcd_mult x (Z_of_nat x)) at 2.\n  apply (Z_lt_is_gcd_pos x (Z_of_nat y)).\n  rewrite <- (Z_is_gcd_mult x (Z_of_nat y)).\n  apply (Z_lt_is_gcd_pos x (Z_of_nat y)).\n  rewrite <- (Z_is_gcd_mult x (Z_of_nat y)).\n  apply (Z_lt_is_gcd_pos x (Z_of_nat y)).\n  rewrite <- (Z_is_gcd_mult_r x (Z_of_nat y)).\n  apply (Z_lt_is_gcd_pos x (Z_of_nat y)).\n  rewrite <- (Z_is_gcd_mult_r x (Z_of_nat y)).\n  apply (Z_lt_is_gcd_pos x (Z_of_nat y)).\n  rewrite <- (Z_is_gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\nLemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (Z_zerop x); intros. left; exact a.\nright; split. exact b. exists 1%Z. split. exact I. auto with zarith.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6107,
                "proof_end_offset": 7147,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (x * (b * v) + y * (a * u))%Z.\nunfold congruentZ in |- *; split.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - x)%Z with (a * (u * (y - x)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop a); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (u * (y - x))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (b * v)%Z with (1 + - (a * u))%Z; auto with zarith.\nring.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - y)%Z with (b * (v * (x - y)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (v * (x - y))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (a * u)%Z with (1 + - (b * v))%Z; auto with zarith.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros. unfold congruentZ in |- *. split. exact I.\n elim (Z_zerop x); intros. left; exact I.\nelim (Z_zerop x); intros. right; exact I.\nelim (Z_zerop x); intros.\n intro. left; exact I.\nelim (Z_zerop x); intros.\n intro. right; exact I.\nelim (Z_zerop x); intros.\n intro. right; exact I.\nelim (Z_zerop x); intros.\n intro. right; exact I.\nelim (Z_zerop x); intros.\n intro.\n right; exact I.\nelim (Z_zerop x); intros.\n intro.\n right; exact I.\nelim (Z_zerop x); intros.\n intro.\n left; exact I.\nelim (Z_zerop x); intros.\n intro.\n right; exact I.\nelim (Z_zerop x); intros.\n intro.\n left; exact I.\nelim (Z_zerop x); intros.\n intro.\n right; exact I.\nelim (Z_zerop x); intros.\n intro.\n right; exact I.\nelim (ZQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y z.\n elim (Z_zerop x); intros.\n exists (Z_zerop y); split. exact I.\n elim (Z_zerop y); intros.\n exists (Z_zerop y); split. exact I.\n apply (Z_zerop x); split. exact I.\n apply (Z_zerop y); split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y H.\n assert (H : 0 <= x * y * y * z) by ring.\n apply Zlt_le_weak.\n apply (Z_lt_is_gcd_pos a b x H).\n rewrite H.\n apply Z_lt_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ.\n rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ. rewrite <- H.\n apply Z_le_succ.\n apply Z_succ. rewrite <- HQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\napply (Z_lt_abs_rec _ _ _ H).\nintros x.\nunfold Zminus in |- *.\nrewrite (Zmult_comm (-1)).\napply (Z_lt_reg_r (a + - y)); auto with zarith.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros. unfold Euclid.\n assert (a = b); [ intro; discriminate | intro; discriminate ].\n case (Z_zerop a); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nunfold gcd in |- *.\nrewrite (Z_is_gcd_is_gcd_r a b); auto with zarith.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold Bezout in |- *. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros. unfold gcd in |- *. split. exact I.\nelim (Z_zerop x); intros. left; exact I.\nelim (Z_zerop y); intros.\nleft; split. exact I.\nelim (Z_zerop y); intros.\nleft; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nleft; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); intros.\nright; split. exact I.\nelim (Z_zerop y); introsQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros. unfold gcd in |- *. split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\n elim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop x); intros.\n split. exact I.\nelim (Z_zerop y); intros.\n split. exact I.Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfolddvd in |- *. split. exact I. split. exact I.\nelim (Z_zerop x); intros.\n  exists 1%Z. intros. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq. rewrite Z_div_eucl_eq.\n  rewrite Z_div_eucl_eq. rewrite Z_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\ndestruct x.\nnow rewrite Z_minus.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nnow apply Z.quot_eq.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\napply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\ndestruct (Z_eq_dec x 0) as [H|H].\nunfold Z.modulo.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.mod_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_l.\nrewrite Z.modulo_plus_distr_r.\nrewrite Z.modulo_plus_distr_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  apply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\napply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg x).\nrewrite (Z.abs_neg xQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros.\nrewrite Z_div_neg_eq.\napply Z_div_pos.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x; destruct x; simpl; try discriminate.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n unfold Z.abs.\n now rewrite Z.mul_comm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nred in |- *; auto with zarith.\nintros p; elim p; simpl in |- *; auto with zarith.\nintros p; elim p; simpl in |- *; auto with zarith.\nintros p; elim p; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintro.\nrewrite <- Z_group.\napply Z_ring.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Z_unit in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nintros.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nunfold Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit.\nintros.\napply Z_unitary_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_revQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\napply Z_unitary_commutative_ring.\nred in |- *; auto with zarith.\nsplit.\nexact Z_unitary_rev_ring.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Z_unit, inj in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ ; simpl in |- *.\nintros.\nunfold IdZ in |- *.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 1); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_eq 0 0); intro.\ngeneralize (Z_div_mod_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integheless in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integbMoreThanOne.\nrepeat rewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ ; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ,*)\nintros; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integRo in |- *.\nunfold integRo in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integang in |- *.\nunfold integangQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ DECLARE in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *.\nsplit; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integverif_mult; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold Integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold Integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold integerbenz in |- *.\nunfold IntegerbenzQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ }+{ in |- *; simpl in |- *.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nunfold IdZ in |- *.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim a.\n(* succ n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right; discriminate.\n(* succ n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right; discriminate.\n(* succ n *)\nintros; right; discriminate.\n(* succ n *)\nintros; right; discriminate.\n(* succ n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* succ n *)\nintros; right.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clearQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clearQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x; intro; apply inversibleZ; trivial.\nintros; right.\ngeneralize (Z_div_div_mod_eq x 0); intro; apply inversibleZ; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right; generalize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim a.\n(*... *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; trivial.\n(* Case 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* Case 0 *)\nintros; left.\ngeneralize H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold is_zero in |- *; intros; apply inversibleZ.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; introsQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; right; apply Z_div_mult; auto with zarith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim a.\n(* 0 *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* a < 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* - a < 0 *)\nintros; right.\ngeneralize H; clear H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n",
                "context_tokens": 187,
                "proof_start_offset": 546,
                "proof_end_offset": 679,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply add_lt_mono_l with (Add x (Add x (Add x (Add x (Add x (Add x (Add x (Add x (Add x y)))) x))); auto with algebra.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply Add_Add; auto.\napply Add_Add; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply Add_0 with (Add 1 1).\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; auto.\nrewrite Add_add; autoQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\nassert (Add (Add x (Add x y)) (Add (Add x y)) (Add (Add x y)) (Add x y)).\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply add_add; auto.\napply addQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nmove=> S; apply: (@add_0_r _ _ S); rewrite?add_add; move/IH=> x y;\nby move/IH=> x y; rewrite!add_add; move/IH=> x y; rewrite!add_add; move/IH=> y; rewrite!add_add; move/IH=> x y;\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\nrewrite (add_comm H).\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\napply add_comm; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y H.\n  apply (Add_add O); auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\ninduction 1.\nreflexivity.\nreflexivity.\nreflexivity.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y; rewrite Add_Add, Add_Add.\n  rewrite Add_Add, Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add; rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add; rewrite Add_Add.\n  rewrite Add_Add.\n  rewrite Add_Add; rewrite Add_Add; rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Add;\n  rewrite Add_Add; rewrite Add_Add;\n  rewrite Add_Qed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply Add_add; intros.\nrewrite <- H0; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; apply add_assoc; applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\nLemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n",
                "context_tokens": 267,
                "proof_start_offset": 760,
                "proof_end_offset": 981,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim (H0 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H5;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6;Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply opp_com.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H x y H1 H2; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elimQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply opp_com; assumption.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y; elim (H0 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim (H0 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H11; intros; elim H9; intros; elim H11;\n intros; elim H10; intros; elim H10; intros; elim H12; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim HQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nelim H; intros; elim (H1 O H0); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n",
                "context_tokens": 114,
                "proof_start_offset": 397,
                "proof_end_offset": 1206,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H.\nunfold is_ring.\napply mult_O_O.\napply mult_O_O.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_O_r.\napply mult_OQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim (eq_nat_dec x 0).\nintros.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H4.\nrewrite H1.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros.\n  elim (eq_nat_dec (S x) 0).\n  intros.\n  elim (eq_nat_dec (S x) 0).\n  intros.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x; elim (mult_comm x x); intro H1; elim H1; clear H1; intros H2.\nexists x; split; auto.\nunfold Mult.\napply plus_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n; auto with arith.\nunfold Mult.\napply mult_O_n;Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros.\n  unfold is_ring.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not in |- *.\n  unfold not inQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros.\n  unfold is_ring.\n  elim H; intro.\n  apply H; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim (le_gt_dec (S x) (S x)).\nintro.\napply H1.\napply H2.\napply H3.\napply H1.\napply H3.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\napply minus_O_O.\nunfold mult_O_O_n.\nunfold mult_O_m in |- *.\nsimpl in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_m in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfold mult_O_n in |- *.\nsimpl in |- *.\nunfoldQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nunfold is_ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n",
                "context_tokens": 463,
                "proof_start_offset": 1208,
                "proof_end_offset": 1952,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (H0 O x); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H1; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nintros.\nunfold is_ring.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nunfold is_ring.\nelim (div_eucl_l S A (Mult x y) O (H0 O H1)).\nelim (div_eucl_l S A (Mult x y) O (H1 O H0)); intros; elim H5.\napply (div_eucl_l S A (Mult x y) O (H1 O H1)).\nelim (div_eucl_l S A (Mult x y) O (H2 O H1)).\nelim (div_eucl_l S A (Mult x y) O (H2 O H5)).\nintros; rewrite H2.\nelim (div_eucl_l S A (Mult x y) O (H2 O H5)).\nintros; rewrite H2.\nelim (div_eucl_r S A (Mult x y) O (H2 O H5)).\nintros; rewrite H2.\nelim (div_eucl_l S A (Mult x y) O (H2 O H6)).\nintros; rewrite H4.\nelim (div_eucl_l S A (Mult x y) O (H2 O H5)).\nintros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nunfold is_ring.\nelim H; intros; elim H; intros; elim H0; intros.\nclear H0; elim (H1 O x); intros; elim H1; intros.\nclear H1; elim (H2 O x); intros; elim H2; intros.\nclear H2; elim H3; intros.\nclear H2; elim (H1 O x); intros; elim H2; intros.\nclear H2; elim (H2 O x); intros; elim H2; intros; elim H2; intros.\nclear H2; elim (H3 O x); intros; elim H3; intros.\nclear H2; elim (H1 O x); intros; elim H3; intros.\nclear H3; elim (H1 O x); intros; elim H3; intros.\nclear H4; elim (H1 O x); intros; elim H3; intros.\nclear H2; elim (H1 O x); intros; elim H3; intros.\nclear H3; elim (H1 O x); intros; elim H3; intros.\nclear H4; elim (H3 OQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n",
                "context_tokens": 721,
                "proof_start_offset": 1954,
                "proof_end_offset": 2696,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H1; intros; elim H2; intros; elim H6; intros; elim H6; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H6; intros; elim H6;\n intros; elim H1; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim (prod_assoc_r S A Opp (Mult x y) (Ar x y)); intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H7;\n intros;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim (prod_sum A O Opp (Mult x y) O (H x O H0 H1)).\nelim (prod_sum A O Opp (Mult x y) O (H x O H1)).\nelim (prod_sum A O Opp (Mult x y) O (H x O H1)).\nintros; elim H4; intros; elim H5; intros.\nclear H4 H5 H5 H6 H7 H8 H9 H10 H11.\nexists x; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x y H1).\nsplit.\nexact (H8 x y H1).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H3).\nsplit.\nexact (H8 x y H0).\nsplit.\nexact (H8 x y H0).\nsplit.\nexact (H8 x y H1).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 xQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2698,
                "proof_end_offset": 3190,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H4; intros; elim H4; intros.\nrewrite H0; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim (mult_opp_l (A:=A) (B:=A)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x y H1).\nsplit.\nexact (H8 x y H1).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplit.\nexact (H8 x y H2).\nsplitQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros;\n rewrite H0; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nrewrite (opp_involutive (S x)).\napply sym_equal.\nexact (H0 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.\nexact (H3 x y H0).\nsplit.\nexact (H1 x y H0).\nsplit.\nexact (H2 x y H0).\nsplit.Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elimQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H7; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nrewrite (mult_opp_l (A:=A) (B:=B) (B:=B) (B:=A) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B) (B:=B) (B:=B) (B:=B) (B:=B) (B)Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim (prod_assoc_opp A (Mult x y) x y); intros; rewrite H; auto.\nelim (prod_assoc_opp A (Mult x y) x y); intros; rewrite H; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3490,
                "proof_end_offset": 3729,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nunfold is_power in |- *.\nintros.\nelim (mult_O_O_O_O _ H).\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim H3; intros; elim H3; intros; elim H4; intros.\nelim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros.\nelim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros.\nelim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H11; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elimQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\ntrivial.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro.\nrewrite <- (div_0_l O).\ntrivial.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H.\nunfold is_power in |- *.\nsplit; intros.\napply H; assumption.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H H0.\napply le_antisym.\napply le_trans with (S a).\napply le_trans with (S a).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S b).\napply le_trans with (S bQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nintro H.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nsplit.\nexact (div_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H H H0; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H8;\n intros; elim H10; intros; elim H9; intros; elim H10; intros; elim H8;\n intros; elim H11; intros; elim H10; intros; elim H9;\n intros;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nunfold is_power in |- *.\nintuition.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_empty in |- *.\nintros a b H.\ndestruct (O_or_lt (O_or_lt 0 (S a) (S b)) (S b)).\nintro H.\napply (div_O_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (S b)).\napply (div_O_or_lt 0 (S b) (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3731,
                "proof_end_offset": 4957,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nrewrite <- (div_0_l a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_r a b) in |- *.\nrewrite (div_0_l a b) in |- *.\nrewrite (div_r a b) in |- *.\nrewrite (div_0_r a b) in H.\nrewrite (div_l a b) in H.\nrewrite (div_0_l a b) in H.\nrewrite (div_l a b) in H.\nrewrite (div_0_l a b) in H.\nrewrite (div_r a b) in H.\nrewrite (div_0_l a b) in H.\nrewrite (div_r_r a b) in H.\nrewrite (div_r a b) in H.\nrewrite (div_0_r aQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H.\nrewrite (mult_comm a d H).\nrewrite (mult_comm b d H).\nrewrite (mult_comm d H).\nrewrite (mult_comm a d H).\nrewrite (mult_comm d H).\nrewrite (mult_comm a d H).\nrewrite (mult_comm d H).\nrewrite (mult_comm a d H).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm a d H).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_comm (S d H)).\nrewrite (mult_Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nrewrite <- (div_opp a b).\napply gcd_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.\nexact div_opp_r.Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nunfold divide in |- *.\nelim H; intros; elim H1; intros; elim H1; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplit.\nexact H10.\nsplitQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H1; intros; elim H2; intros; elim H2; intros.\nelim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros.\nelim H3; intros; elim H3; intros; elim H4; intros.\nelim H4; intros; elim H3; intros; elim H4; intros.\nelim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros.\nelim H4; intros; elim H5; intros; elim H4; intros; elim H4; intros.\nelim H4; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros.\nelim H6; intros; elim H5; intros; elim H6; intros.\nelim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; introsQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H4; intros.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H12.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exactQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [A d] *)\nelim H0; trivial.\nsplit.\n(* [A (a+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 4959,
                "proof_end_offset": 5659,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d.\nunfold divide in |- *; intros.\nsplit.\n(* [a] *)\nelim H; intros; elim H0; intros; elim H1; intros.\nsplit.\nexact (H0 a b H1).\n(* [a] *)\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_power in |- *.\nintros a b d H H0 H1 H2.\nelim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elimQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_ring.\nintros a b d H.\nrewrite <- (mult_comm a b).\napply Zmult_le_compat_l.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_l.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_l.\napply Zmult_le_compat_r.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_r.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.\napply Zmult_le_compat_l.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0 H1.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H8;\n introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_ring.\nintro; elim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_power in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; clear H0.\nelim H0; intros; elim H0; intros; clear H0.\nelim H1; intros; elim H1; intros; elim H2; intros; clear H1.\nelim H1; intros; elim H2; intros; clear H1.\nelim H1; intros; elim H2; intros; elim H2; intros; clear H2.\nelim H1; intros; elim H2; intros; clear H1.\nelim H1; intros; elim H2; intros; clear H2.\nelim H1; intros; clear H1.\nelim H1; intros; elim H2; intros; clear H2.\nelim H1; intros; elim H2; intros; clear H2.\nelim H1; intros; clear H1.\nelim H1; intros; elim H2; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; elim H2; intros; clear H1.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H2; intros; elim H3;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [a] *)\nelim H; intros; elim H0; intros; elim H2; intros; elim H2; intros; elim H4; intros.\nelim H2; intros; elim H4; intros; elim H4; intros.\nelim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros.\nsplit.\nexact H2.\n(* [a = 0] *)\nelim H2; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros.\nsplit.\nexact H1.\n(* [a = 0] *)\nelim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_ring.\nintros.\nunfold is_zero in |- *; intro.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H8;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_ring.\nintros a b d H H0 H1.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 5661,
                "proof_end_offset": 6477,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros; elim H; intros; elim H; intros.\nclear H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *.\nintros.\nsplit.\nexact (H0 a H). \nexact (H1 a H0 H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold is_ring.\nintros; elim H; intros.\nsplit.\nexact (H a H). \napply div_opp.\nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0).\nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0). \nexact (H a H0Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; intros.\nunfold divide in |- *.\nelim H; introsQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros; elim H; intros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nsplit.\nexact (H4 a b H0 H1).\nrewrite (H4 d x b).\nelim H3; intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H2); intros.\nrewrite H1.\nelim (mult_O H b H1); intros.\nrewrite H2.\nelim (mult_O H b H1); intros.\nrewrite H1.\nelim (mult_O H b H2Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros.\nelim H; intros.\nelim H; intros.\nsplit.\nexact (H1 a b H0 H1).\nrewrite (H2 (H d x)).\nelim H0; intros.\nsplit.\nexact (H1 d x H1).\nrewrite (H2 (H d x)).\nelim H0; intros.\nsplit.\nexact (H1 d x).\nrewrite (H2 (H d x)).\nrewrite (H2 d x).\nelim H0; intros.\nsplit.\nexact (H1 d x H1).\nrewrite (H2 d x).\nelim H1; intros.\nsplit.\nexact (H2 d x H0).\nrewrite (H2 d x).\nelim H1; intros.\nsplit.\nexact (H2 d x H1).\nrewrite (H d x).\nelim H0; intros.\nsplit.\nexact (H1 d x H1).\nrewrite (H2 d x).\nrewrite (H1 d x).\nelim H1; intros.\nsplit.\nexact (H2 d x).\nrewriteQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold is_ring; intros.\nelim H; intros.\nrewrite H0.\nelim (mult_O_O H); intros.\nsplit.\nexact (H2 a b H0 H1). \nelim H1; intros.\nrewrite H1.\nelim (mult_O_O H).\nexact (H2 a b H0 H1). \nexact (H2 a b H1). \nexact (H2 a b H1).\nexact (H2 a b H1). \nexact (H2 a b H1).\nexact (H2 a b H2). \nexact (H2 a b H1). \nexact (H2 a b H1). \nexact (H2 a b H1). \nexact (H2 a b H1). \nexact (H3 b H2). \nexact (H3 a b H1). \nexact (H3 a b H1). \nexact (H2 a b H2). \nexact (H3 a b H1). \nexact (H4 a b H1). \nexact (H1 b H2).Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d.\nunfold divide in |- *.\nelim H; intros.\nsplit.\nexact (H a b H0 H1).\nrewrite (H2 a b H1).\nexact (H1 a b H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros; apply div_mult; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_oppQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a] is_a,d,d] *)\nelim H; intros; elim H1; intros; elim H2; intros.\nsplit.\nexact (H (a*b) (a*b) (a*b) (a*b) H1).\nelim H1; intros.\nsplit.\nexact (H3 a b H1).\nrewrite (H1 d x b H1).\nrewrite (H2 d x b H2).\nelim H1; intros.\nsplit.\nexact (H2 a b H0 H0).\nrewrite (H0 d x b H1).\nrewrite (H2 d x b H2).\nrewrite (H3 d x b H2).\nelim H2; intros.\nsplit.\nexact (H3 a b H3).\nrewrite (H3 d x b H1).\nrewrite (H3 d x b H2).\nrewrite (H0 d x b H3).\nrewrite (H0 d x b H1).\nrewrite (H0 d x b H2).\nrewrite (H1 d x b H2).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6601,
                "proof_end_offset": 6974,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nunfold is_gcd in |- *.\nintros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nelim (mult_O_or_O _ H); intros.\nsplit; intros.\nexact (H3 a H1).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H3).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H2).\nsplit; intros.\nexact (H3 a H3).\nsplit; intros.\nexact (H4 a H2).\nsplit; intros.\nexact (H4 a H2).\nsplit; intros.\nexact (H4 b H2Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0 H1 H2 H3 H4.\nelim H2; intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H2).\nintros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H3); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H3); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_2 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nelim (divide_1 _ H4); intros.\nunfold is_gcd in |- *.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\nexact (gcd_1 a b).\nexact (gcd_1 a b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\napply gcd_0_l.\nassumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0 H1.\ncase (gcd_or_eq a b); intros.\nrewrite H1.\nrewrite <- H0.\nelim H0; intros.\nrewrite H1.\nelim H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H2; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H2; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H2; intros.\nsplit.\nexact H2; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.\nsplit.\nexact H1; intros.Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\nunfold is_gcd in |- *.\nsplit; intros.\nunfold divide in |- *.\nelim (divide_1_l a); intros.\nelim H2; intros.\nrewrite <- H1. \nrewrite <- H1. \nrewrite <- (mult_comm a b).\nelim H2; intros.\nrewrite <- H1. \nrewrite <- (mult_comm b b).\nelim H2; intros.\nrewrite <- H2. \nrewrite <- H1. \nrewrite <- (mult_assoc a b).\nelim H2; intros.\nrewrite <- H2. \nrewrite <- (mult_comm b b).\nelim H2; intros.\nrewrite <- H2. \nrewrite <- (mult_comm b b).\nelim H2; intros.\nrewrite <- H2. \nrewrite <- H1. \nrewrite <- (mult_comm b b).\nelim H2; intros.\nrewrite <- H2. \nrewrite <- H2. \nrewrite <- (mult_comm b b).\nelim H2; intros.\nrewrite <- H1.\nrewrite <- (mult_commQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\napply divide_refl.\nintros; elim H1; intros; elim H2; intros.\nsplit. exact (H1 H3).\nintros; elim H2; intros; elim H3; intros.\nsplit. exact (H2 H3).\n(* [a] *)\nelim H3; intros; elim H3; intros.\nsplit. exact (H3 H4).\n(* [a|b] *)\nelim H4; intros; elim H2; intros.\nsplit. exact (H4 H4).\n(* [a|b] *)\nelim H4; intros; elim H3; intros.\nsplit. exact (H4 H5).\n(* [a|b|b] *)\nelim H5; intros; elim H4; intros.\nsplit. exact (H5 H5).\n(* [a|b|b] *)\nelim H4; intros; elim H4; intros.\nsplit. exact (H5 H4).\n(* [a|b|b] *)\nelim H4; intros; elim H4; intros.\nsplit. exact (H5 H5).Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nunfold is_gcd in |- *; split; intros.\n(* [a] *)\nelim H; intros.\n(* [a] *)\nelim H; intros.\n(* [a] *)\nelim H0; intros.\n(* [a] *)\nelim H; intros.\n(* [a|b] *)\nelim H; intros.\n(* [a|b|b|b|b|c|b|b|d|b|b|b|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|d|Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\ndestruct a as [n|n].\nrewrite <- H.\napply gcd_unique; assumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0 H1.\nsplit.\nexact (gcd_comm a b H H0).\nexact (gcd_comm a b H H1).\nexact (gcd_comm a b H H1).\nexact (gcd_comm a b H H1).\nexact (gcd_comm a b H H1).\nexact (gcd_comm a b H H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm b a H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm b a H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (gcd_comm a b H1).\nexact (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6976,
                "proof_end_offset": 7247,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros.\nelim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros.\nsplit. exact H3.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H2.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H2.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H2.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H1.\nexact H1.\nsplit. exact H2.\nsplit. exact H1.\nsplit. exact H1.\nsplit. exact H2.\nsplit. exact H1.\nsplit. exact H2.Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nsplit. exact H1.\napply gcd_nonneg.\nexact H0.\nexact H1.\nexact H1.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H2; intros; elim H1; intros.\nsplit; apply gcd_neg.\nelim H; intros; elim H1; intros; elim H1; intros.\nsplit. exact H3. clear H0 H1.\nelim H1; intros; elim H1; intros.\nsplit. exact H3. clear H0 H1.\nelim H1; intros; elim H1; intros.\nsplit. exact H1. clear H1 H1.\nelim H1; intros.\nsplit. exact H2. clear H1 H1.\nelim H1; intros.\nsplit. exact H3. clear H1 H1.\nelim H1; intros; elim H1; intros.\nsplit. exact H1. clear H1 H2.\nelim H1; intros; elim H1; intros.\nsplit. exact H2. clear H1 H1.\nelim H1; intros.\nsplit. exact H3. clear H1 H2.\nelim H1; intros.\nsplit. exact H2. clear H1Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros; elim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H1; intros.\nelim H2; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H; intros; elim H0; intros; elim H0; intros.\nsplit. exact (H1 0).\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H.\nrewrite H1.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H.\nrewrite H1.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H.\nrewrite HQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros.\nsplit; [ assumption | split ].\nexact H0.\nexact H0.\nexact H0.\nexact H0.\nexact H1.\nexact H0.\nexact H1.\nexact H0.\nexact H0.\nexact H1.\nexact H1.\nexact H0.\nexact H1.\nexact H0.\nexact H0.\nexact H1.\nexact H1.\nexact H.\nexact H0.\nexact H1.\nexact H.\nexact H1.\nexact H1.\nexact H.\nexact H.\nexact H1.\nexact H0.\nexact H0.\nexact H0.\nexact H1.\nexact H.\nexact H1.\nexact H0.\nexact H0.\nexact H1.\nexact H0.\nexact H0.\nexact H1.\nexact H1.\nexact H0.\nexact H0.\nexact H0.\nexact H0.\nexact H0.\nexact H0.\nexact H1.Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nsplit. exact (H1 a H0).\nrewrite H0.\nelim H1; intros.\nsplit. exact (H1 a H0).\nrewrite H1.\nelim H1; intros.\nsplit. exact (H1 a H1).\nrewrite H1.\nelim H1; intros.\nsplit. exact (H1 a H0).\nrewrite H1.\nelim H1; intros.\nsplit. exact (H1 a H1).\nrewrite H0.\nrewrite H1.\nelim H1; intros.\nsplit. exact (H2 a H1).\nrewrite H0.\nelim H1; intros.\nsplit. exact (H2 a H0).\nrewrite H1.\nelim H1; intros.\nsplit. exact (H2 a H1).\nrewrite H1.\nelim H1; intros.\nsplit. exact (H2 a H1).Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nsplit. exact H1.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros.\nsplit. exact H2.\nsplit. exact (H0 _ H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction d; simpl in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros.\nsplit. exact H3.\nelim H1; intros.\nsplit. exact H3.\nelim H1; intros.\nsplit. exact H3.\nelim H2; intros.\nsplit. exact H3.\nelim H3; intros.\nsplit. exact H3.\nexact H3.\nelim H1; intros.\nsplit. exact H3.\nexact H3.\nelim H1; intros.\nsplit. exact H3.\nelim H1; intros.\nsplit. exact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H3.\nexact H4.\nexact H3.\nexact H4.\nexact H4.\nexact H3.\nexact H3.\nexact H2.\nexact H3.\nexact H2.\nexact H4.\nexact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H4.\nexact H2.\nexact HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 7249,
                "proof_end_offset": 8153,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim (H2 O (div_O_O H1)).\nelim (H0 O (div_O_O H1)).\nelim (H1 O (div_O_O H1)).\nelim (H1 O (div_O_O H1)).\nelim (H2 O (div_O_O H1)).\nelim (H1 O (div_O_O H1)).\nelim (H2 (div_O_O H1)).\nelim (H2 (div_O_O H1)).\nelim (H2 O (div_O_O H1)).\nelim (H2 O (div_O H1)).\nelim (H2 O (div_O_O H1)).\nelim (H2 O (div_O H1)).\nelim (H2 O (div_O H1)).\nelim (H2 O (div_O H1)).\nelim (H3 O (div_O H1)).\nelim (H2 O (div_O H2)).\nelim (H3Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H1; intros.\nelim (H4 O (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) H3).\nelim H5; intros; elim H6; intros.\nelim H7; intros; elim H8; intros.\nelim H9; intros; elim H9; intros.\nelim H9; intros; elim H9; intros.\nelim H9; intros; elim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H11; intros.\nelim H11; intros.\nelim H11; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H11; intros.\nelim H11; intros.\nelim H11; intros.\nelim H11; introsQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_inv in |- *; intros.\nelim H; intros; elim H0; intros.\nelim (H1 O (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) H0)); intros; elim H6; intros.\nelim H7; intros; elim H7; intros; elim H7; intros.\nelim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n elim H9; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H11; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H11; intros; elim H11; intros; elim H12; intros; elim H10;\n intros; elim H11; intros; elim H11; intros; elim H11; intros; elim H11;\n intros; elim H11; intros; elim H11; intros; elim H11;\n intros; elim H12; intros; elim H12; intros; elim H11; intros; elim HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (H1 O (div_O_O H) (div_O_O H) (div_O H) (div_O_O H) (div_O H) (div_O_O H) H0)).\napply le_plus_plus_plus.\nexact (le_plus_plus_distr_l (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x H.\nelim H; intros; elim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim (H2 O (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) H1)).\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4;Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *. intros.\nelim H; intros.\nelim H0; intros.\nelim (H4 O (div_O_O H) (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H)).\n intros; elim H8; intros.\nelim H8; intros.\nelim (H5 O (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H)).\n intros; elim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H11; intros.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros.\nelim H; intros.\nelim (H1 (S a) H0); intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H1; intros.\nelim H1; intros; elim H1; intros.\nsplit; assumption.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "rewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n",
                "context_tokens": 684,
                "proof_start_offset": 8155,
                "proof_end_offset": 9563,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\napply (is_gcd_or_eq (fun a b : S => a = S a /\\ b = S b)).\nintros.\nelim H0; intros; elim H1; intros.\nsplit; intros.\nelim (H4 O (div_O_O H1) (div_O_O H1) (div_O H1) (div_O_O H1) (div_O H1) (div_O H1) (div_O H2) (div_O H1) (div_O H1) (div_O H1) (div_O H1) H3) (div_O H2) H3) H2).\nintro.\nelim (H5 O (div_O_O_O H1) (div_O H1) (div_O H1) (div_O H1) (div_O H1) (div_O H2) H2)).\nintro.\nelim H2; intros; elim H4; intros.\nsplit; intros.\nelim H2; intros; elim H4; intros.\nsplit; intros.Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H1; intros.\nelim (H4 O (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H1 H2)).\n\nintros H5 H6 H7.\nelim (H5 O (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H5)).\nintros H7.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim H1; intros.\nelim (H2 (div_O_O H) (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H)).\nelim (H2 (div_O_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H)).\nelim (H2 (div_O_OQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nelim H0; intros; elim H1; intros.\nelim H0; intros; elim H1; intros; elim H1; intros.\nelim H1; intros; elim H1; intros.\nelim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros.\nelim H1; intros; elim H1; intros; elim H2; intros.\nelim H1; intros; elim H2; intros; elim H2; intros.\nelim H2; intros; elim H3; intros.\nelim H3; intros; elim H4; intros.\nelim H3; intros; elim H4; intros.\nelim H4; intros.\nelim H3; intros; elim H4; intros.\nelim H4; intros; elim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim (H4 O (div_O_O H1) (div_O H1) (div_O H2) (div_O H2) (div_O H2) (div_O H3) (div_O H3) (div_O H3) (div_O H3) H5)).\nintros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H5; intros; elim H6; intros; elim H7; intros; elim H8; intros.\nelim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* [d2 = O] *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* [d2 <> 0] *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* [d1 <> 0] *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 9565,
                "proof_end_offset": 9774,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply opp_0.\napply opp_0.\napply opp_0.\napply opp_0.\napply opp_opp.\napply opp_0.\napply opp_0.\napply opp_0.\napply opp_opp.\napply opp_0.\napply opp_opp.\napply opp_opp.\napply opp_0.\napply opp_opp.\napply opp_opp.\napply opp_0.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nunfold inv_proj in |- *.\nintros.\nelim (prod_comm (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_of_R (sum_R_of_R_of_R (sum_of_R_R_of_R (sum_of_R (sum_of_R_R_of_R_of_R_R_of_R_S n)))))));\n intros.\nelim H1; intros; elim H2; intros; elim H2; intros.\nelim (prod_assoc (sum_of_R (sum_R0 (sum_of_R (sum_R0 (sum_of_R0 (sum_of_R_R0 (sum_of_R0 (sum_R0_of_R0 (sum_R0_of_R0 (sum_of_Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nintro.\nintro.\napply (opp_opp_opp_opp_opp _ _ H0).\nassumption.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nunfold is_midpoint in |- *.\nintro.\nunfold is_midpoint in |- *.\nintro.\nunfold is_midpoint in |- *.\nintro.\nunfold is_midpoint in |- *.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nintro.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0.\nunfold is_midpoint in H0Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply HQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H3; intros.\nelim H3; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; introsQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_O.\napply opp_Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply opp_O; assumption.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros;\n elim H3; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H3; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H3; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P.\nred in |- *.\nintros x y H'.\napply H.\nexact H.\nexact H'.\nexact H'.\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact H'.\nexact (H' x y H').\nexact (H' x y H').\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact (H' x y H').\nexact H'.\nexact (H' x y H').\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (H' x y H').\nexact (H' x y H').\nexact H'.\nexact (H' x y H').\nexact (H' x y H').\nexact (H' x y H').\nexact H'.\nexact H'.\nexact (Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P.\n  apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P x); apply (fun x => P xDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P x y H H0; generalize (H x); clear H H.\n  intro H1; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n clear H H H1; elim H2; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H H H1; elim H2; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H H H2; elim H2; intros; elim H6; intros; elim H6;\n clear H H H2; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H H6 H2; elim H6; intros; elim H6; intros; elim H6;\n clear H H6 H6 H6; elim H6; intros; elim H6; intros; elim H6;\n clear H H6 H6 H6; elim H6; intros; elim H6;\n clear HDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nintros A P.\napply (Build_Predicate (Pred_fun:=fun x y => P y) x y); auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P x y H1 H2; apply H2.\nexact (H0 x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P x.\napply\n (Build_subtype (subtype_elt:=fun_elt:=fun_elt:=fun_elt_to_elt) (x:A) => R x).\nred in |- *.\nintros a x; red in |- *.\napply Trans with a; auto with algebra.\napply Trans with a; auto with algebra.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P.\napply (Build_Map (Ap:=fun x => P (fst x))).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A R x y H'; apply H'.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A R H x y H' H'0; elim H'0; clear H'0; intros; elim H'0; intros; elim H'1; clear H'0;\n intros; elim H'1; intros; elim H'2; clear H'0; intros; elim H'2; clear H'1;\n intros; elim H'2; intros; elim H'3; clear H'1; intros; elim H'3; clear H'2;\n intros; elim H'3; intros; elim H'4; clear H'3;\n intros; elim H'4; clear H'3; intros; elim H'4; clear H'4;\n intros; elim H'5; intros; elim H'5; clear H'5; intros; elim H'5;\n intros; elim H'6; clear H'5; intros; elim H'6; clear H'5;\n intros; elim H'6; intros; elim H'6; clear H'5; intros; elim H'6;\n clear H'5; intros; elim H'6; clear H'6; intros; elim H'Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof fun A P.\n  intros A P.\n  apply (fun x => P) (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun x => P x).\n  apply (fun xDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros; apply pi1.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros; apply pi2; apply pi2; apply pi2; apply pi2; apply pi3; apply pi3; apply pi3; apply pi4; apply pi4; apply pi5; apply pi5; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; apply pi6; applyQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros.\napply ( pi2) in H.\napply (pi1 A P p).\napply (pi1 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\napply (pi2 A P p).\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros.\napply p.\napply p.\napply p.\napply p.\napply (Build_Map (Ap:=fun x : A => P (pi2 A P p))).\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros.\napply (pi2 _ _ _ (pi2 _ _ (pi2 _ _ _ _ (pi3 _ _ _ _ _ _ _ _ _ _ H))).\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nintros.\napply (Build_Map (Ap:=fun y : A => f y = f y) (f x).\nexact (Ap:=fun y : A => f y = f y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold mult in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold Clock, Clock, Clock, Clock, tick in |- *; intros.\nelim H0; clear H0; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H2; clear H2;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim HQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros; discriminate.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H8; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elimQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros.\nunfold inversible in |- *.\ngeneralize (inv_assoc _ _ H).\nintros.\nelim H1; intros.\napply (inv_assoc _ _ H1).\nexact H0.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H1.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H0.\nrewrite <- H0.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite H2.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H2.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H0.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H0.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl in |- *.\nrewrite <- H1.\nsimpl inQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nintros; elim (eq_nat_dec x0); intros; auto.\nintros; elim (eq_nat_dec x0); intros; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros.\napply inv_trans with (S x0); auto.\napply inv_trans with (S x0); auto.\nQed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\n",
                "context_tokens": 200,
                "proof_start_offset": 1664,
                "proof_end_offset": 2222,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim (classic (G y) (G y)).\nintro.\napply H1.\nunfold not in |- *.\nauto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros y z H'; elim H'; intros x H'0; elim H'0; intros x H'1; elim H'1; intros H'2; elim H'2;\n intros x H'1; elim H'0; intros H'2; elim H'2; intros H'3 H'4; elim H'4;\n intros x H'4; elim H'5; intros H'5 H'6; elim H'5;\n intros x H'6; elim H'6; intros H'7; elim H'6;\n intros x H'7; elim H'7; intros H'7 H'8; elim H'8;\n intros H'9; elim H'8; intros H'9 H'10; elim H'8; intros H'11 H'9; elim H'9;\n intros H'10 H'11; elim H'9; intros H'10 H'11; elim H'11;\n intros H'10 H'12; elim H'10; intros H'11 H'12; elim H'12;\n intros H'11 H'12; elim H'12; intros H'Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nsimple induction 1.\n intros.\n rewrite H0 in |- *.\n rewrite (G1 y); auto with *.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply H; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H'0; elim H'0; intros H'1 H'2; elim H'1; intros H'3 H'4;\n elim H'1; intros H'4 H'5; elim H'5; intros H'6 H'7;\n elim H'7; intros H'7 H'7; elim H'7; intros H'8 H'9;\n elim H'8; intros H'9 H'10; elim H'9; intros H'11 H'12;\n elim H'9; intros H'12 H'13; elim H'9; intros H'11 H'13;\n elim H'9; intros H'10 H'11; elim H'12; intros H'11 H'12;\n elim H'9; intros H'12 H'13; elim H'10; intros H'12 H'13;\n elim H'9; intros H'13 H'13; elim H'13; intros H'13 H'14;\n elim H'9; intros H'13 H'14; elim H'9; intros H'15 H'14;\n elim H'9Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nsimple induction 1.\nintros x y H0; elim H0; intros x0 y1 H1; elim H1; intros x1 H2; elim H2; intros x2 H3;\n elim H3; intros x1 H4; elim H3; intros x3 H5;\n elim H5; intros x4 H6; elim H6; intros x4 H6;\n elim H6; intros x5 H7; elim H7; intros x6 H7;\n elim H7; intros x6 H8; elim H8; intros x7 H8; elim H8; intros x8 H9;\n elim H8; intros x8 H9; elim H8; intros x9 H10;\n elim H8; intros x9 H10; elim H8; intros x9 H10;\n elim H9; intros x10 H11; elim H9; intros x11 H11;\n elim H10; intros x12 H12; elim H12; intros x12 H13;\n elim H13; intros x13 H14; elim H14; intros x15 H14;\n elim H14; intros H15 H15Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros y z H'; elim H'; intros H'1 H'2; elim H'2; intros H'3 H'4; elim H'3; intros H'5; elim H'5;\n clear H'0; intros H'5; elim H'5; intros H'6; elim H'6;\n clear H'5; intros H'7; elim H'7; intros H'7; elim H'8;\n clear H'8; intros H'8; elim H'9; intros H'8; elim H'8;\n clear H'8; intros H'9; elim H'8; intros H'9 H'9; elim H'9;\n clear H'9; intros H'9; elim H'9; intros H'9 H'10; elim H'9;\n clear H'10; intros H'9; elim H'9; intros H'9 H'9; elim H'10;\n clear H'9; intros H'9; elim H'9; intros H'10 H'9; elim H'9;\n clear H'10; intros H'9; elim H'9; introsQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros; elim H; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros x y z H H0; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n introsQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nsimple induction 1.\nintro x; elim x; intros x1 y2 H3; elim H4; intros H5; elim H6; intros H7 H8; elim H8; intros H8;\n elim H8; intros H9 H10; elim H9; intros H10;\n elim H10; intros H10 H11; elim H12; intros H12 H12; elim H12; intros H13 H12;\n elim H12; intros H13 H13 H14; elim H13; intros H14 H14; elim H14; intros H15 H15 H16;\n elim H14; intros H15 H16 H16; elim H16; intros H17 H17 H17 H18 H18 H19 H20 H21 H21 H22 H23 H24 H24 H24 H25 H25 H25 H25 H26 H26 H26 H27 H29 H29 H28 H29 H29 H30 H30 H30 H30 H30 H30 H30 H30 H30 H30 H30 H31 H32 H33 H29 H31 H34 H30 H30 H31 H31 H31 H33 H31 H33Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 434,
                "proof_start_offset": 2239,
                "proof_end_offset": 2567,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x H1); intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H2;\n intros; elim H4; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H2;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 y H0); intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2 H3 H4.\n(* use of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set *)\nelim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2 H3 H4.\n(* use of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the *)\n\nLemma add_add :\n forall x y z : S,\n In x (add y z) -> In z (add x z) -> In z (add x z).\nProof.\nintros.\nelim (H0 y H0); intros; elim H1; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H2;\n intros; elim H3; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 y H); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H2 H3 H4 H5.\n(* use of the left *)\nelim (H1 y H0); intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n clear H2 H3 H4.\n(* use of the left *)\nelim (H1 y H0); intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n clear H2 H3 H4.\n(* use of the left *)\nelim (H1 y H0); intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2 H3.\n(* use of the left *)Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 y H2); intros; elim H2; intros; elim H2; intros; elim H2; intros.\nclear H4 H5 H7.\n(* use of the multiplication *)\nelim (H1 y H2); intros; elim H2; intros; elim H2; intros.\nclear H2 H3.\n(* use of the multiplication *)\nelim (H1 y H2); intros; elim H2; intros.\nclear H2 H3.\n(* use of the multiplication *)\nelim (H1 y H2); intros; elim H2; intros; elim H2; intros; elim H2; intros.\nclear H2 H3.\n(* use of the multiplication *)\nelim (H2 y H2); intros; elim H2; intros; elim H2; intros.\nclear H2 H3.\n(* use of the multiplication *)\nelim (H1 y H2); intros; elim H2; intros; elim H3; intros; elim H2; intros.\nclear H2 H3.\n(* use of the multiplication *)\nelim (H2 y H2); intros; elim H3Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n clear H2 H3; elim (H5 y H1); intros; elim H3; intros; elim H3; intros; elim H3;\n clear H3 H4; elim (H5 y H4); intros; elim H4; intros; elim H4;\n clear H4 H5 H6 H7 H8 H9.\n(* use of the union *)\nelim (H6 x H2); intros; elim H5; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9.\n(* use of the same result *)\nelim (H6 x H3); intros; elim H6; intros; elim H7; intros; elim H7;\n clear H6 H8 H9; elim (H8 y H9); intros; elim H8;\n clear H6 H7 H9; elim (H8 y H9); intros; elim H9;\n clear H9 H9; elim (Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H (Add x1 y2)); intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H9;\n clear H5 H8 H9 H10.\n(* use of the same order *)\nelim (H9 x H2); intros; elim H7; intros; elim H9; intros; elim H9;\n clear H8 H9 H10.\n(* use of the inverse *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9;\n clear H8 H9 H10.\n(* use of the inverse *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9 H9.\n(* use of the inverse *)\nelim (H9 x H3); intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the inverse *)\nelim (H9Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n clear H4 H5 H8 H9 H10.\n(* use of the opposite *)\nelim (H5 y H1); intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n clear H5 H8 H9 H10.\n(* use of the opposite *)\nelim (H7 (Opp x1) x y); intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n clear H6 H7 H8 H10.\n(* use of the left *)\nelim (H7 (Opp x1) x y); intros; elim H7; intros; elim H8; intros; elim H9;\n clear H8 H9 H10.\n(* use of the left *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "                                                  *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 549,
                "proof_start_offset": 2588,
                "proof_end_offset": 3197,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (ass x y H0); elim (ax (Add x1 y) x2); elim (ax (Add x1 y) x1);\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H3 H3 H4 H5.\n(* use of the following theorem *)\nelim (H1 x2); intros; elim H1; intros; elim H1; intros; elim H2;\n clear H1 H2; intros; elim H1; intros; elim H2; intros; elim H2;\n clear H2 H3 H4.\n(* use of the order *)\nelim (H1 x2); intros; elim H2; intros; elim H2; intros; elim H2;\n clear H2 H2 H3 H4.\n(* use of the inverse of a *)\nelim (H1 x2); intros; elim H1; intros; elim H2; intros; elim H2;\n clear H2 H3 H4.\n(* use of the inverse of a *)\nelim (H1 x2); intros; elim H2; intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x -> 0).\napply opp_unicity with (P:=fun x : S => x ->Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x H1); intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H1 x H2); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": " Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\n",
                "context_tokens": 733,
                "proof_start_offset": 3214,
                "proof_end_offset": 3568,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold not in |- *; intro.\nrewrite (opp_opp_opp _ H).\nrewrite (opp_opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (opp_opp _ H).\nrewrite (oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_inj.\nelim (H x H0); intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H4; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H3; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_group in |- *.\nelim (H (conj H (conj H (conj H (conj H (conj H (conj H (conj H (conj H H (conj H H))) H))) H).\n(* x+y= 0 *)\nelim H; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H11;\n intros; elim H10; intros; elim H11Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n apply (H2 (Opp x) x H3); intros; elim H2; intros; elim H2; intros; elim H2;\n apply (H1 (Opp x) x H3); intros; elim H2; intros; elim H3;\n apply (H3 (Opp x) x H3); intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n apply (H4 (Opp x) x H3); intros; elim H3; intros; elim H3; intros; elim H4;\n apply (H4 (Opp x) x H3); intros; elim H5; intros; elim H5; intros; elim H6;\n apply (H5 (Opp x) x H3); intros; elim H6; intros; elim H6;\n apply (H6 (Opp x) x H3); intros; elim H6; intros; elim H6; intros; elim H7Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H x H); intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H1;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n clear H1 H2 H3 H4; rewrite H2; clear H1 H2 H3 H4.\n(* x+y = 0+x *)\nelim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n clear H1 H2 H3 H4; rewrite H3; clear H1 H2 H4.\n(* x+y = 0+x *)\nelim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H1 H2 H3 H4; rewrite H2; clear H1 H2 H3 H4.\n(* x+y= 0 *)\nelim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n clear H1Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\n",
                "context_tokens": 716,
                "proof_start_offset": 3585,
                "proof_end_offset": 4727,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H11; intros; elim H12; intros; elim H12;\n intros; elim H11; intros; elim H9Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intro; intro; elim H; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H9; intros; elim H8Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intro.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) (Opp x) (Opp x y)).\nunfold is_empty in |- *; split.\nelim (H (Opp x y)).\n(* x=x *)\nelim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elimQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intro H; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n [ intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n [ intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n [ intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n [ intros; elim H6; intros; elim H6; intros; elim H7; elim H6; intros; elim H7;\n [ intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n [ intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;\n [ intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H8;\n [ intros;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intro H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H1;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold not in |- *; intro H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_empty in |- *; split; intro H0; elim H0; intros; elim H0; intros.\n(* x=y *)\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H4; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H4; intros; elim H4; intros; elim H6; intros; elim H6;\n intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\n\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* G (x+y) *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* G ((-x)+(-y)) *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* (x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0 *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* x+(-x) = 0 (-x)+x = 0 *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* y+(-y) = 0 (-y)+y = 0 *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* 0+0 = 0 *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n(****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 4748,
                "proof_end_offset": 4967,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold is_power in |- *; split; intro; apply opp_def; assumption.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_inj.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\ndestruct (eq_dec_points O O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (opp_involutive O).\nrewrite <- (oppQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim (opp_zero_ext O); intros; elim H; intros; elim H; intros.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nsimple induction 1; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elimQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold opp; rewrite opp_opp.\nunfold opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewriteQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold is_empty, opp_left in |- *.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; introsQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_neq.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intro; apply (mult_neg_eq _ _ H); apply mult_pos_eq; assumption.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply mult_eq_reg_l with (- p); [ apply mult_pos_pos | apply mult_pos_pos ]; assumption.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n simple induction n.\n simpl in |- *. intros.\n simpl in |- *.\n rewrite (mult_comm n).\n rewrite (mult_comm n).\n rewrite (mult_comm m).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewriteQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros n; apply lt_O_n.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n; simpl in |- *; auto with arith.\n  intros; simpl in |- *; auto with arith.\n  intros; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros; elim (multZ_eq_1_dec n 1); intro H.\n  elim (multZ_eq_1_dec n 1); intro H1.\n  elim (multZ_eq_1_dec n 1); intro H1.\n  elim (multZ_eq_1_dec n 1); intro H1.\n  elim (multZ_eq_1_dec n 1); intro H2.\n  elim (multZ_eq_1_dec n 1); intro H3.\n  elim (multZ_eq_1_dec n 1); intro H4.\n  elim (multZ_eq_dec n 1); intro H4.\n  elim (mult_Z_eq_1_dec n 1); intro H4.\n  elim (mult_Z_eq_dec n 1); intro H5.\n  elim (mult_Z_eq_1_dec n 1); intro H5.\n  elim (mult_Z_eq_dec n 1); intro H5.\n  elim (mult_Z_eq_1_dec n 1); intro H6.\n  elim (mult_Z_eq_dec n 1); intro H6.\n  elimQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intro.\n apply lt_O_le.\n apply le_n_S.\n assumption.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  unfold multZ in |- *.\n  case n.\n  simpl in |- *.\n  intros.\n  elim H0.\n  simpl in |- *.\n  intros.\n  elim H0.\n  simpl in |- *.\n  intros.\n  elim H1.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H2.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.\n  elim H3.\n  simpl in |- *.\n  intros.Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros; unfold multZ; rewrite H; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intro.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto with arith.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros; apply multZ_eq_1.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto with arith.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto with arith.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros n; auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros n.\n unfold multZ.\n rewrite Z.add_assoc.\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_comm (S n)).\n rewrite (mult_commQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y.\n rewrite (mult_comm x y).\n rewrite (mult_comm y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_commQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_0_r.\n\n(*******************)\n\nLemma mult_pos_l : forall x y : Z, multZ (neg x) y = multZ x y.\nProof multZ_eq_1_l.\n\n(*******************)\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x y.\nProof multZ_eq_1_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp y x.\nProof multZ_eq_1_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x y.\nProof multZ_eq_1_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x y.\nProof multZ_eq_1_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x y.\nProof multZ_eq_1_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x yQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_1_r.\n\nLemma mult_neg_pos_eq : forall (x : nat) (y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_r.\n\nLemma mult_neg_neg_eq : forall (x : nat) (y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_l.\n\nLemma mult_neg_neg_eq : forall (x : nat) (y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_r.\n\nLemma mult_neg_eq : forall (x y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_r.\n\nLemma mult_neg_eq : forall (x y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_r.\n\nLemma mult_neg_eq : forall (x y : Z), multZ x y = oppZ x.\nProof multZ_eq_1_r.\n\nLemma mult_neg_eq : forall (Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros x y; pattern x at 2 in |- *; rewrite mult_0_r.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply mult_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof mult_neg_Z.\n\nLemma mult_neg_pos_neg_pos :\n forall (x : Z) (y : Z),\n multZ (pos x) y = exp (multZ x y) (multZ x y).\nProof mult_neg_Z.\n\nLemma mult_neg_neg_neg_neg :\n forall (x : Z) (y : Z),\n multZ (pos x) y = exp (multZ x y) (multZ x y).\nProof mult_neg_pos_neg_neg.\n\nLemma mult_neg_neg_neg :\n forall (x : Z) (y : Z),\n multZ (pos x) y = exp (multZ x y) (multZ x y).\nProof mult_neg_neg_neg.\n\nLemma mult_neg_neg_neg_neg_neg :\n forall (x : Z) (y : Z),\n multZ (pos x) y = exp (multZ x y) (multZ x y).\nProof mult_neg_neg_neg.\n\nLemma mult_neg_neg_neg :\n forall (x y : Z), multQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y.\n rewrite (mult_comm x).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_1_l.\n\nLemma mult_neg_neg_neg_neg : forall x y : Z, x = y -> x = y.\nProof multZ_eq_1_l.\n\n(** We define a real number of 1 *)\nLemma mult_neg_neg_neg : forall x : Z, x = -x.\nProof mult_neg_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x = -x.\nProof mult_neg_neg_neg.\n\n(** We define a real number of 1 *)\nLemma mult_neg_neg_neg_neg : forall x : Z, x = -x.\nProof mult_neg_neg_neg.\n\n(** We define a real number of 1 *)\nLemma mult_neg_neg_neg : forall x : Z, x = -x.\nProof mult_neg_neg_neg.\n\n(** We define a real number of 1 *)\n\nLemma mult_neg_neg_neg : forall x : Z, x = -x.\nProof mult_neg_neg_neg.\n\n(** [x] is theQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall (x y : Z), multZ x y = zeroZ x.\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall (x y : Z), multZ x y = oppZ x.\nProof multZ_eq_1.\n\nLemma mult_neg_r : forall (x y : Z), multZ x y = oppZ x.\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = oppZ x + (x - y).\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall x y : Z, multZ (neg x) y = oppZ x + (x - y).\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = oppZ x + (x - y).\nProof multZ_eq_1.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = oppZ x + (x - yQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof mult_neg_Z.\n\nLemma mult_neg_negZ : forall x y : Z, multZ x y = exp x y.\nProof mult_neg_Z.\n\nLemma mult_neg_neg_pos : forall x y : Z, multZ x y = exp y.\nProof mult_neg_Z.\n\nLemma mult_neg_pos_neg_pos : forall x y : Z, multZ x y = exp x y.\nProof mult_neg_pos_pos.\n\nLemma mult_neg_neg_neg : forall x y : Z, multZ x y = exp x y.\nProof mult_neg_pos.\n\nLemma mult_neg_neg_neg : forall x y : Z, multZ x y = exp x y.\nProof mult_neg_pos.\n\nLemma mult_neg_neg_neg_pos : forall x y : Z, multZ x y = exp y.\nProof mult_neg_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, multZ x y = exp x y.\nProof mult_neg_neg_pos.\n\nLemmaQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_1.\n\n(**************)\nLemma mult_pos_pos :\n forall (x : nat) (y : Z),\n mult_pos (pos (S x)) y = exp x y.\nProof mult_pos_pos_nat.\n\nLemma mult_neg_pos_neg : forall x y : Z, x = y -> x = y.\nProof mult_pos_pos_pos_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x <> y -> x = y.\nProof mult_neg_pos_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x <> y -> x = y.\nProof mult_neg_neg.\n\nLemma mult_neg_neg_neg_pos : forall x y : Z, x <> y -> x <> y.\nProof mult_neg_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x <> y -> x <> y.\nProof mult_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x <> y -> xQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_neg_Z.\n\nLemma mult_pos_pos_pos : forall (x : Z) (y : Z), multZ x y = Ebinop (multZ x y) (multZ x y).\nProof mult_pos_pos.\n\nLemma mult_pos_neg_neg_pos : forall (x : Z) (y : Z), multZ x y = Ebinop (multZ x y) (multZ x y).\nProof mult_pos_pos.\n\nLemma mult_pos_pos_neg : forall (x : Z) (y : Z), multZ x y = Ebinop (multZ x y) (multZ x y).\nProof mult_pos_pos.\n\nLemma mult_pos_pos_neg : forall (x : Z) (y : Z), multZ x y = Ebinop (multZ x y) (multZ x y).\nProof mult_pos_pos.\n\nLemma mult_pos_neg_neg : forall (x : Z) (y : Z), multZ x y = Ebinop (multZ x y) (multZ x y).\nProof mult_pos_neg.\n\nLemma mult_posQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = Qnum (multZ x y) (oppZ y).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = Qnum (multZ x y) (oppZ x).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, x = Qden (multZ x y) (oppZ x).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, x = Qden (multZ x y) (oppZ x).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, x = Qden (multZ x y) (oppZ x).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, x = Qden (multZ x y) (oppZ x).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, x =Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_compat_l.\n\nLemma mult_pos_pos_r : forall x y : Z, multZ (pos x) y = addl (multZ x y) (oppZ y).\nProof multZ_eq_compat_l.\n\nLemma mult_pos_neg_r : forall x y : Z, multZ (pos x) y = addl (multZ x y) (oppZ y).\nProof multZ_eq_compat_l.\n\nLemma mult_pos_neg_r : forall x y : Z, multZ (pos x) y = addl (multZ x y) (oppZ y).\nProof mult_pos_r.\n\nLemma mult_pos_neg_l : forall x y : Z, multZ x y = addl (multZ x y) (oppZ y).\nProof mult_pos_r.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = addl (multZ x y) (multZ x y).\nProof mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simplQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_neg_l.\n\n(** The following lemmas are used in a particular way of the usual\n   [multZ_eq] and [multZ_eq_1] and [multZ_eq_1] and [multZ_eq_1] and [multZ_eq_1] *)\nLemma mult_pos_l : forall x y : Z, multZ x y = 0%Z.\nProof mult_comm.\n\n(** [multZ_eq_1] and [multZ_eq_1] and [multZ_eq_1] *)\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = 0%Z.\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = 0%Z.\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, mult x y = 0%Z.\nProof mult_pos_l.\n\nLemma mult_neg_r : forall x y : Z, mult x y = 0%Z.\nProof mult_pos_lQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; apply mult_pos_pos_pos.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y).\n(* negQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n) *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivityQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* abs n *)\nintros; elim (Zorder.Zlt_irrefl 0); exact (Zlt_irrefl 0); exact (Zlt_irrefl 0); exact (Zlt_irrefl 0); exact (Zlt_irrefl 0); exact (Zlt_irrefl 0); exact (Zlt_irrefl 0).\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_neg_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = predZ (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = predZ (multZ x y) (oppZ x).\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = norm (multZ x y) (oppZ x).\nProof mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = norm (multZ x y) (multZ x y).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = norm (multZ x y) (multZ x y).\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = norm (multZ x y) (multZ x y).\nProof mult_Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim (tech_mult_pos_pos n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_multZ_neg_pos n0 y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_multZ_neg_pos n0 y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_neg_Z n0 y).\nelim (tech_mult_neg_pos n0 y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_neg_Z n0 y).\nelim (tech_mult_neg_pos n0 y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *;Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim (mult_neg_pos_l n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simplQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_multZ (pos n0) y) y.\nelim (tech_multZ (pos n0) y) y.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y) y.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_neg_Z n0 y).\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_neg_Z n0 y).\nelim (tech_mult_neg_ZQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimplQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (SORsetoid (multZ_neg n0 y) y).\nelim (SORsetoid (multZ_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 y) y).\nelim (SORsetoid (mult_neg n0 yQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nintros; unfold neg in |- *; rewrite (tech_mult_posZ n0 y).\nelim (mult_neg_pos_pos n0 y); intros.\nelim (mult_neg_pos_pos n0 y); intros.\nelim (mult_neg_pos_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 y); intros.\nelim (mult_neg_pos n0 yQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n (* neg n *)\nsimpl in |- *; reflexivity.\n (* neg n *)\nintros; unfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_multZ_negZ n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_mult_neg_Z n0 y); intros.\nelim (tech_mult_neg_Z n0 y); intros.\nelim (tech_multZ_neg_Z n0 y); intros.\nelim (tech_mult_negQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; unfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros. elim H0; intros; elim H1; intros; exact H3.\n(* pos n *)\nintros; unfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros. elim H1; intros; elim H2; intros; exact H4.\n(* pos n *)\nintros; unfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\nelim H1; intros.\nunfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\nelim H1; intros.\nunfold multZ in |- *; rewrite (tech_mult_negZQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* abs (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros. elim H1; intros.\n(* abs n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; rewrite <- (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; rewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_comm Z).\nrewrite (add_commQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; rewrite (plus_comm 0).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (plus_comm 0).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (plus_comm 0).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; rewrite (plus_comm 0).\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; rewrite (plus_comm 0).\n(* neg n *)\nsimple induction n.\n(* neg n *)\nintros; simpl in |- *; rewrite (plus_comm 0).\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* negQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; rewrite (add_comm (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred x)).\nelim (mult_comm x (Z.succ_pred xQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; apply mult_pos_l.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; unfold succ in |- *; rewrite (mult_comm 0).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ x) y).\nelim (mult_comm (Z.succ xQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\n intros; elim x.\n (* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* pos O *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimple induction n.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimple induction n.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimple induction n.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (S n0) *)\nsimple induction n.\n(* pos (S n0) *)\nsimpl in |- *; intros; apply mult_pos_pos.\n(* pos (Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintro; elim x.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimpleQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\n intros; apply mult_IZR.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nunfold multZ in |- *; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; unfold multZ in |- *; do 2 rewrite (tech_mult_neg_pos_r (neg x) (pos x)).\nrewrite (tech_mult_neg_r (neg x) (neg x)).\nrewrite H; elim (mult_neg_neg_l (neg x) (pos x)).\nreflexivity.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\napply H; assumption.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nsimple induction x; intros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; apply mult_IZR; auto with arith.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintro; elim x.\n(* neg (S n0) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; absurd (0 < x); auto.\nrewrite (mult_comm x); rewrite (mult_comm (x * y)).\nrewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm (x * y)).\nrewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (mult_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; apply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napply mult_IZR.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\nsimple induction x.\n(*Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg x *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* abs n *)simple induction n.\n(* succ n *)simple induction n.\n(* neg n *)simple induction n.\n(* succ n *)simple induction n.Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* abs n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimpleQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)simple induction x.\n(* neg 0 *)simple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* negQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(* neg n *)simple induction x.\n(*Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nintros x H; rewrite (tech_mult_negZ x BDDzero); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nintros; rewrite (tech_mult_negZ y BDDone); rewrite H; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* negQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(*Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivityQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* succ n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* n = succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* n = succ n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* abs n *)simple induction n.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(*Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n (* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Z y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 8247,
                "proof_end_offset": 8887,
                "proof": "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_IZ y).\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H.\nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (mult_mIZ y).\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H.\nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_commutativity : commutativity Z multZ.\nintro Z.\nelim Z.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_assoc_apply Qplus_assoc_apply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_assoc_apply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc_apply Qplus_assoc_Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_assoc_apply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\nexact Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\nexact Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\napply Qplus_assoc_exact.\nexact Qplus_assoc_exact.\nexact Qplus_assoc_exact.\napply Qplus_assoc_exact.\nexact Qplus_assoc_exact.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply Qinv_right; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nsimple destruct x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_assoc.\napply Qplus_assoc.\napply Qplus_comm.\napply Qplus_comm.\napply Qplus_Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\ninduction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(*Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n (* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivityQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply Z_commutativity.\napply H0.\napply H0.\nassumption.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8912,
                "proof_end_offset": 9098,
                "proof": "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold neutral in |- *.\nsplit.\nexact I.\nintros.\nsplit.\nelim (multZ_commutativity IZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold field in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* pos (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(*Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)simple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* app n *)simple induction n.\n(* n *)\nsimple induction n.\n(* abs n *)simple induction n.\n(* x *)simple induction n.\n(* abs n *)simple induction n.\n(* a *)simple induction n.\n(* abs n *)simple induction n.\n(* app n *)simple induction n.\n(* app n *)simple induction n.\n(* 0 *)simple induction n.\n(* app n *)simple induction n.\n(* n *)simple induction n.\n(* n *)simple induction n.\n(* succ n *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Qplus in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)simple induction n.\n(* abs n *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* abs n *)simple induction n.\n(* abs n *)simple induction n.\n(* abs n *)simple induction n.\n(* abs n *)\nsimple induction n.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\n",
                "context_tokens": 743,
                "proof_start_offset": 9133,
                "proof_end_offset": 10783,
                "proof": "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nProof.\nunfold distributivity in |- *; intros; case x.\nsplit; reflexivity.\nsimple induction n.\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z).\nreflexivity.\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\nsimple induction n.\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z).\nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nintros y0 H.\nsplit.\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros.\nrewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim (add_add Z addZ addZ_commutativity addZ_associativity (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zminus in |- *; intros; elim x.\n(*... *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\nreflexivity.\n(* In this case *)\n(* In this case *)\nreflexivity.\n(* In thisQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Qminus in |- *; intros.\nelim x.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nintros.\nrewrite (tech_mult_neg_R 0 x); rewrite (tech_mult_neg_R 0 x); rewrite (tech_mult_neg_R 0 x); reflexivity.\n(* x = 0 *)\nsimple induction n.\n(* 0 = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x <> 0 *)\n(* x = 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(*Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zminus in |- *; intros.\nelim x; case y; case z; simpl in |- *; auto with zarith.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Qminus in |- *; intros; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Qminus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qminus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qminus, Qplus, Qplus, snd, snd.\nrewrite (add_comm (Z_of_nat x) (Z_of_nat x)).\nunfold Qminus, Qplus, Qmult, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, snd.\nrewrite (add_comm (Z_of_nat x)).\nunfold Qminus, Qplus, Qplus, snd.\nrewrite (add_comm (Z_ofQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Ndigits.\nunfold Ndigits.\nunfold Ndigits.\nunfold Ndigits.\nunfold Ndigits.\nunfold Ndigits.\nunfold Ndigits.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map in |- *.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map in |- *.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map in |- *.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfold Map.\nunfoldQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Qminus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qminus, Qplus, Qplus, Qplus, Qplus, Qplus, Qplus, snd, snd, snd.\nunfold Qminus, Qplus, Qplus, Qplus, snd, snd, snd.\nunfold Qminus, Qplus, Qplus, Qplus, Qplus, snd, snd, snd.\nunfold Qplus, Qplus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qminus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qplus, Qplus, Qplus, Qplus, snd, snd.\nunfold Qopp, Qplus, snd in |- *; reflexivity.\n(* neg n *)\nintros y H; rewrite (tech_mult_neg_Z y (pos y)); rewrite H; reflexivity.\n(* neg n *)\nintros x H; rewrite (tech_mult_neg_Z y (pos y)); rewrite H; reflexivity.\n(* neg n *)\nintros x H; rewrite (tech_mult_neg_Z y (pos y)); rewrite H; reflexivity.\n(* neg n *)\nintros y H; rewrite (tech_mult_neg_Z y (pos y)); rewrite H;Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Qminus in |- *; intros; elim x.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - x = 0 *)\nreflexivity.\n(* - - x = 0 *)\nreflexivity.\n(* -Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Rminus in |- *; intros; elim x.\n(* *)\nreflexivity.\n(* In this case, the case, the case of the case of the case of the case of the case of the case of the case of the case of the *)\n(* *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zminus in |- *; intros; elim x.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*...Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\nTheorem mult_add_distributivity : distributivity Z addZ multZ.\n\nunfold distributivity in |- *; intros; case x.\n(* OZ *)\nsplit; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z). \nreflexivity.\n(* pos (S y0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 10804,
                "proof_end_offset": 11399,
                "proof": "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; case x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) y) y I I).\nelim H; reflexivity.\nintros; elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y; case x; case y; case y; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nunfold multZ in |- *; intros; apply plus_opp_l.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y; apply mult_opp_l.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y; rewrite mult_opp_r; reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nunfold multZ, oppZ in |- *; intros; apply mult_opp_r.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y H.\nelim H; intros; split.\nrewrite <- (mult_comm (Z_opp x) (Z_opp y)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp x)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp y)).\nrewrite <- (mult_comm (Z_opp yQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y; rewrite <- oppZ_eq.\nrewrite <- oppZ_eq.\nrewrite <- oppZ_eq.\nrewrite <- oppZ_eq.\nrewrite <- oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_eq.\nrewrite oppZ_opp.\nrewrite oppZ_opp.\nrewrite oppZ_eq.\nrewrite oppZ_opp.\nrewrite oppZ_eq.\nrewrite oppZ_opp.\nrewrite oppZ_opp.\nrewrite oppZ_opp.\nrewrite oppZ_eq.\nrewrite oppZ_opp.\nrewrite oppZ_eq.\nrewriteQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; apply mult_opp_r.\napply (opp_add Z IdZ]).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_opp_opp Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_opp Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_opp_opp Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napply (opp_add Z IdZ).\napplyQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y H; elim (mult_nonneg_l (abs x) y); intros; apply H; assumption.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y H.\nelim (mult_neg_opp Z IdZ x); unfold oppZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 11420,
                "proof_end_offset": 12246,
                "proof": "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nsimple destruct y.\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\nintros; elim (multZ_commutativity (pos n) (oppZ x)).\nelim (multZ_commutativity (pos n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) x) x I I).\nintros; elim (multZ_commutativity (neg n) (oppZ x)).\nelim (multZ_commutativity (neg n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) x) (oppZ x) I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos n *)\nreflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(*Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x; trivial.\n (* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* || abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* neg *)\nreflexivity.\n(* pos (S y0) *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple inductionQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nintros; case x.\n(* neg (S y) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12380,
                "proof_end_offset": 12674,
                "proof": "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivityQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n; intros.\nreflexivity.\nelim (mult_comm n m); reflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)\nsimple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simple induction n; intros.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nunfold multZ in |- *; apply (mult_pos_pos_pos n).\nrewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nintros; elim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelim (mult_comm (pos n) (pos n)).\nelimQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros.\n rewrite (tech_mult_negZ n m); elim n.\n (* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros n m; elim n.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple destruct n.\nreflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ").\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12702,
                "proof_end_offset": 13018,
                "proof": "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S yQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\n(* succ n *)\nreflexivity.\n(* succ n *)\nreflexivity.\n(* succ n *)\n(* succ n *)\nreflexivity.\n(* succ n *)\n(* succ n *)\nreflexivity.\n(* succ n *)\n(* succ n *)\nreflexivity.\n(* succ n *)\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)\nreflexivity.\n(* n *)\n(* n *)Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\n intros; elim n.\n (* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n=0 *)\nsimple induction n.\n(* n=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* n=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* n=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* 0=0 *)\nsimple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)\nsimple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction n.\n(* 0=0 *)simple induction nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n (* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n (* 0 *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(*Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* SQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13046,
                "proof_end_offset": 13355,
                "proof": "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* n *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_mult_negZ y (pos m + (n + m))) in |- *.\nrewrite (tech_oppZ y (pos m + (n + m))) in |- *.\nrewrite H.\nrewrite <- (tech_oppZ y (pos m + (n + m)) m).\nelim (tech_oppZ y (pos m + (n + m))) in |- *.\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nelim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (tech_oppZ y (pos m + (n + m)) H).\nintros; elim (Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m) y H).\nelim (tech_mult_neg_neg_neg_Z y (pos m) y H); reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)\nintros; elim H; reflexivity.\n(* S y *)Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nrewrite (tech_mult_pos_Z y (pos m + (n + m))) in |- *.\nrewrite (tech_mult_negZ y (pos m + (n + m))) in |- *.\nrewrite (tech_mult_neg_Z y (pos m + (n + m))) in |- *.\nrewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m) + (n + m) + (n + m + m))).\nelim (tech_mult_neg_Z y (pos m + (n + m) + (n + m) + (n + m + n) + m)).\nelim (tech_mult_neg_Z y (pos m + (n + m) + (n + m) + (n + m) + (n + m) + (n + m + n + m))).\nelim (tech_mult_neg_Z y (pos m + (n + m) + (n + m) + (n + m) + (n +Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S yQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* SQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m + (n + m)) H).\nelim (tech_mult_neg_negZ y (pos m + (n + m)) H).\n(* S y *)\nintros; elim (multZ_left_negZ y (pos m + (n + m)) H).\n(* S y *)\nelim (mult_nonneg_nonneg y (pos m + (n + m)) H).\n(* S y *)\nsimple induction  n.\n(* 0 *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (mult_nonneg_nonneg y (pos m + (n + m)) H).\n(* S y *)\nsimple induction  n.\n(* n *)\nsimple induction  n.\n(* 0 *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (mult_nonneg_nonneg y (pos m + (n + m)) H).\n(* S y *)\nsimple induction  n.Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* S y *)\n(* S y *)\nreflexivity.\n(* SQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13383,
                "proof_end_offset": 13714,
                "proof": "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *; rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nintros; elim n.\n(* S y *)\nintros.\nrewrite (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_pos_Z y (pos m + (n + m))).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nintros; elim n.\n(* S y *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nsimple induction n; intros; elim n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; elim H; intros; rewrite (tech_mult_neg_pos_neg_neg_pos y); reflexivity.\n(* S y *)\nintros; elim H; intros; rewrite (tech_mult_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_neg_pos_negZ y (pos m + (n + m))) in |- *.\nelim (tech_mult_neg_pos_pos_neg Z y (pos m + (n + m)) H).\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_neg_neg Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_neg_neg Z y (pos m + (n + m)) H).\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_neg_neg_pos Z y (pos m + (n + m))) in |- *.\nelim (tech_mult_neg_pos Z y (pos m + (n + m)) H).\n(* S y *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* n *)\nrewrite (tech_mult_neg_posZ y (pos n)) in |- *.\nrewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + mQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintro x; rewrite (tech_mult_negZ y (pos m + (n + m)) H).\nrewrite (tech_add_neg_pos_Z y (pos m + (n + m)) H).\nrewrite H; reflexivity.\n(* S y *)\nsimple induction 1.\n(* n *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_pos_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_Z y (pos m + (n + m)) H).\nelim (tech_mult_neg_Z y (pos m + (n + m)) H).\nelimQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* n = 0 *)\nintro; elim (multZ_nonneg_nonneg x); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_nonneg y); reflexivity.\n(* S y *)\nintros; elim (multZ_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 13745,
                "proof_end_offset": 14428,
                "proof": "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nreflexivity.\nsimple induction n.\nunfold multZ in |- *; reflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros.\nelim H0.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_oppZ_l y z).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros.\nelim H0.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nintros; elim n.\n(* O *)\napply mult_comm.\napply plus_comm.\napply plus_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply multQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nProof.\nsimple induction 1; auto with zarith.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivity.\n (* 0 *)\nsimpl in |- *; reflexivityQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nProof.\nsimple induction n; simpl in |- *; reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z y (pos m)); unfold oppZ in |- *;\n rewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\n(* S y *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\n(* S y *)\nintros; rewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\n(* S y *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (Qed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nsimple induction 1; reflexivity.\n(* n *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 2; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimple induction 1; reflexivity.\n(* S y *)\nsimpleQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nintro; elim n.\n(* S y *)\nintro; rewrite (tech_mult_negZ y (pos m + (n + m)) m).\nelim (tech_mult_neg_pos_pos (y * n + (n + m)) m); reflexivity.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nintros; elim n.\n(* A *)\nsimpl in |- *; reflexivity.\n(* A *)\nsimpl in |- *; reflexivity.\n(* A *)\nintros y H; rewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos y)); rewrite H.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nauto with arith.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nintros n m; elim n.\n(* n *)\nrewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_neg_Z (y * n + m)) n.\n(* S y *)\nintros; elim n.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; elim n.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; elim n.\n(* S y *)\nrewrite (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (tech_mult_neg_Z y (pos m + (n + m)) m).\nelim (techQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nreflexivity.\n(* S y *)\nintros x y H; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_Z x y H); reflexivity.\n(* S y *)\nintros; rewrite (tech_mult_neg_ZQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 739,
                "proof_start_offset": 14446,
                "proof_end_offset": 14693,
                "proof": "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact addZ_commutativity.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit.\nexact multZ_associativity.\nexact mult_add_distributivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nred in |- *; intros; elim x.\n(* S y *)\nsimple induction n.\n(* Case y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nsimple induction n.\n(* abs (S y) *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_to_nat in |- *; apply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_P.\napply Z_to_PQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold Z_ring; intros; elim x.\n(* S y *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(*Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold not in |- *; intro; elim x.\n(* In the previous result *)\nunfold not in |- *; intro; elim x.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(* In the equality *)\nintros y H; rewrite (tech_mult_neg_Z y H); reflexivity.\n(*Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nintros; elim (mult_opp_pred x y).\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* negQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nintros; elim x.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple inductionQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nintro; elim x.\n(* 0 *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)\nreflexivity.\n(* - S y *)Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold Z_ring; intros; elim x.\n(* 0 *)\nunfold multZ in |- *; reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_mult_neg_pos_Z y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred y (pos n)).\nelim (mult_opp_pred yQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nsimple induction n.\n(* - S y *)\nsimple induction n.\n(* n = 0 *)\nintros y H; rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite H; elim (mult_oppZ_l y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite H; rewrite (tech_mult_neg_Z y (pos m)) in H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H; rewrite H;\n  rewrite (tech_mult_neg_Z y (pos m)) in H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\n",
                "context_tokens": 728,
                "proof_start_offset": 14731,
                "proof_end_offset": 14951,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nexact multZ_commutativity.\nexact multZ_neutral.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact ZL_mult_pos.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact ZL_zero.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold Z_unit in |- *; simpl in |- *;\n reflexivity.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold Z_unit in |- *.\nsplit.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_exact Z_unitary_exact Z_unitary_exact Z_unitary_exact Z_unitary_exact Z_unitary_exact Z_unitary_exact Z_unit_ exact Z_unit_unit.\nexact Z_unitary_exact Z_unitary_exact Z_unit_ary_exact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_ary_exact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_I_I.\nexact Z_unit_ary_exact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_I.\nexact Z_unit_ary_exact Z_unit_ary_exact Z_Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact absZ.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_exact Z_unit_ary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexact Z_unit_ary_ring.\nexactQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nunfold is_ring in |- *.\nsplit. exact absZ_zero.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit.\nexact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact ZQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring.\nsplit. exact absZ_of_group.\nunfold is_ring.\nsplit. exact absZ_of_group.\nunfold is_ring.\nsplit. exact absZ_of_group.\nunfold is_ring.\nunfold is_ring.\nsplit. exact absZ_of_group.\nunfold is_ring.\nunfold is_ring.\nsplit. exact absZ_of_group.\nunfold is_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit.\nexact Z_unitary_exact.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15006,
                "proof_end_offset": 15394,
                "proof": "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z n); reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x.\nelim n.\n (* x = 0 *)\nintros.\nrewrite (tech_mult_pos_pos_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_pos_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 1); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 1); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_mult_neg_eq (pos n) 0); trivial.\nrewrite <- (tech_Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; case x.\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (mult_comm n x).\n(* abs *)\nintros; apply le_plus_n_Sm.\nelim (multQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; case x; intros; try assumption.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; case x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim x.\nintros; elim xQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; case x.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimplQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x; intros; rewrite H; assumption.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim n.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_Z n x); reflexivity.\n(* 0 *)\nintros n x H0; rewrite (tech_mult_neg_ZQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0 *)\nintros n; case x.\n(* 0Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x H; unfold multZ in |- *; rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15419,
                "proof_end_offset": 15807,
                "proof": "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(* pos n0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* 0Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n; elim x.\n(* 0 *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_pos_eq n (pos n0) (pos n0)); intros.\nabsurd (pos (n0 + (n0 + n0)) = pos n0).\n discriminate.\n(* pos n0 *)\nintros n1; rewrite (tech_mult_pos_eq n (pos n0) (pos n0)); intros.\nabsurd (pos (n0 + (n0 + n0)) = pos n0).\n discriminate.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\n(* 4Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(*/x *)\nunfold multZ in |- *; simpl in |- *; reflexivity.\n(*/x *)\nintros x H; rewrite (tech_mult_pos_pos_Z n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (n0 + n0)).\n discriminate.\n(*/x *)\nintros n0; rewrite (tech_mult_pos_Z n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (n0 + n)).\n discriminate.\nrewrite <- (tech_mult_pos_Z n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (n0 + n)).\n discriminate.\nrewrite H; elim (mult_opp_l n0); intros.\nabsurd (pos (n0 + (n0 + n0)) = pos (n0 + n)).\n discriminate.\nrewrite H; elim (mult_opp_l n0); intros.\nabsurd (pos (n0 + (n0 + n0)) = pos (Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(* x <> 0 *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* 0 *)\nintros n H; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + m)) = pos n0).\n discriminate.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* 0 *)\nintros n0; rewrite (tech_mult_neg_pos_eq n0); intros.\nabsurd (pos (n0 + (n0 + n0)) = pos 0). reflexivity.\napply H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple inductionQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros n0; rewrite (tech_mult_pos_pos_pos n n0); intros.\nabsurd (neg (n * n0)) = 0). discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Qed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 15829,
                "proof_end_offset": 16089,
                "proof": "Theorem integrityZ : integrity Z multZ OZ.\nProof.\nunfold integrity in |- *; intros a b; elim a.\nintros; left; reflexivity.\nintros; right; apply (tech_integ_posZ n b); exact H.\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold IntZ in |- *.\nsplit.\nexact (Z_to_Q_zero (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.absQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold is_zero in |- *.\nsplit.\nexact (mult_neg_neg_Z n); intros.\nabsurd (neg (n * n0)) = pos (S (S n0 + n0)). discriminate.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold integ in |- *.\nsplit.\nexact (multZ_neg_neg_eq n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (S n0 + n0)).\n discriminate.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_pos_eq n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (S n0 + n0)).\n discriminate.\napply mult_comm.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZR.\napply le_IZRQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold IntZ in |- *; intros.\nabsurd (neg (S n0 + (n0 + n0)) = pos (S n0 + n0)).\n discriminate.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integ in |- *.\nunfold integQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold not in |- *; intro; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim HQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nunfold ZQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold not in |- *; intro; apply lt_O_n.\n(* pos n0 *)\nTheorem pos_neg_neg : forall n : nat, pos (neg n) = pos (neg (neg n)).\nintros n; rewrite (tech_mult_neg_neg_Z n n); intros.\nabsurd (neg (n * n0) = neg (neg n)). discriminate. exact H.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_neg_Z n n0); intros.\nabsurd (neg (n * n0) = pos (neg n)). reflexivity. exact H.\n(* neg n0 *)\nintros; rewrite (tech_mult_neg_neg_Z n n0); intros.\nabsurd (neg (n * n0) = pos (neg n)). reflexivity. exact H.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold not in |- *; intros; elim H.\n(* Here's the same result *)\n(* The same result *)\n(* the same result *)\n(* the same result *)\n\nTheorem add_zero_l :\n forall (n : nat) (x y : Z),\n (0 <= x)%Z -> (x <= y)%Z -> (x <= y)%Z -> (y <= x)%Z.\nProof.\nintros n x y; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold IntZ in |- *; simpl in |- *; intros; elim H; auto.\n(* pos n0 *)\nintros; rewrite (tech_mult_neg_pos_pos_Z n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = 0). discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\n",
                "context_tokens": 722,
                "proof_start_offset": 16118,
                "proof_end_offset": 16787,
                "proof": "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros; elim m.\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros.\nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)).\nrewrite (mult_neutr (S n)).\nunfold posOZ in |- *; reflexivity.\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)); elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* 0 *)\nintros; right; apply (tech_poseg_posZ n); exact H.\n(* - pos n *)\nintros; right; apply (tech_poseg_negZ n); exact H.\n(* - pos n *)\nintros; left; apply (tech_poseg_negZ n); exact H.\n(* - pos n *)\nintros; right; apply (tech_negeg_negZ n); exact H.\n(* - pos n *)\nintros; right; apply (tech_negeg_negZ n); exact H.\n(* - pos n *)\nintros; right; apply (tech_neg_pos_pos n); exact H.\n(* - pos n *)\nintros; right; apply (tech_neg_pos_pos n); exact H.\n(* - pos n *)\nintros; right; apply (tech_neg_pos_pos n); exact H.\n(* - pos n *)\nintros; right; apply (tech_neg_pos_pos n); exact H.\n(* - pos n *)\nintros; right; apply (tech_neg_pos n); exact H.\n(*Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; case m; trivial.\nintros; right; apply (tech_integ_negZ n m); exact H.\n(* pos n *)\nintros n0; rewrite (tech_mult_pos_neg_pos_pos_Z n m); intros.\nabsurd (neg (n * n0)) = pos (S n0 + (n0 + n0)). reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* neg n *)\nintros; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* neg n *)\nintros; left; apply (tech_mult_pos_pos_pos n m); exact H.\n(* neg n *)\nintros; right; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; right; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; left; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; right; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; right; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; left; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; left; apply (tech_mult_pos_pos n m); exact H.\n(* neg n *)\nintros; left; apply (tech_mult_pos_posQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; rewrite (tech_mult_neg_neg_pos_pos n m); intros.\nabsurd (pos (S m) = pos 0). discriminate.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nunfold Z.abs; case m; trivial.\n(* neg n0 *)\nintros; right; apply (tech_neg_pos_pos_pos n); exact H.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_neg_neg_pos n0); intros.\nabsurd (neg (n * S n0) = pos 0). discriminate.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; elim n.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (pos (n * S m)) = pos (n * S m + (S n0 * S m)).\n discriminate.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_neg_pos_Z n0); intros.\nabsurd (pos (n * S m)) = pos (n * S m + (S n0 * S m)).\n discriminate.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; rewrite (tech_mult_neg_neg_Z n m); intros.\nabsurd (pos (m * S m) = pos m). trivial. exact H.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; rewrite (tech_mult_neg_pos_pos_Z n m); intros.\nabsurd (pos (n * m)) = pos (S n * S m). discriminate.\n exact H.\n(* pos n0 *)\nintros; right; apply (tech_pos_pos_pos_pos_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_pos_pos_pos_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_pos_pos_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_pos_pos_pos n m); exact H.\n(* neg n0 *)\nintros; right; apply (tech_pos_pos_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_pos_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_neg_pos n m); exact H.\n(* neg n0 *)\nintros; left; apply (tech_neg_pos n m); exactQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nunfold pos in |- *; intros; elim a.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_neg_pos n m); intros; apply (tech_neg_pos_pos n m); exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_neg_pos n m); intros; apply (tech_neg_pos_pos n m); exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_neg_pos n m); intros; apply (tech_pos_pos n m); exact H.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_pos_pos n m); intros; apply (tech_neg_pos n m); exact H.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_pos_neg n m); intros; apply (tech_neg_pos n m); exact H.\n(* pos n0 *)\nintros; right; apply (tech_neg_pos n m); exact H.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n; elim n; auto with arith.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_pos_pos n n0); intros.\nabsurd (neg (n * n0)) = 0).\n discriminate.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_neg_pos n n0); intros.\nabsurd (neg (n * S m)) = 0).\n discriminate.\nelim (plus_neg_neg_pos_pos n0); intros.\nabsurd (neg (n * S m)) = 0).\n discriminate.\nrewrite (tech_mult_neg_neg_neg_pos n n0); intros.\nabsurd (neg (n * S m)) = 0).\n discriminate.\nelim (plus_neg_neg_pos n0); intros.\nabsurd (neg (n * S m)) = 0).\n discriminate.\nrewrite (tech_mult_neg_neg_pos n0); intros.\nabsurd (neg (n * S m)) = 0).\n discriminate.\nrewrite (tech_mult_neg_neg_pos n m); intros.\nabsurd (neg (n * SQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\n",
                "context_tokens": 721,
                "proof_start_offset": 16816,
                "proof_end_offset": 17035,
                "proof": "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* S y *)\nelim multZ_reg_l with (pos (S n) * m + n * S m).\nunfold pos)))); auto with arith.\n(* S y *)\nintros n0; rewrite (tech_mult_pos_pos_pos_Z m n0); intros.\nabsurd (pos (S n0 * S m + n0 * S m + n0)).\napply le_lt_trans with (pos (S n0 * S m + n0)).\napply le_lt_trans with (pos (S m + n0 * S m + n0)).\napply le_trans with (pos (S n0 * S m + n0)).\napply le_trans with (pos (S n0 * S n0)).\napply le_S_n.\napply le_trans with (pos (S n0 * S m + n0)).\napply le_trans with (pos (S n0 * S m + n0)).\napply le_trans with (pos (S m + n0)).\napply le_trans with (pos (S n0 * S n0)).\napply le_trans withQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim m.\n(* n0 *)\nintros n0; rewrite (tech_mult_neg_pos_pos n0); intros.\nabsurd (pos (S n0 * S m)); auto with arith.\nelim mult_pos_pos_pos_pos; assumption.\nelim (mult_comm 1 (S n0)).\nrewrite (tech_mult_pos_pos_pos_Z n0); intros.\nabsurd (pos (S (S n0 * S m)) = pos (S n0 * n)).\n discriminate.\nrewrite (tech_mult_neg_pos_Z n0); intros.\nabsurd (pos (S (S n0 * S n)) = pos (S n0 * n)).\n discriminate.\nrewrite (tech_mult_neg_pos_Z n0); intros.\nabsurd (pos (S n0 * S m)) with 0.\n discriminate.\nrewrite (tech_mult_pos_pos_Z n0); intros.\nabsurd (pos (S n0 * S m)) = pos (S n0 * n)).\n discriminate.\nrewrite (tech_mult_neg_pos_Z n0); intros.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros n m; elim m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)\nsimple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* x *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.\n(* S y *)simple induction m.Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros n m; elim m.\n(* n0 *)\nintros n0; rewrite (tech_mult_pos_pos_neg_eq n0); intros.\nabsurd (pos (S n0 * S m + n0)) = pos (S n0 * m).\n discriminate.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* n0 *)\nintros; right; apply (tech_mult_pos_pos_pos_pos n (pos m)); exact H.\n(* n0 *)\nintros; left; apply (tech_mult_pos_pos_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos n (pos m)); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos n (pos m)); exact H.\n(*Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos_pos 2).\nrewrite (tech_mult_pos_neg_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); assumption.\napply H0.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos 2).\nrewrite (tech_mult_neg_pos_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); intros.\nabsurd (pos (S n * S y + n)).\napply (tech_mult_pos_pos 2); intros.\nabsurd (pos (S n * SQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* n0 *)\nintros n0; rewrite (tech_mult_pos_pos_pos_Z n n0); intros.\nabsurd (pos (S n0) = 0). discriminate.\nrewrite (tech_mult_pos_pos_pos_Z n0); intros.\nabsurd (pos (S (S (S n0 + n0))) = 0). discriminate.\nrewrite (tech_mult_pos_pos_Z n0); intros.\nabsurd (pos (S (S n0 + n0)) = 0). discriminate.\nrewrite (tech_mult_pos_pos_Z n0); intros.\nabsurd (pos (S (S (S (S n0 + n0))) = 0). discriminate.\nrewrite (tech_mult_pos_Z n0); intros.\nabsurd (pos (S (S (S (S n0 + n0))) = 0). discriminate.\nrewrite (tech_mult_pos_Z n0); intros.\nabsurd (pos (S (S (S n0 + n0)) = 0). discriminate.\nrewrite (tech_mult_pos_Z n0); intros.\nabsurdQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros n m; elim n.\n(* S y *)\nintros n m H; elim (mult_comm 0 (S n)) (S y)).\n(* S y *)\nintros n m H; rewrite (tech_mult_pos_pos_neg_eq n m H); intros.\nabsurd (neg (S n * S y + n0)) with 0; auto.\nrewrite H0.\nelim (mult_comm 1 (S x)).\nrewrite (tech_mult_pos_pos_eq n m H); intros.\nabsurd (pos (S (S m * S y + n0)) = pos (S (S n * m + n0))%nat; auto.\nrewrite H0.\nelim (mult_comm 1 (S x)).\nrewrite (tech_mult_pos_eq n m H); intros.\nabsurd (pos (S (S m * S y + n0)) = pos (S (S (S n * m + n0)))%nat; auto.\nrewrite H0.\nelim (mult_comm 1 (S x)).\nrewrite (tech_mult_pos_eq n m H); intros.\nabsurd (pos (S n *Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros n m; elim m.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; left; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_pos_pos 2); exact H.\n(* 0 *)\nintros; right; apply (tech_mult_posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 17054,
                "proof_end_offset": 17961,
                "proof": "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n q r; elim q.\nelim r.\nintros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *; reflexivity.\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (tech_mult_pos_pos_pos q); intros.\nrewrite (tech_mult_neg_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_posQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros; elim (tech_mult_pos_pos_pos_pos_pos n m); elim (mult_comm (pos n) (pos authors) r).\nrewrite (tech_mult_pos_pos_pos_pos n m); intros.\nabsurd (pos (S n * n0)) = pos (S (S n0 * S n0)) by omega.\nrewrite (tech_mult_pos_pos_pos n m); intros.\nabsurd (pos (S n0 * S n0)) = pos (S n0 * S n0)). reflexivity.\nrewrite (tech_mult_pos_pos_pos n m); intros.\nabsurd (pos (S n0 * S n0)) with (S n0 * S n0). reflexivity.\nrewrite (tech_mult_pos_pos_pos n m); intros.\nabsurd (pos (S n0 * S n0)) = pos (S (S n0 * S n0))); [ idtac | ring ].\nrewrite (tech_mult_pos_pos_pos n m); intros.\nabsurd (pos (S n0 * S n0)) = pos (S (S n0Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros; elim n0.\n (* O *)\nrewrite (tech_mult_pos_pos_pos n p0); simpl in |- *; elim (mult_comm 1 (S n0)).\nrewrite (tech_mult_pos_pos_pos n0); simpl in |- *; elim (mult_comm 1 (S n0));\n reflexivity. \nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim r.\n(* O *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S y *)\nsimple induction n0; simpl in |- *; intros; reflexivity.\n(* S yQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (tech_mult_pos_pos_pos n r).\nsimpl in |- *; elim (mult_comm (pos n) (pos Qone)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos x) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *; elim (mult_comm (pos n) (pos y)).\nsimpl in |- *;Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (tech_mult_pos_pos_pos n m).\nsimpl in |- *; elim (mult_assoc_pos_pos_pos_pos n m).\nsimpl in |- *; elim (mult_comm n m); elim (mult_comm n m); elim (mult_comm m n);\n reflexivity. \nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros; elim r; simpl in |- *; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H1; intros; elim H1; intros; elim H3; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H1; intros; elim H3;\n intros; elimQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim r.\n(*... *)\nintros n0; rewrite (tech_mult_neg_neg_neg_neg_neg_pos n0); intros.\nabsurd (pos (S n0) = pos (S n0)). apply H.\nrewrite H; reflexivity.\n(*... *)\nintros n0; rewrite (tech_mult_neg_neg_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim n.\n(* 0 *)\nintros n0; rewrite (tech_mult_pos_neg_pos_neg_pos n0); trivial.\n(* 1 *)\nintros n0; rewrite (tech_mult_neg_pos_pos n0); trivial.\n(* 1 *)\nintros n1; rewrite (tech_mult_neg_pos_neg_pos n0); trivial.\n(* 2 *)\nintros n0; rewrite (tech_mult_neg_pos_pos n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg_pos n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg_neg n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg_pos n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg n0); trivial.\n(* 2 *)\nintros n1; rewrite (tech_mult_neg_neg_pos n1);Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (tech_mult_pos_pos_pos_pos n m).\nsimpl in |- *; elim (mult_assoc 1 (S n0) (pos Dz)).\nelim (mult_assoc 1 (S n0) (pos Dz)).\nelim (mult_assoc 1 (S n0) (pos Dz)).\nrewrite (tech_mult_pos_pos_pos_pos_pos_pos n m).\nunfold pos in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 17980,
                "proof_end_offset": 18420,
                "proof": "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\nsimpl in |- *; intros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold negOZ in |- *.\nrewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q r; elim r.\n(* O *)\nelim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro r; elim r.\n(* O *)\nintro rQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* O *)\nintros; elim (mult_comm 1 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n0)).\nrewrite (plus_comm 1 (pos n)).\nrewrite (plus_comm (pos n0)).\nrewrite (plusQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q H; elim (mult_comm 1 (pos n)).\nsimpl in |- *; intros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nintros; elim (mult_comm 1 (pos n0)); simpl in |- *.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* O *)\nelim mult_assoc.\nintros; absurd (S n0 = 0). discriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim q.\n(* O *)\nintro; elim (mult_comm 0 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (mult_comm 1 (pos n)).\n(* O *)\nintro; elim (multQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim n0; simpl in |- *; intro; rewrite (mult_comm n0).\nelim (mult_comm 1 (S n0) q).\nelim (mult_comm 1 (S n0) q).\nunfold pos at 1 in |- *; rewrite (mult_comm n0).\nelim (mult_comm 1 (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nelim (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (S n0) q).\nrewrite (mult_comm (SQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* O *)\nelim mult_pos_pos.\nintros; elim (plus_comm 0 (S n0) (pos Dz)).\n(* O *)\nelim mult_pos_pos.\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nelim mult_pos_pos_pos.\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nelim mult_neg_pos_pos.\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nintros; elim mult_neg_pos.\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nintros; elim mult_neg_pos.\nintros; elim (mult_comm 0 (S n0) (pos Dz)).\n(* O *)\nintros; elim (mult_comm (S n0) (pos Dz)).\n(* O *)\nintros; elim mult_neg_pos.\nintrosQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q r; elim r.\n(* O *)\nelim r.\n(* O *)\nintros n0 q r; elim r.\n(* O *)\nintros n1 q r; elim r.\n(* O *)\nintros n1 q r; elim r.\n(* O *)\nintros n1 q r; elim r.\n(* O *)\nintros n2 q r; elim r.\n(* O *)\nintros n3 r; elim r.\n(* O *)\nintros n1 q r; elim r.\n(* O *)\nintros n3 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n5 r; elim r.\n(* O *)\nintros n4 r; elim r.\n(* O *)\nintros n5 r; elim r.\n(* O *)\nintros n4 r; elimQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* O *)\nelim (mult_comm n0 q).\nsimpl in |- *; elim (mult_comm n0 q).\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q r; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintros; elim r.\n(* O *)\nintrosQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 711,
                "proof_start_offset": 18440,
                "proof_end_offset": 19318,
                "proof": "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros; elim q.\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)).\ncut (IZ = pos 0); intros.\nelim H.\nrewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity.\nreflexivity.\nintros y H; unfold posOZ in |- *; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y) (pos n)) (pos n) I I).\nelim (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. \nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. \nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; introsQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros;Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. \nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros; elim (mult_assoc n q); simpl in |- *;\n reflexivity.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0). discriminate.\n(* (S y) *)\nintros; absurd (S y = 0Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate.\nsimpl in |- *; introsQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S (S (S (S (S (S (S (S (S (S (S (S n0))))%nat) * S n0)).\nrewrite H0; apply H1.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0).\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_n_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_n_n.\n apply le_S_n.\n apply le_S_n.\n apply le_S_n.\n apply le_n.\n apply le_S_n.Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* n = 0 *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 719,
                "proof_start_offset": 19338,
                "proof_end_offset": 19708,
                "proof": "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n)); elim (minus_n_O n).\nreflexivity.\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry in |- *.\nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim q.\n(* S y *)\nsimpl in |- *; intros; elim (mult_assoc n q r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *; elim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelim (mult_comm r r); simpl in |- *.\nelimQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim r; intros; elim r; intros; elim r; intros; elim r; intros; elim r;\n [ idtac | elim (mult_comm (pos n)); elim (mult_comm (pos n) r);\n reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n = 0).\nauto with arith.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0).Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n > r). discriminate.\nunfold pos in |- *; rewrite (plus_comm (S (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S n))); apply le_n_O.\nunfold pos in |- *; rewrite (plus_comm (S (S (S n))); apply le_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* S y *)\nsimpl in |- *; intros; absurd (S x = 0).\nauto.\nsimpl in |- *; intros; absurd (S y = 0).\nauto.\nsimpl in |- *; intros; absurd (S y = 0).\nauto.\nsimpl in |- *; intros; absurd (S y = 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nauto.\nsimpl in |- *; intros; absurd (S y = S 0).\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S (S n0) = S (S n0)).\n reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* O *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear H.\n(* S y *)\nsimpl in |- *; intros; elim H; clear HQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = S n0).\napply lt_O_Sn.\nelim (mult_comm r (S n0) (pos n0)).\nintros; elim (mult_comm r (S n0) (pos (S n0))).\napply lt_O_Sn.\nelim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (S n0))).\nintros; elim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (S n0))); reflexivity.\nintros; elim (mult_comm r (S n0) (pos (SQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0). discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 19727,
                "proof_end_offset": 20249,
                "proof": "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r))) .\nrewrite (tech_div31 n q).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0).\n discriminate.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nunfold pos)))); simpl in |- *; intros.\nelim H.\n(*O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (mult_comm r n).\n(* O *)\nunfold pos in |- *; rewrite (mult_comm r).\nelim (Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0); intro; auto.\nelim (minus_n_O n0).\nunfold pred in |- *; intro; absurd (S n0 = 0); intro; auto.\nrewrite (mult_comm (S n0)).\nelim (mult_comm (pos n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r; auto.\n(* S y *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S y)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewriteQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* S y *)\nsimpl in |- *; intros; absurd (S x0 = 0).\nreflexivity.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nunfold pos at 1 in |- *; unfold oppZ in |- *; rewrite (opp_involutive (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite <- (mult_comm (pos nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros;\n rewrite H4; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0); intros; elim H4; intros; elim H4; intros; elim H5;\n rewrite H4; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S y = 0); intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9;Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r; simpl in |- *; intros; elim H0; intros.\nrewrite H1; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S n0 = 0).\nelim (mult_comm r r).\nunfold pos in |- *; unfold oppZ in |- *; simpl in |- *; rewrite (add_IZR (pos n)).\nelim (mult_assoc r r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewrite <- (opp_involutive r).\nrewriteQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nunfold pos in |- *; unfold oppZ in |- *; rewrite (add_comm n0); reflexivity.\n(* S y *)\nintros y H; unfold neg)))); rewrite (add_comm y H).\nelim (mult_assoc n y H).\n(* O *)\nunfold pos in |- *; unfold oppZ in |- *; rewrite (add_comm y H); reflexivity.\n(* S y *)\nintros y H; unfold pos in |- *; unfold oppZ in |- *; rewrite (add_comm y H); reflexivity.\n(* S y *)\nintros x H; unfold pos in |- *; rewrite (opp_comm y H).\nelim (mult_assoc n y H).\n(* S y *)\nintros y H; unfold neg in |- *; rewrite (opp_comm y H).\nelim (mult_assoc n y H).\n(* S y *)\nintros y H; unfold pos in |- *; rewrite (opp_comm y H).\nelim (mult_assoc n y H).\n(* S y *)\nintros y H; unfold pos in |- *; rewrite (opp_comm y H).\nelim (mult_assoc n y H).Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r; simpl in |- *; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H1; intros; elim H3; intros; elim H1;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 20268,
                "proof_end_offset": 20706,
                "proof": "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n0 q r; elim r.\n(* O *)\nunfold pos))));\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite opp_opp_involutive.\nunfold oppZ in |- *; rewrite (opp_involutive 0).\nunfold oppZ in |- *; rewrite opp_opp_involutive.\nunfold oppZ in |- *; rewrite opp_opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n unfoldQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros.\nelim (tech_opp_pos_pos_pos (pos n) (pos eps)); intros; elim H1; intros; elim H1; intros; elim H2;\n rewrite (mult_opp_r (pos n0)) (pos n0)).\nelim (tech_opp_pos_pos (pos n) (pos n0)).\nrewrite (tech_opp_pos_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nrewrite (tech_opp_pos_Z n0 (pos n0)).\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r.\n(* 0 *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S n0)). \nelim (mult_comm (S n0) (pos (S n0))); reflexivity.\n(* 0 *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S n0) (S n0)). \nelim (mult_comm (S n0) (pos (S n0))); reflexivity.\n(* 0 *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S n0) (S n0)). \nelim (mult_comm (S n0) (pos (S n0))); reflexivity.\n(* 0 *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S n0) (S n0)).\nelim (mult_comm (S n0) (pos (S n0))); reflexivity.\n(* 0 *)\nunfold pos)))); simpl in |- *; rewrite (plus_comm (S n0) (S n0)). \nelim (mult_comm (S n0) (pos (S n0))); reflexivity.\n(* 0 *)\nunfold pos)))); simplQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 q r; elim r.\n(* O *)\nunfold pos at 1 in |- *; unfold oppZ in |- *; rewrite (add_commut (Z.neg n0)).\nelim (mult_comm r (pos (S n0) (pos n0))); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 q r; elim r.\n(* O *)\nunfold pos)))); simpl in |- *; rewrite (mult_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plus_comm (pos n0)).\nrewrite (plusQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_div3 n0 n0 q r H); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 q r; elim r.\n(* O *)\nunfold pos)))); simpl in |- *; unfold oppZ in |- *; rewrite (opp_involutive (pos n)).\nelim (mult_nonneg_pos_pos n0 q r H); intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; introsQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos_pos n0 n0 q r H); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos_pos n r); intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 q r; elim r; elim r;\n [ elim r0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 20725,
                "proof_end_offset": 21054,
                "proof": "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; cut (posOZ q = oppZ (negOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; apply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div4.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napply tech_div3.\napplyQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 q r; elim r.\n(* S x *)\nintros; elim (tech_opp_pos_pos_pos n); intros; elim H1; intros; elim H2; intros.\nrewrite H2; rewrite (mult_opp_opp Z IdZ)); rewrite H2.\nelim (mult_opp_opp Z IdZ\"); intros; elim H1; intros.\nrewrite H1; rewrite (mult_opp_opp Z IdZ)); rewrite H2.\nelim (mult_opp_opp Z IdZ); intros; elim H1; intros.\nrewrite H1; rewrite (mult_opp_opp Z IdZ); rewrite H2.\nelim (mult_opp_opp Z IdZ); intros; elim H1; intros.\nrewrite H1; rewrite (mult_opp_opp Z IdZ); rewrite H2.\nelim (mult_opp_opp Z IdZ); intros; elim H1; intros.\nrewrite H1; rewrite (mult_opp_opp Z IdZ); rewrite H2.\nelim (mult_opp_opp Z IdZ); intros; elim H1; intros.\nrewrite H1; rewrite (mult_opp_Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; elim n0; simpl in |- *; intros; elim H1; intros; elim H1; intros;\n rewrite (mult_opp_r (pos n0) (pos nw) H1).\nelim (mult_opp_r (pos n0) (posnZ q) I); intros; elim H1; intros; elim H2; intros;\n rewrite (mult_opp_r (pos n0) (posnZ q) H1).\nelim (mult_opp_r (posnZ q) (posnZ q) I); intros; elim H1; intros; elim H2; intros;\n rewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_r (posnZ q) H2).\nrewrite (mult_opp_r (posnZ q) H1).\nrewrite (mult_opp_Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n0; simpl in |- *; intros; elim H1; intros.\nrewrite (mult_opp_l (pos n0) (pos Qone))); rewrite (tech_div3 (pos n0) (pos Qone));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone)); rewrite (tech_div3 (pos n0) (pos Qone));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone)));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone)); rewrite (tech_div3 (pos n0) (pos Qone));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone));\n rewrite (tech_div2 (pos n0) (pos Qone) (pos Qone)); rewrite (tech_div2 (pos n0) (pos Qone) (pos Qone)));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone));\n rewrite (tech_div3 (pos n0) (pos Qone) (pos Qone)); rewrite (tech_div2 (pos n0) (pos Qone) (Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n0; intros; elim H1; intros; elim H1;\n rewrite (mult_opp_Z n0 (posstod m)); rewrite (tech_div2 n0 q r H0).\nelim (mult_opp_pos_pos n0 (posstod m)); intros; elim H1; intros; elim H1;\n rewrite (mult_opp_Z n0 (posstod m)); rewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0).\nrewrite (tech_div2 n0 q r H0Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; apply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napply tech_div2.\napplyQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim (tech_opp_pos_pos n0 n); intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros;Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n0; elim n1; elim n2; elim n2;\n reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n0; elim n1; simpl in |- *; intros;\n unfold oppZ in |- *; rewrite (add_comm (pos n0) (pos Qone));\n elim (opp_opp_opp Z IdZ)); intros; elim H1;\n rewrite (opp_involutive Z IdZ); rewrite H0.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 21073,
                "proof_end_offset": 21415,
                "proof": "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (negRat (pos n) (pos n) = 0); intros.\nrewrite H0; intros; exact (tech_div3 n0 n r H).\nrewrite (mult_opp_opp_r (pos n) (pos n) (pos n) (pos m) H0).\nrewrite (mult_opp_opp_r (pos n) (pos n) (neg n) (neg m) H0).\nrewrite (mult_opp_r (pos n) (pos n) (pos n) (neg m) H0).\nrewrite (mult_opp_opp_r (pos n) (pos n) (neg n) H0).\nrewrite (mult_opp_l (pos n) (pos n) (pos n) (neg m) H0)).\nrewrite (mult_opp_r (pos n) (pos n) (pos m) H0).\nrewrite (mult_opp_opp_l (pos n) (pos n) (neg n) H0).\nrewrite (mult_opp_r (pos n) (pos n) (neg m) H0).\nrewrite (mult_opp_l (Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros.\nelim (tech_opp_pos_pos_pos n); intros; elim H1.\nrewrite (mult_opp_opp_opp Z IdZ));\n elim (tech_opp_pos_pos n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ); elim (tech_opp_pos_pos n); intros; elim H2.\nrewrite (mult_opp_opp_opp Z IdZ); elim (tech_opp_pos n); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ); elim (tech_opp_pos n); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ); elim (tech_opp_neg_pos n); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ); elim (tech_opp_pos n); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ); elim (tech_opp_pos n); intros; elim H2.\nrewrite (mult_opp_opp_opp Z IdZ); elim H2.\nrewrite (mult_opp_opp Z IdZ); elim (techQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros.\nelim (tech_opp_pos_pos n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ      \n      (mult_opp_opp Z IdZ      \n      (mult_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim r.\nintros; apply (tech_opp_pos_pos_pos n); intros; elim H1.\napply (mult_opp_opp Z IdZ || (pos n) (pos n) (pos alph)); reflexivity.\napply (tech_opp_pos_pos n0 (pos n) (pos n) (pos n) (pos n) (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos_pos n0 (pos n) (pos n) (pos n) (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos n0 (pos n) (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos n0 (pos n) (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos n0 (pos n) (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos n0 (pos n) (pos n) (pos n))); reflexivity.\napply (tech_opp_pos n0 (pos n)Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros n0 n0 q r; elim r; reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* n0 = 0 *)\nintros; rewrite H0; intros; exact (tech_div3 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n0 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2 n0 q r H).\n(* n1 = 0 *)\nintros; rewrite H1; intros; exact (tech_div2Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim r; reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim r.\nelim (tech_opp_pos_neg_pos n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ)); auto with arith.\nelim q; reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim r.\nunfold pos in |- *; unfold oppZ in |- *; rewrite (opp_involutive (S n0)); reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros n0 q r H0 H1 H2 H3.\nelim (tech_opp_pos_pos_pos n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ_]; auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZ); auto.\nrewrite (mult_opp_opp Z IdZQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 21436,
                "proof_end_offset": 22829,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nsimple destruct x.\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\nsimple induction n.\nintros; left; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (pos (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\nsimple induction n.\nright; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (neg (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nunfold inversible.\nrewrite (mult_opp_opp Z.abs_neg Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_neg) in H.\nrewrite (mult_opp_opp Z.abs_negQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nelim (tech_opp_pos_neg_neg_neg_neg_neg); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ Zint radix); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ Zint); intros; elim H4Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (tech_opp_pos_pos_neg x); intros; elim H1.\nrewrite (mult_opp_opp Z IdZParity Z); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ)); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (multQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (tech_opp_pos_pos_neg Z_pos_pos); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ=>->.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZ); auto with zarith.\nrewrite <- (mult_opp_opp ZQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (tech_opp_pos_neg_pos x); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ)); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_oppQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x; elim (tech_opp_pos_pos_pos x); intros; elim H2.\nrewrite (mult_opp_opp Z IdZ NArith Nnat.Pos.id_pos) in H2.\nrewrite (mult_opp_opp Z IdZ NArith Nnat.Pos.id_pos) in H2.\nrewrite (mult_opp_opp Z IdZ NArith Nnat.Pos.id_pos) in H2.\nrewrite (mult_opp_opp Z IdZ NArith Nnat.Pos.id_pos) in H2.\nrewrite (mult_opp_opp Z IdZ NArith Nnat.Pos.id_pos) in H2.\nrewrite (mult_opp_opp Z.id_pos) in H2.\nrewrite (mult_opp_opp_opp Z.id_pos) in H2.\nrewrite (mult_opp_opp Z.id_pos) in H2.\nrewrite (mult_opp_opp Z.id_pos) in H2.\nrewrite (mult_opp_opp Z.id_pos) in H2.\nrewrite (mult_opp_opp Z.id_pos) in H2.\nrewrite (Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x H; elim H; intros; elim H; intros; auto with zarith.\nrewrite (mult_opp_opp Z IdZ)); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ)); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); auto with zarith.\nrewrite (mult_opp_opp Z IdZ); autoQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (tech_opp_pos_neg_pos x); intros; elim H1.\nrewrite (mult_opp_opp_neg x); reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros x; elim (tech_opp_pos_pos_pos x); intros; elim H2.\nrewrite (mult_opp_opp_neg x); rewrite <- H0; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim x; auto.\nintros; elim H2.\nrewrite (mult_opp_opp_opp Z IdZpexpr); auto with zarith.\nrewrite <- (mult_opp_opp Z IdZpexpr); auto with zarith.\napply (tech_opp_pos_pos x); auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\nLemma inversibleZ :\n forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\n\nsimple destruct x.\n(* OZ *)\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nintros; left; reflexivity.\n(* pos (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (pos (S y))). discriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\n(* neg n *) \nsimple induction n.\n(* neg O *)\nright; reflexivity.\n(* neg (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (neg (S y))). discriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.\n\n(************)\n",
                "context_tokens": 734,
                "proof_start_offset": 22846,
                "proof_end_offset": 23040,
                "proof": "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple destruct x.\nreflexivity.\nintros; exact (mult_IZ (pos n)).\nintros; exact (mult_mIZ (neg n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros.\nelim (tech_opp_pos_pos_pos x); intros; elim H; intros; elim H; intros;\n elim H; intros; elim H0; intros.\nabsurd (multZ (pos x) x0 = succZ x0).\nelim x0.\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x).\nrewrite (mult_comm x0).\nrewrite (mult_comm x).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm xQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* negative numbers *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)\nsimple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)simple induction x.\n(* t = (S x) *)Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\nsimpl in |- *; auto with zarith.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim HQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros.\nrewrite <- (abs_abs_abs_pos x).\nrewrite (abs_abs_pos x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_pos x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_abs_neg x).\nrewrite (abs_neg_neg x).Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* pos (S y) *)\nsimple induction x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* 0 *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* posQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *.\nauto.\n(* pos 0 *)\nsimple induction x.\nsimpl in |- *.\nauto.\n(* pos (S x) *)\nsimple induction x.\nsimpl in |- *.\nauto.\n(* pos (S x) *)\nsimple induction x.\nsimple induction x.\nsimple induction x.\nauto.\n(* pos (S x) *)\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nintros; simpl in |- *; reflexivity.\n(* var 0 *)\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x3.\nsimple induction x2.\nsimple induction x3.\nsimple induction x1.\nsimple induction x2.\nsimple induction x3.\nsimple induction x3.Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)simple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* pos n *)simple induction x.\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\n",
                "context_tokens": 307,
                "proof_start_offset": 1870,
                "proof_end_offset": 2140,
                "proof": "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intro.\n apply pred_ind.\n apply pred_ind.\n apply pred_ind.\n apply pred_ind.\n apply succ_ind.\n apply succ_ind.\n apply pred_ind.\n apply succ_ind.\n apply succ_ind.\n apply pred_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply pred_ind.\n apply succ_ind.\n apply succ_ind.\n apply pred_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_ind.\n apply succ_Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intros.\n apply pred_pos.\n assumption.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  intro.\n  unfold succZ in |- *.  apply pred_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos.  simpl in |- *.  apply succ_pos_pos.  simpl in |- *.\n  apply succ_pos_pos. Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  unfold succZ.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  apply pred_pos.\n  applyQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intros.\n apply pred_pos_pos.\n apply lt_le_weak.\n assumption.\n assumption.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intro x.\n intro.\n intro.\n apply False_ind.\n apply False_ind.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply HQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  intros.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n  intro.\n  case x.\n  (* neg n *)\n Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intros.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  intros x.\n  case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros; case x; auto.\n  intros;Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n intros.\n apply pred_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_pos.\n apply succ_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2160,
                "proof_end_offset": 2430,
                "proof": "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; apply pred_pos.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim (eq_dec x 0).\nrewrite (succ_neg_neg_neg_neg_neg_neg); assumption.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimplQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim x.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimpl in |- *; reflexivity.\n(* succ_pos x *)\nsimplQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim (succ_pred x); trivial.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimplQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim x.\n(* Focus 1 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* Focus 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 3 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 3 *)\nsimpl in |- *; reflexivity.\n(* no 2 *)\nsimpl in |- *; reflexivity.\n(* no 3 *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\n intros; apply pred_pos.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; apply succ_pos.\nreflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "******************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 471,
                "proof_start_offset": 2460,
                "proof_end_offset": 2604,
                "proof": "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl inQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_pred_pos or succ_pred_pos and succ_pred_pos and succ_pred_pos and succ_succ_pos and succ_pred_pos and succ_pos_pos.\n*)\nLemma pred_pred_pos : forall x : Z, succZ x = succZ x.\nProof.\nintros; pattern x in |- *; elim x.\n(* succ_pred_pos and succ_pred_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_pos_pos or succ_pos.\n*)\n\nLemma pred_pos : forall x : Z, succZ x = succZ x.\nProof.\nintros; pattern x in |- *; elim x.\n(* succ_pred_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_pos and succ_posQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(*... *)\nsimpl in |- *; reflexivity.\n(* gt n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |- *; reflexivity.\n(* Case n *)\nsimpl in |-Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\n(* succ_pred_Rlength *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl inQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* Zero *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |-Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                    *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\n",
                "context_tokens": 513,
                "proof_start_offset": 2627,
                "proof_end_offset": 2801,
                "proof": "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro; elim n; intro.\nelim (lt_n_O 0); exact H.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_Rlength n); exact (pred_pos_pos n).\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_pos_pred_pos _ H); exact (succ_pred_pos_pred _ H).\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_pred_pos_pred 0); reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; pattern n at 1 in |- *; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; pattern n in |- *; elim n.\nintros; rewrite (pred_predZ n); reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_involutive n); exact (succ_pred_posZ n).\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_pos_neg_neg n); reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_succ_pred_pos _ _ H).\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros n; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros n H.\npattern x in |- *; elim x.\n(* np *)\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* np *)\nintros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                  INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\nLemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\n\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H. intros; simpl in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 566,
                "proof_start_offset": 2826,
                "proof_end_offset": 2975,
                "proof": "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; simpl in |- *; reflexivity; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; rewrite (pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0);\nexact (succ_pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0); exact (succ_pred_pos 0).\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\n intro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite (pred_Rlength (pos Qone)); reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (le_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; intro.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\n(* 0 < pos n *)\nrewrite (pred_pred_pos pred_pos).\nelim n; intro.\n(* 0 < pos n *)\nrewrite (pred_pos pred_pos).\nelim (le_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_pos).\nelim (lt_pred_pos pred_posQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\n intro; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\n",
                "context_tokens": 158,
                "proof_start_offset": 1436,
                "proof_end_offset": 1965,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nexact (mult_IZ d1).\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros.\n apply gcd_sym.\n apply div_unique.\n apply div_unique.\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans with (Zabs b + 1).\n apply Z.le_trans withQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n  simple induction 1; intros.\n    apply Zlt_le_weak.\n    apply Zle_le_trans with (1 := H).\n    assumption.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _ H).\n intros.\n apply (Z_div_unique _ _Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2 H; elim H; intros H1 H2; elim H1; intros H2; elim H2; intros H3 H4; elim H2; intros H4 H5; elim H4;\n intros H5 H5 H6; elim H5; intros H6 H7; elim H6; intros H8 H8; elim H7;\n intros H8 H9; elim H8; intros H9 H10; elim H9;\n intros H10 H11; elim H10; intros H10 H11; elim H11; intros H11 H12;\n elim H12; intros H12 H12; elim H12; intros H13 H14 H14 H15 H15 H16 H17 H18 H19.\napply (cond_equal (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (p - q)) (fun p : Z => Rabs (Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2 H.\n case (Z_eq_dec a b).\n intro.\n left.\n apply Zplus_le_reg_l with (q := - a).\n rewrite <- (Zmult_1_l (q := a).\n rewrite <- (Zmult_1_l (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_l (q := a).\n rewrite (Zmult_1_l (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_l (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_l (q := a).\n rewrite (Zmult_1_r (q := a).\n rewrite (Zmult_1_r (q := a).Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; intros.\n simpl in |- *.\n apply Zle_antisym.\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (Zlt_le_weak _ _ H).\n apply (Zlt_le_weak _ _ _ H).\n apply (ZltQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2.\n case (Z_eq_dec a b).\n intro H.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_r.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_div_mult_l.\n assumption.\n intro.\n apply H.\n apply Z_divQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2 H.\n case (Zle_or_lt 0 (Zeven (Fnum p)) 0).\n intro H1.\n cut (0 < b)%Z.\n intro.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\n rewrite H1 in H1.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2 H0 H1 H2.\n apply gcd_unique.\n intro H0.\n rewrite H1.\n assumption.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n intros a b d1 d2 H0; elim H0; intros H1; elim H1; intros H2; elim H2; intros H3; elim H3;\n intros H4; elim H4; intros H5; elim H5; intros H6 H7;\n elim H4; intros H7; elim H6; intros H7; elim H7;\n intros H8 H8; elim H8; intros H9 H10; elim H8;\n intros H9 H10; elim H9; intros H10 H11; elim H10;\n intros H10 H11; elim H12; intros H12 H12; elim H12; intros H13 H13;\n elim H13; intros H13 H13 H14; elim H14; intros H14 H15;\n elim H14; intros H15 H16; elim H14; intros H15 H16; elim H15; intros H15 H16; elim H16;\n intros H16 H16; elim H17; intros H16 H17; elim H17;\n intros H17 H17; elim H17; intros H18 H19; elim H18;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\nLemma gcd_unicity_apart_sign :\n forall a b d1 d2 : Z,\n is_gcd Z IdZ multZ OZ a b d1 ->\n is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\n\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ\n    Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2. \nexact (mult_IZ d1).\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\n",
                "context_tokens": 373,
                "proof_start_offset": 1981,
                "proof_end_offset": 3327,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (abs_eq_or_oppZ b); intro y.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ b).\nintros; exact H0.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split.\nexact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry in |- *; exact (mult_IZ b).\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (oppZ x).\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nsymmetry in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim\n (gcd_dec Z_dec (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat_abs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat_abs_abs (Zabs_nat (Zabs_nat (Zabs_nat_abs_nat (Zabs_abs_nat (Zabs_nat (Zabs_nat_abs_abs_nat (Zabs_nat (Zabs_abs_nat (Zabs_nat_abs_abs_abs (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat_abs_abs_abs (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat_abs_abs (Zabs_nat (Zabs_nat_abs_abs_abs (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_absQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\n intros.\nelim (inversibleZ x); intros.\nleft. elim H0; intros.\nleft; elim H1; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim HQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (invetibleZ x); intros.\nleft. elim H1; intros.\nright. elim H1; intros.\nright. elim H1; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elim H4; intros.\nright. elim H2; intros.\nleft. elim H3; intros.\nleft. elim H3; intros.\nleft. elim H4; intros.\nright. elim H5; intros.\nright. elim H2; intros.\nright. elim H2; intros.\nright. elim H3; intros.\nright. elim H2; intros.\nleft. elim H3; intros.\nleft. elim H3; intros.\nright. elim H3; intros.\nright. elim H3; intros.\nright. elim H2; intros.\nright. elim HQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim\n (gcd_dec (a + b) (absZ b) (absZ b)).\nintro.\nelim (gcd_dec (a + b) (absZ b) (absZ b)).\nintro.\nelim (gcd_dec (a + b) (absZ b) (absZ b)); intros.\nelim (gcd_dec (a + b) (absZ b) (absZ b))).\nintro.\nelim (gcd_dec (a + b) (absZ b) (absZ b))).\nintro.\nelim (gcd_dec (a + b) (absZ b) (absZ b))); intros.\nelim (gcd_dec (a + b) (absZ b) (absZ b))); intros.\nelim (gcd_dec (a + b) (absZ b) (absZ b))); intros.\nelim (gcd_dec (a + b) (absZ b) (absZ b))); intros.\nelim (gcd_dec (a + b) (absZ b) (absZ b))); intros.\nelim (gcd_dec (a + b) (absZ bQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_nat b) (absZ b)).\nintros.\nelim (inversibleZ (Z_of_natQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (inversibleZ (fun n : nat => n * m)%Z).\nexact (mult_comm _ _ H).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim\n (gcd_unique_apart_zero _ _ H).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros. rewrite H2.\nexact (mult_comm (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_Zabs_eq (Zabs_eq (Zabs_Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_abs_eq (Zabs_eq (Zabs_eq (Zabs_eq (Zabs_Zabs_eq (Zabs_eq (ZabsQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\n intros.\nelim (inversibleZ x); intros.\nright. elim H1; intros. rewrite H2.\nelim (inversibleZ (inversibleZ x) (inversibleZ y) H0).\nintro.\nright. elim H1; intros. rewrite H0.\nelim (inversibleZ (inversibleZ x) (inversibleZ x) (inversibleZ x) H0).\nintro.\nright. elim H1; intros. rewrite H2.\nelim (inversibleZ (inversibleZ y) (inversibleZ (inversibleZ x) (inversibleZ y) H0).\nintro.\nelim (inversibleZ (inversibleZ (inversibleZ y) (inversibleZ x) (inversibleZ x) (inversibleZ y) H0)).\nintro.\nelim H1; intros.\nleft.\nelim H1; intros.\nrewrite H1.\nelim (inversibleZ (inversibleZ x) (inversibleZ x) (inversibleZ x) H1).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nsimple induction 1.\nsimpl in |- *.\n intros.\n elim (inversibleZ x); intros.\nleft.\n elim H1; intros; elim H2; intros.\nright; elim H1; intros; elim H2; intros.\nright; elim H2; intros.\nright; elim H1; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H2; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nleft; elim H3; intros.\nleft; elim H3; intros.\nright; elim H3; intros.\nright; elim H3; intros.Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nsimple induction 1; intros.\nleft; elim H1; intros; elim H1; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nleft; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2; intros.\nright; elim H2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\n\nintros. elim (abs_eq_or_oppZ b); intro y.\n(* |b|=b *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3865,
                "proof_end_offset": 4332,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros.\ncase (eq_OZ_dec n); intro.\nunfold P in |- *.\nintro.\nsplit with (absZ b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (divZ b n).\nintros.\ncut (lt_absZ r n); intros.\nelim (H r H0 n).\nintros.\nsplit with x.\napply gcd_mod with (2 := i); trivial.\ninversion i.\ndecompose [and] H1.\nunfold lt_absZ in |- *.\nrewrite (tech_le_pos_abs r H2).\nexact H4.\nexact n0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H; elim (le_n_O _ H); intros m H0.\napply lt_S_n.\n apply (H m).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n Hn Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P m) by tauto.\nintros m Hm.\nunfold P in |- *.\nassert (forall m : Z, (m <= n)%Z -> P mQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H; elim H; intros m H0.\nelim (H m); intros m H1.\nelim (H1 m); intros m H2.\nelim (H2 m); intros m H3.\nelim (H3 m); intros m H4.\nelim (H4 m); intros m H5.\nelim (H4 m); intros m H5.\nelim (H4 m); intros m H5.\nelim (H4 m); intros m H5.\nelim (H5 m); intros m H6.\nelim (H4 m); intros m H6.\nelim (H5 m); intros m H6.\nelim (H4 m); intros m H6.\nelim (H5 m); intros m H6.\nelim (H5 m); intros m H6.\nelim (H4 m); intros m H6.\nelim (H5 m); intros m H6.\nelim (H6 m); intros m H6.\nelim (H6 m); intros m H6.\nelim (H6 m); intros m H6.\nelim (H6 m); intros m H6.Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H.\nelim (le_n_O _ H).\nintros m H.\nelim H.\nintros m H.\nelim H.\nintros m H0.\nelim H0.\nintros m H1 H2.\nelim H1; intros m H2.\nelim H2.\nintros m H2.\nelim H2; intros m H3.\nelim H3.\nintros m H3 H4.\nelim H4; intros m H4.\nelim H4; intros m H4.\nelim H4; intros m H4.\nelim H4; intros m H5.\nelim H4; intros m H5 H6.\nelim H5; intros m H6.\nelim H5; intros m H6.\nelim H6; intros m H6.\nelim H6; intros m H6.\nelim H6; intros m H6.\nelim H6; intros m H6.\nelim H6; intros m H7.\nelim H6; intros m H7.\nelim H6; intros m H6.\nelim H7; intros m H7.\nelim HQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n H.\nelim (le_gt_dec n 0).\nelim (lt_n_O 0).\nelim (lt_n_O 1).\nelim (lt_O_O 1).\nelim (lt_n_O 1).\nelim (lt_O_O 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_O 1).\nelim (lt_n_O 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_n 1).\nelim (lt_O_Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n; elim n; intros m H1; elim H2; intros; elim H3; intros;\n    [ apply le_trans with (P := fun m : Z => m < n + m)%Z;\n      [ apply le_trans with (P := fun m : Z => m < n + m)%Z;\n        [ apply le_n_S; assumption | apply le_n_S; assumption ] ].\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H; elim H; intros.\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S n) (S m))).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S n) (S m)).\nexact (le_abs_eq (S m)).\nexact (le_abs_eq (S m) (S m)).\nexact (le_abs_eq (S m) (S m)).\nexact (le_abs_eq (S m) (S m)).\nexact (le_abs_eq (S m) (SQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H.\nelim (le_lt_or_eq (P m) 0); intro H; clear H.\nelim (le_or_eq (P n) 0); intro H; clear H.\nintros m H0.\nelim (le_or_eq (P m) 0); intro H0; clear H0.\nelim (le_or_eq (P m) 0); intro H1; clear H1.\nelim (le_or_eq (P n) 0); intro H1; clear H1.\nelim (le_or_eq (P m) 0); intro H1; clear H1.\nelim (le_or_eq (P m) 0); intro H2; clear H2.\nelim (le_or_eq (P m) 0); intro H2; clear H2.\nelim (le_or_eq (P m) 0); intro H3; clear H3.\nelim (le_or_eq (P m) 0); intro H4; clear H3.\nelim (le_or_eq (P m) 0); intro H4; clear H4.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n m H; elim H; intros m H; elim H; intros; elim H; intros; elim H; intros; elim H0;\n    intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n    intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n    intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n    intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n    intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H2;\n    intros; elim H2; intros; elim H4; intros; elim H2; intros; elim H4;\n    intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H4;\n    intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n    intros; elim H4; intros;Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intro.\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := P m).\n  apply le_trans with (m := PQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4334,
                "proof_end_offset": 4420,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (recZ P acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_sgn a) as [Ha|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* b = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [Hb|Hb].\n  (* a = (b,0) *)\n  case (eq_sgn b) as [HbQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (total_order_Z a b). intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro. unfold is_gcd.\n  case (total_order_Z a b); intro.\n    unfold is_gcd.\n    case (total_order_Z a b); intro. unfold is_gcd.\n    case (total_order_Z b); intro.\n    unfold is_gcd.\n    case (total_order_Z a b); intro.\n    unfold is_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_zerop b); intro. unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfold P in |- *. intro. apply (gcd_sgn a b).\n  unfoldQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold not in |- *; intro. unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *;Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_sgn a b); intro. unfold Q in |- *.\n  split with (absZ b). rewrite e. apply (gcd_sgn a).\n  unfold Q in |- *; intro. elim (Z_zerop b); intro.\n    elim (H0 r H1). intros. split with x. rewrite e. apply (gcd_sgn a).\n    apply gcd_mod with (2 := b).\n    apply gcd_mod with (2 := a).\n    apply gcd_mod with (2 := b).\n    apply gcd_mod with (2 := H).\n    apply gcd_mod with (2 := H0).\n    apply gcd_mod with (2 := H0).\n    apply gcd_mod with (2 := H0).\n    apply gcd_mod with (2 := H1).\n    apply gcd_mod with (2 := H0).\n    apply gcd_mod with (2 := H1).\n    apply gcd_mod with (2 := H1).\n    apply gcd_mod with (2 := H0).\n    apply gcd_mod with (2 := H1).\n    apply gcd_mod with (2 := H1).\n    apply gcd_mod with (2 := H0Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (total_order_dec a b); intro. unfold P in |- *. intro.\n  case (total_order_dec a b); intro. unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. intro. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. apply H.\n  unfold P in |- *. intro. unfold P in |- *. intro. unfold P in |- *. apply H.\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_sgn a); intro. unfold inside_gcd in |- *.\n  intro.\n  rewrite <- H.\n  apply gcd_unique with (2 := H). assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_zerop b); intro. unfold P in |- *. intro.\n  elim (lt_irrefl 0). intros.\n  unfold not in |- *; intro. elim H. intros.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold not in |- *; intro.\n    unfold notQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_decidable (lt_sgn a b)). intro. unfold not in |- *. intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |- *; intro.\n  unfold not in |-Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply gcd_nonneg.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "rewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\n",
                "context_tokens": 721,
                "proof_start_offset": 4441,
                "proof_end_offset": 5553,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\nintros.\nelim H; intros.\napply (gcd_OZ_absZ b0).\nunfold is_gcd in |- *.\nsplit.\nelim H3; intros; elim H5; intros; exact H6.\nsplit.\nelim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros.\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros.\nelim H3; intros; elim H7; intros.\napply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros.\nrewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros.\nelim H17; intros.\nelim H19; intros.\nrewrite H20.\nsymmetry in |- *.\nexact (add_OZ r).\nexact H4.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  exact (recZ_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_is_gcd Z_divide_is_gcd Z_is_gcd Z_gcd Z_is_gcd Z_is_Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  introQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  exact (recZ_is_gcdZ a b d).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_decidable (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point ())))))))))))\n                          (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point ()))) (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (point (pointQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros a b d H H0.\n  elim H; intros.  elim H; intros.  split with a.\n  apply gcd_div_pos; trivial.\n  unfold Z.div at 1 in |- *; apply Z.div_pos; trivial.\n  unfold Z.div at 1 in |- *; apply Z.div_pos; trivial.\n  unfold Z.div at 1 in |- *; apply Z.div_pos; trivial.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_bezout Z_mod_Z a b d). intro.\n  case (eq_bezout Z_mod_Z a b d). intro.\n  apply gcd_0_l with (2 := H0); trivial.\n  apply gcd_0_l with (2 := H1); trivial.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_informative 0 a); intro. unfold P in |- *. intro.\n  elim (eq_informative a b); intro.\n    elim (H r H0 n). intros. split with (absZ b).\n    assumption.\n    apply H0.\n    assumption.\n    apply H0.\n    assumption.\n    apply H0.\n    assumption.\n    apply H0.\n    assumption.\n    apply H0.\n    assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_Rat_dec a b); intro.\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn b a).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn b a).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn b a).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn b a).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn a b).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn b a).\n  unfold is_gcd in |- *; split. intros. apply (gcd_sgn bQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_Nbit0 a). intro.\n  apply H. assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_Nbit0 a). intro. unfold not in |- *. intro. elim H. intro.\n    split with (absZ b). rewrite e. apply (gcd_bezout_r a b d). assumption.\n  intro. rewrite e. apply (gcd_bezout_r a b d). assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 5810,
                "proof_end_offset": 5941,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros; elim H; intros.\napply (sign_absZ b0).\nexact H3.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2 Z (is_gcd a b) (gcd_Z a b).\n\nEnd gcdZ_divide.\n\n(****************)\n(*******************)\n\n(*****************\n(*****************\n\n(*****************\n\n\nWe define the usual binary operations on the same in the usual operations and in the\n of the usual operations in the\n\n\nWe define the usual operations over binary operations in the usual operations\n\n\n of the usual operations over the operations with\n\n\nwe define the equivalence of the operations\n\n\n the operations\n\nWe define the usual operations with the operations over\n\n\n(A:Type)(eq:A->Prop)\n(A:Type)(eq:A->Prop)\n(B:Type)(eq:A->Prop)(eq:A->B->Prop)\n(eq:A->A->Prop)\n(B:A->Prop)\n(eq:A->B->A)\n(A->Prop)(eq:A->A->Prop)\n(eq:A->A->Prop)\n(A->A)(eq:A->A->A->Prop)\n(A->A->Prop)\n(eq:AQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => a = b /\\ d = d.\n\nsimple induction 1; intros.\n elim H; intros; elim H0; intros; elim H1; intros; exact H2; exact H1.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => a = b.\n intros.\n apply (gcd_intro a b).\n apply (gcd_intro a b).\n apply (gcd_intro a b).\n apply (gcd_intro a b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_intro b).\n apply (gcd_Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2Z (is_gcdZ a b) (gcdZ_exists a b).\n\nLemma positive_is_gcd_r : forall a b : Z, is_gcdZ a b (gcdZ a b) (gcdZ_exists a b).\nProof fun a b : Z => pi2Z (is_gcdZ a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd_r : forall a b : Z, is_gcdZ a b (gcd_Z a b).\nProof fun a b : Z => pi2Z (is_gcd_Z a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd_r : forall a b : Z, is_gcd_r a b (gcd_Z a b).\nProof fun a b : Z => pi2Z (is_gcd_r a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd_r : forall a b : Z, is_gcd_r a b (gcd_Z a b).\nProof fun a b : Z => pi2Z (is_Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => a = b /\\ a = b.\n\n(*************)\nLemma gcd_is_gcd : forall a b : Z, is_gcd a b -> a = b.\nProof fun a b : Z => a = b /\\ a = b.\n\nLemma gcd_is_gcd : forall a b : Z, is_gcd a b -> a = b /\\ a = b.\nProof fun a b : Z => a = b /\\ b = a.\n\nLemma gcd_is_gcd : forall a b : Z, is_gcd a b -> a = b.\nProof fun a b : Z => a = b /\\ a = b /\\ b = a.\n\nLemma gcd_is_gcd : forall a b : Z, is_gcd a b -> a = b /\\ b = b.\nProof fun a b : Z => a = b /\\ a = b.\n\nLemma gcd_is_gcd : forall a b : Z, is_gcd a b -> a = b /\\ b = b.\nProof fun a b : Z => a = b /\\ b = a /\\ b = b.\n\nLemma gcd_is_gcd : forall a bQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd : forall a b : Z, is_gcdZ a b -> exists q : Z, q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = b.\nProof fun a b : Z => exists q : Z, q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = b.\nProof fun a b : Z => exists q : Z, q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q).\n\n\nLemma prime_is_gcd : forall a b : Z, is_gcd a b -> exists q : Z, q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q = a /\\ q =Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => a = a /\\ b = a /\\ b = b.\n\n(** Properties of gcd *)\n\nLemma gcd_divide : forall a b : Z, gcd a b a.\nProof fun a b : Z => a = a /\\ b = a /\\ b = b.\n\n(** Properties of gcd *)\nLemma gcd_divide : forall a b : Z, gcd a b a.\nProof fun a b : Z => a = b /\\ b = b /\\ b = a /\\ b = b.\n\n(** Properties of gcd *)\n\nLemma gcd_divide : forall a b : Z, gcd a b a.\nProof fun a b : Z => a = b /\\ b = a /\\ b = b.\n\n(** Properties of gcd *)\n\nLemma gcd_divide : forall a b : Z, gcd a b a.\nProof fun a b : Z => a = b /\\ b = a /\\ b = b.\n\n(** Properties of gcd *)\n\nLemma gcd_divide : forall a b : Z, gcd a b a.\nProof fun a b : Z => a = b /\\ b = a /\\ b = a /\\ b = a /\\ b = a /\\Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2 Z (is_gcd a b) (gcd_Z_exists a b).\n\n(*************)\n\nDefinition gcd (a b : Z) := pi2 Z (is_gcd a b) (gcd_Z_exists a b).\n\nLemma gcd_refl : forall a b : Z, gcd a b -> forall x : Z, x = a -> x = b.\nProof fun a b : Z => pi2 Z (is_gcd x b) (gcd_Z_exists a b).\n\nLemma gcd_refl : forall a b : Z, gcd a b -> forall x : Z, x = a -> x = b.\nProof fun a b : Z => pi2 Z (is_gcd x b) (gcd_Z_exists a b).\n\nLemma gcd_sym : forall a b : Z, gcd a b -> forall x : Z, x = a -> x = b -> x = b.\nProof fun a b : Z => pi2 Z (is_gcd x b) (gcd_morphism a b).\n\nLemma gcd_sym : forall a b : Z, gcd a b -> forall x : Z,Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2 Z (is_gcd Z a b) (gcdZ_exists a b).\n\nLemma positive_is_gcd : forall a b : Z, is_gcd a b (gcdZ a b) = true.\nProof fun a b : Z => pi2 Z (is_gcd Z a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd : forall a b : Z, is_gcd a b (gcd_Z a b) = true.\nProof fun a b : Z => pi2Z (is_gcd Z a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd : forall a b : Z, is_gcd a b (gcd_Z a b) = true.\nProof fun a b : Z => pi2Z (is_gcd Z a b) (gcd_Z_exists a b).\n\nLemma positive_is_gcd : forall a b : Z, is_gcd a b (gcd_Z a b) = false.\nProof fun a b : Z => pi2Z (is_gcd Z a b) (gcd_Z_exists aQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcd_Z a b).\n\nDefinition gcd (a b : Z) := pi2 Z (is_gcd a b) (gcd_Z a b).\n\nLemma gcd_mul_l : forall a b : Z, gcd a b = gcd a b.\nProof fun a b : Z => pi2 Z (is_gcd a b) (gcd_Z a b).\n\nLemma gcd_mul_l : forall a b : Z, gcd a b = gcd a b.\nProof fun a b : Z => p (is_gcd a b) (gcd_Z a b).\n\nLemma gcd_mul_r : forall a b : Z, gcd a b = gcd a b.\nProof fun a b : Z => p (is_gcd a b) (gcd_Z a b).\n\nLemma gcd_mul_r : forall a b : Z, gcd a b = gcd a b.\nProof fun a b : Z => p (is_gcd a b) (gcd_Z a b).\n\nLemma gcd_mul_r : forall a b : Z, gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\n",
                "context_tokens": 714,
                "proof_start_offset": 5966,
                "proof_end_offset": 6284,
                "proof": "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H) (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros; apply (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0) (positive_is_gcdZ a b d1 H)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2 : Z => a = b /\\ d1 = d2.\n intros; elim H; intros.\n apply (sign_abs_Z a b d1).\n intro.\n case (Z_zerop b); intro.\n rewrite H1 in H2; apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n case (Z_zerop d1); intro.\n rewrite H2 in H2; apply (sign_abs_Z a b d1).\n intro.\n rewrite H3 in H2; apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n rewrite H3 in H2; apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b d1).\n intro.\n apply (sign_abs_Z b dQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2 : Z => a = b /\\ d1 = d2.\n intros a b d1 d2; elim H; intros; apply (sign_absZ b0).\n elim H0; intros; assumption.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d : Z => a = b /\\ d1 = b /\\ d1 = d2.\nintros; elim H; intros. apply (sign_absZ a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d2).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg b d2).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg b d2).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg b d1).\n apply (abs_nonneg b d1).\n apply (abs_nonneg a b d1).\n apply (abs_nonneg b d1).\n apply (abs_nonneg b d1).\n apply (abs_nonneg a b d1Qed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nDefinition gcdZ (a b : Z) := fun b : Z => a = b.\n\nDefinition gcdZ (a b : Z) := fun a b : Z => a = b.\n\nLemma gcdZ_is_gcd : forall a b : Z, gcdZ a b = a.\nProof fun a b : Z => a = b.\n\nLemma gcdZ_is_gcd : forall a b : Z, gcd a b = a.\nProof fun a b : Z => a = b.\n\n intros a b H.\n case (Z_is_gcd Z a b); intros.\n rewrite <- H.\n apply (gcd_is_gcd_iff a b); trivial.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2 : Z => a = b /\\ d1 = d2.\n intros; elim H; intros; elim H; intros.\n apply (gcd_pos a b d1). apply H1.\n apply (gcd_pos a b d1). apply H0.\n apply (gcd_pos a b d1). apply H0.\n apply (gcd_pos a b d1). apply H1.\n apply (gcd_pos a b d1). apply H0.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos a b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_neg b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_pos b d1). apply H1.\n apply (gcd_Qed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2 : Z => a = b /\\ d1 = b /\\ d2 = b /\\ d1 = d2.\n\nLemma Zle_is_gcd_gcd_Z : forall a b d : Z, is_gcd a b d -> forall q : Z, (is_gcd q a b) -> q = a /\\ d = b /\\ d = b.\nProof fun a b d : Z => a = b /\\ d = b /\\ d = b /\\ d = b.\n\nLemma Zle_is_gcd_Z : forall a b d : Z, (is_gcd a b) d -> (is_gcd a b) d.\nProof fun a b d : Z => a = b /\\ d = b /\\ d = b /\\ d = b.\n\nLemma Zle_is_gcd_Z : forall a b d : Z, (is_gcd a b) d -> (is_gcd a b) d.\nProof fun a b d : Z => a = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b.\n\nLemma Zle_is_gcd_Z : forall a b : Z, (is_Qed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2.\n intros; elim H; intros.\n apply (sign_abs_Z a b d1).\n assumption.\n apply (sign_abs_Z a b d1).\n assumption.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b : Z => a = b /\\ d1 = d2.\n intros; elim H; intros.  apply (sign_abs_Z a b).\n intros; elim H0; intros.  apply (sign_abs_Z a b).\n intros; elim H0; intros.  apply (sign_abs_Z a b).\n intros; elim H0; intros.  apply (sign_abs_Z a b).\n intros; elim H0; intros.  apply (sign_abs_Z b).\n intros; elim H0; intros.  apply (sign_abs_Z a b).\n intros; elim H0; intros.  apply (sign_abs_Z b).\n intros; elim H1; intros.  apply (sign_abs_Z b).\n intros; elim H1; intros.  apply (sign_abs_Z b).\n intros; elim H1; intros.  apply (sign_abs_Z b).\n intros; elim H1; intros.  apply (sign_abs_Z b).\n intros; elim H1; intros.  apply (sign_abs_Z b).\n intros; elim H2Qed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b d1 d2 : Z => a = d1 \\/ d2 = d2 \\/ d1 = d2.\n intros; elim H; intros.\n apply (sign_absZ b0).\n unfold is_gcd, is_gcd, is_gcd in |- *.\n split; intros; assumption.\n apply (Z_is_gcd_Z (a * b) (gcd_Z a b) d1).\n apply (gcd_is_gcd_Z a b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_Z b) (gcd_is_gcd_ZQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof fun a b : Z => a = b /\\ d2 = a /\\ d1 = b /\\ d2 = a /\\ d1 = d2.\n\nLemma expZ_correct : forall a b d : Z, is_gcdZ a b d -> is_gcd Z (a + b) d.\nProof fun a b : Z => a = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b.\nProof fun a b : Z => a = b /\\ b = b /\\ d = b.\n\nLemma expZ_correct : forall a b : Z, a = b /\\ a = b /\\ d = b /\\ d = b /\\ d = a /\\ d = b.\nProof fun a b : Z => a = b /\\ d = b /\\ d = b /\\ d = a /\\ d = b /\\ d = b.\n\nLemma expZ_correct : forall a b : Z, a = b -> a = b /\\ a = b /\\ d = b /\\ d = b /\\ d = b /\\ d = b /\\ d = a /\\ d = b.\nProof fun a bQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 6306,
                "proof_end_offset": 6452,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b.\n intros.\n case (Z_lt_trichotomy a b); intro.\n apply (gcd_sgn_pos a b); intro.\n apply (gcd_sgn_pos a b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos a b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos b); intro.\n apply (gcd_sgn_pos bQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros; elim H; intros.\napply (gcd_antisym a b); assumption.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => p (is_gcd a b) (gcdZ_is_gcd a b).\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcd a b d ->\n is_gcd a b d ->\n (exists p : Z, (exists q : Z, (exists q : Z, (exists q : Z, (exists q : Z, q = q /\\ q = q)%Z) /\\ q = q)).\nintros a b d H.\nelim H; intros.\nelim H; intros.\napply (gcd_sym a b); intros.\nelim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n rewrite H4; apply (gcd_sym a b); intros.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H6; intros;\n rewrite H5; apply (gcd_sym a b); intros.\nelim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros;\n rewrite H5; apply (gcd_sym a b); intros.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b \\/ a = b \\/ d = b.\nintros.\nelim H; intros.\nexact (gcd_is_gcdZ a b d1 H1) || (intros; assumption).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a * b = a * c * b.\nsimple induction 1; simpl in |- *; intros; trivial.\nrewrite (gcd_comm a b) in H.\ngeneralize (gcd_divide_r a b d1 (gcdZ_is_gcd a b d1 H)).\nintros; apply (gcd_cancel_r a b d1 H).\nelim (gcd_cancel_r a b d1 (gcd_is_gcd a b d1 H)).\nintros; apply (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancel_r a b d1 H).\nrewrite (gcd_cancelQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b.\nsimple induction a; intros; assumption.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nintros; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b.\n intros.\n apply gcd_is_gcdZ.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b.\n intros.\n case a; trivial.\n intros; apply (gcd_sgn a b); trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b /\\ d = b.\n\nintros.\nelim (gcd_dec a b d); intros.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\nelim (gcd_sym (Z_is_gcd a b d)); intros.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (Z_is_gcd a b d)); trivial.\napply (gcd_sym (ZQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof fun a b : Z => a = b.\nintros.\nelim (gcd_morphism_apart_sign a b d1 (gcdZ_is_gcd a b d1 H)\n    (gcd_Z_is_gcd a b d1 H)\n      (gcd_Z_is_gcd a b d1 H) (gcd_Z_is_gcd a b d1 H)).\nintros; exact H1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\n",
                "context_tokens": 719,
                "proof_start_offset": 6470,
                "proof_end_offset": 6674,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros.\nelim H; intros.\napply (gcd_is_gcd_Z a b q); trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b q r H0 H1 H2; intros; elim H1; intros. \n apply (gcd_is_gcd Z a b q r H0 H1).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b : Z => gcd a b.\n\nLemma gcd_modZ : forall a b q r : Z, (a * q) = gcd a b.\nProof fun a b q r : Z => gcd (a * q) (b * q) (b * q) (b * q) (b * q) (b * q) (b * q) (b * q) (c * q) (b * q) (b * q) (c * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (d * q) (dQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b q r H0 (q0 : Z) =>\n (forall q : Z, (a * q)%Z = (q0 + r)%Z -> (a * q)%Z = (q0 + r)%Z) * r)%Z.\nintros.\n case (Z_zerop r); intro.\n intro H1; elim H1; intros.\n apply (gcd_unique_Z a b q H1 (gcdZ_is_gcd a b q H1) H2).\n intro; apply (gcd_unique_Z b q H2 (gcd_is_gcd a b q H1)).\n intro; apply (gcd_unique_Z b q H1 (gcd_is_gcd a b q H1)).\n intro; apply (gcd_unique_Z b q H1 (gcd_is_gcd a b q H1)).\n intro; apply (gcd_unique_Z b q H1 (gcd_is_gcd a b q H1)).\n intro; apply (gcd_unique_Z b q H1 (gcd_is_gcd a b q H1)).\n intro; apply (gcd_unique_Z b q H1 (Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b : Z => a * b = gcd (Z_mod a b) (gcd_Z b a).\n\nLemma gcd_mod : forall a b : Z, (a * b) <> b -> (a * b) <> (a * b) -> gcd a b = gcd (Z_mod a b) (Z_mod b).\nProof fun a b : Z => a * b = gcd (Z_mod a b) (Z_mod a) (Z_mod b).\n\nLemma gcd_mod : forall a b : Z, (a * b) <> 0 -> (b * b) <> 0 -> gcd a b = gcd a b.\nProof fun a b : Z => a * b = gcd (Z_mod a b) (Z_mod a).\n\nLemma gcd_mod : forall a b : Z, (a * b) <> 0 -> (a * b) <> 0 -> gcd a b = gcd (Z_mod a b) (Z_mod b).\nProof fun a b : Z => a * (Z_mod a b) (Z_mod a).\n\nLemma gcd_mod : forall a b : Z,Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b q r : Z => exists q : Z, (r = q /\\ r = q /\\ r = q).\n\nLemma gcd_modZ : forall a b q r : Z, b <> Zero -> (r + q) = gcd a b q.\nProof fun a b q r : Z => exists q : Z, (r + q)%Z = gcd a b q.\n\nLemma gcd_modZ : forall a b q r : Z, (a + q) = (q + r) * q.\nProof fun a b q r H0 H1 H2.\n intros; apply H1; apply (gcd_modZ a b q r H0 H1).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros a b q r H1 H2; elim H1; intros;\n [ assumption | apply (gcd_is_gcdZ a b (gcd_is_gcd a b q) H2)].\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b : Z => exists q : Z, q = q /\\ r = gcdZ b a.\n\nLemma gcd_div_Z : forall a b c : Z, (a + b) = (a + b) + c -> gcd a b = gcd b a.\nProof fun a b c d : Z => exists q : Z, q = p /\\ r = gcd q a b.\n\nLemma gcd_div_1 : forall a b c d : Z, (a + b) = (a + b) * c -> gcd a b = gcd b a.\nProof fun a b c d : Z => exists q : Z, q = p /\\ r = gcd q a b.\n\nLemma gcd_div_1 : forall a b c d : Z, (a + b) = (a + b) * c -> gcd a b = gcd b a.\nProof fun a b c d : Z => exists q : Z, q = p /\\ r = gcd q b.\n\nLemma gcd_div_2 : forall a b c d : Z, (a + b) = (a + b) * d.\nProof fun a b c d :Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros.\nelim H; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelim H0; intros.\nrewrite <- (gcd_gcd_abs_iff a b).\nelimQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof fun a b q r H0 H1 H2. intros.\n apply (gcd_unique_morphism a b q r H1 H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ")) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6945,
                "proof_end_offset": 8358,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros q f.\ncase (eq_OZ_dec q); intro.\nunfold Q in |- *; intro b.\nsplit with IZ (sgnZ b).\nrewrite e.\nsimpl in |- *.\nrewrite (sgn_abs b).\napply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (divZ b q).\nintros div rem; intros.\ncut (lt_absZ rem q); intros.\nelim (f rem H q).\nintros.\nsplit with (addZ v (oppZ (multZ div u))) u.\nelim i.\nintros.\nelim H1.\nintros.\nelim H3.\nintros.\npattern b at 1 in |- *.\nrewrite H5.\nelim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\nrewrite H7.\nelim (mult_add_distributivity (multZ q div) rem u); intros.\nrewrite H8.\nrewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\nelim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\nrewrite (add_add Z addZ addZ_commutativity addZ_associativity (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u) (multZ (multZ q div) u)).\nelim (addZ_commutativity (multZ rem u) (multZ q v)).\nrewrite e.\nelim (multZ_associativity q div u).\nelim (addZ_opposite (multZ q (multZ div u)) I); intros.\nelim H11; intros; elim H13; intros.\nrewrite H15.\nrewrite (add_OZ (gcdZ rem q)).\nexact (gcd_modZ b q div rem n i).\nunfold lt_absZ in |- *.\nelim i; intros; elim H0; intros.\nrewrite (tech_le_pos_abs rem H1).\nelim H2; trivial.\nexact n.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\ndestruct n.\nintros.\nrewrite (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm a b).\nrewrite (div_comm a b).\nrewrite (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm a b).\nrewrite (div_comm b).\nrewrite (div_comm a b).\napply (div_comm a b).\nrewrite (div_comm b a).\napply (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm b a).\nrewrite (div_comm a b).\napply (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm b a).\napply (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm b a).\nrewrite (div_comm b a).\napply (div_comm a b).\nrewrite (div_comm a b).\napply (div_comm b a).\nrewrite (divQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun a b.\n  intros.\n  destruct a.\n  reflexivity.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun a b.\n  intros.\n  elim H; intros.\n  apply (H 0%Z); auto.\n  apply (H 0%Z); auto.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q n).\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m.\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m.\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m).\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m).\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m).\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m).\nintros.\napply (Build_K (fun m : Z => forall m : Z, n < m -> Q m) -> Q m).\nintros.\napply (Build_Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun n m => fun n m => fun n => fun n => fun n => fun n => n => n = m).\ninduction n as [| n0]; intros.\n rewrite (plus_comm (S n0)) in H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\nelim n; auto with arith.\nintros.\nexact (H0 m).\nexact (H0 m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun n => n.\ninduction n as [| n IH]; simpl; intros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q n.\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite H0.\napply (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m).\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite (fun m : Z => forall m : Z, n = m -> Q m) -> Q m.\nintros.\nrewrite H0.\napply (fun m : Z => forall m : Z, n =Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\ndestruct (is_gcdZ_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelim (is_gcd_Z_is_gcd a b) as [q|q].\nelimQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun n m n H.\nsimple induction n.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nsimpl in |- *.\ntrivial.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ _ (H _ _ H0)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ (H _ _ H0)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ (H _ H0)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ H0).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ (H _ H0)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ H1).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ (H _ H0)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ H1).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ (H _ _ H1)).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ _ H1).\nintros.\ngeneralize (q_is_gcd_Z _ _ _ _ H2).\nintros.\ngeneralize (qQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ".\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 8360,
                "proof_end_offset": 8453,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (recZ Q acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. apply (Build_ Bezout_i a b (gcd_Z a b)).\n  elim (Build_ Bezout_i a b (gcd_Z a b) (gcd_Z a b)).\n  intros.\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  elim (Build_ Bezout_i a b (gcd_Z a b)).\n  intros.\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  assumption.\n  intros.\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  apply (Build_ Bezout_i a b (gcd_Z a b)).\n  assumption.\n  intros.\n  apply (Build_Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b H.\n  rewrite (divZ_is_gcd_Z a b) at 1.\n  apply (gcd_mod b a); apply gcd_bezout_exists; assumption.\n  apply (gcd_mod b a); apply gcd_bezout_exists; assumption.\n  apply (gcd_mod b a); apply gcd_bezout_exists; assumption.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Build_funspec (fun _ => a) (fun _ => b)).\n  apply (Build_funspec (fun _ => a) (fun _ => b)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a) (fun _ => b)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  apply (Build_funspec (fun _ => a)).\n  applyQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. unfold verify_BezoutZ.\n  destruct (eq_Rat_dec a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); intro. unfold Q in |- *; intro b.\n  elim b; intros; trivial.\n  elim (mult_eq_Rat a b); introQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  apply (Build_funspec (fun x => a)).\n  apply (Build_funspec (fun x => a) (fun y => x)).\n  applyQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_K (a * b)).\n  apply (Build_KQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  case (eq_pointsH (quot a b)) as [Hle|Hnle].\n  intros; elim (H a b); intros; elim H0; intros.\n  rewrite H1.\n  rewrite (add_commut b).\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H3; intros.\n  rewrite H3.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H3; intros.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H4; intros.\n  rewrite H5.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H4; intros.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H4; intros.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H5; intros.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H5; intros.\n  rewrite (add_comm b).\n  apply (gcd_mod b a).\n  elim H6; introsQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. apply (Build_ verify_BezoutZ a b (gcdZ a b)).\n  elim (Build_ verify_BezoutZ a b (gcdZ a b)).\n  intros. elim H0; trivial.\n  intros. elim H0; trivial.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  case (eq_ oeedec a b); intro.\n  case (eq_ oeedec a b); intro.\n  apply Bezout_i. trivial.\n  apply Bezout_i. trivial.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro a b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_intro b).\n  apply ( Bezout_introQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "Lemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\n",
                "context_tokens": 736,
                "proof_start_offset": 8579,
                "proof_end_offset": 8840,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (recZ Q).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (recZ Q acc_Q).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x.\n  destruct (eq_dart_dec x 0); intro.\n    apply (gcd_uniqueZ (absZ x) (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ x) (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ x) (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ z)).\n    rewrite e.\n    apply (gcd_uniqueZ (absZ y)).\n   Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (invZ 1).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (recZ Q acc_Q).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (recZ Q acc_Q).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x.\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ x)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  apply (inv_eq_Z (absZ y)).\n  applyQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  apply divide_selfZ.\n  apply divide_selfZ.\n  apply divide_selfZ.\n  apply divide_selfZ.\n  apply divide_selfZ.\n  apply divide_selfZ.\n  apply divide_selfZ.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (recZ.is_gcd).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim H.\n  intros.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\nLemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\n\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec x); intros. left; exact a.\nright; split. exact b. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ x).\nQed.\n\n(**********************************)\n",
                "context_tokens": 717,
                "proof_start_offset": 8879,
                "proof_end_offset": 12106,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (addZ (multZ x (multZ b v)) (multZ y (multZ a u))).\nunfold congruentZ in |- *; split.\nreplace (multZ b v) with (addZ IZ (oppZ (multZ a u))).\nelim (mult_add_distributivity x IZ (oppZ (multZ a u))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ x).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring a u I I).\nrewrite (multZ_associativity x a (oppZ u)).\nelim (multZ_commutativity a x).\nelim (multZ_associativity a x (oppZ u)).\nrewrite (multZ_associativity y a u).\nelim (multZ_commutativity a y).\nelim (multZ_associativity a y u).\nelim (addZ_associativity x (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))).\nelim (addZ_commutativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x).\nelim (addZ_associativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x (oppZ x)).\nelim (addZ_opposite x I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)) a).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ x (oppZ u)) a (divide_selfZ a) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ y u) a (divide_selfZ a) I).\nelim H.\nelim e.\nelim (addZ_commutativity (multZ b v) (multZ a u)).\nelim (addZ_associativity (multZ b v) (multZ a u) (oppZ (multZ a u))).\nelim (addZ_opposite (multZ a u) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nexact (add_OZ (multZ b v)).\ncut (multZ a u = addZ IZ (oppZ (multZ b v))); intros.\nrewrite H0; clear H0.\nelim (mult_add_distributivity y IZ (oppZ (multZ b v))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ y).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring b v I I).\nrewrite (multZ_associativity y b (oppZ v)).\nelim (multZ_commutativity b y).\nelim (multZ_associativity b y (oppZ v)).\nrewrite (multZ_associativity x b v).\nelim (multZ_commutativity b x).\nelim (multZ_associativity b x v).\nelim (addZ_commutativity (multZ b (multZ y (oppZ v))) y).\nrewrite (addZ_associativity (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) y) .\nelim (addZ_associativity (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v)))) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) b).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ x v) b (divide_selfZ b) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ y (oppZ v)) b (divide_selfZ b) I).\nelim H.\nelim e.\nelim (addZ_associativity (multZ a u) (multZ b v) (oppZ (multZ b v))).\nelim (addZ_opposite (multZ b v) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nsymmetry in |- *; exact (add_OZ (multZ a u)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ in |- *. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y. elim (eq_ memren_dec x y); intros.\n  elim (eq_ memren_dec y x); intros.\n  elim H; intros; assumption.\n  elim H0; intros; assumption.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ. destruct (Z_zerop y); auto.\n  elim (eq_zerop z); intros.\n  elim (Zmult_add_remZ a b); intros.\n  elim (Zmult_add_remZ a b); intros.\n  rewrite (mult_comm (Z.div a b)); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  rewrite (mult_comm (Z.div a b)); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ b b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n  elim (Zmult_remZ a b); intros.\n Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y.\n  case (eq_dart_dec z x); intros.\n    elim (eq_dart_dec z y); intros.\n    elim (eq_dart_dec z y); intros.\n      elim (eq_dart_dec z x); intros.\n      elim (eq_dart_dec z y); intros.\n        elim (eq_dart_dec z x); intros.\n        elim (eq_dart_dec z z); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z z); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z z); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z x); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z y); intros.\n          elim (eq_dart_dec z x); introsQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcd in |- *. split. exact I.\nelim (eq_trichotomy 0 x); intros. \n  elim H1; intros. elim H2; intros. rewrite H2. apply gcd_antisym. \n  apply gcd_antisym. apply gcd_comm. apply gcd_comm. apply gcd_comm.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ.\n  destruct a. destruct b.\n  destruct b.\n  destruct z.\n  destruct a.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct a.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct a.\n  destruct b.\n  destruct z.\n  destruct a.\n  destruct z.\n  destruct c.\n  destruct a.\n  destruct z.\n  destruct z.\n  destruct z. destruct z.\n  destruct a.\n  destruct z. destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct a.\n  destruct z.\n  destruct z. destruct z.\n  destruct a.\n  destruct z.\n  destruct z.\n  destruct a.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z. destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z. destruct z.Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcd in |- *. split. exact I. split. exact I. intros.\n  destruct (divZ_mod_pos a b); trivial.\n  apply Bezout_exists with (b:=0). exact I. intros. elim H0; trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold dvdp in |- *. split. exact I. apply C. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D. apply D.Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y. unfold gcdZ in |- *. split. exact I. assumption.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ in |- *. split. exact I. split. exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\n",
                "context_tokens": 134,
                "proof_start_offset": 1314,
                "proof_end_offset": 1558,
                "proof": "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n apply False_ind.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply False_ind.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply False_ind.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_O_Sn.\n intro.\n apply H.\n apply lt_Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros.\napply lt_S_eq.\napply lt_O_Sn.\napply lt_O_Sn.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros.\nelim (eq_dec (absZ m) 0).\n intro.\n apply (lt_irrefl 0).\n assumption.\n assumption.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction 1; intros; elim H.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintro.\nelim (lt_or_eq _ _ H).\nintro.\nelim (le_or_eq _ _ H).\nintro.\napply (le_or_eq _ _ H).\nintro.\napply (le_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (le_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (le_or_eq _ _ H).\nintro.\napply (le_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _ H).\nintro.\napply (lt_or_eq _ _Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros.\napply le_lt_trans with (absZ m).\napply lt_Sn_m.\napply lt_n_Sn.\napply lt_S_n.\napply le_n_Sn.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_n_Sn.\napply lt_S_n.\napply le_n.\napply lt_n_Sn.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_n.\napply lt_n_Sn.\napply lt_S_n.\napply lt_S_n.\napply lt_n.\napply lt_S_n.\napply lt_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_S_n.\napply lt_SQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros.\nunfold lt in |- *.\nintro.\nelim H.\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\napply lt_n_O.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napplyQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction 1; intros.\n assumption.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nelim (lt_lt_eq_dec 0 (absZ m)).\nintro H1.\napply lt_le_weak.\napply lt_O_le.\napply lt_le_weak.\napply lt_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\n",
                "context_tokens": 219,
                "proof_start_offset": 1573,
                "proof_end_offset": 1786,
                "proof": "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0.\nelim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; introsQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\n intros P H; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0; clear H0; intros; elim H0; clear H0; intros;\n [ assumption | elim H0;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H H0; elim H; intros; elim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\n  intros P H0; elim H0; intros; elim H1; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0; elim H; auto with *.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H'; elim H'; intros; elim H'; intros; elim H'; intros; elim H'; intros; elim H'0; intros; elim H'0;\n intros; elim H'0; intros; elim H'0; intros; elim H'1; intros; elim H'1;\n intros; elim H'1; intros; elim H'1; intros; elim H'1; intros; elim H'1; intros; elim H'2;\n intros; elim H'1; intros; elim H'2; intros; elim H'2;\n intros; elim H'1; intros; elim H'1; intros; elim H'1; intros; elim H'1;\n intros; elim H'1; intros; elim H'1; intros; elim H'2; intros; elim H'1;\n intros; elim H'1; intros; elim H'1; intros; elim H'1; intros; elim H'1;\n intros; elim H'1; intros; elim H'1; intros; elim H'2; intros; elim H'1;\n intros; elim H'1; intros; elim H'Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H'; elim H'; intros n H'0; elim H'0; intros; auto with arith.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H H0; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H; elim H; intros; elim H; intros; elim H0; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nunfold not inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\n",
                "context_tokens": 413,
                "proof_start_offset": 2085,
                "proof_end_offset": 2498,
                "proof": "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\nelim (le_n_O_eq n H0).\napply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\napply (H n); assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H0 H1 H2; elim H2; intros.\nunfold lt_absZ in |- *; elim H0; intros.\nunfold not in |- *; intro; elim H0; intros.\nunfold not in |- *; intro; elim H0; intros.\nunfold not in |- *; intro; elim H0; intros.\nunfold not in |- *; intro; elim H0; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\nexact (H0 H1).\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H H0; elim H; intros.\nexists 0%nat; split; [ assumption | assumption ].\nelim H1; intros.\nelim H2; intros.\nexists 0%nat; split; [ assumption | assumption ].\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\nelim H; intros.\napply (H (S n)).\nunfold lt_absZ in H0; elim H0; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H1.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros; assumption.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H0.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intro n; elim n; clear n.\nexact (H n H1).\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "                                                                        *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\n",
                "context_tokens": 562,
                "proof_start_offset": 2513,
                "proof_end_offset": 3508,
                "proof": "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsplit.\nelim (lt_succ n p H1); intros.\nelim (H0 n a); intros; trivial with arith.\nrewrite b.\napply (H (neg (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nelim (lt_succ n p H1); intros.\nelim (H0 n); intros; trivial with arith.\nrewrite b.\napply (H (pos (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p.\nelim (Zle_or_lt 0 p).\n intro.\nelim (Zlt_or_lt 0 p).\n intro.\nelim (Zlt_or_lt 0 p).\n intro.\nelim (Zlt_or_lt 0 p).\n intro.\nrewrite (tech_lt_abs_ authors _ H2).\n exact (H (pos 0)); intros.\nrewrite (tech_lt_abs_ CREDITS _ _ H2) H3) in H2.\nexact (H (pos 0)); intros.\nrewrite (tech_lt_abs_ authors _ H2).\n exact (H (pos 0)); intros.\nrewrite (tech_lt_abs_ tidn m). apply (Zrec1 P H). exact H2.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H; elim H; intros.\nunfold not in |- *; elim H; intros.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *;Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H.\nelim H; intros.\nelim H; intros.\nrewrite (tech_lt_abs_predZ m). apply (Zrec1 P H).\n exact H.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p; pattern p, p in |- *; apply and_ind_K1; intros.\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_fam m). apply (Zrec1 P H). exact H0.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H n H H0 H1.\nelim H0; intros.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |-Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H H0.\nelim (le_n_O_eq n H).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_INZ (S p)).\napply (H (pos 0)); intros.\nrewrite (tech_ltQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H H0; apply (H (pos 0)); intros.\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_succZ m). apply (Zrec1 P H). exact H1.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0).\n apply (H (neg 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_stepr 0).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ tidn m). apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_ Public 1).\n apply (H (pos 0)); intros.\n rewrite (tech_lt_abs_Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H H0 H1.\ncut (forall m : Z, n <= p -> P m) -> P n).\n intro; apply (H 0).\nelim (le_n_O_eq n H0).\n intro.\napply (H (pos 0)); intros.\nrewrite H3 in H3.\nelim H3.\nelim H3.\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_predZ m). apply (Zrec1 P H0).\n exact H3.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H H0 H1; unfold not in |- *; intro; elim H; clear H; intros;\n elim H1; clear H1; intros; elim H1; clear H1; intros;\n elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1; intros;\n elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1; intros;\n elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": " -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\n",
                "context_tokens": 707,
                "proof_start_offset": 3526,
                "proof_end_offset": 3740,
                "proof": "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros; elim p.\nexact (Zrec2 P H).\nintros; apply Zrec3; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction 1.\nsimple induction 1.\nauto.\nauto.\napply (H (pos (S n))).\nunfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_Z in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H.\nelim (lt_irrefl 0); intros.\nrewrite H0; auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H.\nelim (le_or_eq (P (pos n)) H).\nintros p H0.\nelim (le_or_eq (P (pos n)) H0).\nintros.\nrewrite (tech_lt_abs_INZ (S p)) in |- *.\napply (H (pos n)).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt in |- *.\napply lt_le_trans with (pos n).\nunfold lt inQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P H.\nunfold not_indZ in |- *; unfold not in |- *; intro.\nelim (H0 n); auto with arith.\nelim (le_succ n p H0); intros.\nrewrite (tech_lt_abs_predZ m). apply (Zrec1 P H).\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction 1; intros.\nunfold not_indZ in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n intros.\nelim (H0 n); auto with arith.\n(* P (pos n) *)\nelim (lt_irrefl 0); intros.\nrewrite (tech_lt_abs_predZ n).\n apply (H (pos (S n)) H0); intros.\nrewrite (tech_lt_abs_nSm (S n)) with (S (S (pos n))).\napply (H (pos (S n))).\napply H0; auto with arith.\n(* P (pos (S n) *)\nelim (lt_irrefl 0); intros.\nrewrite (tech_lt_abs_predZ n).\napply (H (pos (S n))).\napply H1; auto with arith.\n(* P (pos (S n) *)\nelim (lt_irrefl 0); intros.\nrewrite (tech_lt_abs_succZ n).\napply (H (pos (S n))).\napply H0; auto with arith.\n(* P (Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P p H n H.\nelim (lt_pred n H); intros.\nelim (lt_pred n H); intros.\nrewrite (tech_lt_abs_succZ m). apply (H (pos n)); auto with arith.\nunfold lt_absZ in |- *; unfold lt_Z in |- *; unfold lt in |- *;\n unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt_Z in |- *; unfold lt_Z in |- *; unfold neq in |- *;\n unfold lt_Z in |- *; unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt_Z in |- *; unfold lt in |- *; unfold lt_Z in |- *;\n unfold lt in |- *; unfold lt_Z in |- *; unfold lt in |- *;\n unfold lt_Z in |- *; unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt in |- *; unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt_Z in |- *; unfold lt in |- *; unfold lt_Z in |- *;\n unfold lt in |- *; unfoldQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H.\nunfold not_recZ in |- *; unfold not_recZ in |- *; intros.\nelim (H H0 n0); auto with arith.\nintros; elim (H0 n0); auto with arith.\nintros; elim (H0 n0); auto with arith.\nintros; elim (H0 n0); auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nunfold and_recZ in |- *; intros; apply or_ind; auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H.\nelim (le_or_lt n p H).\napply (H (pos 0)).\napply (H (pos 0)).\napply (H (pos 0)).\napply (H (pos 0)).\napply (H (pos 0)).\napply (H (pos 0).\napply (H (pos 0)).\napply (H (pos 0)).\nauto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction 1; intros; elim (le_lt_irrefl 0); trivial with arith.\nrewrite b. apply (H (pos (S p)).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_Z in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold lt_Z in |- *; unfold lt_absZ in |- *;\n unfold lt_absQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\nTheorem Zrec4 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n forall p : nat, and_recZ p P.\n\nintros; elim p. \nexact (Zrec2 P H). \nintros; apply Zrec3; trivial with arith.\nQed.\n\n(************)\n",
                "context_tokens": 711,
                "proof_start_offset": 3757,
                "proof_end_offset": 4149,
                "proof": "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p.\nexact (Zrec1 P H).\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p.\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (ind Z P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\napply (fun n : Z => P).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p H H0.\napply (P_ind (fun p : Z => P p) H0).\nexact (P_ind (fun p : Z => P p) H0).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p; elim p. \nintros n H; elim H0; intros.\nunfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold gt in |- *; unfold lt_Z in |- *; apply le_S_n; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P; elim p. \nintros p H; elim p. \nintros; elim H0. \nintros; apply H2; apply H1; apply H2; apply H2; apply H1; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros P H; elim H. \nintros; elim H. \nintros. \nelim H0; intros. \nrewrite H1.\napply (H (pos (S n0))).\napply (H (pos (S n0))).\napply (H (pos (S n0))).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0))).\napply (H (pos (S n0)).\napply (H (pos (S n0))).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0))).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).\napply (H (pos (S n0)).Qed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p. \nexact (Zrec2 P H).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p H0 H1. \nelim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n clear H2; intros.\nelim (H0 n); auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P H; elim H; intros; elim H; intros; elim H; intros; elim H0;\n [ intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n [ intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6;\n [ intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n [ intros; elim H8; intros; elim H9; intros; elim H7; intros; elim H8;\n [ intros; elim H9; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n [ intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H9;\n [ intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10Qed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P H; elim H; intros.\nelim (H1 n); auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p; elim p. \nexact (Zrec2 P H). \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eq y).\n  apply (Z_opp_neg_eqQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intro.\n rewrite (addneg x2 y).\n reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold!; rewrite <- (oppnegnegnegneg x).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegneg y).\n  rewrite (oppnegnegneg y).\n  rewrite (oppnegneg x).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg x).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg x).\n  rewrite (oppnegneg x).\n  rewrite (oppnegneg x).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg x).\n  rewrite (negnegneg y).\n  rewrite (oppneg_neg y).\n  rewrite (oppneg x).\n  rewrite (oppnegneg y).\n  rewrite (oppnegneg y).\n  rewrite (oppneg x).\n  rewrite (oppneg_neg y).\n  rewrite (oppneg y).\n  rewrite (oppneg_neg y).\n  rewrite (oppneg_neg y).Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  unfold Zminus in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2) 1).\n  unfold lt in |- *.\n  apply (addpos_pred (addpos x2)Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  case (le_eq_dec (y - y) (y - x)); intro H;\n    [ left | right ]; reflexivity.\n  intros.\n  apply (lt_irrefl y); assumption.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply (lt_irrefl 0).\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n case y.\n simpl in |- *. intros.\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_irrefl 0).\n apply (lt_trans 0).\n apply (lt_irrefl 0).\n apply (lt_irreflQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n elim (lt_irrefl _ H).\n apply lt_le_trans with (m := x).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := x).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_trans with (m := y).\n apply lt_le_transQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; apply sym_eq; apply sym_eq; apply sym_eq; apply sym_eq; apply sym_eq; apply sym_eq; apply sym_eq; apply sym_eq; apply H.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).\n  apply (Z_div_lt y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros.\nunfold succZ in |- *.\nunfold succZ in |- *.\nunfold succZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ in |- *.\nunfold predZ inQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* 0 *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y; elim x.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* abs n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* abs n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)\nsimple destruct n0.\n(* neg (S n0) *)simple destruct n0.\n(* neg (S n0) *)simple destruct n0.\n(* neg (S n0) *)simple destruct n0.\n(* neg (S n0) *)simple destruct n0.\n(* neg (S n0) *)simple destruct n0.\n(* neg (S n0) *)simple destruct nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nrewrite (opp_involutive x) in |- *; rewrite <- succ_opp_involutive.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_succ_opp.\nrewrite <- pred_opp.\nrewrite <- pred_opp.\nrewrite <- pred_opp.\nrewrite <- pred_opp.\nrewriteQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 730,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofInjNu.\n(**************)\n\nLemma tech_add_pos :\n forall (x : nat) (y : Z),\n)))))) (forall (x y : Z),\n Zsucc (pred x) y = pred x.\nProof sketch.\n(**************)\n\nLemma tech_add_pos :\n forall (x y : Z),\n Zsucc (pred x) y = pred x.\nProof sketch.\n\n(**************)\n\nLemma tech_add_pos_pos : forall x y : Z, x = succZ (pred x) (succ y).\nProof.\n intros.\n apply succ_pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\n apply pred_pos.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Sop_eq3.\n\n(***************)\nLemma tech_add_pos_pos :\n forall (x y : Z) (y : Z),\n Equal (neg x) (sgn y) ->\n forall x : Z,\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (sgn y) ->\n Equal (neg x) (Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof._Z.\n\nLemma tech_add_neg_neg_pos :\n forall x y : Z,\n LeS (neg (S x)) y = succZ (addZ x y).\nProof._Z.\n\nLemma tech_add_neg_neg_pos :\n forall x y : Z,\n LeS (neg (S x)) y = succZ (Nless x y).\nProof._Z.\n\nLemma tech_add_neg_neg_neg :\n forall x y : Z,\n LeS (pos (S x)) y = succZ (Nless x y).\nProof._Z.\n\nLemma tech_add_neg_neg_neg :\n forall x y : Z,\n LeS (neg (S x)) y = succZ (Posz y).\nProof.\n intros.\n apply tech_add_neg_neg; assumption.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof such intros.\n elim (sumbool_of_bool (Neqb x y)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg n *)\nelim (sumbool_of_bool (Neqb y x)).\n (* neg nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Domain.\n\nintros x y; elim x.\n(* negative *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_pos_neg; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |-Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofsquareparallelogram.\n\n(**************)\n\nLemma succ_addZ_r : forall x y : Z, exp x y = exp (pos x) y.\nProofincrst_r.\n\n(***************)\n\nLemma succ_addZ_r : forall x y : Z, exp x y = exp x y.\nProofincrst_r.\n(***************)\n\nLemma succ_ind_l : forall x y : Z, exp x y = exp x y.\nProofwrt_exp.\n(**************)\n\nLemma succ_ind_l : forall x y : Z, exp x y = exp y x.\nProofincrst_r.\n(***************)\n\nLemma succ_ind_r : forall x y : Z, exp x y = exp y x.\nProofwrt_exp.\n(***************)\n\nLemma pred_ind_r : forall x y : Z, exp x y = exp y x.\nProofwrt_exp.\n(***************)\n\nLemma pred_ind_r : forall x y : Z, exp x y = exp y x.\nProofwrt_exp.\n(***************)\n\nLemma exp_ind_r : forall x y : Z, exp x y = expQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof)^(R.\n\n(***************)\nLemma tech_add_neg_pos :\n forall (x y : Z) (y : Z),\n BDDcompare x y = succZ (]>).\nProof Build_succ_pos_pos.\n\nLemma tech_add_neg :\n forall (x y : Z) (y : Z),\n BDDcompare x y = succZ (posnatMult x y) (refl_equal (fun x => x) y).\nProof]|.\n\nsimple induction x.\n simpl in |- *; rewrite pred_pred_succ_pred; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq3.\n\n(***************)\nLemma tech_add_neg_neg :\n forall (x y : Z) (y : Z),\n))),\n pred_ Acknowledgments (fun (y : Z) (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (fun (y : Z) => y) = pred_ Acknowledgments (Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofsse2.\n\nsimple induction x.\nsimpl in |- *; rewrite pred_succ_pred_succ_pred.\nreflexivity.\nintros; rewrite pred_succ_pred_succ.\nreflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq4.\n\n(***************)\nLemma tech_add_neg_neg :\n forall x y : Z, addZ x (pos x) y = succZ (addZ x y).\nProofAppLeft_l.\n(***************)\n\nLemma tech_add_neg_neg_neg :\n forall x y : Z,?]]]]]]];\nintro x; elim x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction  x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)simple induction x.\n(* neg *)\nsimple induction x.\n(* neg *)simple induction x.\n(* neg *)simple induction x.\n(* neg *)simple induction x.\n(* neg *)simple induction x.\n(* neg *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof|.\nintros.\nelim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)simple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)simple induction n.\n(* abs n *)simple induction n.\n(* abs n *)\nsimple induction n.Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple inductionQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction x.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* abs y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple induction n.\n(* neg y *)\nsimple inductionQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)simple induction x.\n(* neg O *)\nsimple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(* neg O *)simple induction x.\n(*Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimple induction x.\n(* neg y *)\nsimpleQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof._eq_4.\n\nLemma pred_ind : forall (x y : Z) (y : Z),\n decide (x = y) (refl_equal x y).\n\nLemma pred_ind : forall (x y : Z), pred (ind x y) = pred x.\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimpleQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof._K.\nLemma pred_addZ_r : forall x y : Z, idr x y = succZ ( Sqrt x y).\nProof._K.\nLemma pred_antisymmetric : forall x y : Z, idl x y = succZ ( Sqrt x y).\nProof.\nintros; elim x.\n(* succ n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* posQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros.\nelim x.\n(* neg x *)\nintros.\ndo 2 rewrite (tech_add_neg_pos_doesn).\nelim H; reflexivity.\n(* pos x *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nsimple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction n.\n(* neg x *)simple induction nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof|.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 741,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg (S y) *)\nreflexivity.\n(* neg x *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg O *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nreflexivity.\n(* neg x *)\nsimple induction n.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\n(* neg x *)\nreflexivity.\n(* neg x *)\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\n(* neg x *)\nreflexivity.\n(* neg x *)\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(*Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* abs n *)\nreflexivity.\n(* neg n *)\nassumption.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nreflexivity.\n(* abs n *)\n(* abs n *)\nreflexivity.\n(*Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimpleQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ") y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* negQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\n forall x y : Z, exp x y = exp y x.\nProof ML Module M := M.\n\nLemma add_ind :\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 4952,
                "proof_end_offset": 5141,
                "proof": "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\ncut (predZ OZ = neg 0); intros.\nelim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\nunfold bequiv in |- *.\nrewrite (succ_,_))]|_succ_succZ; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_neg_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* neg n *)\nsimple induction nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nelim x.\n(* a non-zero *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_pos_neg.\nrewrite (tech_add_neg_succZ n0).\nrewrite H; apply succ_pred_pos.\n(* no element *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg.\nrewrite (tech_add_neg_pos_neg n0).\nrewrite H; apply succ_pred_pos.\n(* no element *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg.\nrewrite H; apply succ_pred_pos.\n(* no element *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg.\nrewrite H; apply succ_pred_pos.\n(* no element *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg.\nrewrite H; apply succ_pred_pos.\n(* no element *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg.\nrewrite H; apply succ_pred_posQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\napply add_mIZ_predZ.\nunfold succ in |- *; apply succ_pred_pred_pos.\n(* - pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(* n/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/pos n *)\nsimple induction n.\nreflexivity.\n(*/posQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nelim x.\n(* (neg (neg 0) *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nsimple induction x.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_neg_pos; trivial.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros; elim x.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)\nsimple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.\nreflexivity.\n(* a proof *)simple induction n.Qed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nelim x.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\napply add_mIZ_succ_pred.\n(* (pos n) *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nrewrite (tech_add_neg_predZ n).\nrewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros; elim x.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)\nsimple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\n(* neg x *)simple induction n.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 5171,
                "proof_end_offset": 5905,
                "proof": "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nsimpl in |- *; symmetry in |- *; exact (add_OZ y).\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_IZ_succZ y).\nintros; rewrite (tech_add_pos_succZ n0 y).\nrewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros.\nelim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros; rewrite (tech_add_neg_predZ n0 y).\nrewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros.\nelim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nintros.\ncut (neg 0 = neg 0); intro. elim H.\nrewrite (succ_succZ (pos 1)); reflexivity.\nrewrite H; reflexivity.\nrewrite H; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nintro.\nrewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* negQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nintros.\ncut (pos 0 = neg 0); intros. elim H.\nrewrite (succ_blockcopy_neg_pos x) in H.\nrewrite (succ_blockcopy_neg_predZ x) in H.\nrewrite (succ_blockcopy_neg_pos x) in H.\nrewrite (succ_blockcopy_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nintros.\ncut (pos n <> 0); intro. elim H.\nrewrite (succ_ARGS); reflexivity.\nrewrite H; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nintros.\ncut (neg 0 = neg 0); intro. elim H.\nrewrite (pred_SORrt); rewrite (succ_bexp (neg 0)); reflexivity.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply eq_sym.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "intros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 710,
                "proof_start_offset": 5935,
                "proof_end_offset": 6461,
                "proof": "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n2.\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros n1 n2 H.\nelim H; auto with *.\nintros; rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nunfold Subproofs in |- *; intros; elim n1.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* succ n *)simple induction n.\n(* neg n *)simple induction n.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\napply tech_add_pos_pos_pos_pos.\n(* pos n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple inductionQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nrewrite (tech_add_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros; elim n1.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm (pos n1)).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm (pos n1)).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (pos n0 < 0); intro. elim H0.\nrewrite (succ_predZ n0). rewrite H.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (pos n1 < n2); intros. elim H0.\nrewrite (pred_Rlength_pos n2); reflexivity.\nreflexivity.\nrewrite (tech_add_pos_neg_pos n2). rewrite H0.\nrewrite H0.\napply succ_pred_pred_Rlength.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pred *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* pred n *)\nsimple induction n.\n(* pred n *)\nsimple inductionQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nunfold Converse in |- *; symmetry  in |- *; exact (add_neg_neg_neg_neg_neg_neg_neg).\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(*Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nelim n2.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_pos_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_pos_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_neg; rewrite H;Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nelim n2.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_neg_neg_neg_neg).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_neg_neg_neg_neg_neg_neg).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_neg_neg_neg_neg).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "reflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 6491,
                "proof_end_offset": 7092,
                "proof": "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nunfold addZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (succ_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (pred_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Rdiv in |- *; intros; elim x.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nreflexivity.\n(* no element *)\nsimple induction x.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Rdiv in |- *; intros; elim x.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(*Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Rdiv in |- *; intros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Qplus in |- *; intros; elim x.\n(* this case the case of (x, y) *)\nsimple induction n.\n(* n=x *)\nsimple induction n.\n(* - n=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)\nsimple induction n.\n(* x=x *)Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold associativity in |- *; intros; elim x.\n(* I *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple inductionQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold not in |- *; intros; elim x.\n(* Post *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpleQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold associativity in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold associativity in |- *; intros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)simple induction nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold associativity in |- *; intros; elim x.\n(* S y *)\nsimple induction n.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* negQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold ssrbool. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ".\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\n",
                "context_tokens": 745,
                "proof_start_offset": 7164,
                "proof_end_offset": 7330,
                "proof": "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nProof.\nunfold neutral in |- *; intros.\nsplit.\nexact I.\nintros.\nsplit.\nexact (add_OZ x).\nunfold addZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold not in |- *; intros; elim x.\n(* neg (S x) *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_comm n).\n(* pos n *)\nintros; elim n.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.\nunfold Z.Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold idZ in |- *; intros; elim x.\n(* pos (S x) *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold not in |- *; intro.\nintro; elim H.\n(* pos n *)\nintros; rewrite (tech_add_neg_pos_pos n0).\nrewrite (tech_add_neg_pos_pos_pos n0).\nrewrite (tech_add_neg_pos_pos n0).\nrewrite (tech_add_neg_pos_neg n0).\nrewrite (tech_add_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg_pos n0).\nrewrite (tech_neg_pos_neg n0).\nrewrite (tech_neg_neg_pos n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_pos_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZ in |- *.\nunfold IdZQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold not in |- *; intros; elim x.\n(* pos O *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold id at 1 in |- *; red in |- *; intro H; elim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold not in |- *; intros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z IdZ in |- *; intros; elim x.\n(* pos n *)\nintros; elim (abs_neg (S n)) ; elim n.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))*)\n  (fun n0 : nat =>\n     match n0 with\n     | O => 0\n     | S p => S (S p)\n     end)\n   | S p => S (S p)\n   | S p => S (S p)\n   end)\n   end).\n\nLemma gt_pos_pos_neg : forall n : nat, n <> 0 -> 0 <> 0.\nsimple induction n.\n (* neg n *)\nintros; elim n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_blockcopy_pos n).\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold id in |- *; intros; elim x.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* neg O *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7528,
                "proof_end_offset": 7725,
                "proof": "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nintros; reflexivity.\nsimple destruct n; intros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros; unfold oppZ in |- *; case (oppZ_dec x); intro.\nintro; left; assumption.\nintro; right; assumption.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nelim (opp_predZ x).\nelim (opp_succZ x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn x).\nelim (opp_sgn xQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nsimple induction x.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; apply opp_neg.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nelim x.\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive x).\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; rewrite <-opp_involutive; rewrite <-opp_involutive; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\napply opp_pos.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_posQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintro.\napply opp_pos_pos_pos.\napply opp_pos_pos_pos_pos.\napply opp_pos_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\napply opp_pos_pos.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nintros; apply opp_neg_neg; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\n",
                "context_tokens": 733,
                "proof_start_offset": 7743,
                "proof_end_offset": 7940,
                "proof": "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nsimple destruct n; intros; reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\n(* pos n *)\nintros; reflexivity. \n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.  (* neg n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.  (* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.  (* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.  (* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nintrosQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\n(* pos nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\n (* neg n *)\nsimple destruct x.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)\nsimple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.\n(* neg n *)simple destruct x.\nreflexivity.Qed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* neg n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)simple destruct x.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)Qed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nintros.\nelim minus_n_O; assumption.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\nsimple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\n(* pos n *)simple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\nsimple destruct x.\n(* pos n *)simple destruct x.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct xQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 7966,
                "proof_end_offset": 8159,
                "proof": "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros;Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct x.\n(* pos n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct x; simplQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (*Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\n (* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destructQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simpleQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct x; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple destruct n; intros; reflexivity.  (*Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct x.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)simple destruct n.\n(* pos n *)simple destruct n.\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)simple destruct n.\n(* pos n *)simple destruct n.\n(* pos n *)simple destruct n.\n(* pos n *)simple destruct n.\n(*Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)\nsimple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\n(* neg n *)simple destruct x.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple destruct n; intros; reflexivity.  (* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 8185,
                "proof_end_offset": 8340,
                "proof": "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nProof.\nintros; elim (addZ_commutativity (pos n) (neg n)); exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* x *)\nsimple induction n.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* x *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* O *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimpleQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* - (pred x) *)\nsimple induction n.\n(* - (pred x) *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* O *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* x *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* x *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimple induction n.\n(* y *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8366,
                "proof_end_offset": 8577,
                "proof": "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim n.\n(* n *)\nsimple destruct n; intros; reflexivity. \n(* n *)\nsimple destruct n.\n(* n *)\nsimple destruct n; intros; reflexivity. \n(* n *)\nsimple destruct n.\n(* n *)\nsimple destruct n.\n(* n *)\nsimple destruct n; intros; reflexivity.  (* n *)\nsimple destruct n.\n(* n *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nsimple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simple destruct n.\n(* 0 *)simpleQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* S y *)\nintros; elim (tech_add_pos_pos_neg_pos n m H).\n(* S y *)\nsimple induction n.\n(* 0 *)\nintros; reflexivity.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simpleQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (tech_add_neg_pos_pos n m); exact H.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (tech_add_neg_pos_pos_neg n).\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* S y *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nintros; reflexivity. \n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple inductionQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8603,
                "proof_end_offset": 8818,
                "proof": "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple destruct n.\nreflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_negZ n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n1 *)\nsimple destruct n0; reflexivity.\n(* S n1 *)\nsimple destruct n0; reflexivity.\n(* S n1 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n0 *)\nsimple destruct n0; reflexivity.\n(* S n1 *)\nsimple destruct n0; reflexivity.\n(* S n1 *)\nsimpleQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S n0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* S n0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simpleQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple induction n.\n(* O *)\nsimple induction n.\n(* O *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n *)simple induction n.\n(* n *)simple induction n.\n(* n *)simple induction n.\n(* n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)simple induction n.\n(* n = SQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple destruct n.\n(* O *)\nintros; rewrite (tech_add_neg_neg_neg_negZ n0).\nelim succ_predZ.\n(* S n0 *)\nintros; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple inductionQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S n0 *)simple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* 0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n0.\n(* n0 *)\nsimple induction n0.\n(* n1 *)simple induction n0.\n(* n1 *)\nsimple induction n0.\n(* n2 *)\nsimple induction n0.\n(* n1 *)simple induction n0.\n(* n1 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n2 *)simple induction n0.\n(* n1 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n2 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n1 *)simple induction n0.\n(* n0 *)simple induction n0.\n(* n1 *)simple induction n0.\n(* n1 *)simple induction n0.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S m *)\nsimple induction n.\nsimple induction n.\n(* S m *)\nsimple induction n.\nsimple induction n.\n(* S n *)\nsimple induction n.\n(* n0 *)simple induction n.\nsimple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\nsimple induction n.\n(* n0 *)simple induction n.\n(* 0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* n0 *)simple induction n.\n(* nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple destruct n; simpl in |- *; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n1Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple induction n.\n(* 0 *)simple inductionQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8843,
                "proof_end_offset": 9198,
                "proof": "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nrepeat split; trivial.\ncase x.\nreflexivity.\nintros; exact (tech_add_pos_negZ n).\nintros; exact (tech_add_neg_posZ n).\ncase x.\nreflexivity.\nintros; exact (tech_add_neg_posZ n).\nintros; exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold alt, oppZ in |- *; intros; apply (add_neg_neg_neg_pos (- n0) (neg m)).\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n0.\n(* S n0 *)\nsimple induction n0.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n0.\n(* S n0 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* S n1 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* 0 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* n2 *)\nsimple induction n0.\n(* n1 *)\nsimple induction n0.\n(* nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppositeZ in |- *;\n [ rewrite (tech_add_neg_pos_pos_pos n0) | reflexivity ].\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n1 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(*Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold not in |- *; intro; apply False_ind; assumption.\n(* S n0 *)\nintros; rewrite (tech_add_neg_neg_pos_neg_neg n0).\nrewrite (tech_add_neg_neg_neg_neg n0).\nrewrite (tech_add_neg_neg_neg_neg n0).\nrewrite (tech_add_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_neg n0).\nrewrite (tech_neg_neg_Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros; elim (Nless_irrefl (S n)).\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* S n1 *)\nsimple induction n.\n(* S n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n1 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n1 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimple induction n.\n(* n0 *)\nsimpleQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple induction zero.\n(* O *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\n(* S n0 *)\nsimple destruct 1.\nreflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_opp_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (tech_add_neg_neg_neg_neg_neg_neg).\nunfold oppZ in |- *; rewrite (Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nunfoldQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; apply opp_pos.\n(* S n0 *)\nsimple destruct n; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(* S n0 *)\nsimple destruct n0; intros; reflexivity.\n(*Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold addZ in |- *; apply oppZ_neg.\n(* S n0 *)\nintros; rewrite (tech_add_neg_pos_neg_neg_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\n",
                "context_tokens": 741,
                "proof_start_offset": 9217,
                "proof_end_offset": 9379,
                "proof": "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nexact addZ_associativity.\nsplit.\nexact addZ_neutral.\nexact addZ_opposite.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nintros.\nelim pred_dec with (Z_to_nat (nat_of_nat (nat_of_nat (nat_of_N n))) 0);\n auto with zarith.\n(*/0 *)\napply Z_to_group_pos_neg.\n(* neg n *)\nintros; exact (tech_add_neg_pos_pos_neg n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_neg_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_neg_neg n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_neg_neg_neg_neg n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_neg_neg n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_neg_neg n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_neg_neg n).Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group;\nunfold Z_group, Z_group, Z_group, Z_group, Z_group;\nunfold Z_group, Z_group, Z_group, Z_group;\nunfold Z_group, Z_group, Z_group, Z_group;\nunfold Z_group, Z_group, Z_inverse, Z_inverse;\nauto with zarith.\n(*/2 *)\nintros H'; exact (tech_add_neg_neg_posZ n).\n(* succ *)\nintros; exact (tech_add_neg_pos_pos_neg_Z n).\n(* succ *)\nintros H'; exact (tech_add_neg_pos_neg_Z n).\n(* succ *)\nintros H'; exact (tech_add_neg_pos_pos n).\n(* succ *)\nintros H'; exact (tech_add_neg_neg_pos_pos n).\n(* succ *)\nintros H'; exact (tech_add_neg_pos_neg_pos n).\n(* succ *)\nintros H'; exact (tech_Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group_plus, Z_plus, Z_plus, Z_plus, Z_plus, Z_plus_0, Z_1, Z_plus_1, Z_1, Z_plus_1, Z_1, Z_plus_1, Z_1, Z_plus_1, Z_1, Z_plus_1, Z_1, Z_plus1_1, Z_plus_1_1.\napply Z_group.\n(*/2/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/4/Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group;\nintros; rewrite <- Z_group_mult_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group.\n\n(*************)\n(*************)\n(* This is the same as a set of the set of a set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set *)\n(* and set of the set of the set of the set of the set of the set of the set of the set *)\n(* set of set of set set of set of the set of the set of the set of the set set of the set *)\n(* set of set of set set of set set of the set set set of the set of the set of the set *)\n(* set of set of set set set of set of set set. *)\n\nDefinition set_set (s : set) (s : set) : set :=\n  set_set (set_set s) (set_set_set s s).\n\nDefinition set_set_set (s : set)Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group;\n\n(*******************)\nDefinition Z_group (x : Z) :=\n  match x return Z with\n  | Z0 => 1\n  | Zneg p => 2 * Zpos p\n  end.\n\n(*************)\nDefinition Z_of_Z (x : Z) :=\n  match x return Z with\n  | Z0 => 1\n  | Zpos p => 2 * Zpos p\n  end.\n\nLemma Z_of_Z_of_Z : forall x : Z, Z_of_Z (Z_of_nat x) = Z_of_Z x.\nProof.\n intros; apply (Z_of_nat_P x).\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group in |- *.\nintro H; exact (proj2 Z).\n(* pos n *)\nintros; exact (proj2 Z).\n(* pos n *)\nintros; exact (proj2 Z).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* pos n *)\nintros; exact (proj2 Z.lt_le_eq_dec 0).\n(* posQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_to_group; split; trivial.\n(* Case n *)\nintros; exact (tech_add_neg_pos_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg Z).\n(* Case n *)\nintros; exact (tech_add_neg_neg Z).\n(* Case n *)\nintros; exact (tech_Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_group.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_power.\nunfold is_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\n",
                "context_tokens": 725,
                "proof_start_offset": 9404,
                "proof_end_offset": 9518,
                "proof": "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nProof.\nsimple destruct x; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; apply abs_eq_oppZ.\n(* - neg n *)\nintros; exact (tech_opp_pos_pos_pos_pos 0).\n(* - neg n *)\nintros; exact (tech_opp_pos_pos_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exact (tech_opp_neg_neg 0).\n(* - neg n *)\nintros; exactQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; rewrite (tech_add_neg_neg_Z n).\nexact (tech_add_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_pos n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_pos n).\n(* neg n *)\nintros; exact (tech_add_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_pos_Z n).\n(* neg n *)\nintros; exact (tech_add_neg_neg_Z n).\n(* neg n *)Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x.\napply opp_eq_opp_Z.\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this means that 0 = x *)\nreflexivity.\n(* In this meansQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; rewrite <- Z_opp_opp_r; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; elim (abs_eq_or_opp_Z x); intros H; elim H; clear H; intros H; elim H; clear H;\n intros H1; apply (tech_add_neg_negZ x).\n(* abs n *)\nintros; exact (tech_add_pos_pos_pos_negZ x).\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; unfold oppZ; case (x==0); trivial.\nintro; absurd (0 < x).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0).\napply (lt_irrefl 0Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; case x.\nreflexivity.\n(* - S n0 *)\nintros; exact (tech_add_pos_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_neg_posZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(* - S n0 *)\nintros; exact (tech_add_negZ n).\n(*Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; elim (abs_eq_or_opp Z).\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(*Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; apply abs_eq_opp_l.\n(* a morphism *)\nintros; exact (tech_add_neg_posZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_posZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_pos_posZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_neg_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphism *)\nintros; exact (tech_add_negZ n).\n(* a morphismQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nsimple destruct x.\n(*... *)\nintros; exact (tech_opp_posZ n).\n(*... *)\nauto.\n(*... *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\nTheorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\n\nsimple destruct x; auto with arith.\nQed.\n\n(*********************)\n",
                "context_tokens": 722,
                "proof_start_offset": 9544,
                "proof_end_offset": 9675,
                "proof": "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\nreflexivity.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* S n = 0 *)\nsimple induction n.\n(* 0 = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* 0 = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* n = 0 *)\nsimple induction n.\n(* 0 = 0 *)\nsimple induction n.\n(* S n =Qed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n.\n(* 0 *)\nintros; exact (tech_opp_posZ n).\n(* 0 *)\nintros; exact (tech_opp_pos_neg Z).\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivity.\n(* 0 *)simple induction n.\nreflexivityQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n.\n(* S n *)\nintros; exact (tech_opp_pos_posZ n).\n(* S n *)\nintros; exact (tech_opp_pos_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_neg_negZ n).\n(* S n *)\nintros; exact (tech_opp_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_neg_negZ n).\n(* S n *)\nintros; exact (tech_opp_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_neg_negZ n).\n(* S n *)\nintros; exact (tech_opp_pos_negZ n).\n(* S n *)\nintros; exact (tech_opp_neg_negZ n).\n(* S n *)\nintros; exact (tech_opp_neg_neg_negZ n).\n(* S n *)\nintrosQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros n; elim n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct x; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n.\n(* O *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* S n = S n *)\nsimple induction n.\n(* n = S n *)\nsimple induction n.\n(* n = S n *)\nsimple induction n.\n(* n = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* n = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* n = S n *)simple induction n.\n(* n = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* 0 = S n *)\nsimple induction n.\n(* 0 = S n *)\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n.\n(* n = 0 *)\nintros; exact (tech_add_pos_pos_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_pos_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_pos_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_neg_neg_negZ n).\n(* n = 0 *)\nintros; exact (tech_add_neg_neg_neg_neg_pos n).\n(* n = 0 *)\nintros; exact (tech_add_neg_neg_neg_neg_pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\n",
                "context_tokens": 316,
                "proof_start_offset": 1992,
                "proof_end_offset": 2126,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros; auto with arith.\nintros x H0; elim (plus_comm x H0); intros; auto with arith.\nintros x H1; elim (plus_comm x H1); intros; auto with arith.\nintros x0 H2; elim (plus_comm x0 H2); intros; auto with arith.\nintros x0 H3; elim (plus_comm x0 H3); intros; auto with arith.\nintros x0 H3; elim (plus_comm x0 H3); intros; auto with arith.\nintros x1 H3; elim (plus_comm x0 H3); intros; auto with arith.\nintros x0 H3; elim (plus_comm x0 H3); intros; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros.\nauto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros; auto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nsimpl in |-Qed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros.\n rewrite plus_comm.\n rewrite plus_comm.\n assumption.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros.\nsimpl in |- *.\nauto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nsimple induction 1; intros.\nauto with arith.\nintros x0 H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim HQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim (Add_add (S O) (Add 1 (S O)) (Add 1 (S O)) (Add 1 (S O)) (Add 1 (S O)) (Add 1 (S O)) (Add 1 (S O)) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (S O) (Add 1 (SQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply H.\nintros x H0; elim H.\nintros x0 H1; elim H1; intros x1 H2; elim H2; intros x2 H3; elim H3; intros x3 H4; elim H3; intros x4 H5; elim H4; intros x5 H6; elim H5; intros H6; elim H6; intros H6; elim H6; intros H7; elim H7;\n intros x5 H6 H8; elim H6; intros x7 H8; elim H8; intros x7 H8; elim H8;\n intros x10 H9; elim H9; intros x10 H10; elim H9; intros x11 H9; elim H10;\n intros x11 H10; elim H10; intros H10 H11; elim H10; intros H12 H11; elim H12;\n intros x12 H13 H14; elim H13; intros x13 H14; elim H14; intros H14 H14;\n elim H14; intros H14 H14 H14; elim H14; intros H15 H14 H15 H15; introsQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\napply H.\napply H.\napply H0.\napply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\nLemma neutral_add : neutral S G Add O -> O = Add O O.\n\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\n(********************)\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n(************)\n",
                "context_tokens": 403,
                "proof_start_offset": 2245,
                "proof_end_offset": 2466,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elimQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim HQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H; intros; elim H1; intros; elim H1;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim HQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nsimple induction x; intros; elim (H0 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim (H1 O H); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply abs_com; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\n",
                "context_tokens": 227,
                "proof_start_offset": 1772,
                "proof_end_offset": 2677,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x.\nelim (mult_comm x x).\nintros x0 H1.\nrewrite H1.\nrewrite (mult_comm x0).\napply mult_assoc_l.\napply mult_comm.\napply mult_comm.\napply mult_assoc.\napply mult_assoc_l.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_comm.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napplyQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros x H.\n  elim (mult_O_or_eq (S x) x).\n  intros x0 H1.\n  elim (mult_O_or_eq (S x) x0).\n  intros x1 H2.\n  elim H2.\n  intros H3 H4.\n  apply H2.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H6.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H5.\n  apply H6.\n  apply H6.\n  apply H5.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H0.\nelim (prod_assoc_l O A (A x) (A x)).\nintros.\nelim (prod_assoc_r O A (A x) (A x)).\nintros.\nelim (prod_assoc_r O A x).\nintros.\nelim (prod_assoc_r O A x).\nintros.\napply prod_assoc_r_r_l_l_r.\napply prod_assoc_r_l_r.\napply prod_assoc_r_l_r.\napply prod_assoc_l.\napply prod_assoc_r_r_r.\napply prod_assoc_r_r.\napply prod_assoc_r_r.\napply prod_assoc_r_r.\napply prod_assoc_r_r_l.\napply prod_assoc_l.\napply prod_assoc_r_l_r.\napply prod_assoc_r_r.\napply prod_assoc_r_r_r.\napply prod_assoc_r_r.\napply prod_assoc_r_r_l.\napply prod_assoc_r_r_r.Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nelim (eq_nat_dec x 0).\nintros.\napply plus_n_O.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_SnQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nunfold is_ring.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintro A.\napply sym_equal; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_r _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_r _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_r _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nintros.\napply (mult_O_l _ _ H).\nunfold mult in |- *.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto with arith.\n  apply le_trans with (S x); auto withQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros.\n  elim (eq_nat_dec (S x) (S x)).\n  intro H1; elim H1; intro H2; elim H2; intro H3; elim H3; intros H4 H5;\n split.\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).\n  apply (H (S x)).Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x.\nunfold is_ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "              *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 576,
                "proof_start_offset": 2697,
                "proof_end_offset": 3436,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (prod_opp_r (Mult x O) (H0 O H1)); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros x y H H1 H2 H3 H4.\nelim (H3 O x H1); intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (div_zero x y); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H9;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (mult_opp_r (R x) (Ar x y)); intros; elim H5.\nelim (H6 O x); intros; elim H6.\nelim (H7 O x); intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_opp_r.\napply mult_oppQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H9; intros; elim H10; intros;\n elim H9Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (mult_opp_r x y); intros; elim H6; intros; elim H6; intros; elim H6; intros.\nclear H6 H7 H8 H9.\nelim (H8 O x H10); intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim (mult_opp_l (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).\nintros.\nelim (mult_opp_r (A:=A)).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\n",
                "context_tokens": 721,
                "proof_start_offset": 3456,
                "proof_end_offset": 4193,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H1 H2 H3 H4.\nelim (H3 O x); intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim (prod_opp_r x y); intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nunfold is_ring.\napply (Build_Map (A:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B) (B:=A) (B:=A) (B) (B:=A) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (B:=A) (B) (Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H7; intros;\n elim H6; intros; elim H7; intros; elim H7;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim (prod_inv_l_l_ex A B x); intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H3; intros.\nclear H3 H4 H5 H6 H8 H9 H10 H11 H12.\nelim (H12 x0 (Opp y x)); intros; elim H5; intros; elim H6; intros.\nclear H5 H5 H6 H7 H9 H11 H12.\nelim (H12 x0 (Opp y x)); intros; elim H7; intros; elim H7; intros.\nclear H5 H6 H7 H8 H10 H12.\ngeneralize (H7 x0 (Opp y x)); intros; elim H7; intros.\nclear H5 H6 H7 H8 H9 H10 H11.\nelim (H12 x0 (Opp y x)); intros; elim H7; intros.\nclear H5 H6 H7 H8 H9 H11 H12.\nrewrite H8.\nrewrite H9.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nrewrite H10.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim (mult_opp_r x y); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\n",
                "context_tokens": 720,
                "proof_start_offset": 4215,
                "proof_end_offset": 4702,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim (mult_opp_l x y); intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim (prod_inv_r x y); intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H10;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H4; intros; elim H4; intros; elim H4; intros.\nelim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H11; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H10; intros; elim H10Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H2; intros; elim H4; intros; elim H4;\n intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nunfold is_upper in |- *; split.\nexact (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))) x)))).\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nunfold is_empty in |- *; split.\nexact (H (0 x)).\nexact (H2 x y H H0).\nsplit.\nexact (H4 x y H H0).\nsplit.\nexact (H4 x y H0 H1).\nsplit.\nexact (H4 x y H0).\nsplit.\nexact (H1 x y H0 H1).\nsplit.\nexact (H2 x y H0 H1).\nsplit.\nexact (H5 x y H1).\nsplit.\nexact (H5 x y H1).\nsplit.\nexact (H5 x y H1).\nsplit.\nexact (H5 x y H1).\nsplit.\nexact (H2 x y H1).\nsplit.\nexact (H4 x y H2).\nsplit.\nexact (H4 x y H1).\nsplit.\nexact (H2 x y H2).\nsplit.\nexact (H4 x y H2).\nsplit.\nexact (H4 x y H0).\nsplit.\nexact (H4 x y H1).\nsplit.\nexact (H5 xQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H11; intros; elim H11; intros; elim H10; intros;\n elim H11; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12;\n intros; elim H13; intros; elim H12; intros; elim H13;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\n",
                "context_tokens": 742,
                "proof_start_offset": 5096,
                "proof_end_offset": 5330,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_zero in |- *.\nintros a b H H0 H1 H2; elim H1; intros; elim H2; intros.\nelim H3; intros; elim H3; intros.\nelim H4; intros; elim H4; intros.\nelim H5; intros.\nelim H5; intros; elim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nelim (prod_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_O_OQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nsimple induction 1; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_empty_I in |- *.\nintros.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.\nunfold is_empty_I in |- *.Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro.\nelim H; intros; elim H0; intros; elim H0; intros.\nsplit.\napply (O_O_O_eq O).\nassumption.\napply (O_O_eq O).\nassumption.\nelim H1; intros; elim H1; intros; elim H2; intros.\nsplit.\napply (O_O_eq O).\nassumption.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H.\nunfold is_empty in |- *.\nintuition.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; \n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; \n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; \n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nsimple induction 1; intros.\nsplit; intros.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |- *.\nsplit; intros.\nunfold inv in |-Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; introsQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H9;\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nelim 1.\nintros.\nelim H1; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": ".\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 5349,
                "proof_end_offset": 6556,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H H0 H1.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H4; intros; elim H5; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H.\napply div_add; assumption.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1 H2.\nelim H1; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H4; intros.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplitQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H H0 H1 H2.\nelim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H9;\n intros; elim H9;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros.\nsplit. exact H1.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H H0.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros; elim H; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3; intros.\nsplit; apply H1.\nexact (H0 a H1).\nsplit; apply H.\nexact (H0 a H1).\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\n\n\nunfold divide in |- *; intros.\nsplit.\n(* A d *)\nelim H0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 727,
                "proof_start_offset": 6576,
                "proof_end_offset": 7261,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1 H2 H3.\nelim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_ring.\nunfold is_field in |- *.\nsplit.\nexact (Z_div_mult a b d).\nexact (Z_div_mult a b d).\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nunfold is_ring.\nintros a b d H H0 H1 H2 H3 H4 H5.\nelim H0; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H11;\n intros; elim H10; intros; elim H10; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0.\nelim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nunfold is_ring.\nintros a b d H H0 H1 H2.\nelim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros.\nelim (H2 d x0 H3); intros.\nelim (H3 d x0 H5); intros.\nelim (H5 d x0 H6); intros.\nelim (H5 d x0 H6); intros.\nelim (H6 d x0 H6); intros.\nelim (H6 d x0 H6); intros.\nelim (H6 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H7 d x0 H6); intros.\nelim (H8 d x0 H6); intros.\nelim (H8 d x0 H6); intros.\nelim (H9 d x0 H7); intros.\nelim (HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H H0 H1.\nelim H; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elimQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1 H2 H3.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H12;\n intros; elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 732,
                "proof_start_offset": 7280,
                "proof_end_offset": 8081,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold is_ring.\nintros a d.\nunfold is_ring.\nintros a b d.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H1.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ring.\nintros a H0.\nunfold is_ringQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d H.\nunfold divide in |- *; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nsplit.\n exact (H a).\nexact (H a).\n\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\n(* A (a*b) *)\nelim H; intros; elim H0; intros; elim H0; intros.\nclear H0 H1.\nelim (mult_O_O H1); intros.\nsplit.\nexact (H0 d x H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\napply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp; apply div_opp;\n applyQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\n(* A d = 0 *)\nelim H; intros.\nelim H0; intros.\nsplit.\nexact (H1 a H1).\nsplit.\nexact (H2 a H1).\nsplit.\nexact (H2 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H2 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H4 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H1 a H2).\nexact (H3 a H2).\nsplit.\nexact (H2 a H2).\nsplit.\nexact (H3 a H2).\nexact (H3 a H2).\nsplit.\nexact (H3 a H2).\nsplit.\nexact (H3 a H2).\nexact (H2 a H2).\nsplit.\nexact (H3 a H2).\nexact (H4 a H2).Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nunfold is_ring.\nunfold is_ring.\nunfold is_mult in |- *; intro.\nelim H; intros.\nsplit; assumption.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\nelim H; intros.\nsplit.\nexact (H0 a H0).\nexact (H1 a H0).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d H H0.\nelim H; intros.\nsplit.\nexact (H a d H H1).\nintros; elim H; intros; elim H2; intros.\nsplit.\nexact (H3 a b H0 H1).\nintros; elim H3; intros; elim H3; intros.\nsplit.\nexact (H3 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H1 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H3 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H1 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H1 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H3 a b H2).\nintros; elim H3; intros.\nsplit.\nexact (H4 a b H2).\nintros; elim H3; intros.\nsplit.\nexact (H1 a b H1).\nintros; elim H3; intros.\nsplit.\nexact (H3 aQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold is_ring.\nintros a d H H0.\nelim H; intros. \nelim H1; intros. \nelim H1; intros.\nsplit.\nexact (H3 a b H0 H1).\nelim H2; intros.\nsplit.\nexact (H3 b H1).\nexact (H3 b H1).\nexact (H2 b H1).\nexact (H3 b H1).\nexact (H1 b H2).\nexact (H3 b H2).\nexact (H3 b H1).\nexact (H3 b H2).\nexact (H4 b H1).\nexact (H1 b H2).\nexact (H3 b H2).\nexact (H3 b H1).\nexact (H1 b H1).\nexact (H2 b H2).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H4 b H2).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H4 b H1).\nexact (H3 b H2).\nexact (H4 bQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d H.\nunfold divide in |- *.\nelim H; intros.\nelim H0; intros.\nelim H0; intros; elim H0; intros.\nclear H0.\nelim H0; intros.\nsplit.\nexact (H2 a b H1).\nrewrite (H1 d x).\nelim H1; intros.\nclear H0.\nelim H1; intros.\nsplit.\nexact (H2 a b H0 H1).\nrewrite (H1 d x).\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1.\nelim H1; intros.\nclear H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8240,
                "proof_end_offset": 8608,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\n apply (H0 H).\nsplit; intros.\n apply (H1 H).\nsplit; intros.\n apply (H1 H0).\nsplit; intros.\n apply (H2 H0).\n split; intros.\n apply (H1 H0).\n split; intros.\n apply (H1 H0).\n split; intros.\n apply (H1 H2).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H1 H0).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H1 H1).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H3 H1).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (H2 H1).\n split; intros.\n apply (H2 H0).\n split; intros.\n apply (Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nunfold is_gcd in |- *.\nsplit.\nexact (gcd_abs a b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nsplit. exact (H1 H).\nsplit. exact (H1 H1).\nsplit. exact (H2 H1).\nsplit. exact (H1 H1).\nsplit. exact (H2 H1).\nsplit. exact (H2 H1).\nsplit. exact (H2 H1).\nsplit. exact (H2 H2).\nsplit. exact (H2 H2).\nsplit. exact (H2 H1).\nsplit. exact (H1 H2).\nsplit. exact (H2 H2).\nsplit. exact (H1 H2).\nsplit. exact (H2 H2).\nsplit. exact (H2 H2).\nsplit. exact (H1 H2).\nsplit. exact (H2 H2).\nsplit. exact (H2 H).\nsplit. exact (H1 H2).\nsplit. exact (H2 H2).\nsplit. exact (H2 H2).\nsplit. exact (H2 H2).\nsplit. exact (Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\n split; intros.\n split.\n assumption.\n split.\n assumption.\n split.\n assumption.\n split.\n assumption.\n split.\n assumption.\n split.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\n split.\n assumption.\n assumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nunfold is_gcd in |- *.\nelim H0; intros.\nelim H1; intros.\nrewrite H1.\nrewrite H0.\nelim (mult_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H2.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H2.\nelim (mult_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1.\nelim (mult_O_O_O a).\nrewrite H1Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nintros.\nunfold is_gcd in |- *.\nsplit.\nexact (gcd_abs a b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nunfold is_gcd in |- *.\nsplit; intros.\nelim H0; intros.\nsplit; intros.\napply H1.\napply H.\napply H0.\napply H.\napply H.\napply H.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\nunfold is_gcd in |- *.\nsplit; intros.\n(* a <> 0 *)\nelim H0; intros.\nelim H1; intros.\nsplit.\nexact (H2 a b H0 H1).\nexact (H3 b H1).\nexact (H3 b H1).\nexact (H3 b H1).\nexact (H2 b H2).\nexact (H3 b H1).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H3 b H2).\nexact (H4 b H2).\nexact (H3 b H2).\nexact (H2 b H2).\nexact (H4 b H2).\nexact (H4 b H2).\nexact (H3 b H2).\nexact (H1 b H2).\nexact (H3 b H2).\nexact (H2 b H2).\nexact (H3 b H2).\nexact (H1 b H2).\nexact (H3 b H2).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\nintros.\napply gcd_sym; assumption.\nintros.\napply gcd_sym; assumption.\nintros.\napply gcd_sym; assumption.\nintros.\napply gcd_sym; assumption.\nintros.\napply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nintros.\napply divide_abs_l with (O := O); assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8628,
                "proof_end_offset": 8894,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\n split; intros.\nsplit; intros.\nsplit; intros.\n split; intros.\nsplit; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\n split; intros.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros; elim H; intros; elim H0; intros.\nsplit. exact (H0 H1).\nsplit. exact (H1 H1).\nsplit. exact (H1 H1).\nsplit. exact (H2 H2).\nsplit. exact (H3 H0).\nsplit. exact (H2 H3).\nsplit. exact (H2 H0).\nsplit. exact (H2 H1).\nsplit. exact (H2 H2).\nsplit. exact (H2 H0).\nsplit. exact (H3 H2).\nsplit. exact (H2 H3).\nsplit. exact (H2 H3).\nsplit. exact (H3 H3).\nsplit. exact (H0 H2).\nsplit. exact (H3 H4).\nsplit. exact (H2 H3).\nsplit. exact (H2 H2).\nsplit. exact (H3 H2).\nsplit. exact (H3 H0).\nsplit. exact (H2 H0).\nsplit. exact (H4 H3).\nsplit. exact (H4 H2).\nsplit. exact (Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nsplit. exact (H1 H2).\nelim H; intros; elim H0; intros; elim H2; intros.\nsplit. exact (H2 H0).\nelim H; intros; elim H2; intros.\nsplit. exact (H2 H0).\nelim H; intros; elim H3; intros.\nsplit. exact (H1 H1).\nelim H; intros; elim H2; intros.\nsplit. exact (H1 H2).\nelim H; intros; elim H3; intros.\nsplit. exact (H3 H2).\nelim H; intros; elim H3; intros.\nsplit. exact (H1 H0).\nelim H; intros.\nsplit. exact (H1 H1).\nelim H; intros; elim H3; intros.\nsplit. exact (H1 H2).\nelim H; intros; elim H3; intros.\nsplit. exact (H2 H2).\nelim H; intros; elim H4; intros.\nsplit. exact (H3 HQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros.\nauto with arith.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros.\nelim H; intros; elim H0; intros.\nelim H; intros; elim H1; intros.\nelim H1; intros; elim H1; intros.\nelim H1; intros.\nelim H1; intros; elim H2; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction d.\n simpl in |- *; intros; elim H; intros; elim H2; intros.\nsplit; apply le_trans with (S d).\n assumption.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros.\nsplit. exact (H1 H2).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros; elim H; intros; elim H; intros; elim H0; intros.\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H3 H1).\nelim (div_eq_dec n H2); intros; elim H1; intros.\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H3 H2).\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H3 H3).\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H4 H4).\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H4 H3).\nelim (div_eq_dec n H2); intros; elim H1; intros.\nsplit. exact (H4 H4).\nelim (div_eq_dec n H2); intros; elim H2; intros.\nsplit. exact (H4 H4).Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; trivial; intros.\nelim H; intros; elim H0; intros.\nsplit. exact (H1 H0).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H0; intros.\nelim H1; intros; elim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H1; intros.\nelim H1; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\n",
                "context_tokens": 711,
                "proof_start_offset": 8928,
                "proof_end_offset": 9827,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (H2 (div_O_O H) (div_O_O H) (div_O H) (div_O H) (div_O_O H) (div_O H) H1)); intros;\n   elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H3 (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) H2)); intros;\n   elim H3; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim (H4 (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H2));\n   intros; elim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim (H4 O (divQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nunfold a in |- *; intros a x H0.\nelim H0; intros; elim H1; intros.\nelim H0; intros; elim H2; intros.\nsplit. exact H3.\nelim H0; intros; elim H3; intros.\nsplit. exact H2.\nelim H2; intros; elim H3; intros.\nsplit. exact H3.\nelim H3; intros.\nsplit. exact H3.\nelim H3; intros.\nsplit. exact H3.\nexact H4.\nelim H4; intros.\nsplit. exact H3.\nelim H4; intros.\nsplit. exact H4.\nelim H4; intros.\nsplit. exact H3.\nelim H4; intros.\nsplit. exact H4.\nexact H4.\nelim H4; intros.\nsplit. exact H4.\nexact H4.\nexact H4.\nexact H4.\nelim H4; intros.\nsplit. exact H2.\nexact H4.\nexact H5.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H2; intros.\nelim (H3 O (div_O_O H) (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H).\n\nelim H4; intros.\nelim (H5 O (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H).\n\nelim (Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim (H2 O (div_O_O H) (div_O H) (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) H) (div_O H) H1).\ngeneralize H2; clear H2; intro.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim (H3 (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H1)).\ngeneralize H2; clear H2; intro.\nelim H3; intros.\nelim (H4 (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) H2)).\ngeneralize H3; clear H2; intro.\nelim (H4 (Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H11;\n intros; elim H8; intros; elim H10; intros; elim H11;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H11;\n intros; elim H10; introsQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x; elim H0; intros; elim H1; intros.\nelim (H1 (A:=A)); intros; elim H3; intros; elim H3; intros.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros.\nelim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros.\nelim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6;Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros.\nelim (H1 O (div_O_O H) (div_O_O_O H) (div_O_O H) (div_O_O H) H1)); intros;\n elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros.\nelim (H4 O (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O H) (div_O_O H) H1));\n intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (H4 O (div_O_O H) (div_O_O H) (div_O_O H) (div_O_O H) (div_O H) H0)); intros;\n elim H0; intros.\nelim (H5 O (div_O_O_O H) (div_O_O H) (div_O_O H) H0)); intros; \n elim H5; intros.\nelim (H5 O (div_O_O H) (div_O H) (div_O H) (div_O H) (div_O H) H1)); intros; \n elim H5; intros.\nelim (H5 O (div_O_O H) (div_O H) (div_O H) (div_O H) H0)); intros; \n elim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim (H7 O (div_O H) (div_O H) (div_O H) (div_O H)Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\napply H.\napply (zero_ext_zero _ _ H).\napply H.\napply (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ H).\napply H.\napply (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).\nexact (zero_ext_zero _ _ H).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n\n\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\n",
                "context_tokens": 684,
                "proof_start_offset": 9908,
                "proof_end_offset": 11305,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H3; intros.\nelim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros.\nelim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros.\nelim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H6; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H0; intros.\nelim H1; intros; elim H2; intros.\nelim H3; intros.\nelim (H4 O (div_O_O H0) (div_O_O H1) (div_O H1) (div_O_O H1) (div_O H2) H3).\nelim (div_O_O_O H1) (div_O_O H1) (div_O_O H1) H3).\nelim (div_O_O_O H1) (div_O_O H1) (div_O H1) (div_O H1) (div_O H2) H3).\nelim (div_O_O_O H1) (div_O_O H1) (div_O H1) H3).\nelim (div_O_O H1) (div_O H1) (div_O H1) H3).\nelim (div_O_O_O H1) (div_O H1) (div_O H1) (div_OQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nelim (H2 O (div_O_O H1) (div_O_O H1) (div_O_O H1) (div_O_O H2) (div_O_O_O H2) (div_O_O H1) H3)).\n\nelim H2; intros; elim H3; intros.\nelim H3; intros; elim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros a b d1 d2 d3.\nelim (H0 a); intros; elim H1; intros.\nelim H1; intros; elim H1; intros.\nelim (H2 a); intros; elim H2; intros; elim H2; intros.\nelim (H3 a); intros; elim H3; intros.\nelim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros.\nelim H8; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros.\nelim (H4 a); intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H7;\n intros; elim HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros; elim H4; intros.\nelim H3; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; introsQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros a b d1 d2 d3 H0 H1 H2 H3 H4 H5 H6 H7.\nelim (H2 a (Add a b d1) (Add a b d2) (Add b d1 b d3)); intros.\nelim H3.\nexact (H3 a (Add x b d1) (Add y d1 b d2)); intros.\nelim H3.\nexact (H4 a (Add y d1 b d2) (Add x b d1) (Add x b d2)); intros.\nelim H3.\nexact (H4 a (Add y d1 b d2) (Add x b d1) (Add x b d1) (Add x b d2) (Add x b d2));\n intros.\nelim H3.\nexact (H4 a (Add y d1 b d1) (Add x b d1) (Add y d2)); intros.\nelim H3.\nexact (H4 b d2 H1 (Add x b d1) (Add x b d2) (Add x b d2)); intros.\nelim H3.\nexact (HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros.\nelim H4; intros.\nelim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros.\nelim H5; intros; elim H4; intros.\nelim H5; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H6; intros.\nelim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros; elim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\n\n\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* d2 = O *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* d2 <> 0 *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* d1 <> 0 *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n(**********)\n",
                "context_tokens": 731,
                "proof_start_offset": 11320,
                "proof_end_offset": 11524,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nunfold is_ring in |- *.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros.\napply (inv_com S A x H0 H1 H2).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H1 H2).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H2).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H2).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H3).\nelim H1; intros.\nsplit.\napply (inv_com S A x H1 H2).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H3).\nelim H1; intros.\nsplit.\napply (inv_com S A x H1).\nelim H1; intros.\nsplit.\napply (inv_com S A x H0 H2).\nelim H2; intros.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\napply opp_zero.\nassumption.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nunfold is_zero in |- *.\nelim (prod_sum_ex_0 (sum A (sum A (sum A (sum B (sum A (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B B (sum B (sum B (sum B (sum B B B)))) B))) B)) B) x)\n (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B B (sum B (sum B B))) B))) B))\n (sum B (sum B (sum B (sum B (sum B (sum B B (sum B (sum B (sum B B (sum B (sum B B))) B))) B)))\n (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B B B))) B))) B))\n (sum B (sum B (sum B (sum B (sum B (sum B (sum B (sum B B (sum B (sum B (sum B B (sum B (sum B B (sum B B))))Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\napply opp_zero.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; introsQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nunfold is_zero in |- *.\nintro.\nunfold not in |- *.\nintro.\nunfold is_midpoint in |- *.\nunfold not in |- *.\nintro.\nunfold not in |- *.\nintro.\nunfold not in |- *.\nintro.\nunfold not in |- *.\nintro.\nunfold not in H.\nintro.\nunfold not in |- *.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.\nunfold not in H.\nintro.Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros x H.\nelim H; intros; elim H; intros; elim H; intros.\nelim (H x H0); intros.\nelim H; intros; elim H; intros; elim H0; intros.\nsplit.\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp S A x0).\napply (inv_opp SQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim (prod_opp_l O A (Add x (O.succ x) 0) H0); intros; elim H0; intros; elim H1; intros.\nelim H1; intros; elim H2; intros.\nrewrite H2; rewrite H3; reflexivity.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nunfold is_zero in |- *.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H3; intros; elim H2; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nunfold is_zero in |- *.\nintros.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nunfold is_midpoint in |- *.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zdiv.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zdiv.v                                  *)\n(****************************************************************************)\nRequire Export Zbase.\nRequire Export Zadd.\nRequire Export Zmult.\nRequire Export Zle.\nRequire Export Euclid.\n\nUnset Standard Proposition Elimination Names.\n\n(********************)\nDefinition is_diveuclZ (a b q r : Z) :=\n  b <> OZ /\\ leZ OZ r /\\ ltZ r (absZ b) /\\ a = addZ (multZ b q) r.\n\n(***************************)\nInductive diveuclZ (a b : Z) : Set :=\n    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.\n\n(************************)\n",
                "context_tokens": 234,
                "proof_start_offset": 1632,
                "proof_end_offset": 3661,
                "proof": "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nintros a b; case b; intros.\nelim H; reflexivity.\ncase a; intros.\napply (divexZ OZ (pos n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (pos n)).\nreflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)).\nintros.\napply (divexZ (pos n0) (pos n) (posOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r).\nexact (gt_S_le r n g).\nexact (tech_div1 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (pos n) (negOZ q) OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (pos n) (negOZ q))).\napply (tech_div2 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (pos n) (neg q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div3 n0 n q r e g).\ncase a; intros.\napply (divexZ OZ (neg n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (neg n)); reflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\napply (divexZ (pos n0) (neg n) (negOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r); exact (gt_S_le r n g).\nexact (tech_div4 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (neg n) (posOZ q) OZ).\nunfold is_diveuclZ in |- *.\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (neg n) (posOZ q))).\napply (tech_div5 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (neg n) (pos q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div6 n0 n q r e g).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction 1.\n simpl in |- *; auto with arith.\n simpl in |- *.\n intros q r H; elim H.\n intros.\n simpl in |- *; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\n intros a b H.\n apply (lt_O_le a b); auto with zarith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\n  intros; elim (Z_lt_dec a b); intros.\n  elim (Z_lt_dec a b); intros.\n  apply Z_le_lt_trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; intros.\n assumption.\n assumption.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; intros.\n apply (mult_reg_l a b); assumption.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\n  intros a b H H0.\n  elim (divZ_mod a b); intros H1; elim (divZ_mod a b); intros H2;\n    elim (divZ_mod a b); intros H3;\n      elim (divZ_mod b b); intros H4; elim (divZ_mod a b); intros H4;\n        elim (divZ_mod a b); intros H4; elim (divZ_mod b b);\n        intros H5; elim (divZ_mod a b); intros H5;\n          elim (divZ_mod b b); intros H5; elim H5; intros H5;\n          elim (divZ_mod a b); intros H6; elim H5; intros H6;\n            elim (divZ_mod b b); intros H6; elim H6; intros H6;\n              elim (divZ_mod b b); intros H6; elim (divZ_mod b b);\n              intros H6; elim H6; intros H7;\n              elim (divZ_mod b b); intros H6; elim H6; intros H7;\n                elim (divZ_mod b b); intros HQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\n intros a b H0.\n case (Z_lt_dec a b).\n intro H1.\n case H1.\n intro H2.\n apply H2.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_lt_trans with (absZ b); auto with zarith.\n apply Z.le_Qed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; intros.\n left.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n left.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n left.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n left.\n right.\n left.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.\n right.Qed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\n intros a b H0.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_lt.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_lt_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\n intro.\n apply Z.div_lt_le.\n assumption.\n intro.\n apply Z.div_lt_le_dec.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\n",
                "context_tokens": 286,
                "proof_start_offset": 1694,
                "proof_end_offset": 1893,
                "proof": "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nintro n.\ninduction n; intro.\n reflexivity.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos (pos n)); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n); assumption.\n apply (pos n);Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n intros n m H; elim H; auto.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nintro n.\ninduction m.\n simpl in |- *.\n apply pos_ind_not_pos.\n simpl in |- *.\n apply pos_ind_not_pos.\n simpl in |- *.\n apply pos_ind_not_pos.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.\n apply pos_ind_not_neg.\n simpl in |- *.Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n intros n m H.\n apply pos_not_negZ.\n assumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nintro n.\n case (le_gt_dec 0 n).\n intro.\n left.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.\n assumption.\n intro.\n apply pos_le_weak.Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  intros n m H; generalize (lt_irrefl _ H).\n  apply pos_not_pos_not_posZ.\n  apply pos_not_pos_not_pos_Z.\n  apply pos_not_pos_not_pos_not_pos_not_pos_not_pos.\n  apply pos_not_pos_not_pos_not_pos_not_pos_not_neg.\n  apply pos_not_pos_not_neg_not_pos_not_neg_not_neg_not_neg_not_neg.\n  apply pos_not_pos_not_neg_not_neg_not_neg_not_neg_not_neg.\n  apply pos_not_neg_not_neg_not_neg_not_neg_not_neg_not_neg.\n  apply pos_not_neg_not_neg_not_neg_not_neg_not_neg.\n  apply pos_not_neg_not_neg_not_neg_not_neg_not_neg_not_neg.\n  apply pos_not_neg_not_neg_not_neg_not_neg.\n  apply pos_Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n intros n m H; elim H; clear H; intros H0; elim H; clear H; intros H0; elim H; clear H; intros H1; elim H; clear H;\n intros H1 H2; elim H1; clear H1; intros H2; elim H2; clear H1;\n intros H3; elim H3; clear H3; intros H4; elim H3; clear H3; intros H5; elim H3; clear H3;\n intros H4; elim H4; clear H3; intros H5; elim H5; clear H3;\n intros H4; elim H4; clear H4; intros H5; elim H5; clear H5;\n intros H5; elim H5; clear H5; intros H6 H6; elim H6; clear H6;\n intros H6 H7; elim H7; clear H6; intros H8 H9; elim H9; clear H9;\n intros H9; elim H9; clear H9; intros H9 H9; elim H10; clear H9;\n intros H9; elim H9; clear H9; introsQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nsimple induction n.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *; intros; discriminate.\n simpl in |- *;Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n intros.\n cut (forall n m : nat, n <> pos m -> n <> pos m) by (intro; discriminate).\n elim H; auto.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n intros n m H.\n elim H.\n apply lt_le_trans with (pos n).\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos_not_pos.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos_not_pos.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos_not_pos_not_pos.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos_not_pos.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos_not_pos_not_neg_not_pos.\n assumption.\n apply pos_not_pos_not_neg_not_pos_not_neg.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_neg_not_pos.\n assumption.\n apply pos_not_pos_not_pos_not_pos_not_pos.\n assumption.\n apply pos_not_pos_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\nLemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\n\n\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H. rewrite H0; simpl in |- *; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 362,
                "proof_start_offset": 1912,
                "proof_end_offset": 2065,
                "proof": "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nintros; elim x.\nleft; reflexivity.\nintros; right; discriminate.\nintros; right; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nunfold not in |- *; intros.\ncut (is_posn x <> 0).\n intro H; elim H; auto with arith.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intro H.\nelim (lt_irrefl _ H).\nintros; apply H; assumption.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos n)).\nsimpl in |- *; exact H.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nsimple induction x; simpl in |- *; intros.\nauto.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nunfold not in |- *; intros.\ncut (is_pos_n x = 0); intro H.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim HQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nintros.\napply lt_not_pos.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelim H.\nelimQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros x.\nunfold not in |- *; intro.\ncut (is_pos_n (pos n) (pos n)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos n)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos n)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (pos m)).\nsimpl in |- *; intro.\ncut (is_pos_n (pos n) (posQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nunfold not in |- *; intro.\ncut (is_posn (pos n)) (pos n) <> pos m).\nsimpl in |- *; exact H.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n)).\nsimpl in |- *; exact H0.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\nunfold not in |- *; intro.\ncut (is_posn (pos n)) (pos n) = pos (pos n)).\nsimpl in |- *; intro.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H2 _ H3); intros; assumption.\nelim (H3 _ H3); intros; assumption.\nelim (H3 _ H3); intros; assumption.\nelim (H1 _ H2); intros; assumption.\nelim (H2 _ H3); intros; assumption.\nelim (H3 _ H3); intros; assumption.\nelim (H3 _ H3);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\n",
                "context_tokens": 156,
                "proof_start_offset": 1347,
                "proof_end_offset": 1460,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi3 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi3 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi5 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi6 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi7 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi8 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi7 : forall (A : Set) (P : A -> Prop), P x.\n\nDefinition pi8 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi9 : forall (A : Set) (P : A -> Prop), P x -> P x.\n\nDefinition pi8 : forall (ADefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop), P x -> P x.\nintros A P P; elim Q.\nexact (fun x => P x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P.\napply (fun x => P x).\nexact (fun x => P x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition empty : forall (A : Set) (x : A) (y : A), P x y -> P y.\nintros A P x y; elim x; elim y; elim x; elim y; elim x; elim y; elim x; elim y; elim y;\n intros x0 y1 H'0; elim H'0; intros H'1 H'2 H'3; elim H'0; intros H'3 H'4; elim H'4;\n intros H'4 H'5; elim H'4; intros H'6 H'6 H'7; elim H'6; intros H'8 H'9;\n clear H'3 H'4 H'5 H'6 H'7 H'8; elim H'5; intros H'9 H'9;\n clear H'3 H'6 H'7 H'8; elim H'8; intros H'9 H'9;\n clear H'4 H'5 H'7; elim H'9; intros H'9 H'9;\n clear H'5 H'6 H'8 H'9; elim H'9; intros H'9 HDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (x y : A) (y : B), pi1 x y -> x = y :>A.\nintros A x y H; elim H; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (x y : A), P x y -> x = y :>A.\nProof.\n  intros A x y H.\n  destruct (H x y) as [y H].\n  apply H0; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\napply (H (x : A) (x : A) (y : A) (z : A) => P (x, z)).\nauto with *.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P.\napply (fun x : A => exists y : A, R y x).\nintros x y H'0 H'1.\napply (fun x y : A => exists y : A, R y x).\nauto with *.\nintros x y H'1.\napply (fun x y : A => exists y : A, R y x).\nauto with *.\nintros x y H'1.\napply (fun x : A => exists y : A, R x y /\\ R y x).\nauto with *.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> P x}.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> P x.\n\nLemma pi3 : forall (A : Set) (P : A -> Prop), pi3 -> pi3.\nintros A P Q.\napply (fun x y => P x y /\\ P y x).\napply (fun x y => P x y /\\ P y x).\nexact (fun x y => P x y /\\ P y x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop), {x : A | P x}.\nintros A P.\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (Build_Map (A:=A) (fun x : A => P x)).\napply (BuildDefined."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\n",
                "context_tokens": 203,
                "proof_start_offset": 1485,
                "proof_end_offset": 1628,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros A P p; elim p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros A P p.\nred in |- *; intros x H0; elim H0.\nintros x0 H1; elim H1; intros H2; elim H2; intros H3; elim H3; intros H4; elim H4; intros H5; elim H5; intros H6; elim H7; intros H7; elim H7;\n intros H8 H9; elim H8; intros H9; elim H9; intros H9; elim H9;\n intros H9 H10; elim H9; intros H10; elim H10; intros H11 H10; elim H11;\n intros H12 H13; elim H12; intros H13 H13; elim H13; intros H13 H14; elim H13;\n intros H14 H14 H14; elim H14; intros H14 H14 H14; elim H14; intros H14 H15; elim H14; intros H14 H14 H14;\n elim H14; intros H14 H14; elim H14; intros H15 H15; elim H14; intros H15 H15;\n elim H14; intros H15 H14; elim H14; introsQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\n\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\n(*******************)\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n(************)\n",
                "context_tokens": 313,
                "proof_start_offset": 1781,
                "proof_end_offset": 2050,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; elim (inv_sym _ H0).\n\nintros x y z H; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; introsQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold ex1 in |- *; intros.\nelim H1; intros.\nexists x0; exists x1; split.\n assumption.\nexists x1; split.\n assumption.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\n simpl in |- *; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nelim (plus_comm (S x) (S x) (S y)).\nauto.\nintros.\napply (plus_comm (S x) (S y)).\nauto.\nintros.\napply (plus_comm (S x) (S y)).\nauto.\nintros.\napply (plus_comm (S x) (S y)).\nauto.\nintros.\napply (plus_comm (S x) (S y)).\nauto.\nintros.\napply (plus_comm (S y) (S y)).\nauto.\nintros.\napply (plus_comm (S y) (S y)).\nauto.\nintros.\napply (plus_comm (S y)).\nauto.\nintros.\napply (plus_comm (S y) (S y)).\nauto.\nintros.\napply (plus_comm (S y) (S y)).\nauto.\nintros.\napply (plus_comm (S y)).\nauto.\nintros.\napply (plus_comm (S y) (S y)).\nauto.\nintros.\napply (plus_comm (SQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold ge in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexact (inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_invQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintro; elim H; intros.\nsplit; trivial.\nintroQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold mult in |- *; intros.\nelim H0; intros.\nsplit; intros.\nelim H1; intros.\nsplit; intros.\nelim H1; intros.\nelim H1; intros.\nsplit; intros.\nelim H1; intros.\nelim H2; intros.\nsplit; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nsplit; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nsplit; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  cut (exists x : Z, exists y : Z, x = y /\\ x = y).\n  intro.\n  cut (exists x : Z, x = y).\n  intro.\n  elim H.\n  apply pos_pos_pos.\n  elim H.\n  elim H.\n  assumption.\n  elim H0.\n  assumption.\n  intros.\n  elim H0.\n  apply pos_pos_pos.\n  elim H0.\n  assumption.\n  elim H0.\n  elim H0.\n  assumption.\n  elim H0.\n  apply pos_pos_pos.\n  elim H0.\n  assumption.\n  elim H0.\n  assumption.\n  apply pos_pos_pos.\n  elim H0.\n  assumption.\n  elim H0.\n  assumption.\n  elim H0.\n  assumption.\n  assumption.\n  elim H0.\n  assumption.\n  assumption.\n  intro.\n  elim H0.\n  apply pos_pos_pos.\n  elim H0.\n  assumption.\n  assumption.\n  elim H0.\n  assumption.\n  apply pos_pos_pos.\n  elim H0.\n  assumption.\n  elim H0.\n  assumption.\n  apply pos_pos_pos.\n Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ y).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ y).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\n intro.\n apply (zero_negZ x).\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros x H.\ncase (x * x); intro H1; elim H1; intro H2.\nelim H1; intro H3; elim H3; intro H4; elim H3; intro H4; elim H4; intro H5; elim H5;\n intro H5; elim H5; intro H6; elim H5; intro H6; elim H6; intro H7; elim H6;\n intro H6; elim H6; intro H7; elim H7; intro H8; elim H8;\n intro H6; elim H7; intro H8; elim H8; intro H8; elim H8;\n intro H9; elim H9; intro H9; elim H9; intro H9; elim H10;\n intro H9; elim H10; intro H10; elim H10; intro H11; elim H11; intro H11; elim H11;\n intro H11; elim H11; intro H11; elim H12; intro H13; elim H11;\n intro H11; elim H12; intro H12; elim H12; intro H13; elim H13;\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (one_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZ x)).\n intro.\n apply (zero_negZ (absZ y)).\n intro.\n apply (zero_negZ (absZQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x.\n  case x.\n  intro.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros.\n apply (zero_pos_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zeroQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x.\n  case x.\n  left.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_absZ.\n  right.\n  apply abs_abs_Z.\n  right.\n Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold planar in |- *.\n intros.\n apply (div_absZ x).\n apply (div_absZ x).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\n apply (div_absZ y).\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intro x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim x; elim H; elim H; elim H;\n clear x x x0 x1; intros y0 H1 H2; elim H1; elim H1; elim H1; elim H2; elim H2; elim H2; elim H1; elim H2;\n clear x0 x1; intros y1 H3; elim H3; elim H3; elim H3; elim H3; elim H3; elim H3;\n elim H3; elim H3; elim H3; elim H3; elim H3; elim H3; elim H3;\n clear x0 x1; introsQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x; elim x; intros.\n  left; apply pos_pos_pos; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x H; elim H; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact (zero_pos x).\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold IHcl_basic in |- *.\nelim (Zle_or_lt x (absZ x)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ y)).\nexact (Z_le_eq_dec x (absZ y)).\nexact (Z_le_lt_eq_dec x (absZ yQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact (fun x : Z => x).\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply Build_Map.\nexact (fun m : nat => m < n * m)%Z.\nexact (fun n : nat => m < n * m)%Z.\nexact (fun n : nat => m < n * m)%Z.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold ec in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact (fun x y : Z => x * y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *; intros; assumption.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H3.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; intro H; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |-Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim x; intro H; elim H; intros H0; elim H0; intros H1;\n [ left | left | right ];\n assumption.\n(* reg *)\nintro; elim H0.\n(* (neg x) *)\nintros; elim H0.\n(* (neg x) *)\nintros; elim H0.\n(* (neg x) *)\nintro; elim H0.\n(* (neg x) *)\nintros; elim H0.\n(* (neg x) *)\nintros; elim H0.\n(* (neg x) *)\nintro; elim H0.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H0.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elim H1.\n(* (neg x) *)\nintros; elimQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (pos 0) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *; intros; elim H.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim x.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *.\nintros; elim H0.\n(* (neg n) *)\nintros n0 H1 H2; elim H1.\n(* (neg n) *)\nintros n0 H1 H2; elim H2.\n(* (neg n0) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros n1 H2; elim H2.\n(* (neg n0) *)\nintros; elim H0.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H1.\n(* (neg n0) *)\nintros; elim H2.\n(* (neg n0) *)\nintros; elimQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)\nintros; elim x; simpl in |- *. \n(* (neg n) *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": " Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 737,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* Zero *)\nreflexivity.\n(* Zero *)\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivity.\n(* Zero *)\nreflexivityQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* negative *)\nreflexivity.\n(* neg n *)\nunfold lt_absZ in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfold ge in |- *; unfold ge in |- *;\n unfold ge in |- *; unfold ge in |- *; unfoldQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros n.\nelim (le_Sn_O n H).\n(* neg n *)\nintros; elim H0.\n(* neg n *)\nunfold lt_absZ in |- *; unfold gt in |- *; unfold gtZ in |- *;\n unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold gt in |- *; unfold lt_absZ in |- *;\n unfold gt_absZ in |- *;\n unfold gt_absZ in |- *; unfold gt in |- *; unfold gt_absZ in |- *;\n unfold gt in |- *; unfold gt_absZ in |- *;\n unfold gt in |- *; unfold gt_absZ in |- *;\n unfold gt in |- *; unfold gt_absZ in |- *;\n unfold gt_absZ in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt_absZ in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt_absZ in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction 1.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n (* var *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\n(* abs *)\n(* abs *)\nreflexivity.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold gt in |- *; unfold gtZ in |- *; unfold lt in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* t *)\nreflexivity.\n(* t *)\nunfold lt_absZ in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfold lt in |- *; unfold lt in |- *; unfold lt in |- *;\n unfoldQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction 1.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivityQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* 0 *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold geZ in |- *; unfold gtZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;\n unfold geZ in |- *; unfold geZ in |- *; unfold geZ in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3529,
                "proof_end_offset": 3703,
                "proof": "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; intros; exact I.\nsimpl in |- *; intros; exact I.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x. \n(* pos n *)\nassert (0 < n).\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold lt in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ inQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim x; simpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* x = 0 *)\nreflexivity.\n(* x = 0 *)\n(* xQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* pos n *)\napply le_succ_l.\n(* pos n *)\nauto.\n(* pos n *)\nunfold lt_opp_pred in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |-Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim x.\n(* pos n *)\nelim (le_absZ x (pos x) (pos x)).\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nsimple induction x.\n(* pos n *)\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim x.\n(* pos n *)\nrewrite (le_opp_signed _ H).\napply le_opp_signed_pos.\napply le_opp_signed_pos.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\napply le_opp_signed_neg.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\n(* x = 0 *)\nreflexivity.\n(* t *)\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x; simpl in |- *.\n (* (neg n) *)\nreflexivity.\n(* no hypothesis *)\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* zero *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(* cond *)\nreflexivity.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 3722,
                "proof_end_offset": 3902,
                "proof": "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros.\napply (leZ_antisymmetric x OZ).\nrewrite H.\nexact (le_opp_OZ_l y H1).\nexact H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H; auto with arith.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H; intros; exact I.  simpl in |- *; intros; exact I.  simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x = yQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elim H0.\n(* x = 0 *)\nintros; elimQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim x.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* y = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x = y *)\n(* x = y *)\nreflexivity.\n(* x =Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(* neg n *)\nintros; elim H.\n(*Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nunfold lt in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold neqZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y; elim x.\n(* (neg x) *)\nunfold le_opp in |- *; unfold oppZ in |- *; intros; exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\nLemma le_opp_OZ :\n forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\n\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_OZ_l y H1).\nexact H0.\nQed.\n\n(***************)\n",
                "context_tokens": 725,
                "proof_start_offset": 3922,
                "proof_end_offset": 4176,
                "proof": "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nrewrite (le_opp_OZ x y H H0 H1).\nrewrite (opp_opp Z IdZ addZ OZ oppZ Z_group y I); elim H.\nrewrite (le_opp_OZ x y H H0 H1); simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nelim (le_opp_predZ x) ; intro y.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 1 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 2 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 3 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\n(* 4 *)\n(* 4 *)\nreflexivity.\n(* 4 *)\nreflexivity.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\n apply (le_opp_COPYING x : nat | x = x :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (x = y :> Z) (Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y; elim x.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (pos n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (neg n) *)reflexivity.\n(* Case (neg n) *)\nreflexivity.\n(* Case (Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y H; elim H.\n(* 0 < x *)\nelim H; intro H; elim H.\n(* 0 < x *)\nelim H; intro H; elim H; intro H; elim H; intro H0; elim H; intro H0; elim H; intro H0; elim H; intro H0;\n elim H; intro H0; elim H0; intro H0; elim H0; intro H0; elim H0; intro H0; elim H0; intro H0;\n elim H0; intro H0; elim H0; intro H0; elim H0; intro H0; elim H0; intro H0;\n elim H0; intro H1; elim H0; intro H1; elim H1; intro H1; elim H1; intro H2;\n elim H0; intro H1; elim H1; intro H1; elim H1; intro H1; elim H1; intro H2;\n elim H1; intro H0; elim H1; intro H0; elim H1; intro H1;\n elim H0; intro H1; elim H1; intro H1;Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y H H0.\nelim H0.\n(* pos n *)\nintro H; elim H0.\n(* (pos n) *)\nintro H; elim H0.\n(* (neg n) *)\nintros H; elim H0.\n(* (pos n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H.\n(* (neg n) *)\nintro H; elim H0.\n(* (neg n) *)\nintro H; elim H0.\n(* (Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\n(* t *)\n(* t *)\nreflexivity.\n(* t *)\nreflexivity.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y) (pos y)).\nexact (le_opp_ memren (pos y) (pos y) (pos x) (pos y)).\nexact (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y))).\nexact (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y))).\nexact (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y)).\nexact (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y))).\nexact (le_opp_ memren (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (pos y) (posQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y; elim x.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x) *)\nreflexivity.\n(* x = (neg x)Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_html x) in H.\nexact (le_opp_sinh2).\nexact (le_opp_predZ y H).\nexact (le_opp_sinh2).\nexact (le_opp_ {-} x H).\nexact (le_opp_sinh2).\nexact (le_opp_tvar y H).\nexact (le_opp_rassoc y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar x H).\nexact (le_opp_tvar y H).\nexact (le_opp_tvar xQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_predZ_l (pos y)). rewrite H. exact (le_opp_predE x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\n",
                "context_tokens": 121,
                "proof_start_offset": 1253,
                "proof_end_offset": 1349,
                "proof": "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\n simpl in |- *.\nsimple inductionQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\n simpl in |- *.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_S_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_O_Sn.\n simpl in |- *.\n apply eq_Qed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.\n  reflexivity.\n  simpl in |- *.\n  intros.  elim (le_n_O _ H).\n  intros.  elim (le_Sn_O _ H).\n  intros.  elim (le_S_O _ H).\n  intros.  apply le_S_n_S.  apply le_S_n.  apply le_S_n.  apply le_S_n.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nintro.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.\n  simpl in |- *. intros. elim (lt_O_O _ H). intros.\n    apply lt_O_Sn.\n    apply lt_O_Sn.\n    apply lt_O_Sn.\n    apply lt_O_Sn.\n    apply lt_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_O_Sn.\n    apply le_OQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\n simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n simple induction n.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n intros.\n apply (lt_O_O_eq (S n)).\n apply lt_O_Sn.\n assumption.\n simpl in |- *.\n intros.\n apply (lt_O_Sn_eq (S n)).\n apply le_S_n.\n assumption.\n apply le_S_n.\n assumption.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nintros.\napply eq_lt_O_eq.\nrewrite <- (eq_S_n _ _ H).\napply eq_le_S.\nrewrite <- (eq_S_n _ _ H).\napply le_S_n.\nrewrite <- (eq_S_n _ _ H).\napply le_S_n.\nrewrite <- (eq_S_n _ _ H).\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply le_S.\napply leQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction 1; simpl in |- *.\nintros; apply eq_gt_O_dec.\nexact H.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n. intro.  elim n.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\n",
                "context_tokens": 164,
                "proof_start_offset": 1370,
                "proof_end_offset": 1528,
                "proof": "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct 1; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 224,
                "proof_start_offset": 1548,
                "proof_end_offset": 1637,
                "proof": "Lemma mult_neutr : forall n : nat, 1 * n = n.\nProof.\nunfold mult in |- *; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; simpl in |- *.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\n",
                "context_tokens": 261,
                "proof_start_offset": 1662,
                "proof_end_offset": 1875,
                "proof": "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nProof.\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple destruct x; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction m; simpl in |- *; auto with arith.\nintros; elim (mult_ne_utr n); simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple destruct n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim (mult_ne_utr n m); intros.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite (mult_comm m); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple destruct 1; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros.\napply (mult_neutr m (y + (y + m) + (y + m)) (y + m)).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + m)).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (mult_neutr m (y + (y + m) + (y + m))).\napply (multQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim (mult_ne_utr n m); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction 1; auto with arith.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; elim n; simpl in |- *.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\n",
                "context_tokens": 352,
                "proof_start_offset": 1894,
                "proof_end_offset": 2016,
                "proof": "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nintros; elim (plus_comm m (y * m) (y * m)).\nrewrite (plus_comm m (y * m + (y * m))).\nrewrite (plus_comm m (y * m + (y * m))).\nrewrite (plus_comm m (y * m + (y * m + (y * m))).\nrewrite (plus_comm m (y * m + (y * m + (y * m)))).\nrewrite (plus_comm m (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + y))))\n  in |- *; intro; elim (plus_comm m (y * m + (y * m + (y * m + (y * m + (y * m + y)))\n  in |- *; intro; elim (plus_comm m (y * m + (y * m + (y * m + (y * m + (y * m + y))))\n  in |- *; intro; elim (plus_comm m (Qed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros.\napply le_antisym; apply le_minus2; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; apply le_minus2; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 400,
                "proof_start_offset": 2036,
                "proof_end_offset": 2173,
                "proof": "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\nLemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\n\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(************)\n",
                "context_tokens": 456,
                "proof_start_offset": 2190,
                "proof_end_offset": 2319,
                "proof": "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nintros; elim (le_lt_eq_dec n (S m) H); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros n m H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0;\n intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H1; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nsimple induction 1; intros.\n rewrite plus_comm; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl a b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.div_eucl b d).\ndestruct (Z.Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct H as [H | H]; [left|right]; intros H.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [right|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\ndestruct (H b d); [left|right]; intros H; subst; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n apply Zis_gcd_iff_gcd.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\ndestruct d as [p|p]; simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec a b); simpl; auto.\ndestruct (Z.ltb_spec aQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct (Kwhile (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Z.leb (Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nunfold Zis_gcd.\nsimpl.\ndestruct (Z.abs_dec a b); [left|right].\nnow left.\nnow left.\nnow right.\nnow right.\nnow left.\nnow right.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n destruct ( Zis_gcd_for_euclid_aux a b d) as [H | H].\n destruct (Zis_gcd_for_euclid_aux b d) as [H | H].\n exists (LIsPtr DO NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOT NOTQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n rewrite <- (Z.abs_eq b); trivial.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H H0.\n apply Zis_gcd; assumption.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H H0.\ndestruct a; simpl in H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 732,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition.\n  rewrite <- H; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.\n intros; destruct H; constructor; intuition.Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case (Zneq_bool x y); intros H; trivial.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Zneq_bool x y); intro H; constructor; intuition; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y.\n  unfold Zneq_bool;\n  destruct (Zneq_bool x y) as [H|H]; simpl in H; discriminate H.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition.\n  rewrite <- (Zneq_bool_false _ H); auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H.\n case (Zeq_dec x y); intro H.\n exists x; auto.\n exists (Z.neq_bool x y); auto.\n exists (Z.neq_bool x y); auto.\n apply Zneq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y; case H; constructor; intuition (auto with zarith).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x==y); auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y); intros; discriminate. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y); auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\n",
                "context_tokens": 702,
                "proof_start_offset": 4191,
                "proof_end_offset": 4728,
                "proof": "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\nintros x0 y0.\napply PHL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e'=> forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nintuition auto with zarith.\ncutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y H0; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H0; apply (Zneq_bool_true _ H1).\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec y0 y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec y0 y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0); intros; auto.\n case (Z.eq_dec x y0);Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H1; apply Zneq_bool_true_iff.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Zneq_bool.\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [right|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [right|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).\n case (x==0); [left|right]; constructor; intuition (auto with zarith).Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; case H; constructor; intuition.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x y H0; case H0; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Zneq_bool; case (x?=y); auto; intros; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H1; case H1; intros H2; subst.\n rewrite Zcompare_refl.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.\n discriminate.Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y H; unfold Zneq_bool; case (x?= y)%Z; auto; intros; \n try (intros; discriminate); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "var A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\nLemma gcd_partial_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) \n   |= gcd  {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\n",
                "context_tokens": 693,
                "proof_start_offset": 4775,
                "proof_end_offset": 6000,
                "proof": "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\nintros x0 y0.\napply THL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\ forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nconstructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\nconstructor 1.\napply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\nauto with datatypes.\nunfold Zwf; simpl; (intuition auto with zarith).\ncutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\ncut ((fst e')<=(snd e')); auto with zarith.\ncut ((fst e')<>(snd e')); auto with zarith.\ncut (~(fst e')<=(snd e')); auto with zarith.\nintros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply PHL.\n repeat split; trivial.\n apply Zneq_bool_true; trivial.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; apply PHL.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n applyQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; rewrite <- (gcd_total_proof x0 y0); auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply PHL.\n assumption.\n assumption.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply PHL.\n simpl.\n intros e; intuition subst; auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H1; apply (gcd_total_proof x0); generalize H1; clear H1; unfold Zneq_bool.\n case (x0?=y0); intros; discriminate. \n intros e; intuition subst.\n (* after POLY THIS LINE *)\n rewrite (gcd_total_proof y0 y0 H1); auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; apply (gcd_total_proof x0 y0 (VX e))).\n case (Z_lt_eq_bool x0 y0); intros; trivial.\n (* - <div *)\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonneg; trivial).\n assert (0 <= Z_of_nat x0) by (apply Z_le_is_nonnegQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; apply (gcd_total_proof x0 y0); assumption.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply PHL.\n destruct a as [x y0].\n exists x0.\n split.\n split.\n split.\n apply gcd_refl.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "un e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\nLemma gcd_total_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0)\n  |= gcd  [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply THL.soundness.\n simpl.\n intros e; intuition subst.\n (** after simplification, I provide the invariant and then the variant *) \n constructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\\n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n constructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\n (** - proof that my variant is a well_founded relation *) \n constructor 1.\n apply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\n auto with datatypes.\n (** - other goals *)\n  unfold Zwf; simpl; (intuition auto with zarith).\n (** -- invariant => postcondition \n      --- gcd part like in partial correctness proof \n *)\n  cutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\n  (** --- new VY in branch \"then\" is positive *)\n  cut ((fst e')<=(snd e')); auto with zarith.\n  cut ((fst e')<>(snd e')); auto with zarith.\n  (** --- new VX in branch \"else\" is positive *)\n  cut (~(fst e')<=(snd e')); auto with zarith.\n  intros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\n  discriminate.\nQed.\n\n(** ** Another example: infinite loops in partial correctness.\n\nBasic Hoare logic is not well-suited for reasoning about non-terminating programs.\nIn total correctness, postconditions of non-terminating programs are not provable.\nIn partial correctness, a non-terminating program satisfies any (unsatisfiable) postcondition.\n\nFor example, in an informal \"meaning\", the program below enumerates all multiples of 3. But this meaning \ncan not be expressed here (even in partial correctness).\n*)\n\nDefinition enum_3N := \n  (Iseq (Iset VX (const 0))\n        (Iwhile (const true)\n                (Iset VX (PLUS VX (const 3))))).\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6625,
                "proof_end_offset": 6819,
                "proof": "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\napply PHL.soundness.\nsimpl.\nconstructor 1 with (x:=fun _:Env => True).\nintuition (discriminate || auto).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n destruct e as [e|e].\n exists e; exists e; auto.\n exists e; auto.\n destruct e as [e|e].\n exists e; exists e; auto.\n exists e; auto.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros; apply I.index_enum_3N_stnesses.\n exists 0%N.\n apply (Iwhile (const true)\n                (fun e => (VX e) + 1)\n                (fun e' => (VX e) + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e) + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e) + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') + 1)\n                (fun e' => (VX e') +Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n apply Iseq_0.\n apply Iseq_1_1_1.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\ndestruct e as [e H].\nconstructor 1 with (x:=fun e0 => (T e0) < 0 /\\ (T e0) < 0 /\\ (T e0) < 0 /\\ (T e0) < 0 /\\ (T e0) < 0 /\\ T e1 < 0 /\\ T e0 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e0 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e0 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e0 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T e1 < 0 /\\ T2 < 0 /\\ T e1 < 0 /\\ T1 < 0 /\\ T e1 < 0 /\\ T1 < 0 /\\ T2 < 0 /\\ T2 < 0 /\\ T1 < 0 /\\ T2 < 0 /\\ T3 < 0 /\\ T1 < 0 /\\ T2 < 0 /\\ T1 <Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n induction 1; simpl; auto.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = false); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = false); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = true); trivial.\n apply (Xseq (fun e => (VX e)) = false);Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nrewrite <- (Iseq 0%nat).\nassert (0<=(snd e)).\n apply H0.\nrewrite H1; auto with arith.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\napply (Iseq (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => VX e)) (fun e => (VX e)) (fun e => VX e)) (fun e => (VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => VX e).\n\nLemma enum_3N_stuff :\n  (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VXQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n destruct (X (const 0)).\n destruct (X (const 0)).\n destruct (X (const 0)).\n destruct (X (const 0)).\n destruct (X (const 1)).\n destruct (X (const 0)).\n destruct (X (const 1)).\n destruct (X (const 1)).\n destruct (X (const 1)).\n destruct (X (const 1)).\n destruct (X (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (const 1) (constQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True))).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun e => True)).\n apply (Iseq (fun eQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros; apply (Iseq (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => (VX e)) (fun e => VX e)) (fun e => (VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => VX e)) (fun e => V X e)) (fun e => VX e)) (fun e => VX e) (fun e => VX e)) (fun e => VX e)) (fun e => VX e)).\n\n(** * Basic function *)\n\nLemma enum_4N_st'': (fun e => True) -> True.\nProof.\n introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "(** * Generation of Hoare proof obligations in total correctness\n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file gives a syntactic definition of the weakest precondition [wp]\n introduced in #<a href=hoarelogicsemantics.html>#[hoarelogicsemantics]#</a>#.\n We refine here the approach of  #<a href=partialhoarelogic.html>#[partialhoarelogic]#</a>#.\n*)\n\nGlobal Set Asymmetric Patterns.\nSet Implicit Arguments.\nRequire Export hoarelogicsemantics.\nRequire Wf.\n\nModule TotalHoareLogic (HD: HoareLogicDefs).\n\nExport HD.\nModule HLD:=HD.\n\nDefinition sem_wp := wp.\n\nExport Wf.\n\n(** * Syntactic definition of the weakest precondition.\n\n In the following, we show that this definition is logically\n equivalent to [wp].\n *)\nFixpoint synt_wp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n          ((E.eval cond e)=true -> (synt_wp p1 post e))\n       /\\ ((E.eval cond e)=false -> (synt_wp p2 post e))\n  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e\n  | (Iwhile cond p) =>  \n        exists inv:Pred,\n        exists R:E.Env -> E.Env -> Prop,\n             (well_founded R)\n          /\\ (inv e)\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=false -> post e')\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=true -> synt_wp p inv e')\n          /\\ (forall e0, (inv e0)\n                  -> (E.eval cond e0)=true -> synt_wp p (fun e1 => R e1 e0) e0)\n  end.\n\n(** * Soundness *)\n\n(** Monotonicity is also trivially satisfied by [wp].\n    We need it here to prove the soundness.\n*)\n",
                "context_tokens": 530,
                "proof_start_offset": 1747,
                "proof_end_offset": 1962,
                "proof": "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\ninduction p; simpl; firstorder eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p R e H.\n  induction H.\n  - destruct (ex_wp p post1 e) as [ | [ | ] ]; destruct (ex_wp p post2 e) as [ | [ | ] ]; simpl in *; try congruence.\n    + simpl in *.\n      destruct (ex_wp_monotonic p post1 e) as [ | [ | ] ]; destruct (ex_wp_monotonic p post2 e) as [ | [ | ] ]; simpl in *; try congruence.\n      + simpl in *.\n      destruct (ex_wp_monotonic p post1 e) as [ | [ | ] ]; destruct (ex_wp_monotonic p post2 e) as [ | [ | ] ]; simpl in *; try congruence.\n      + simpl in *.\n      destruct (ex_wp_monotonic p post2 e) as [ | [ | ] ]; destruct (ex_wp_monotonic p post2 e) as [ | [ | ] ]; simpl in *; try congruence.\n      + simpl in *.\n      destruct (ex_wp_monotonic p post1 e) as [ | [ | ] ]; destruct (ex_wp_monotonic p post2 e) as [ | [ | ] ]; simpl in *; try congruence.Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p R1.\n  destruct (ex_wp_monotonic (fun p => ps1 e) _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\nintros ppost1 post2 e.\nintros ppost1 post1 e.\nintros ppost1 ppost2.\nintros ppost2 ppost2.\nintros ppost1 ppost2.\nintros ppost1 ppost2 ppost1 ppost2.\nintros ppost1 ppost1 ppost1 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost1 ppost2 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost2 ppost2 ppost1 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost1 ppost2 ppost2 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost1 ppost2 ppost2 ppost2 ppost1 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost1 ppost2.\nintros ppost1 ppost1 ppost1 ppost1 ppost2 ppost2.\nintros ppostQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p ps1 e0.\n  induction sigma1 as [ | x e0 sigma0 e1 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e0 sigma0 e1 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e2 sigma0 e1 sigma0 e2 sigma0 e2 sigma0 e3 sigma0 e3 sigma1 e3 sigma0 e2 sigma0 e2 sigma1 e3 sigma0 e3 sigma0 e3 sigma1 e3 sigma0 e3 sigma1 e3 sigma0 e3 sigma1 e3 sigma1 e3 sigma2 e3 sigma0 e3 sigma0 e3 sigma1 e3 sigma0 e3 sigma1 e3 sigma0 e3 sigma0 e3 sigma1 e3 sigma0 e3 sigma1 e3 sigma2 e3 sigma0 e3 sigma0 e4 e5 sigma0 e3 sigma0 e5 sigma1 e3 sigma1 e3 sigma1 e3 sigma0 e3 sigma1 e3 sigma0 e4 sigma1 e3 sigma1 e3 sigma0 e3 sigmaQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p [s1 s2] [s2 s3] [s3] [s4 [s4 [s5 [s5 [s6 [s6 [s7 [s7 [s7 [s8 [s9 [s9 [s10 [s10 [s10 [s11 [s11 [s12 [s11 [s12 [s12 [s13 [s13 [s14 [s14 [s14 [s14 [s15 [s14 [s15 [s14 s14 [s15 [s14 [s15 s15 s15]]]]]]]]]]]]]]]].\n  - (* i.1.2.2.2.2.2.2.3.3.4.4.4.5.6.7.7.7.8.8.9.9.9.10.10.11.11.12.12.13.13.14.\n  - (* i.1.2.2.3.4.4.5.6.7.7.8.9.9.10.11.12.13.14.14.\n  - (* i.1.2.2.3.4Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p cs e H0 H1 H2 H3.\n  destruct H3 as [H3 [H4 H6]].\n  destruct H3 as [H4 [H5 H7]].\n  exists e; split; auto.\n  apply (H3 H5).\n  apply (H2 H7).\n  apply (H2 H7).\n  apply (H2 H8).\n  apply (H3 H7).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H0 H8).\n  apply (H0 H7).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H0 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (H2 H8).\n  apply (Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\nintros.\ndestruct (isCoarse (fun b => valid (eval expr e b)) as [ | b | b | b | d ]; intros.\n- (* c = c *)\n  destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | b | d ]; intros.\n  - (* c = c *)\n    destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | d ]; intros.\n    + (* c = c *)\n      destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | d ]; intros.\n      * (* c = c *)\n      destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | d ]; intros.\n      * (* c = c *)\n        destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | d ]; intros.\n        * (* c = c *)\n        destruct (isCoarse (fun b => valid (eval expr e b))) as [ | b | d ]; intros.\n        * (* c = c *)\n        destruct (isCoarse (fun b => valid (eval expr e b))) as [ | bQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p0 e H0 H1 H2 H3 H4.\n  destruct (Post1 _ H0 H2) as (e0 &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &?Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p post1.\n  generalize dependent prog.\n  induction (ex_wp_monotonic p post1 e) as [ | [ | ] | [ | ] | [ | ] | [ | ] | | [ | ] | | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | | [ | ] | | [ | ] | | | [ | ] | | | [ | ] | | | | ] | | [ | ] | | | | ]; [ | | | ] | | | | | ]; [ | | | | | ] | | | | | ]; [ | | | | | | ]; [ | | | | | ]; [ | | | | | | ]; [ | | | | | | | ]; [ | | | | ]; [ | | | | | ]; [ | | | | | ]; [ | | | | ]; [ | | | | | ]; [ | | | ]; [ | | | | ]; [ | | | | | ]; [ | | | | ]; [ | | | | ]; [ | | | ]; [ | | | ]; [ | | | ]; [ | | ]; [ | | | ]; [ | | | ];Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p R e e e H H0.\n  unfold synt_wp.\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True)) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True) (fun _ => True)) (fun _ => True)).\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (fun _ => True)).\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (fun _ => True)) (fun _ => True).\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (fun _ => True)).\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (fun _ => True)).\n  apply (well_founded_induction_wf (fun _ => True) (fun _ => True) (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "dec2 H2 H.\n generalize Hinv.\n pattern e.\n (* -- here the proof proceeds by induction on the well-founded relation *)\n eapply well_founded_ind; eauto.\n clear Hinv e.\n intros e' X H'.\n set (b:=E.eval cond e').\n cut (E.eval cond e'=b); auto.\n case b; [ idtac | firstorder eauto with hoare ].\n intros H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\n",
                "context_tokens": 707,
                "proof_start_offset": 5789,
                "proof_end_offset": 5976,
                "proof": "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; simpl; try ((firstorder eauto with hoare); fail).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros until e'; intros; subst.\nintros s e e' X H.\nassert (X: (i<j)%nat).\napply (exec_inversion H; clear H; subst; auto.\nassert (X: (i<j)%nat).\napply (exec_inversion H; clear H; subst; auto.\nrewrite <- H0; apply H1; apply H1; apply H1; apply H1; apply H2; apply H2; apply H3; apply H1; apply H3; apply H4; apply H1; apply H3; apply H1; apply H3; apply H1; apply H3; apply H4; apply H4; apply H1; apply H4; apply H4; apply H4; apply H5; apply H1; apply H4; apply H1; apply H; apply H1; apply H4; apply H1; apply H3; apply H4; apply H1; apply H; apply H2; apply H3; apply H4; apply H4; apply H2; apply H4; apply H4; apply H4; apply H4; apply H4; applyQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n intros.\n induction es.\n simpl in *.\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H1).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H1).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H1).\n destruct (exec_inversion_clear H1).\n destruct (exec_inversion_clear H1).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).\n destruct (exec_inversion_clear H0).Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n intros until post. intros H.\n destruct (exec_inversion _ _ _ _ _ H H0 H1 H2).\n destruct (exec_inversion _ _ _ _ _ _ H H2).\n destruct (exec_inversion _ _ _ _ H1 H2).\n destruct (exec_inversion _ _ _ _ H1 H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ H2).\n destruct (exec_inversion _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\n destruct (exec_inversion _ _ _ _ H2).\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros; red; intros.\n(* H1 H2 H3 H4. *)\nunfold exec_inversion.\n(* H4 H5. *)\n(* H5. *)\n(* H6. *)\n(* H7. *)\n(* H7. *)\n(* H7. *)\n(* H7. *)\n(* H7. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H9. *)\n(* H8. *)\n(* H8. *)\n(* H8. *)\n(* H9. *)\n(* H9. *)\n(* H9. *)\n(* H8. *)\n(* H9. *)\n(* H9. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10. *)\n(* H10Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n intros.\n induction post; simpl in *; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros until post.\ndestruct (exec_inversion_clear H).\n(* receptiveness of [m] is the same\n   of the proof of [m] and [m] is the same\n   of the proof of [m] and [m] are the same\n   in the proof of [m] are the proof of the proof of [m]\n   or [m] are the proof of [m] are equivalent. *)\n(*\nLemma exec_inversion: forall (prog: program) (e: env) (A:Type),\n  forall (m : mem) (P : A -> Prop),\n  (forall (P : A -> Prop), P (prog_funct prog_funct prog_funct prog_funct prog_funct prog_funct prog_funct prog P)) -> post e.\nProof.\nintros until R.\ninduction prog; intros; simpl; intros.\ndestruct H.\n(* receptiveness of [m] is the same\n   case of the case of the proof of [m] is the same\n   of the proof of [m] and the proof of [m]\n   which is the proof of [m] are the proof of [m]\n   proof of [Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros until post.\ninduction es; intros; simpl in *; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nrevert H; induction post; intros; simpl in *; try contradiction; intros; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradiction; try contradictionQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nunfold exec_inversion.\n(* receptiveness of [eval e] case, which is an\n   [eval e] case, the \"eval e] case,\n   case, the \"eval e] case, the \"eval e] case,\n   case, the \"eval e] case, which is\n   case, the \"eval e] case, the \"eval e] case,\n   case, the \"eval e] case, the \"eval e] case,\n   case, the \"eval e] case, the \"eval e] case, the \"eval e] case\n   case, the \"eval e] case, the \"eval e\" case,\n   case, the \"eval e\" case, the \"eval e\" case, the\n   case, the \"eval e] case, the \"eval e\" case, the \"eval e\" case,\n   case, the \"eval e\" case, the \"eval e\" case, the\n   case, the \"eval e\" case, the \"eval e\" case, the \"eval e\" case\n   case, the \"eval e\" case, the \"eval e\" case, the\n   case, the \"eval e\" case, theQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\napply step_wlp; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\n",
                "context_tokens": 696,
                "proof_start_offset": 6074,
                "proof_end_offset": 6404,
                "proof": "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\nintros A x expr e e' H.\npattern e'; apply (exec_inversion H); simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl;\n  try (try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e' e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e e');\n  try (simple destruct (eval_expr e' e');\n  try (Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  - destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (E.eval_expr e e0); simpl; auto.\n    destruct (EQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros;\n  try ((firstorder eauto with hoare); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_exprwpe); try (rewrite <- eval_expr_wpe); try (rewrite <- eval_exprQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; auto;\n  try (try (congruence || fail));\n  (try (try (congruence || fail));\n  (try (congruence || fail));\n  (try (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail));\n  (try (congruence || fail || fail));\n  (try (congruence || fail));\n  (try (congruence || fail || fail));\n  (try (congruence || fail));\n  (try (congruence || fail || fail));\n  (try (congruence || fail));\n  (try (congruence || fail || fail ||\n  (try (congruence || fail));\n  (try (congruence || fail || fail));\n  (try (Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros;\n  try (try discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminate || fail).\n  -\n  destruct e; try (discriminateQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  - apply E. reflexivity.\n  - apply E. reflexivity.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros;\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite E; eauto with hoare);\n  try (rewrite EQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  - destruct (E.eq_dec x e).\n    + subst. apply E.eq_refl.\n    + apply E.eq_refl.\n    + apply E.eq_refl.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros;\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);\n  try (eauto with hoare);Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros;\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H0; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewrite <- H; clear H; subst);\n  try (try rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ct the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\nLemma exec_test_inversion:\n  forall A (x:E.Var A) expr e e',\n     (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  (** Here, try \"[inversion H]\" instead the tactic below. \n      The generated goal is not directly provable. *)\n  pattern e'; apply (exec_inversion H); simpl; auto.\nQed.\n \n(** Below, a little tactic to helps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\n",
                "context_tokens": 712,
                "proof_start_offset": 6917,
                "proof_end_offset": 7168,
                "proof": "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\ninduction 1; intros ef' X; exec_inversion X; eauto.\nintros e1 e2 X1 X2; assert (X3: e'=e1); auto.\nsubst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply (exec_inversion H); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl; auto.\n  apply (exec_inversion H); simpl;Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  (* t case *)\n  intros.\n  (* t case *)\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  (* t case *)\n  intros.\n  (* t case *)\n  intros.\n  (* t case *)\n  (* t case *)\n  intros.\n Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; subst; apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply exec_inversion.\n  apply execQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_equal. *)\n  (* i.e. f_Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; apply (exec_inversion H); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  unfold exec_inversion.\n  destruct (eval_inversion H) as [s' [ | [ | [ | ] | ] | [ | ] | [ | ] | [ | ] | [ | ] | | | [ | ] | | | | | ]; try (discriminate H).\n  destruct (eval_inversion H) as [s' [ | [ | ] | [ | ] | | [ | ] | | | | | | ]; try (discriminate H).\n  destruct (eval_inversion H) as [s' [ | [ | ] | [ | ] | [ | ] | | [ | ] | | | | | | | ]; try (discriminate H).\n  destruct (eval_inversion H) as [s' [ | [ | ] | [ | ] | [ | ] | | | | | | ]; try (discriminate H).\n  destruct (eval_inversion H) as [s' [ | [ | ] | [ | ] | | | [ | ] | | | | ]; try (discriminate H).\n  destruct (eval_inversion H) as [s' [ | [ | ] | [ | ] | [ | ] | | | [ | ] | | | |Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; subst; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  destruct ef; try (monadInv H; simpl; try discriminate).\n  (* Here we don't prove the [exec_inversion H] case analysis on the\n   [update_inversion H] case, [t] is not provable, then it's not happen *)\n  rewrite <- (update_inversion H); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction i; simpl; intros.\n  + auto.\n  + auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8653,
                "proof_end_offset": 8793,
                "proof": "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\ninduction 1; firstorder (eauto with hoare).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros. apply execnI. apply execnI. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply exec_Iif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply execnIif. apply exec_Iif. apply execnIif. apply execnIif. apply exec_Iif. apply execnIif. apply execnIif. apply exec_Iif. apply execnIif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply execIif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply exec_Iif. apply execIifIif. apply execIif. apply execIifI. apply exec_Iif.\n  apply exec_Iif.Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction i; intros; try solve [apply (exec_inv H); simpl; clear H | ].\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n  intros e.\n  (* - case [Iseq] *)\n Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros; induction i; intros.\n  + simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in H0; inv H0.\n    simpl in HQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros; apply execnI; auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros; induction p; simpl; auto.\n  induction p; simpl; auto.\n  simpl; auto.\n  simpl; auto.\n  simpl; auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destruct ef as [p p].\n  destructQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros. unfold execn. simpl. apply execn_Iif.\n  intros; simpl.\n  apply execn_Iif.\n  intros; simpl.\n  apply execn_Iif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  apply execnIif.\n  intros; simpl.\n  applyQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply exec_Iload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply exec_Iload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIload.\n  apply execnIQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros. unfold execn. apply (exec_elim H).\n  unfold execn. apply (exec_elim H).\n  unfold execn. apply (exec_elim H).\n  unfold execn. apply (exec_elim H).\n  unfold execn. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold execn. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_elim H).\n  unfold exec_elim. apply (exec_Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  destruct ef; try solve [inversion H; auto].\n  destruct ef; try solve [inversion H; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; try solve [inversion H0; auto].\n  destruct ef; tryQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\n",
                "context_tokens": 739,
                "proof_start_offset": 9000,
                "proof_end_offset": 9914,
                "proof": "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\nunfold well_founded.\nintros cond p e0; apply Acc_intro.\nintros e1 H; unfold reduces in H.\ndecompose [ex and] H; clear H.\nclear H2 H0 e0.\ncase (exec_execn H1).\nintros n.\ngeneralize cond p e1 x; clear cond p e1 x H1.\nelim n.\nintros cond p e0 e1 H; inversion_clear H.\nclear n; intros n HR cond p e0 e1 H.\ninversion_clear H.\ninversion_clear H0.\nset (b:=E.eval cond e0) in * |-.\ncut (E.eval cond e0=b); auto.\ngeneralize H; clear H; case b; simpl.\nintros H; inversion_clear H.\nintros; apply Acc_intro.\nintros e2 H3; unfold reduces in H3.\nintuition.\nrewrite (exec_deterministic H3 H0); eauto.\nintros H H0; apply Acc_intro.\nunfold reduces; rewrite H0.\nintuition.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros cond p e; split; intros; auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros; induction cond; firstorder.\n  - destruct (E.eval cond e0); firstorder.\n  - destruct (E.eval cond e0); firstorder.\n  - destruct (E.eval cond e0); firstorder.\n  - destruct (E.eval cond e0); firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros; apply (step (fun n => forall n, size e n = size e0 /\\ (forall n, size e n = size e0 /\\ (forall n, size e n = size e0 /\\ (forall i, size e i < size e0) -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0)) ->\n  (forall i, size e i < size e0 -> forall i, size e i < size e0 -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0)) ->\n  (forall i, size e i < size e0 -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0)) ->\n  (forall i, size e i < size e0 -> e1 = size e0 /\\ (forall i, size e i < size e0 -> e1 = size e0))Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  eapply forever_ind.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_wf.\n  apply star_Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction cond; firstorder.\n  simpl.\n  intros; destruct p as [n p].\n  apply H.\n  simpl.\n  apply H.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\ninduction cond; intros; inv H.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).\n  intros.\n  apply (E.eval cond).Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros; simpl; intros.\n  apply (E.eval cond); auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros cond p e0 e1 e2 X H.\n  induction cond; firstorder.\n  destruct (eval e0 e1); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e1); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e1 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e0 e0); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e1); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e1); firstorder.\n  destruct (eval e0 e2); firstorder.\n  destruct (eval e0 e0 e); firstorder.\n  destruct (eval e0 e); firstorder.\n Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros; split; intros.\n  - intros; apply H.\n  - intros; apply H.\n  - intros; apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "Prog -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\n",
                "context_tokens": 734,
                "proof_start_offset": 10044,
                "proof_end_offset": 11057,
                "proof": "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\nunfold wp.\nintros prog post e H; case H; clear H.\nintros e' H; case H; clear H.\ngeneralize post e e'; clear post e e'; elim prog; clear prog; simpl.\nintros post e e' H; exec_inversion H; auto.\nintros A v expr post e e' H; exec_inversion H; auto.\nintros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\ncase (E.eval cond e); simpl; firstorder auto || discriminate.\nintros p1 Hp1 p2 Hp2 post e e' H.\nexec_inversion H.\neauto.\nintros cond p Hp post e e' H H0.\nconstructor 1 with (x:=wp (Iwhile cond p) post).\nconstructor 1 with (x:=reduces cond p).\nunfold wp; (intuition eauto with hoare); dec2 e1 H1; case H1; clear H1; intros H1; exec_inversion H1; intros e2 H1; exec_inversion H1; rewrite H2; intros e3 H1; exec_inversion H1; unfold reduces; eauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  induction sigma; simpl; intros.\n  - intros; subst; simpl; auto.\n  - intros; subst; simpl; auto.\n  - intros; subst; simpl; auto.\n  - intros; subst; simpl; auto.\n  - intros; subst; simpl; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; induction post; simpl; intros; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (exec_size s); intros; simpl; auto.\n  case (Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros until post.\n  induction post.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n  - apply hoare_wp; auto.\n - apply hoare_wp; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; econstructor; eauto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; constructor; intros; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; subst; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoare_weaken; auto.\n  intros. simpl.\n  apply hoare_weaken; auto.\n  intros.\n  simpl.\n  apply hoareQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoare_step with (wf_sig _).\n  intros; apply hoareQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply hoare_step; auto.\n  intros; apply hoare_step; auto.\n  intros; apply hoare_step; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros x0.\n  apply hoare_extensionality.\n  intros xQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  destruct (eval_expr_step_deterministic _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  generalize (ex_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfold_unfoldQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros.\n  apply hoare_wp.\n  intros x y z R.\n  apply hoare_wp.\n  intros y z R.\n  apply hoare_wp.\n  intros y z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp.\n  intros y z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp.\n  intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.\n  apply hoare_wp. intros z R.Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  assert (forall x, In x (ex x) -> safe x) by intuition.\n  assert (forall x, In x (ex x) -> safe x) by intuition.\n  subst.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_expr_sound _ _ H1); eauto.\n  apply safe_step with (y:=R) in H1.\n  rewrite <- (eval_Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n unfold hoare.\n intros; destruct (ex p) as [tr [s s] | [s s] s] s] s] s.\n revert s; induction s; simpl; intros; try discriminate.\n- (* case [Iwhile] *)\n  intros x s s.\n  generalize (ex p s).\n  destruct s; simpl in *.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear s; intros.\n  generalize (ex p s).\n  destruct s; simpl in *.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear H; intros.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear H; intros.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear H; intros.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear H; intros.\n  assert (x = s); [ | discriminate].\n  intros x s; case (P s); clear H; intros.\n  assert (x = s); [Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold wp; intros.\n  destruct (ex_ret (fun x => x)).\n  intros x; apply H0.\n  apply H0.\n  apply H1.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros until post.\n  destruct post as [x post].\n  destruct post as [x post].\n  destruct post.\n  destruct post.\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].\n  destruct x as [x post].Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold post, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ.\nProof.\n  intros until PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ.\nProof.\n  intros until PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ.\nProof.\n  intros until PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ.\nProof.\n  intros until PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ, PQ.\nProof.\n  intros until PQ, PQ, PQQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct (ex_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_or_and_and_and_and_and_and_and_and_and_and_or_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_andQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros; apply hoare_wp; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros (p & [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [Q], [QQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n apply hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply hoare.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\n",
                "context_tokens": 556,
                "proof_start_offset": 1603,
                "proof_end_offset": 1825,
                "proof": "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' He H1 H2 H3.\nassert (H3 := exec_Iif cond p1 p2 e' He H1 H2).\nassert (H1 := exec_Iif cond p1 p2 e' He H2).\nassert (H3 := exec_Iif cond p1 p2 e' He H3).\nassert (H4 := exec_Iif cond p2 e' He H2).\nassert (H4 := exec_Iif cond p1 p2 e' He H4).\nassert (H5 := exec_Iif cond p1 p2 e' He H5).\nassert (H7 := exec_Iif cond p1 p2 e' He H3).\nassert (H8 := exec_Iif cond p2 e' He H5).\nassert (H7 := exec_Iif cond p1 p2 e' He H7).\nassert (H8 := exec_Iif cond p2 e' He H8).\nassert (H9 := exec_Iif cond p1 p2 e' He H8).\nassert (H9 := exec_Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros; destruct cond; simpl; auto;\n try solve [apply exec_Iif; auto].\n apply exec_Iif; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\nunfold exec.\nassert (forall e e' cond p1 p2 e',\n   (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e)\n       -> (exec e (Iif cond p1 p2) e)\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p2 p2) e')\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e)\n       -> (exec e (Iif cond p1 p2) e)\n       -> (exec e (Iif cond p1 p2) e')\n       -> (exec e (Iif cond p2 p1 p2) e')\n       -> (exec e (Iif cond p1 p2) e)\n       -> (exec e (IQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\n(*\ninduction cond.\n(* nil *)\n(* nil *)\n(* nil *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)\n(* cons *)Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2 H3; apply exec_Iif; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\ndestruct cond as [ | cond].\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n-\n-\n-\n\n-\n\n-\n-\n\n-\n\n-\n\n\n-\n-\n\n\n\n-\n\n-\n\n-\n\n\n-\n\n\n-\n\n\n\n-\n\n-\n\n\n\n\n-\n\n\n-\n\n\n\n\n\n\n-\n\n\n\n\n\n-\n\n\n\n\n\n\n\n-\n\n\n\n\n\n\n\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (exec e (Iif cond p1 p2) e')).\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (exec e (Iif cond p1 p2) e)).\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (eval cond e (Iif cond p1 p2) e)).\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (eval cond e (Iif cond p1 p2) e)).\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (eval cond e (Iif cond p1 p2) e)).\nintros.\nassert (forall e cond p1 p2 e, (E.eval cond e) = true -> (eval cond e (Iif cond p1 p2) e)).\nintros.\nassert (forall e cond p1 p2 e,Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\ninduction cond as [| r1].\n- (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  + (* eval *)\n  +\n  +\n  (* eval *)\n  + (* eval *)\n  +\n  (* eval *)\n  + (* eval *)\n  +\n  + (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +\n  (* eval *)\n  +Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\nunfold exec in |- *.\nassert (H := exec_Iif_true _ _ _ H).\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | ]; try solve [inversion H].\ndestruct cond as [ | [ | ] | [ | ] | [ | ] | | | ]; try solve [inversion H].\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\nunfold exec.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nunfold exec in *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\n",
                "context_tokens": 646,
                "proof_start_offset": 1829,
                "proof_end_offset": 2053,
                "proof": "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif; [idtac|idtac].\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H H2.\n  apply exec_Iif; auto.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif; [ tauto | tauto].\n  intros; tauto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": " E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nLemma exec_Iif_false:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=false\n      -> (exec e p2 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nDefinition Pred := E.Env -> Prop.\n\nDefinition wlp: ImpProg -> Pred -> Pred\n := fun prog post e => (forall e', (exec e prog e') -> (post e')).\n\nDefinition wp: ImpProg -> Pred -> Pred\n := fun prog post e => exists e', (exec e prog e') /\\ (post e').\n\n\nNotation \"p |= q\" := (forall e, (p e) -> (q e)) (at level 80, no associativity).\nNotation \"p {= post =}\" := (wlp p post) (at level 70).\nNotation \"p [= post =]\" := (wp p post) (at level 70).\n\nEnd HLD.\n\nExport HLD.\n\nModule PHL<: HoareProofSystem := PartialHoareLogic(HLD). \nModule THL<: HoareProofSystem := TotalHoareLogic(HLD). \n\nImport THL.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 2648,
                "proof_end_offset": 2853,
                "proof": "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nunfold wp, wlp.\nintros prog post e H e' H'.\ndec2 e0 H.\ndec2 H0 H.\nrewrite (exec_deterministic H' H0).\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; hnf; intros.\n  apply (H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros. unfold prog in *; simpl in *; intros.\n  apply (is_true_is_true_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_false_iff_false_iff_false_iff_false_iff_false_iff_false_Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nintros.\ndestruct (H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; split; intro; subst; auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; unfold prog; simpl.\n  intros; unfold prog.\n  intros; unfold prog; simpl.\n  intros; unfold prog.\n  intros; unfold prog.\n  intros; unfold prog.\n  intros; unfold prog; simpl.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros.\n  unfold prog in *.\n  intros.\n  unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros.\n  unfold prog in *.\n  intros; unfold prog in *.\n  simpl.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros; unfold prog in *.\n  intros;Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  assert (forall e, (eval cond e) = true) by (intros; apply H; auto).\n  destruct H as [e' H].\n  apply (eval_expr e); auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; apply (H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros. apply (H (nil _)).\n  apply (H (nil _)).\n  apply (H (nil _)).\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; unfold prog in *; destruct post; simpl in *; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate;Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; apply pred_ext.\n  + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\n    + intros; apply pred_ext.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nauto with arith.\nintros p H; elim p.\nautoSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; intros m H1 H2; elim H1; intros m H3; elim H3; intros m H4; elim H3; intros m H5;\n elim H3; intros m H5; elim H5; intros m H6;\n elim H6; intros m H6 H6; elim H6; intros m H7; elim H7; intros m H8;\n elim H7; intros m H8 H10; elim H8; intros m H11 H12; elim H9; intros m H10 H11;\n elim H7; intros m H10 H11; elim H7; intros m H10 H12; elim H10; intros m H12;\n elim H7; intros m H11 H12; elim H12; intros m H12; elim H12; intros m H12;\n elim H7; intros m H10 H11; elim H12; intros m H12 H12;\n elim H7; intros m H11 H12; elim H13; intros m H12; elim H13; intros m H13 H14;\n elim H7; intros m H13 H15; elim H8Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n H H0 H1.\napply (lt_O_Sn n); auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\napply (fun x => plus (plus x x) (plus y x)).\napply (fun x => plus (plus x x) (plus y x)).\napply (fun x => plus (plus x y x)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plus (plus x y)).\napply (fun x => plusSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintro n.\npattern n in |- *.\napply (le_S_n_O _ H).\napply le_trans with (n + S (S n)).\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_n_S.\napply le_trans with (S (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n H; elim H; intros.\nexact H; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nintros.\napply H.\nsimpl in |- *.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; case n.\nauto.\nintros; apply le_trans with (n := 0); auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nintros m n H; elim (plus_n_O _ H); intros.\nelim (plus_n_O _ _ H); intros.\nelim (plus_n_O _ H); intros.\nelim (plus_n_O _ H0); intros.\nelim (plus_n_O _ H1); intros.\nelim (plus_n_O _ H1); intros.\nelim (plus_n_O _ H1); intros.\nelim (plus_n_O _ H1); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H1); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelim (plus_n_O _ H2); intros.\nelimSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nintros n0 p0 H1; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction 1; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\nunfold size in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros;Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nsimple induction n; simpl in |- *; auto with core.\nintros t u v v H.\n(* case *)\nauto with core.\n\nintros v v v H.\n(* case *)\nauto with core.\n\nintros v v' v' H.\n(* case *)\nauto with core.\n\nintros v' v' H.\n(* case *)\nauto with core.\nintros v' v'' H.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n\n(* case *)\nauto with core.\n\n(* case *)\nauto with core.\n\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)auto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)\nauto with core.\n(* case *)autoSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *;Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v v H H0.\napply le_S.\napply le_trans with (1 := H0).\napply le_S.\napply le_trans with (2 := H1).\napply le_trans with (2 := H0).\napply le_trans with (2 := H1).\napply le_trans with (1 := H0).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (1 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans with (2 := H1).\napply le_trans withSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\ncut (size t = n).\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto with arith.\n2: auto.\n2: auto.\n2: auto with arith.\n2: auto.\n2: auto with arith.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.\n2: auto.Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v v H.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tip.\napply tSave size_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\n",
                "context_tokens": 379,
                "proof_start_offset": 1699,
                "proof_end_offset": 1769,
                "proof": "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C D H; elim H; intros H0; clear H; intro H0; elim H; intros H1 H2; elim H1; intros H2; elim H1; clear H1;\n intros H2 H3; elim H2; intros H3; elim H3; clear H3; intros H4 H5; elim H4; intros H5 H6; elim H6;\n intros H6 H7; elim H7; intros H8; elim H8; clear H7;\n intros H8; elim H8; intros H9; elim H8; clear H9; intros H9; elim H9;\n intros H10; elim H8; intros H9; elim H8; clear H9; intros H10; elim H10;\n intros H11 H10; elim H12; intros H10 H11; elim H12; intros H11 H12; elim H12;\n intros H12 H13; elim H12; intros H13 H13 H14; elim H14; intros H15 H15; elim H13; intros H15 H16;\n elim H14; intros H16 H17; elimQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros.\napply H.\nauto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros.\nassert (H := even_intro_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elimQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros; apply even_intro; assumption.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C H0.\nelim H1; intros H2 H3; elim H2; intros H3 H4; elim H3; intros H5 H6; elim H3; intros H6 H7; elim H6; intros H7 H8; elim H7; intros H8 H9; elim H8;\n intros H10 H11; elim H8; intros H10 H11; elim H11; intros H12 H12; elim H12; intros H12 H13;\n elim H11; intros H12 H13 H14; elim H12; intros H13 H14; elim H14; intros H14 H15;\n elim H14; intros H14 H15 H16; elim H14; intros H14 H16; elim H15; intros H16 H16;\n elim H16; intros H17 H17 H17; elim H16; intros H17 H17 H18; elim H16;\n intros H18 H19; elim H18; intros H19 H18 H20; elim H21; intros H22 H19 H20; elim H21;\n intros H18 H20; elim H18; intros HQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C D H H1 H2 H3 H4 H6.\nelim H1; intros H3 H4.\nelim (even_or_odd A B C D); intros H5.\nelim H5; intros H6; elim H6; intros H7.\nelim (even_or_odd B C D); intros H6.\nelim (odd_or_odd B C D); intros H6.\nelim (even_or_odd B C D); intros H6.\nelim H6; intros H6 H7.\nelim (even_or_odd B C D); intros H6.\nelim (odd_or_odd B D); intros H7.\nelim (even_or_odd B C D); intros H8.\nelim (even_or_odd B C D); intros H9.\nelim (even_or_odd B C D); intros H8.\nelim (even_or_odd B C D); intros H9.\nelim (even_or_odd B C D); intros H9.\nelim (even_or_odd B C D); intros H9.\nelim (evenQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C D.\nunfold even in |- *.\napply (even_odd_even_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\napply Ex_Wielandt_fixpoint.\nintros w w?.\napply Ex_Wielandt_fixpoint.\nintros w w?.\napply Ex_Wielandt_fixpoint.\nintros w?.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C.\nunfold not in |- *.\nelim (classic (A \\/ A \\/ B)).\nintro H0.\nelim H0.\nelim (classic (A \\/ B)).\nintro H1.\nelim (classic (A \\/ B)).\nintro H2.\nelim H2.\nelim H2.\nelim (classic (A \\/ B)).\nintro H3.\nelim H3.\nintro H4.\nelim (classic (A \\/ B)).\nintro H4.\nelim (classic (A \\/ B)).\nintro H5.\nelim H4.\nelim (classic (A \\/ B)).\nintro H5.\nelim (classic (A \\/ B)).\nintro H5.\nelim (classic (A \\/ B)).\nintro H6.\nelim (classic (A \\/ B)).\nintro H5.\nelim (classic (A \\/ B)).\nintro H5.\nelim (classic (A \\/ B)).\nintro H6.\nelim (classic (A \\/ B)).\nintro H6.\nelim H5.\nintro H5.\nelim (classic (B \\/ B)).\nintro H5.\nelim (Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply 2.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact Ex_Wielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact ExWielandt_fixpoint.\nexact ExWielandt_fixpointQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 1771,
                "proof_end_offset": 1818,
                "proof": "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \n",
                "context_tokens": 448,
                "proof_start_offset": 1867,
                "proof_end_offset": 1948,
                "proof": "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nProof.\nintro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\n",
                "context_tokens": 499,
                "proof_start_offset": 2006,
                "proof_end_offset": 2102,
                "proof": "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\n",
                "context_tokens": 582,
                "proof_start_offset": 2243,
                "proof_end_offset": 2346,
                "proof": "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\n",
                "context_tokens": 750,
                "proof_start_offset": 3167,
                "proof_end_offset": 3202,
                "proof": "Lemma NoMember : False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\nintro.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3215,
                "proof_end_offset": 3288,
                "proof": "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3290,
                "proof_end_offset": 3326,
                "proof": "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ulus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 3328,
                "proof_end_offset": 3393,
                "proof": "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "bolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3395,
                "proof_end_offset": 3462,
                "proof": "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3464,
                "proof_end_offset": 3527,
                "proof": "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 3529,
                "proof_end_offset": 3565,
                "proof": "Theorem a4 : ~ A -> ~ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\n",
                "context_tokens": 745,
                "proof_start_offset": 3567,
                "proof_end_offset": 3607,
                "proof": "Theorem e2 : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "amathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3609,
                "proof_end_offset": 3657,
                "proof": "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 3659,
                "proof_end_offset": 3767,
                "proof": "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3769,
                "proof_end_offset": 3823,
                "proof": "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ".\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3825,
                "proof_end_offset": 3883,
                "proof": "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3885,
                "proof_end_offset": 3937,
                "proof": "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "s red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\nTheorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4257,
                "proof_end_offset": 4323,
                "proof": "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "s of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\n",
                "context_tokens": 377,
                "proof_start_offset": 2468,
                "proof_end_offset": 2722,
                "proof": "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.",
                "end_command": "Save Ackermann.",
                "generated_proofs": [
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p H.\nsimpl in |- *.\nauto.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros.\nchange (p 0 + p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in |- *.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (Pos.eq_nat_of_P p) in H.\nrewrite (PosSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p H0.\nelim H0.\nexact (H _ H0).\nexact (H _ H0).\nexact (H _ H0).\nexact (H _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (H _ _ H0).\nexact (HSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; induction n; simpl in |- *; auto.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\n  intros n m p H; elim H.\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* p = p *)\n  exact (refl_equal (S p)).\n  (* pSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nrewrite (lt_O_nat (S m)).\nrewrite (lt_O_nat (S m)).\nrewrite (lt_O_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_O_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_nat (S m)).\nrewrite (lt_S_natSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; elim n; simpl in |- *; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p H; generalize (H _ _ H); clear H; intros.\nAbort.\n\nGoal forall n m : nat, {p : nat | ZCG n m p} + {p : nat |}).\nintros n m p; generalize (H _ H); clear H; intros.\nAbort.\n\nGoal forall n m : nat, {p : nat | ZCG n m p }.\nintros n m p H; generalize (H _ _ H); clear H; intros.\nAbort.\n\nGoal forall n m : nat, {p : nat | ZCG n m p }.\nintros n m p H; generalize (H _ H); clear H; intros.\nAbort.\n\nGoal forall n m p : nat, {p : nat | ZCG n m p }.\nintros n m p H; generalize (H _ _ H); clear H; intros.\nAbort.\n\nGoal forall n m : nat, {p : nat | ZCG n m p }.\nintros n m p H; generalize (H _ _ H); clear H; intros.\nAbort.\n\nGoal forall n m : nat, {p : nat | ZCG n m p }.\nintros n m pSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Map (Ap:=fun m : nat => m) (p : nat) => p * m) p.\nintros.\napply (Build_Save Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p; elim p.\nSave Ackermann."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": " not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\n",
                "context_tokens": 519,
                "proof_start_offset": 3199,
                "proof_end_offset": 3373,
                "proof": "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.",
                "end_command": "Save ack_Ack.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\nelim H; intros.\nelim (H 0); intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim (H2 0); intros.\nelim (H1 0); intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim (H1 0); intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim (H8 0); intros.\nelim H6; intros.\nelim H7; intros.\nelim (H2 0); intros.\nelim H7; intros.\nelim (H2 0); intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim (H2 0); intros.\nelim H7; intros.\nelim H7; intros.\nelim (HSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n p.\nelim p.\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H (S m) p).\nelim (H (S m) p).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H (S m) p).\nelim (H n).\nelim (H n).\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H; elim H; intros.\nexists (S m); auto.\nelim (H 0); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nexists x; auto.\nelim (H x); intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nexists (S m'); auto.\nelim H'; intros.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H0; elim H0; intros.\n(* (S m) = (S m) *) \n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *)\nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *)\nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nrewrite H0.\nreflexivity.\n(* S m *) \nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H; elim H; auto.\nintros m p H0 H1; elim H1; intros.\nexists x0.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply Zplus_reg_l with (p := p); auto with arith.\napply ZplusSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p.\npattern m at 1 in |- *.\nelim (H 0); intros.\nexists x0.\napply Zplus_le_compat_r; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H0; intros.\nelim H1; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim HSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H; elim n.\nintros n m p H; elim n.\nintros m p H; elim n.\nintros m p H0; elim n.\nintros m p H0; elim n.\nintros m' H0; elim n.\nintros m' H0; elim n.\nintros m' H0; elim n.\nintros m' H0; elim n.\nintros m' H0; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H1; elim n.\nintros m' H2; elim n.\nintros m' H1; elim n.\nintros m' H2; elim n.\nintros m' H3; elim n.\nintros m' H3; elim n.\nintros m' H4; elim n.\nintros m' H5; elim n.\nintros n' H4;Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\nelim H; intros.\nelim (H x); intros.\nelim H; intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim H0; intros.\nelim (H x); intros.\nelim H0; intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); intros.\nelim (H x); introsSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H0 H1 H2 H3 H4.\napply H2.\nauto.\napply H3.\nauto.\nSave ack_Ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "               *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\nGoal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.\n\n",
                "context_tokens": 554,
                "proof_start_offset": 3375,
                "proof_end_offset": 3606,
                "proof": "Goal forall n m : nat, Ack n m (ack n m).\nProof.\nsimple induction n.\nsimpl in |- *; auto.\nintros n' H; simple induction m.\nsimpl in |- *; auto.\nintros m' H'; apply AckSS with (ack (S n') m'); auto.\napply (H (ack (S n') m')).\nSave Ack_ack.",
                "end_command": "Save Ack_ack.",
                "generated_proofs": [
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1 p0; rewrite <- plus_n_O; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1 p1 q2 ASn Eq An.\nelim (H 0); intros.\nexists x0.\napplyimesS.\napplyimesS; assumption.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m2); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1); auto.\napply Zle_trans with (S m1Save Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n0 m0 p1 q2 ASn Eq An.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H' x); intros.\nexists x0.\napply floatEq; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q2 ASn Eq An.\nelim (H 1); intros.\nelim (H2 0); intros.\nelim (H3 0); intros.\nelim (H3 0); intros.\nelim (H2 0); intros.\nelim (H3 0); intros.\nelim (H3 0); intros.\nelim (H4 0); intros.\nelim (H2 0); intros.\nelim (H3 0); intros.\nelim (H4 1); intros.\nelim (H5 0); intros.\nelim (H6 0); intros.\nelim (H2 0); intros.\nelim (H1 0); intros.\nelim (H2 0); intros.\nelim (H2 0); intros.\nelim (H2 0); intros.\nelim (H4 1); intros.\nelim (H2 0); intros.\nelim (H2 0); intros.\nelim (H2 0); intros.\nelim (H3 0); intros.\nelim (H4 0); intros.\nelim (H2 0); intros.\nelim (H2 0Save Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An.\nelim (H (S n1)); intros.\nexists x.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.\napplyucnS.Save Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1 p2 p0 H1 H2; elim H1; intros.\nexists x0; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m0 p1 q2 ASn Eq An.\nelim (H 1); intros.\nexists x; auto.\nintros m' H' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'0); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.\nexists x; auto.\nintros m' H'0; elim (H'0); intros.\nexists x; auto.\nintros m' H'0; elim (H'1); intros.Save Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1 p1 p2 H0; elim H0; intros.\nexists x1.\napply strong_zero_rec.\nassumption.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1 p2 H H0; elim H; intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nexists x0.\napply discr_S; assumption.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m p1 p2 H0; elim (H0 H1); intros.\nexists x; auto.\nSave Ack_ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\n",
                "context_tokens": 307,
                "proof_start_offset": 1329,
                "proof_end_offset": 1418,
                "proof": "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nautorewrite with base0 using try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ResAck0 : Ack 3 2 = 29.\nred in |- *; intro; discriminate.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nAdmitted.\n\nLemma ResAck2 : forall m : nat, ResAck (S m) (S m) = ResAck (S m) (S m).\nProof.\nintros.\nunfold ResAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nrewrite HeqAck.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nauto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nred in |- *.\nauto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nauto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nintro; case (eq_dec 1 0); intro.\nauto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nrewrite (fun m : nat => match m with O => 0 | S m => 1 | S m => 1 end).\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nunfold Zminus in |- *.\nauto with arith.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\n  induction 1; simpl; auto.\n  simpl; auto.\n  simpl; auto.\n  simpl; auto.\n  simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\n",
                "context_tokens": 462,
                "proof_start_offset": 1725,
                "proof_end_offset": 1826,
                "proof": "Lemma Resg0 : g 1 110 = 100.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n Qed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  apply f_equal with (f := fun m => g (S n)).\n  apply g1.\n  apply g2.\n  apply g1.\n  apply g1.\n  apply g2.\n  apply g0.\n  apply g0.\n  apply g2.\n  apply g1.\n  apply g2.\n  apply g1.\n  apply g1.\n  apply g1.\n  apply g2.\n  apply g1.\n  apply g1.\n  apply g2.\n  apply g1.\n  apply g3.\n  apply g1.\n  apply g1.\n  apply g3.\n  apply g1.\n  apply g2.\n  apply g2.\n  apply g1.\n  apply g3.\n  apply g3.\n  apply g1.\n  apply g2.\n  apply g3.\n  apply g3.\n  apply g1.\n  apply g3.\n  apply g3.\n  apply g1.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n  apply g3.\n Qed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  auto with arith.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  apply (Build_Map (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : nat => m * nat) (Ap:=fun m : natQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  auto.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\n  rewrite <- (app_nil_r 0).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (app_nil_r 1).\n  rewrite (Qed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\nLemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1828,
                "proof_end_offset": 1927,
                "proof": "Lemma Resg1 : g 1 95 = 91.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n Qed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using (try reflexivity || simpl in |- *.\n  autorewrite with base0 using (try reflexivity || simpl in |- *.\n  autorewrite with base0 using (try reflexivity || simpl in |- *; auto).\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n Qed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using (auto || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base0.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n Qed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base2 using (auto with base1).\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base2.\n  autorewrite with base1.\n  autorewrite with base1.\n  autorewrite with base2.\n Qed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using try reflexivity || simpl in |- *.\n  auto.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using try reflexivity || simpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "ense, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\n",
                "context_tokens": 352,
                "proof_start_offset": 2584,
                "proof_end_offset": 2664,
                "proof": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros X.\ninversion_clear X.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros X; apply (fun _ => false).\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros; apply false.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros X; elim X; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros.\n  case (bool_irrelevance (fun x y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => y) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => y) (fun y => x) (fun y => x) (fun y => x) (fun y => y) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun y => x) (fun yQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nintros X.\napply (fun (X : Set) (x y : X) (y : X) =>\n  match b with\n  | true => x\n  | true => y\n  | false => y\n  end.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction 1; intros.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply a.\napply b.\napply b.\napply a.\napply b.\napply a.\napply b.\napply b.\napply b.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H.\napply H.\napply H.\napply H1.\napply H1.\napply H1.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H1.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply HQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros X; elim X; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintro X.\napply (A (B (B (C (C a))) (B (C (C a))) (C a)) (C (C (C a))) (C (C (C a)) (C (C (C a)) (C (C a))) (C (C (C a))) (C (C a))) (C a))) (C (C (C (C a)) (C (C a) (C (C a))) (C (C (C (C a))) (C (C a))) (C (C (C (C a))).\napply (A (B (C (C (C (C a))) (C (C (C a))) (C (C (C a))) (C (C (C a))) (C (C (C a))) (C (C (C a)) (C (C (C a))) (C (C a)) (C (C (C (C a))) (C (C (C a))) (C (C (C a))) (C (C (C a))) (C (C (C (C a))) (C (C (C a))) (C (C (C a)))Qed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros X H.\ncut (In (fun y : X => orb (In y) (In y) (In y)).\nintro H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "                                                *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 373,
                "proof_start_offset": 2666,
                "proof_end_offset": 2747,
                "proof": "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "eceived a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\n",
                "context_tokens": 475,
                "proof_start_offset": 3105,
                "proof_end_offset": 3181,
                "proof": "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n intros.\n apply inf_egal_eq1.\n apply inf_egal_eq1.\n apply inf_egal_eq2.\n apply inf_egal_eq1.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eq2.\n apply inf_egal_eqQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n intros m; elim m.\n trivial.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n unfold inf_egal.\n intros m H.\n elim H; intros.\n apply H0; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H;Qed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n intros.\n reflexivity.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n intros; apply (odd_egal_eq1 0); auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n intros m H.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq2 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq2 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq2 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq1 0 m H).\n simpl in |- *.\n apply (inf_egal_eq2 0 m H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "rogram; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 3183,
                "proof_end_offset": 3264,
                "proof": "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\n",
                "context_tokens": 501,
                "proof_start_offset": 3267,
                "proof_end_offset": 3361,
                "proof": "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "n                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4026,
                "proof_end_offset": 4088,
                "proof": "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n induction l.\n simpl; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; auto.\n simpl in |- *; autoQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n intros.\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).\n apply (lt_irrefl (Nil nat)).Qed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "        *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4090,
                "proof_end_offset": 4181,
                "proof": "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n intros n.\n rewrite (sorted_eq1 n); auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 4183,
                "proof_end_offset": 4343,
                "proof": "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n induction n.\n simpl.\n trivial.\n simpl.\n rewrite H.\n simpl.\n trivial.\n rewrite H.\n simpl.\n trivial.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x H.\n induction m; simpl in |- *; auto.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n intros.\n inversion_clear H.\n introsQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m H.\n induction m.\n simpl in |- *.\n intro.\n rewrite H.\n reflexivity.\n simpl in |- *.\n rewrite (IH m H).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x) (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IH (Cons nat m x)).\n reflexivity.\n simpl in |- *.\n rewrite (IHQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).\n rewrite (sorted_eq2 (Cons nat m x)).Qed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m.\n apply (lt_irrefl 0).\n assumption.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m H.\n simpl in |- *.\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (le_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (le_S_eq n).\n rewrite (le_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewrite (lt_S_eq n).\n rewriteQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n apply (H m).\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m H.\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\n rewrite (IH m).\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m H.\n induction n.\n simpl in |- *.\n rewrite H.\n reflexivity.\n simpl in |- *.\n rewrite H.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4504,
                "proof_end_offset": 4577,
                "proof": "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 4579,
                "proof_end_offset": 4724,
                "proof": "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros n m x.\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (nocc_eq2 n m).\n rewrite (noccQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros n m x.\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m x).\n rewrite <- (IH m xQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros n m x; elim n.\n rewrite <- (plus_n_Sm n); auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\n",
                "context_tokens": 746,
                "proof_start_offset": 4780,
                "proof_end_offset": 4846,
                "proof": "Theorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\n",
                "context_tokens": 698,
                "proof_start_offset": 4879,
                "proof_end_offset": 5155,
                "proof": "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\nintros.\nrewrite si_eq1.\napply H.\ntrivial.\nintros.\nrewrite si_eq2.\napply H0.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros.\n apply (H (fun a b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => b) (fun b => bQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros.\n apply (lt_not_eq (S (S (S (S n))) (S (S (S (S n))) (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S (S (S n)))) (S (S (S (S n)))) (S (S (S (S n))))) (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (SQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n unfold test in |- *.\n auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros.\n absurd (P (si X) (fun x => negb (H x)) = true).\n apply (H (fun x => negb (H x))) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negb (H x)) in H0.\n apply (H (fun x => negbQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x) -> P x y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x y) -> P y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x y) -> P x y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x y) -> P y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x y) -> P x y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x y : X) (b : bool), P x y) -> P x y.\n intros.\n apply (fun (X : Set) (P : X -> Prop) (x yQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\n",
                "context_tokens": 728,
                "proof_start_offset": 5197,
                "proof_end_offset": 5481,
                "proof": "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\napply False_ind.\napply diff_true_false.\nassumption.\nsimple induction m.\nintro.\ntrivial.\nintros.\nrewrite inf_egal_eq3.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n assumption.\n simpl in |- *.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction m.\n simpl in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold pocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold pocc in |- *.\n unfold nocc in |- *.\n unfold pocc in |- *.\n unfold nocc in |- *.\n unfold pocc in |- *.\n unfold nocc inQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl inQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintros n m H.\nelim (eq_nat_dec m n).\nintros.\nrewrite <- H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.Qed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n apply H.\n trivial.\n simpl in |- *.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n assumption.\n intro.\n apply (le_Sn_S m).\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n unfold inf_egal in |- *.\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ") (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 5518,
                "proof_end_offset": 5731,
                "proof": "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\nintro.\nunfold sorted in |- *.\ntrivial.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite e.\n apply le_trans with (nil (Cons nat n x)).\n simpl in |- *.\n apply le_trans with (nil (Cons nat n x)).\n simpl in |- *.\n apply le_trans with (nil (Cons nat (Cons nat (Cons nat n x) x))).\n simpl in |- *.\n apply le_trans with (nil (Cons nat (Cons nat n x) x)).\n simpl in |- *.\n apply le_trans with (cons (Cons nat (Cons nat n x) x)).\n simpl in |- *.\n apply le_trans with (nil (Cons nat n x)).\n simpl in |- *.\n apply le_trans with (nil (Cons nat (Cons nat (Cons nat n x) x))).\n simpl in |- *.\n apply le_trans with (cons (Cons nat (Cons nat (Cons nat n x) x)).\n simpl in |- *.\n apply le_trans with (cons (Cons nat (Cons nat n x) x)).\n simpl in |- *.\n apply le_trans with (cons (Cons nat (Cons nat (Cons nat (Cons nat n x) x))).\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n apply lt_n_O.\n assumption.\n simpl in |- *.\n apply lt_n_O.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl.\n intros.\n rewrite (inf_conv_length n).\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite H.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n apply le_lt_trans with (nil (Cons nat n x)).\n apply lt_n_S.\n apply lt_n_S.\n apply le_trans with (nil (Cons nat (Cons nat n x))).\n apply lt_n_S.\n apply le_trans with (nil (Cons nat n x)).\n apply lt_n_S.\n apply le_trans with (nil (Cons nat (Cons nat n x))).\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_trans with (nil (Cons nat n x)).\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n apply lt_n_S.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.Qed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\n apply lt_S.\n assumption.\n intro.\n rewrite e.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \n",
                "context_tokens": 719,
                "proof_start_offset": 5734,
                "proof_end_offset": 5910,
                "proof": "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n simpl in |- *. reflexivity.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite (IH _ H0).\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite H.\n simpl in |- *.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n rewrite a.\n simpl in |- *. apply lt_n_O.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\n simpl in |- *.\n apply lt_n_O.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intro.\n apply lt_S.\n assumption.\n intro.\n rewrite H1.\n apply le_n_S.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *. intros.\n apply (H n).\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *. intros.\n apply le_S.\n apply lt_n.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply (H (n0 :: m0)).\n apply lt_n0.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply lt_trans with (S n0).\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 6171,
                "proof_end_offset": 6267,
                "proof": "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n apply eq_S.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl in |- *.\n apply H.\n simpl inQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n unfold ins in |- *.\n simpl in |- *.\n intros.\n rewrite H.\n rewrite H.\n assumption.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro. intro.\n intro.\n rewrite H.\n apply IH.\n assumption.\n assumption.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n simpl in |- *.\n elim (lt_irrefl 0).\n simpl in |- *.\n intro.\n rewrite (H x).\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n simpl in |- *.\n assumption.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite (IH n).\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n intros.\n simpl in |- *.\n unfold ins in |- *.\n simpl in |- *.\n assumption.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n intros.\n simpl in |- *.\n intro.\n rewrite H.\n rewrite H.\n rewrite <- H.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro.\n intro.\n apply H0.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 6269,
                "proof_end_offset": 6448,
                "proof": "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\n discriminate.\n intros.\n simpl in |- *.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nintros.\nrewrite ins_eq2.\ntauto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nintro.\n rewrite cons_eq2.\n tauto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n intro.\n rewrite cons_eq2.\n rewrite cons_eq1.\n assumption.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nintro.\n rewrite (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IH _ H).\n apply (IHQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n apply le_trans with (1 := H0).\n assumption.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nintro.\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH m x).\n rewrite (IH mQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *. intros.\n elim (H 0).\n simpl in |- *. intros.\n rewrite <- H0.\n apply H.\n apply H.\n apply H.\n apply H0.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H0.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n applyQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nintro. intro.\n rewrite <- (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq1 H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\n rewrite (Hrec (cons_eq H)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 6573,
                "proof_end_offset": 6640,
                "proof": "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n intro.\n rewrite (Nil nat).\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n induction l.\n simpl.\n intro.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n apply IHs.\n simpl.\n applyQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n induction l.\n simpl in |- *.\n apply eq_ind.\n apply H0.\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (2 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (2 := H).\n apply IH with (2 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (2 := H).\n apply IH with (1 := H).\n apply IH with (2 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := H).\n apply IH with (1 := HQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n induction l.\n simpl.\n simpl.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.Qed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6642,
                "proof_end_offset": 6758,
                "proof": "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intro.\n induction n.\n simpl in |- *. intros.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.\n apply IHs.\n simpl in |- *.Qed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n replace (n + S n) with (S (S (S n)) by auto.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_n_O.\n rewrite <- minus_Qed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros n.\n induction n.\n simpl.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simplQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n induction n.\n simpl in |- *.\n intros.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Cons nat n) x).\n simpl in |- *.\n apply (IH (Cons nat n) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Cons nat (Cons nat n) x)).\n simpl in |- *.\n apply (IH (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (S (S n)))) x))).\n simpl in |- *.\n apply (IH (Nil nat) x).\n simpl in |- *.\n apply (IH (Cons nat (Cons nat (Cons nat (Cons nat (Qed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intro.\n unfold re_ins in |- *.\n simpl in |- *.\n intro.\n rewrite <- (H1 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <- (H3 H).\n rewrite <- (H2 H).\n rewrite <- (H3 H).\n rewrite <- (H3 H).\n rewrite <- (H3 H).\n rewrite <- (H4 H).\n rewrite <- (H5 H).\n rewrite <- (H3 H).\n rewrite <- (H4 H).\n rewrite <- (H4 H).\n rewrite <- (H3 H).\n rewrite <- (H4 H).\n rewrite <- (H2 H).\n rewrite <- (H3 H).\n rewrite <- (H4 H).\n rewrite <- (H2 H).\n rewrite (H4 H).\n rewrite <- (H4 H).\n rewrite <- (H2 H).\n rewrite <- (H2 H).\n rewrite <-Qed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n induction n.\n simpl in |- *.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\n",
                "context_tokens": 711,
                "proof_start_offset": 6851,
                "proof_end_offset": 7541,
                "proof": "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\nintros.\nrewrite ins_eq1.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\nintro.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\nrewrite sorted_eq3.\nsplit.\napply H2.\napply (sorted_cdr m).\nassumption.\nintro.\nrewrite sorted_eq3.\nsplit.\napply (sorted_inf m x0 l).\nassumption.\napply H.\nassumption.\napply (sorted_cdr m).\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n elim H.\n intros.\n apply H.\n intros.\n simpl in |- *.\n apply (H (S m)).\n apply (H (S m)).\n assumption.\n assumption.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H0.\n intro.\n rewrite (IH _ _ H2).\n rewrite (IH _ _ H3).\n rewrite (IH _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewrite (IH _ _ _ H3).\n rewriteQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *. intros.\n apply lt_n_S.\n simpl in |- *. intros.\n rewrite <- (lt_n_S m).\n simpl in |- *.\n intros.\n rewrite H0.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n apply (IH1 _ H0).\n assumption.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros x n m H.\nelim H.\nintros.\nrewrite H0.\napply IH.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H2.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H2.\n rewrite <- H0.\n rewrite <- H2.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H2.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H1.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H2.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H1.\n rewrite <- H0.\n rewrite <- H.\n rewrite <- H0.\n rewrite <- H.\n rewrite <-Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\nreplace (length (Cons nat m x)) with (length (Cons nat m x)) in |- *.\nauto with arith.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros x n m H.\nelim n.\nintros.\napply H0.\napply H1.\napply H.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\napply H1.\napply H1.\napply H2.\napply H1.\napply H3.\napply H3.\napply H3.\napply H2.\napply H1.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros x n m.\n elim m.\n intros.\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x)) (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x)) (nil nat)).\n simpl in |- *.\n apply (H (nil nat)).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x))) with (nil nat).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x))).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x))).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x))).\n simpl in |- *.\n apply (H (cons nat m (Cons nat m x))).\n simpl inQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite (IH _ H0).\n apply H1.\n apply H2.\n apply H.\n apply H1.\n apply H2.\n apply H1.\n apply H2.\n apply H2.\n apply H1.\n apply H2.\n apply H3.\n apply H1.\n apply H1.\n apply H1.\n apply H1.\n apply H2.\n apply H.\n apply H1.\n apply H1.\n apply H3.\n apply H3.\n apply H1.\n apply H1.\n apply H3.\n apply H1.\n apply H1.\n apply H.\n apply H3.\n apply H1.\n apply H3.\n apply H2.\n apply H3.\n apply H3.\n apply H1.\n apply H1.\n apply H3.\n apply H1.\n apply H3.\n apply H1.\n apply H3.\n apply H3.\n apply H2.\n apply H3.\n apply H1.\n apply H3.\n apply H3.\n apply H3.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 7543,
                "proof_end_offset": 7836,
                "proof": "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply si_intro.\nintros.\nrewrite sorted_eq3.\nsplit.\nassumption.\nassumption.\nintro.\napply sorted_ins_Cons.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intros.\n rewrite ins_eq1.\n rewrite ins_eq1.\n apply (sorted_more_l m). assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n intros.\n apply (sorted_inf m x). assumption.\n intros.\n rewrite ins_eq1.\n apply (sorted_node_l m). assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n simpl in |- *. intro. intro. elim H.\n   intro. elim H. intro.\n   elim H. intro. intro. elim H. intro.\n   elim H0. intro. intro. elim H1. intro. elim H1. intro.\n   elim H1. intro. elim H1. intro. elim H1. intro. elim H2. intro.\n   elim H2. intro. elim H3. intro. elim H4. intro.\n   elim H3. intro. elim H4. intro. elim H5. intro. elim H5. intro. elim H2. intro.\n   elim H6. intro. elim H5. intro. elim H6. intro.\n   elim H6. intro. elim H6. intro. elim H6. intro. elim H7. intro.\n   elim H7. intro. elim H6. intro. elim H6. intro. elim H6. intro.\n   elim H7. intro. elim H8. intro. elim H7. intro.\n   elim H7. intro. elim H7. intro. elim H7. intro.\n   elim H7. intro. elim H6. introQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intros. elim H.\n intros.\n rewrite ins_eq2.\n apply (sorted_ins_r m). assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. introQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. introQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. intro. introQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\n simpl in |- *. intros. elim H.\n intros.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n simpl in |- *. intros.\n rewrite ins_eq3.\n assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n simpl in |- *. intros.\n rewrite ins_eq1.\n apply (sorted_ins_cons_eq2 H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7983,
                "proof_end_offset": 8871,
                "proof": "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\nintro.\nrewrite nocc_eq2.\napply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite (nocc_eq2 n m x).\napply si_intro.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite <- H.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n intros.\n rewrite H.\n simpl in |- *.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite <- (IH_cons n).\n rewrite <- (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_cons n).\n rewrite (IH_consQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n rewrite cons_eq1.\n assumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n apply nocc_Cons_Cons. assumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n simpl in |- *.\n assumption.\n intros.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n apply nocc_Cons.\n assumption.\n apply nocc_Cons.\n assumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\n rewrite <- (IH (Cons nat p x)).\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 8873,
                "proof_end_offset": 9171,
                "proof": "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\nassumption.\nintro.\nrewrite H0.\nsimpl in |- *.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite nocc_eq2.\n apply (H (S n) (Cons nat m x)).\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\n assumption.\n simpl in |- *.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_neq n m x).\napply si_intro.\nauto.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n simpl in |- *.\n apply (bin_ind_l m x y).\n assumption.\n simpl in |- *.\n apply (bin_ind_r m x y).\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat p x)).\napply frel_intro.\nrewrite (nocc_eq2 n p (Cons nat m x))).\napply frel_intro.\nrewrite H.\napply frel_intro.\nrewrite H.\napply (H2 n).\nauto.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply IHs.\n assumption.\n intro.\n rewrite nocc_eq2.\n rewrite nocc_eq2.\n apply refl_equal.\n intro.\n rewrite nocc_eq2.\n rewrite nocc_eq2.\n assumption.\n intro.\n rewrite nocc_eq2.\n rewrite nocc_eq2.\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite (nocc_eq2 n).\n apply not_cons_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_inv.\n apply not_cons_inv.\n apply not_cons_inv.\n apply not_cons_Qed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (nocc_eq2 n p (Cons nat m x)).\n rewrite (Qed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Cons. assumption.\n simpl in |- *.\n apply nocc_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 9173,
                "proof_end_offset": 9520,
                "proof": "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\ntrivial.\nintro.\nrewrite nocc_Cons_Cons.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply lt_S.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply lt_le_trans with (n := n); assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply Socc_In.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n m H).\napply nocc_Cons. assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply  (occ_Cons nat m (Cons nat m x)).\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq n m).\napply lt_n_S.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n simpl in |- *.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 9522,
                "proof_end_offset": 9729,
                "proof": "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite tri_ins_eq2.\nrewrite nocc_ins.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_tl.\n intro.\n rewrite nocc_eq with (n := x) (last (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (cons (Qed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq1.\n apply (si_intro (list nat)\n      (fun t : list nat => nocc (S t) t = nocc n (Cons nat (S t) t))).\n  trivial.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\napply nocc_Eq.\napply (occ_O_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil (occ_nil_nil (occ (nil_nil_nil (occ t)))) (occ_nil (occ_Qed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n apply not_true_ind.\n apply not_true_ind.\n assumption.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply (IH (Nil nat) (Nil nat) (Nil nat)); simpl in |- *; intros.\n rewrite nocc_Eq.\n assumption.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply H.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n simpl in |- *.\n rewrite ins_eq2.\n apply ins_eq with (n := 0%nat).\n assumption.\n intro.\n rewrite (nocc_eq2 n).\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumption.\n intro.\n rewrite (nocc_neq2 n).\n assumptionQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n t)\n     (fun t : list nat => nocc t = nocc n t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = nocc t)\n     (fun t : list nat => nocc t = n)\n     (fun t : list nat => nocc t = n)\n     (fun t : list nat => nocc t = n)\n     (fun t : list nat => nocc t = n)\n     (fun t : list nat => nocc t = n)\n     (fun t : list nat =>Qed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n simpl in |- *.\n simpl in |- *.\n apply lt_n_trans with (occ n (Cons nat m (Cons nat m x))).\n  trivial.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_Cons.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 10123,
                "proof_end_offset": 10190,
                "proof": "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.Qed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n simpl in |- *.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.Qed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n simpl in |- *.\n simpl in |- *.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simpl in |- *.\n discriminate H.\n intros.\n simplQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite <- (bub'_aux l n0 (bub'_aux l n0)).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l n0).\n simpl in |- *.\n rewrite (bub'_aux l nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simpl in |- *.\n apply Cons.\n trivial.\n intros.\n simplQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |- *.\n rewrite (bub'_aux l n0 H).\n simpl in |-Qed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_r (a :: l)).\n rewrite (app_nil_rQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n apply bublocBSrc_aux.\n assumption.\n intro.\n rewrite (clb'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_aux l n0 l0).\n simpl in |- *.\n apply bub'_aux.\n assumption.\n intro.\n rewrite (dub'_Qed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite (Hrec x).\n trivial.\n intros.\n rewrite (Hrec x).\n trivial.\n intros.\n rewrite (Hrec x).\n trivial.\n intros.\n rewrite (Hrec x).\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 10192,
                "proof_end_offset": 10301,
                "proof": "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  induction n.\n    reflexivity.\n    intros.\n    simpl in |- *.\n    rewrite (H n).\n    reflexivity.\n    intro.\n    rewrite (H n).\n    reflexivity.\n    intro.\n    rewrite (H n).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (H (n :: l)).\n    reflexivity.\n    intro.\n    rewrite (HQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_alt.\n  apply bub'_Qed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nintros.\n induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  unfold bubvararg in |- *.\n  case b.\n  simpl in |- *.\n  rewrite (plus_comm (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0))))))))))))\n      (Cons nat (bub Index_aux l n0))\n      (Cons nat (bub Index_aux l n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (ConsQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  induction n.\n  trivial.\n  simpl in |- *.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.\n  rewrite (ale_S_n n) in H.Qed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  intros n.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.\n  rewrite bubBDD_correct.Qed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  unfold bubplacement_aux in |- *.\n  apply bubplacement_aux_eq1.\n  assumption.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  intros n H.\n  elim H.\n  intros.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite <- H0.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ".\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\n",
                "context_tokens": 682,
                "proof_start_offset": 10302,
                "proof_end_offset": 10522,
                "proof": "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bubHomo in |- *.\n  elim (decdec bubplacing_aux l n0 n0).\n  intro.\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bubplacing_aux l n0).\n  intro.\n  rewrite (dec bubplacing_aux l n0).\n  apply (dec bQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  rewrite bubHomo_eq2.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq2.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eq1.\n  rewrite bubBDD_eqQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  apply bubTl_eq1.\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq2).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n  apply (bubTl_eq1).\n Qed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bub National demodulate, bubHomo in |- *.\n  unfold bubHomo in |- *.\n  apply bub'_eq1.\n  intros.\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq2 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eq1 b).\n  rewrite (bub'_eqQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bub(**********)\n  rewrite (plus_comm (a + b) (b + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).\n  rewrite (plus_comm (a + b) (b + b)).Qed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  rewrite bub -?(Cons nat n (Nil nat n)).\n  apply bubirule.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eq3.\n  apply bubplac_eqQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  apply bub'_aux_eq1.\n  apply (bub'_aux_eq2 (bub'_aux x) (bub'_aux x)) with (bub'_aux x (bub'_aux x))).\n  apply bub'_aux_eq1.\n  apply bub'_aux_eq2.\n  apply (bub'_aux_eq2 (bub'_aux x) (bub'_aux x) (bub'_aux x)) with (bub'_aux x (bub'_aux x)).\n  apply bub'_aux_eq1.\n  apply (bub'_aux_eq2 (bub'_aux x) (bub'_aux x) (bub'_aux x)) with (bub'_aux x (bub'_aux x)).\n  apply bub'_aux_eq2.\n  apply (bub'_aux_eq2 (bub'_aux x) (bub'_aux x) (bub'_aux x) (bub'_aux x)).\n  apply bub'_aux_eq2.\n  apply (bub'_aux_eq2 (bub'_aux x) (bub'_aux x)Qed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 11196,
                "proof_end_offset": 11281,
                "proof": "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  apply fummies_eq1 with (f := f).\n  apply fummies_eq2 with (f := f).\n  apply fummies_eq1 with (f := f).\n  apply fUniv_eq2 with (f := f).\n  apply fummies_eq2 with (f := f).\n  apply fission_eq2 with (f := f).\n  apply fission_eq2 with (f := f).\n  apply fission_eq2 with (f := f).\n  apply fission_eq1 with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq1 with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq1 with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq2 with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq1 with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq with (f := f).\n  apply fission_eq2 with (Qed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros.\nunfold fission in |- *.\ninduction n0.\nauto.\nintros.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Cons nat)) (Nil nat).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Nil nat)) (Nil nat)).\nauto.\nrewrite (Rec (fission (Cons nat)) (Qed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros ms.\ninversion ms.\n auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros ms.\n  induction ms.\n  simpl.\n  trivial.\n  rewrite (fusion_eq2 _ _ (fusion_r_sort0 _ _ (fusion_r_sort _ _ _ (fusion_r_sort _ _ _ _ (fCtype_r_sort _ _ _ (fusion_r_sort _ _ _ _ (fCtype_r_sort _ _ _ (fCtype_r_sort _ _ _ (fCtype_l_sort _ _ _ _ (fCtype_r_sort _ _ (fCtype_r_sort _ _ _ (fCtype_r_sort _ _ _ (fCtype_r_sort _ _ _ (fCtype_l_sort _ _ _ (f)))));\n  trivial.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n intros.\n rewrite (map_map (fun x : list nat => fCons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (S (S (S n)))))))))))) 0) (Nil nat).\n simpl.\n rewrite (map_map (fun x : list nat => fCons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (S (S (S n)))))))) 0) (Nil nat).\n simpl.\n rewrite (map_map (fun x : list nat => fCons nat (Cons nat (Cons nat (Cons nat (Cons nat (Cons nat (S (S (S (S (S n)))) (Cons nat (Cons nat (S (S (S (S (S (S n)))))))) 0) (Nil nat).\n simpl.\n rewrite (map_map (fun x : list nat => fCons nat (Cons nat (Cons nat (S (S (S (S n)))) (Qed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros; simpl in |- *; auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros; induction ms.\n simpl in |- *.\n simpl in |- *.\n apply f pds.\n rewrite f pds.\n reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\n intro.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  induction x.\n  trivial.\n  intros.\n  rewrite (fission_eq0 _ _ H0).\n  rewrite (fission_eq0 _ _ H0).\n  rewrite (fission_eq0 _ _ H0).\n  trivial.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros; simpl; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 11283,
                "proof_end_offset": 11406,
                "proof": "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n inversion_clear H.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fissionQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros n.\n induction n.\n simpl.\n simpl.\n simpl.\n reflexivity.\n simpl.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simpl.\n reflexivity.\n simplQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n induction n.\n simpl in |- *.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |-Qed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n induction n.\n simpl.\n rewrite (f Branch_eq2 n n (Nil nat)).\n rewrite (f Branch_eq2 n (Cons nat n0 (Cons nat n0 (Cons nat n0 l))))\n   with (f:=@eq nat 0 (Cons nat (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0)))))))); \n simpl.\n rewrite (f Branch_eq2 n (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0)))))))); \n simpl in |- *.\n rewrite (f Branch_eq2 n (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0 (Cons nat n0Qed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n induction n.\n simpl in |- *.\n apply fusion_eq.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_Qed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\nLemma fusion_eq2 :\n forall (n : nat) (ns : list nat),\n fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 11408,
                "proof_end_offset": 11665,
                "proof": "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros n.\n unfold font in |- *.\n rewrite folded_eq1.\n rewrite folded_eq2.\n rewrite folded_eq1.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewrite folded_eq2.\n rewriteQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n induction n.\n simpl in |- *.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |-Qed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros n.\n apply fummies_eq.\n apply fission_eq.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq2.\n apply fission_eq1.\n apply fission_eq1.\n apply fission_eq1.\n apply fQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 753,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\n  intros H1.\n  apply H1.\n  apply H2.\nAbort.\n\n(* The following lemma works when it's not be needed to be used to be used to be used to be used. *)\n\nDefinition b :=\n  |> # # # #' # # b # = |> # # # #' # b # b # b.\n\n(* The following lemma is used in the following lemma: *)\n\nDefinition b :=\n  |> # # # # # # # # # # # # # b # # # b.\n\n(* The following lemma works in the following lemmas are not change for the following lemmas. *)\n\nDefinition b :=\n  |> # # # # # # # # # # # # # # # b # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Save solution'_b.",
                    "Goal solvable b.\nFail eapply H; eauto.\nSave solution'_b.",
                    "Goal solvable b.\nintros H b Hb.\nunfold.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply HSave solution'_b.",
                    "Goal solvable b.\nintros H1 H2 H3.\napply H3.\n(* The following theorem is a valid in the two style\n   and then a disjunctively on the first argument\n   always be defined in the previous version. *)\n\nTactic Notation \"not\" \"*\" :=\n  ( |> # # # \\  # #  #  /  #  #  /  #  #  /  #  /  #  *)\n(*        # # # # #  /  #  /  #  *)\n(*       # # # # # # #  /  #  *)\n(*       # # # # # # # #  *)\n(*         # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Save solution'_b.",
                    "Goal solvable b.\nProof.\nintros.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply.\napplySave solution'_b.",
                    "Goal solvable b.\n  unfold b at 1; apply: (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 * b) ||\n  (2 *Save solution'_b.",
                    "Goal solvable b.\n  unfold sol in H.\n  unfold sol in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n Save solution'_b.",
                    "Goal solvable b.\nintro H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.Save solution'_b.",
                    "Goal solvable b.\ncongruence.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\n  unfold solvable, b, b, b, c, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, dSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 748,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Stepping east, the proof of the lemma: *)\napply H with C.\nunfold b in |- *.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.\n(* Step through the proof of the lemma *)\napply H with E.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H1 H2].\n(* Step through *)\nintros.\ndestruct H as [H2 H3].\n(* Step through *)\nintros.\ndestruct H as [H1 H3].\n(* Step through *)\nintros.\ndestruct H as [H1 H3].\n(* Step through *)\nintros.\ndestruct H as [H2 H4].\n(* Step through *)\nintros.\ndestruct H as [H1 H3].\n(* Step through *)\nintros.\ndestruct H as [H2 H3].\n(* Step through *)\nintros.\ndestruct H as [H1 HSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable.\nintros H'.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 := H').\nunfold b in |- *.\napply H' with (1 :=Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Stepping *)\nintros.\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecialize (H b).\nspecializeSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Stepping east, we know that the two different definition. *)\napply H; assumption.\n(* Step through the previous hypothesis, we can use the two cases. *)\napply H; assumption.\n(* Step through the same relation, we use the second case. *)\napply H; assumption.\n(* Step through the same relation, we prove that the second case. *)\napply H; assumption.\n(* Step through the same relation, we can use the second case. *)\napply H; assumption.\n(* Step through the same relation, which must use the first case. *)\napply H; assumption.\n(* Step through the same relation, we use the second case. *)\napply H; assumption.\n(* Step through the same relation, and prove that the second case. *)\napply H; assumption.\n(* Step through the same relation, we can use the second case. *)\napply H; assumption.\n(* Step through the same relation, we use the second case. *)\napply H; assumption.\n(* Step through the same relation, which can use the first case. *)\napply H; assumption.\n(* Step through the same relation, we have theSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable in |- *.\nunfold sub at 1 in |- *;\n(* Tarate the proof of the lemma *)\napply H0.\n(* Tarate the lemma, so we can write the same as follows from the same as follows: *)\napply H0.\n(* Tarate the lemma, so we do not have to prove *)\napply H0.\n(* Tarate the case of the lemma *)\napply H0.\n(* Tarate the lemma, which can be read in the lemma *)\napply H0.\n(* Tarate the lemma, we can do not apply the lemma *)\napply H0.\n(* Tarate the lemma, so we have an explicit substitution. *)\napply H0.\n(* Tarate the proof of the lemma *)\napply H0.\n(* Tarate the lemma can use this lemma *)\napply H0.\n(* Tarate the lemma *)\napply H0.\n(* Tarate the lemma works *)\napply H0.\n(* Tarate the lemma *)\napply H0.\n(* Tarate the lemma *)\napply H0.\n(* Tarate the lemma *)\napply H0Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable, micularity in |- *.\nunfold not in |- *.\nintros a b c c Hc Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd HdSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable at 1.\nunfold sub at 1.\nunfold sub at 1.\nunfold sub at 1.\nunfold sub at 1.\nunfold sub at 1 3.\nunfold sub at 1.\nunfold sub at 1.\nunfold sub at 1.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 2.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1.\nunfold sub at 1 2.\nunfold sub at 1 3.\nunfold sub at 1 3.\nunfold sub at 1 3Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable at 1.\nunfold ric|]].\napply H.\nintros x y.\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.\n(*... *)\napply H.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable in |- *; unfold cut (micularity (micularity (micularity (micularity (micularity (micularity (micularity (micularity (micularity (msym_not m)))) (micularity (micularity (micularity (micularity (micularity (min))));\n    [apply proper_refl | apply proper_refl ];\n    apply proper_refl.\n(* A direct version of B is a right-hand side of the new goal. *)\napply H with (micularity (micularity (micularity (micularity (micularity (micularity (mic))));\n    [apply proper_refl | apply proper_refl ];\n    apply proper_refl.\n(* A direct version of B_Converture, it's not a left-hand side of the original goal. *)\napply H with (micularity (micularity (micularity (micularity (micularity (micularity (micularity (mic))));\n    [apply proper_refl | apply proper_refl ];\n    apply proper_refl.\n(* A direct version of B_Converture, we haveSave microban_1_solution."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\n",
                "context_tokens": 356,
                "proof_start_offset": 1314,
                "proof_end_offset": 1504,
                "proof": "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nsimpl.\napply head_insertion.\nsimpl.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs. simpl in |- *.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros.\nsimpl in |- *.Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  induction xs; intros.\n  - reflexivity.\n  - simpl.\n    rewrite app_nil_r.\n    reflexivity.\n  - simpl.\n    rewrite app_nil_r.\n    reflexivity.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n intros.\n apply insert_insertion.\n apply insert_insertion.\n apply insert_insertion_cons.\n apply insert_insertion_nil.\n apply insert_insertion_nil.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_nil.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.\n apply insert_insertion_cons.Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros.\nunfold insertion in |- *.\nsimpl in |- *.\nintuition.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  induction xs as [ | x xs' xs' ]; simpl; intros.\n  + simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::xs)).\n    simpl.\n    apply (sorted_insertion (x::Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  intros.\n  induction xs; simpl; auto.\n  destruct xs; simpl; auto.\n  destruct xs; simpl; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros.\ninduction xs.\nsimpl.\nreflexivity.\nsimpl.\nreflexivity.\nsimpl.\nrewrite <- app_nil_end.\nrewrite <- app_nil_end.\nrewrite app_nil_end.\nrewrite <- app_nil_end.\nrewrite <- app_nil_end.\nrewrite app_nil_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite app_nil_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_nil_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_end.\nrewrite <- app_Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  intros.\n  induction xs.\n    simpl.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\n  Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  induction xs.\n    reflexivity.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\n    simpl.\n    reflexivity.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n induction xs; simpl; intros; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\n",
                "context_tokens": 435,
                "proof_start_offset": 1551,
                "proof_end_offset": 1679,
                "proof": "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\nintros.\ninduction H;simpl;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply tl_insertion.\n  simpl.\n  apply hd_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply insert_insertion.\n  simpl.\n  apply insert_insertion.\n  simpl.\n  apply insert_insertion.\n  auto.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply app_nil.\n  simpl.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l'.\n  simpl.\n  apply app_nil_nil.\n  apply cons_insertion.\n  auto.\n  apply cons_insertion_cons.\n  apply cons_insertion_nil.\n  apply cons_insertion_nil.\n  auto.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_nil.\n  auto.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_nil.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  applyQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l'.\n  simpl.\n  apply app_nil.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_nil_r.\n  simpl.\n  apply app_Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.\n  simpl.\n  apply cons_nil.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l'.\n  simpl.\n  apply app_nil.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_insertion_in.\n  apply tail_Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l'.\n  simpl.\n  apply insert_insertion.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insertQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l'.\n  simpl.\n  apply cons_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\n",
                "context_tokens": 500,
                "proof_start_offset": 1735,
                "proof_end_offset": 1960,
                "proof": "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;simpl;try tauto.\ncase H0;try tauto.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply HQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intro.\n  apply (insert_nonnil l l').\n  intro.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply HQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l';simpl in |- *; tauto.\n  simpl in |- *.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_neq.\n  apply cons_Qed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l'; simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n  simpl in |- *; tauto.\n Qed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  apply insertion_in.\n  apply insertion_in.\n  apply insert_insertion.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_sortedQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intro.\n  case (Compare_dec.eq_dec x y); intro.\n  left; left; auto.\n  right; right; right; right; right; right; right; right; right; right; left; left; auto.\n  right; left; right; right; right; right; right; left; auto.\n  left; right; left; right; left; auto.\n  right; right; right; right; left; right; auto.\n  right; left; right; right; left; auto.\n  right; right; right; right; right; right; right; right; left; auto.\n  right; left; left; auto.\n  right; left; right; left; auto.\n  left; right; left; auto.\n  right; right; right; right; right; left; auto.\n  right; left; right; auto.\n  right; right; left; auto.\n  right; right; right; right; right; right; auto.\n  right; right; left; right; auto.\n  right; left; right; left; auto.\n  right; right; right; right; auto.\n  right; left; left; auto.\n  right; leftQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l'; simpl; tauto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion_sort.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  simpl.Qed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_insertion_in.\n  apply insert_insertion_in.\n  apply insert_sorted.\n  apply insert_sorted.\n  apply insert_insertionQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  apply insert_preserves_insert.\n  assumption.\n  apply insert_preserves_insert.\n  assumption.\n  apply insert_preserves_insert.\n  assumption.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  unfold insertion_in.\n  split.\n  apply (insert_insertion_in _ _ H).\n  apply insert_insertion.\n  apply insert_insertion_in.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\n",
                "context_tokens": 603,
                "proof_start_offset": 2029,
                "proof_end_offset": 2310,
                "proof": "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\ninduction l;simpl;try tauto;intros.\ncase H;intro.\nrewrite H0;exists l;apply head_insertion.\nelim (IHl H0);intro l';intro.\nexists (a::l');apply tail_insertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H1;try tauto.\n  case H1;try tauto.\n  case H2;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H0Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  caseQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  inversion_clear H.\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (H (a::l)).\n  apply (HQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  right;auto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tautoQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;try tauto;intros.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  apply cons_insertion_cons.\n  applyQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intro.\n  apply in_insertion.\n  apply (H (a::a::l) (a::l) (a::l) (a::l) (a::l) (a::l') (a::l) (a::l) (a::l) (a::l') (a::l) (a::l) (a::l') (a::l) (a::l) (a::l') (a::l') (a::l') (a::l) (a::l') (a::l') (a::l') (a::l) (a::l') (a::l') (a::l) (a::l') (a::l) (a::l') (a::l') (a::l') (a::l') (a::l') (a::l) (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (a::l') (Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;auto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simpl;tauto.\n  destruct l;simplQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intro.\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  caseQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "riais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\n",
                "context_tokens": 694,
                "proof_start_offset": 2378,
                "proof_end_offset": 2605,
                "proof": "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\nintros.\ninduction H;simpl in H0.\ncase H0;intro H1;try (symmetry in H1);tauto.\ncase H0;simpl;intro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l';simpl;try tauto;intros.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;apply H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <- H;auto.\n  rewrite <-Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion HQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H;try tauto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;autoQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l';simpl;try tauto;intros.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;try tauto.\n  apply H;auto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion HQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;try tauto;intros.\n  rewrite H0;exists l;apply head_insertion.\n  elim (H0 H1);intro l';auto.\n  case H0;try tauto.\n  case H;try tauto;intros.\n  rewrite H0;exists l;apply head_insertion_trivial.\n  elim (H0 H1);intro l';auto.\n  case H0;try tauto.\n  case H0;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  caseQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  apply in_insertion_inv.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  apply H0;auto.\n  applyQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case (H0 x);try tauto;intros.\n  right;auto.\n  right;auto.\n  case (H0 x);try tauto.\n  left;auto.\n  left;auto.\n  left;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  inversion_clear H.\n  rewrite <- (H (x::l)); auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertion_inv; auto.\n  apply in_insertionQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2890,
                "proof_end_offset": 3177,
                "proof": "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction 1;intros.\ninversion H;trivial.\ninversion H0.\napply cons_is_set.\napply IHinsertion;trivial.\nintro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l'; simpl;try tauto;intros.\n  apply (is_set_insertion _ _ _ _ H0); auto.\n  apply (is_set_insertion _ _ _ _ _ H0); auto.\n  apply (is_set_insertion _ _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _ _ _ _ H1); auto.\n  apply (is_set_insertion _ _Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case H;try tauto.\n  case (H0 l');intro.\n  case H;try tauto;intros;elim H0;intro H0;try tauto.\n  case H;try tauto;intros;elim H0;intro H1;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H0;try tauto;intros;elim H0;try tauto.\n  case H;try tauto;intros;elim H0;try tauto.\n  case H0;try tauto.\n  case H;try tauto;intros;elim HQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case H;intro H;try tauto;intros.\n  case H;intros.\n  case (H0 x);intros;try tauto.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H1;intros.\n  case H0;intros.\n  case H1;intros.\n  case H0;intros.\n  case H0;intros.\n  case H0;intros.\n  case H1;intros.\n  case H0;intros.\n  case H1;intros.\n  case H0;intros.\n  case H1; intros.\n  case H1;intros.\n  case H1; intros.\n  case H1;intros.\n  case H1; intros.\n  case H1; intros.\n  case H1; intros.\n  case H2; intros.\n  case H1; intros.\n  case H1; intros.\n  case H2; intros.\n  case H1; intros.\n  case H1;Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l';simpl;try tauto;intros.\n  elim (H0 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H0 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H2 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H3 l);intro.\n  apply (H2 l);intro.\n  apply (H3 l);intro.\n  apply (H3 l);intro.\n  apply (H1 l);intro.\n  apply (H2 l);intro.\n  apply (H0 l);intro.\n  applyQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros;subst;assumption.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;intros.\n  case H;simpl;try tauto;introsQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  apply (H a);simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion HQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case (H0 x);intro H1;try (right; tauto));intro H2;try tauto.\n  case (H1 x);intro H3;try tauto;intros.\n  apply (H1 x);intro H3;try tauto.\n  apply (H2 x);intro H3;try tauto.\n  apply (H2 x);intro H3;try tauto.\n  apply (H3 x);intro H4;try tauto.\n  apply (H3 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H5 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H4 x);intro H4;try tauto.\n  apply (H5 x);intro H4;try tauto.\n  apply (H4 x);intro HQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros;inversion_clear H.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;try tauto.\n  case H;simpl;Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros;inversion_clear H;intros.\n  apply (is_set_list A l l' x);intro.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  apply (is_set_list A l l' x);intro.\n  exists (a::l);apply a.\n  apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (a::l);apply a.\n  exists (aQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.\n  case H;try tauto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\n",
                "context_tokens": 713,
                "proof_start_offset": 3243,
                "proof_end_offset": 3575,
                "proof": "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;rewrite <- H3 in H0;inversion H0.\nsimpl in H7;trivial.\nintro.\ncase H10;intro.\napply H9;rewrite H11;eapply insertion_in;apply H5.\nelim (IHl l'0 x H5 H8 H11).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction 1;intros.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H0; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l'; simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversionQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;simpl;intro.\n  rewrite H0;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  apply (list_sorted_lt x l l);trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl;intro.\n  rewrite H;exists l;apply head_insertion_in;trivial.\n  case H;simpl; intro.\n  rewrite H;exists lQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l';simpl;try tauto;intros.\n  case H;intro H0;try tauto.\n  case H;intro H0;try tauto.\n  case H;intro H0;try tauto.\n  case H;intro H0;try tauto.\n  case H;intro H0;try tauto.\n  case H0;intro H0;try tauto.\n  case H0;intro H0;try tauto.\n  case H0;intro H0;try tauto.\n  case H0;intro H1;try tauto.\n  case H0;intro H1;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;intro H1;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;try tauto.\n  case H0;intro H2;try tauto.\n  case H0;tryQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction l;simpl;try tauto;intros.\n  inversion H;subst;auto.\n  inversion H;subst;auto.\n  apply cons_is_set.\n  apply IHinsertion_in with l';trivial.\n  intro;apply (IHinsertion_in A x l l');trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  inversion H;trivial.\n  inversion H;trivial.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H0.\n  apply H;apply H.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l; simpl;try tauto;intros.\n  inversion H;clear H;subst; tauto.\n  inversion H;clear H;subst; tauto.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply (IHinsertion A x l l l');trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  apply (is_set_insertion_in A x l l' x);trivial.\n  apply (is_set_insertion_in A x l l' x);trivial.\n  intro;apply (is_set_insertion_in A x l l' x);trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l';simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simpl;try tauto;intros.\n  inversion H;simplQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  inversion H;simpl;try tauto.\n  apply cons_is_set;apply (H x);trivial.\n  apply (H0 x);trivial.\n  apply (H0 x);trivial.\n  apply (H0 x);trivial.\n  apply (H0 x);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\nLemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;rewrite <- H3 in H0;inversion H0.\n  simpl in H7;trivial.\n  intro.\n  case H10;intro.\n  apply H9;rewrite H11;eapply insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\n",
                "context_tokens": 697,
                "proof_start_offset": 4672,
                "proof_end_offset": 5534,
                "proof": "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros;simpl in H.\ndestruct l'.\napply nil_is_permutation.\nelim (H a);intros.\nelim H3;simpl;tauto.\ninversion H0.\nsymmetry in H2;rewrite H2 in H;elim (H a);intros.\nrewrite H2 in H6;rewrite H2.\nassert (In x l');auto.\nelim (in_insertion A x l' H8).\nintro l'';intro.\napply cons_is_permutation with l'';trivial.\napply IHl;trivial.\nsplit;intro.\nelim (H x0);intros.\nelim (in_insertion_inv A x0 x l'' l');auto.\nintro;rewrite H13 in H10;rewrite H2 in H5;tauto.\nelim (H x0);intros.\ncase H12;try tauto.\napply (insertion_inclusion A x l'' l');trivial.\nintro;rewrite <- H13 in H10.\nelim (is_set_insertion_in A l'' l' x);trivial.\neapply is_set_insertion;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  inversion H; subst.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_is_empty.\n  apply cons_Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros;inversion H.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\n  apply is_empty.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros.\n  inversion H;clear H0.\n  apply (is_empty_is_set A l l l);trivial.\n  apply (is_empty_is_empty A l l);trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros.\n  inversion H; rewrite <- H1 in H1.\n  apply (is_set_cons A l l l');trivial.\n  apply (is_set_cons A l l l');trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros.\n  apply False_ind.\n  apply False_ind.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros.\n  inversion H;subst;auto.\n  inversion H;subst;auto.\n  inversion H0;subst;auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l';simpl;try tauto;intros.\n  inversion H;rewrite <- H0 in H;inversion H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  inversion H; subst.\n  inversion H0.\n  apply cons_is_empty.\n  apply H1.\n  apply cons_is_set.\n  apply H0.\n  apply cons_is_set.\n  apply H0.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  apply H2.\n  apply H2.\n  apply cons_is_set.\n  apply H0.\n  apply H1.\n  apply cons_is_set.\n  apply H0.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H1.\n  apply cons_is_set.\n  applyQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\ninduction 1;intros.\n inversion H.\napply (is_empty A l');trivial.\napply (is_empty A l);trivial.\napply (is_empty A l);trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction 1;intros.\n  inversion H0.\n  apply cons_is_set.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply cons_is_set.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply cons_is_set.\n  apply H1.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply cons_is_set.\n  apply H2.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply H2.\n  apply cons_is_set.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply cons_is_set.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\n",
                "context_tokens": 732,
                "proof_start_offset": 5571,
                "proof_end_offset": 5760,
                "proof": "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l.\napply nil_is_permutation.\neapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l;intros;simpl in *.\n  destruct l;simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *; subst.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *; subst.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destruct l';simpl in *.\n  destructQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l;intros;simpl in H.\n  destruct l.\n  apply (is_permutation_refl A l);trivial.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l;intros;simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct H;simpl in H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct H;simpl in H.\ndestruct H;simpl in H; inv H.\ndestruct l';simpl in H.\ndestruct l';simpl in H.\ndestruct H;simpl in H.\ndestruct H;simpl in H.\ndestruct H;simpl in H; inv H.\ndestruct H;simpl in H.\ndestruct H; simpl in H; inv H.\ndestruct l';simpl in H.\ndestruct H;simpl in H.\ndestruct H;simpl in H.\ndestruct H; simpl in H.\ndestruct H; simpl in H.\ndestructQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l;simpl in *; intuition.\n  apply (is_trivial_left A l);trivial.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;simpl in |- *; tauto.\n  induction l;intros;simpl in |- *; tauto.\n  induction l;simpl in |- *; tauto.\n  inductionQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l;intros;simpl in H.\n  apply H.\n  apply is_permutation_refl.\n  apply is_permutation_refl.\n  apply is_permutation_refl.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in H;inversion H.\n  apply (is_permutation_trans A l);auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  apply is_permutation_trans with l';auto.\n  applyQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros; apply is_permutation_refl.\n  apply is_permutation_trans with l; trivial.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in H;auto.\n  apply (is_permutation_refl A (is_permutation_refl A (is_permutation_refl A l)) (is_permutation_refl A l)).\n  apply (is_permutation_refl A (is_permutation_trans A l l)).\n  apply (is_permutation_trans A l);auto.\n  apply (is_permutation_trans A l);auto.\n  apply (is_permutation_trans A l);auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in H.\n  apply is_permutation_refl.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.\n  apply is_permutation_trans with (is_permutation A l');auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\n",
                "context_tokens": 716,
                "proof_start_offset": 5839,
                "proof_end_offset": 6163,
                "proof": "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\nProof.\ninduction 1.\napply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\napply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l; intros;simpl in *; tauto.\n  induction l'; simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\n  simpl in *; tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl in |- *.\n  induction l.\n  simpl in |- *.\n  simpl in |- *.\n  simpl in |- *.\n  apply (IHis_nil A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHis_permutation A); auto.\n  simpl in |- *.\n  apply (IHQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l'; intros; simpl in |- *; auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (is_permutation_trans A (x::l')); auto.\n  apply (isQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l; simpl in *.\n  apply cons_is_permutation with (x:=l) in H.\n  apply (a:=a) in H.\n  apply (a0:=a0) in H.\n  apply H0.\n  apply cons_is_permutation.\n  assumption.\n  assumption.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  apply nil_is_permutation.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l');auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply cons_is_permutation with (x::l');auto.\n  apply cons_is_permutation with (x::l);auto.\n  apply consQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l';intros;simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destruct l';simpl in *; auto.\n  destructQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  apply (l_is_permutation A (x::l')) in H.\n  apply (l_is_permutation A (x::l')) in H.\n  apply H.\n  simpl in H.\n  apply (l_is_permutation A (x::l')) in H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.Qed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H.\n  apply (H a);trivial.\n  simpl in H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in *; intuition.\n  destruct l';simpl in *; intuition.\n  apply cons_is_permutation.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H1.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H1.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H0.\n  eapply cons_is_permutation.\n  apply H1.\n  eapply cons_is_permutationQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l; simpl; auto.\n  destruct l'.\n  apply (list_is_permutation A (x::l)); auto.\n  rewrite <- is_permutation_sym; auto.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ".\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\n",
                "context_tokens": 682,
                "proof_start_offset": 6350,
                "proof_end_offset": 6985,
                "proof": "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\nProof.\ninduction 1;intros.\ninversion H.\nexists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\nexists l';split;[trivial | apply head_insertion].\ninversion H0.\nexists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\nelim (IHinsertion l'0 y0 H5);intro l3;intro.\nelim H6;intros.\nexists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation with (y::l);trivial.\n  apply cons_is_permutation with (y::l);trivial.\n  apply cons_is_permutation with (y::l);trivial.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation with (y::l);trivial.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutationQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1.\n  apply cons_is_permutation with (x:=nil) (y:=nil) (y:=nil) (x:=nil) (y:=nil) (y:=nil) (x:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (x:=nil) (y:=nil) (x:=nil) (y:=nil) (y:=nil) (x:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nil) (x:=nil) (x:=nil) (y:=nil) (y:=nil) (y:=nil) (y:=nilQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation_sym with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\n  apply cons_is_permutation with l; trivial.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1.\n  apply cons_is_permutation with l1;trivial.\n  induction l1.\n  apply cons_is_permutation with (y::l1);trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l1;Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation with (y:=nil).\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_is_permutation with l0; trivial.\n  apply cons_Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivialQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H.\n  apply cons_is_permutation_1 with (y:=nil)(y:=x0)(l:=x0)(l':=x0)(l:=x1)(l:=x1)(l':=x0)(l':=x0)(l':=x1)(l':=x0)(l':=x1)(l':=x1)(l':=x1)(l':=x2)(l':=x0)(l':=x1)(l':=x0)(l':=x0)(l':=x1)(l':=x1)(l':=x2)(l':=x2)(l':=x0)(l':=x0)(l':=x1)(l':=x0)(l':=x1)(l':=x1)(l':=x2)(l':=x0)(l':=x1)(l':=x1)(l':=x2)(l':=x1)(l':=x1)(l':=x2)(l':=x0)(l':=x0)(l':=x1)(l':=x0)(l':=x0)(l':=x1)(l':=x0)(l':=x1)(l':=x2)(l':=x2)(x2:=x0Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation.\n  apply cons_is_permutation with (y::l0);trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_is_permutation with l;trivial.\n  apply cons_is_permutation with (y:=x);trivial.\n  apply cons_isQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\n",
                "context_tokens": 690,
                "proof_start_offset": 7110,
                "proof_end_offset": 7644,
                "proof": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\nProof.\ninduction 1;intros.\ninversion H;inversion H0;apply is_permutation_refl.\ninversion H1.\napply cons_is_permutation with l'';trivial.\napply cons_is_permutation with l';trivial.\nelim (insertion_trans A l' l'' x H0 l3 x0 H2).\nintro l4;intro.\nelim H8;intros.\napply cons_is_permutation with l4;trivial.\neapply IHis_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1; intros.\n  inversion H.\n  inversion H0.\n  exists (y::l0);split;[apply cons_is_permutation_1 | apply tail_insertion];trivial.\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion | apply tail_insertion | apply tail_insertion;trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion;trivial | apply tail_insertion];trivial.\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (yQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros; auto.\n  inversion H0; subst.\n  apply cons_is_permutation with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply cons_is_permutation_1 with l0;trivial.\n  apply cons_is_permutation_trans with l0;trivial.\n  apply consQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1; intros.\n  inversion H0.\n  inversion H0.\n  apply cons_is_permutation_1 with l1;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l1;trivial.\n  apply cons_is_permutation_2 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l1;trivial.\n  apply cons_is_permutation_2 with l1;trivial.\n  apply cons_is_permutation_2 with l3;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l1;trivial.\n  apply cons_is_permutation_1 with l2;trivial.\n  apply cons_is_permutation_1 with l2;trivial.Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  apply cons_is_permutation.\n  apply cons_is_permutation with l0;trivial.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H.\n  destruct l1 as [|a l1]; simpl in *.\n  apply (IHForall_nil A l1 l2); auto.\n  apply (IHForall_nil A l1 l2); auto.\n  apply (IHForall_nil A l1 l3); auto.\n  apply (IHForall_nil A l1 l2); auto.\n  apply (IHForall_nil A l1 l2); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l2); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  apply (IHForall_nil A l1); auto.\n  applyQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H.\n  apply (IHinsert_insertion_in A x l0 H H H0).\n  apply (IHinsert_insertion_in A x l0 H1 H H0 H2).\n  apply (IHinsert_insertion_in A x l0 H1 H1 H2).\n  apply (IHinsert_insertion_in A x l0 H1 H0 H2).\n  apply (IHinsert_insertion_in A x l0 H1 H0).\n  apply (IHinsert_insertion_in A x l0 H1 H2).\n  apply (IHinsert_insertion_in A x l0 H1 H2).\n  apply (IHinsert_insertion_in A x l0 H1).\n  apply (IHinsert_insertion_in A x l0 H1).\n  apply (IHinsert_insertion_in A x l0 H2).\n  apply (IHinsert_insertion_in A x l0 H1 H1).\n  apply (IHinsert_insertion_in A x l0 H1 H1).\n  apply (IHinsert_insertion_in A x l0 H1).\n  apply (IHinsert_insertion_in A x l0Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_2 | apply tail_insertion;trivial].\n  inversion H1.\n  exists (y::l);split;[apply cons_is_permutation_1 | apply tail_insertion;trivial].Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros; simpl; tauto.\n  exists (x::l);split;[apply list_is_permutation_refl | apply tail_insertion_trivial].\n  exists l0;split;[apply tail_insertion_permut | apply tail_insertion_permut].\n  apply cons_is_permutation_1 with (y::l0);assumption.\n  apply cons_is_permutation_1 with (y::l0);assumption.\n  apply tail_insertion_permut.\n  apply cons_is_permutation_2 with (y::l1);assumption.\n  apply tail_insertion_permut.\n  apply cons_is_permutation_1 with (y::l1);assumption.\n  apply tail_insertion_permut.\n  apply cons_is_permutation_1 with (y::l0);assumption.\n  apply tail_insertion_permut.\n  apply tail_insertion_permut.\n  apply cons_is_permutation_1 with (y::l0);assumption.\n  apply tail_insertion_permut.\n  apply cons_is_permutation_1 with (y::l0);assumption.\n  apply tail_insertion_permut.\n  apply tail_insertion_permut.\n  apply tail_insertion_permut.\n  applyQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l0.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l3;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l2;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_is_permutation with l1;trivial.\n  apply cons_Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H.\n  exists (y::l0);split;[apply cons_is_permutation_1 | apply tail_insertion | apply tail_insertion];trivial.\n  apply cons_is_permutation_1 with l0;[apply tail_insertion | apply tail_insertion];trivial.\n  apply cons_is_permutation_1 with l0;[apply tail_insertion | apply tail_insertion;trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion | apply tail_sort].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion | apply tail_insertion_trivial].\n  inversion H0.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivial].\n  inversion H1.\n  exists (y::l0);split;[apply tail_insertion_trivial | apply tail_insertion_trivialQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\n",
                "context_tokens": 722,
                "proof_start_offset": 7681,
                "proof_end_offset": 7890,
                "proof": "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l;intros; inversion H; inversion H; clear H.\n  inversion H0;clear H; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; subst; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; subst; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; subst; clear H0; inversion H0; clear H0;\n    inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear H0; inversion H0; clear HQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  inversion H;apply is_permutation_refl.\n  apply (is_permutation_sym A l l');trivial.\n  apply is_permutation_refl.\n  apply is_permutation_sym.\n  apply H.\n  apply (is_permutation_sym A l l');trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  inversion H;inversion H;clear H0; inversion H.\n  inversion H;clear H; inversion H.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  inversion H;clear H.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l;intros.\n  inversion H;clear H; inversion H0;clear H0; inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0;clear H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0;\n    inversion H0; clear H0;\n    inversion H0; clear H0;\n    inversion H0;\n    inversion H0; clear H0;\n    inversion H0Qed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  inversion H;clear H.\n  exists (y::l);split;[apply H;trivial|apply cons_is_permutation_1 with l1;trivial].\n  inversion H;clear H0.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H3.\n  inversion H2.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H2.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H5.\n  inversionQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  apply (is_permutation_trans A l l);auto.\n  apply (is_permutation_trans A l l');auto.\n  apply (is_permutation_trans A l l);auto.\n  apply (is_permutation_trans A l l');auto.\n  apply (is_permutation_trans A l l);auto.\n  apply (is_permutation_trans A l l);auto.\n  apply (is_permutation_trans A l l);auto.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply nil_is_permutation.\n  apply (is_permutation_sym A l l);trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l);trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l);trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l');trivial.\n  apply (is_permutation_sym A l l);trivial.\n  apply (is_permutation_sym A l l');trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l;intros; constructor.\n  inversion H.\n  exists (y::l);split;[apply is_permutation_refl | apply head_insertion ].\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l;trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.\n  apply cons_is_permutation with l';trivial.\n  inversion H0.Qed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\n  apply is_permutation_sym; trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l';intros.\n  inversion H;clear H; inversion H;clear H; inversion H;clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H; inversion H; clear H;\n  inversion HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 7892,
                "proof_end_offset": 8346,
                "proof": "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\nProof.\ninduction l;simpl;intros.\ninversion H;simpl;tauto.\ninversion H;simpl.\nsplit;intro.\ncase H5;intro.\neapply insertion_in;rewrite H6 in H4;apply H4.\nelim (IHl l'0 H2 x);intros.\neapply insertion_inclusion;eauto.\ncase (in_insertion_inv A x a l'0 l' H4 H5);intro.\nrewrite H6;tauto.\nelim (IHl l'0 H2 x);intros.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_trans with (y::l);trivial.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_trans with (y::l); trivial.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_trans with (y::l); trivial.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_trans with (y::l); trivial.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_trans with (y::l); trivial.\n  apply incl_trans with (y::l); trivial.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_refl.\n  apply incl_Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  apply permutation_nil.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_sym.\n  apply permutation_Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1; intros.\n  inversion H; inversion H; clear H.\n  inversion H; clear H.\n  inversion H; clear H; clear H; subst; inversion H.\n  inversion H; clear H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H; clear H.\n  inversion H; clear H; subst; inversion H; clear H.\n  inversion H; clear H; subst; inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H; clear H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst; inversion H; clear H.\n  inversion H; clear H; subst; inversion H.\n  inversion H; clear H; subst;Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l; intros; constructor.\n  inversion H; inversion H0; clear H0; subst.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;inversion H; inversion H; clear H; subst.\n  inversion H;clear H0; subst.\n  inversion H;clear H0; subst.\n  inversion H;clear H0; subst.\n  inversion H;clear H; clear H0; subst.\n  inversion H;clear H; clear H0; subst.\n  inversion H;clear H0; subst.\n  inversion H;clear H; clear H0; subst.\n  inversion H;clear H; clear H0; subst.\n  inversion H;clear H; clear H0; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversion H;clear H; clear H; subst.\n  inversionQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H;clear H;clear H; inversion_clear H;\nconstructor;\nconstructor;\napply cons_is_permutation_1 with l;trivial.\napply cons_is_permutation_2;assumption.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros; auto.\n  inversion_clear H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;inversion l';intros;inversion H;clear H;clear H;\ninversion H;apply is_permutation_trans with l';trivial.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;inversion 1.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.\n  apply permutation_in with (x::l');auto.Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l; intros.\n  inversion H; inversion H;clear H; subst; trivial.\n  inversion H;clear H0; subst; trivial.\n  inversion H;clear H0; subst; trivial.\n  inversion H;clear H0; subst; trivial.\n  inversion H;clear H0; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n  inversion H;clear H; subst; trivial.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 8348,
                "proof_end_offset": 8572,
                "proof": "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\nProof.\nintros.\neapply permutation_insertion;eauto.\napply is_permutation_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l';simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l';simpl;intros;inversion H;clear H.\n  exists (y::l);split;[apply cons_is_permutation | apply cons_is_permutation_1].\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_ass.Qed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 8574,
                "proof_end_offset": 8857,
                "proof": "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\nProof.\nintros.\napply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros; simpl in *.\n  split;intro.\n  inversion H;simpl;tauto.\n  apply cons_is_permutation with l';trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\n  apply cons_is_permutation_sym;trivial.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  eapply (is_permutation_trans A x a H).\n  apply is_permutation_refl.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  apply H.\n  apply (H0 l).\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros;simpl;intros.\n  inversion H;simpl;tauto.\n  apply IHn;auto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  apply (H _ (S a));auto.\n  apply (H _ (S a));auto.\n  apply (H _ (S a));auto.\n  apply (H _ (S a));auto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros; simpl.\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_app (a::nil)).\n  apply (Forall_appQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  eapply permutation_insert;eauto.\n  apply is_permutation_trans with (a:=a);auto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  inversion H0;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 8859,
                "proof_end_offset": 9031,
                "proof": "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\ninduction 1;simpl;trivial.\nrewrite IHinsertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;intros.\n  inversion H;simpl;tauto.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  apply cons_is_permutation_sym.\n  applyQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;intros.\n  inversion H.\n  apply (H (length l)).\n  apply (H (length l')).\n  apply (H (length l)).\n  apply (Hlength l').\n  apply (Hlength l).\n  apply (Hlength l).\n  apply (Hlength l').\n  apply Hlength.\n  apply (Hlength l).\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l).\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l).\n  apply (Hlength l').\n  apply (Hlength l').\n  apply Hlength.\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply Hlength.\n  apply (Hlength l').\n  apply Hlength.\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength l).\n  apply (Hlength l').\n  apply (Hlength l').\n  apply (Hlength lQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l)%nat).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l)%nat).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l)%nat).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l)%nat)).\n  apply (well_founded_ind (well_founded_ltof (list A)) (fun l:list A => length l <= length l)%nat).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l)%nat).\n  apply (well_founded_ind (list A) (fun l:list A => length l < length l)%nat).\n  apply (well_founded_ind (list A) (fun l:list A => length l <= length l)%nat).\n Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l) (fun l:list A => length l) l').\n  intro.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l) (fun l:list A => length l) l)).\n  intro.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) l)).\n  intro.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) (fun l:list A => length l) l))).\n  intro.\n  apply (well_founded_ind (well_Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l')).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  apply (Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l')) (fun l:list A => length l = length l') l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l')) l').\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l')) l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l')) l).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l)) l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l))).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l)).\n  intros.\n Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l')) l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = length l)).\n  intros.\n  apply (well_founded_ind (Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l' = length l')) (fun l:list A => length l = length l') l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l')) (fun l':list A => length l = length l')) (fun l':list A => length l = length l') l).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A)) (fun l:list A => length l = length l') l').\n  apply (well_founded_ind (well_founded_ltof (list A)) (fun l:list A => length l = length l')) (fun l':list A => length l = length l') (fun l':list A => length l = length l') l').\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l') l).\n  intros.\n  apply (well_founded_ind (listQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 9033,
                "proof_end_offset": 9234,
                "proof": "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\nProof.\ninduction 1;simpl;trivial.\ngeneralize (insertion_length A l' l'' x H0);intro;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;intros;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply (well_founded_ind (list A) (fun l:list A => length l) l' (fun l':list A => length l') l' (fun l':list A => length l) l l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply (well_founded_ind (list A) (fun l:list A => length l) l' (fun l':list A => length l) l' (fun x':list A => length l') l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;auto.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHinsertion;trivial.\n  apply IHQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\nLemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\nQed.\n\n",
                "context_tokens": 705,
                "proof_start_offset": 9236,
                "proof_end_offset": 10306,
                "proof": "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\nProof.\ninduction l;intros;inversion H.\ninversion H0.\napply is_permutation_refl.\nrewrite <- H4;destruct l.\ninversion H8.\ngeneralize (head_insertion A a0 l);intro.\nassert (In x (a0::l)).\neapply insertion_in;apply H8.\ncase (in_insertion_inv A x a0 l (a0::l) H10 H11);intro.\nrewrite H12;rewrite <- H12 in H10;rewrite <- H12 in H8;rewrite <- H12 in IHl.\nassert (is_permutation A l l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nelim (in_insertion A x l H12);intro l2;intro.\ngeneralize (tail_insertion A x a0 l2 l H13);intro.\nassert (is_permutation A (a0::l2) l1).\neapply IHl;eauto.\napply is_permutation_sym;auto.\neapply cons_is_permutation;eauto.\nrewrite H1 in H3.\ninversion H0.\nrewrite <- H9;apply insertion_is_permutation;trivial.\nassert (is_permutation A l0 l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l':list A => length l' = length l')) (length l') (length l').\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l':list A => length l' = length l') (length l')).\n  apply (well_founded_ind (list A) (fun l':list A => length l = length l) (length l)).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l':list A => length l' = length l')) (length l')).\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l':list A => length l' = length l')) (length l')).\n  apply (well_founded_ind (list A) (fun l':list A => length l' = length l')).\n  apply (well_founded_ind (list A) (fun l':list A => length l = length l' = length l')).\n  apply (well_founded_ind (Qed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\n  generalize (insertion_length A l'' x H0);intro;congruence.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\n  generalize (insertion_length A l' l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H0);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H0);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalize (insertion_length A l'' x H1);intro;congruence.\n  generalizeQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' x H0);intro;congruence.\n  generalize (insertion_length A l' x H0);intro.\n  rewrite <- H1;tauto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;clear H;subst.\n  inversion H;subst.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n Qed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;auto.\n  rewrite IHinsertion_cons;trivial.\n  apply IHinsertion_cons;trivial.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;intros;simpl;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHinsertion_length;trivial.\n  rewrite IHQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\n  apply IHinsertion_sym;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\n  apply IHordered;trivial.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l = length l));unfold ltof;auto.\n  generalize (Forall_hd A l' l' x H0);intro;congruence.\n  generalize (Forall_hd A l' l'' x H0);intro.\n  case (list_dec (list A x l' l'));intro.\n  apply (list_dec (list A x l' x l');intro.\n  apply (list_dec A x l l' x H0 H1);intro.\n  apply (list_dec A x l');intro.\n  apply (list_dec A x l' x H1);intro.\n  apply (list_dec A x l' x H1);intro.\n  apply (list_dec A x l l' x H0);intro.\n  apply (list_dec A x l' x H1);intro.\n  apply (list_dec A x l' x' H1);intro.\n  apply (list_dec A x l' x');intro.\n  apply (list_dec A x l' H1);intro.\n  apply (list_decQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;intros.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  apply (H (length l') x H0 l').\n  apply (H (length l') x H0 l'').\n  apply (H (length l') x H0 l'').\n  apply (Hlength l') x H0 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l) x H1 l''.\n  apply (Hlength l'') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l'') x H1 l''.\n  apply (Hlength l) x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H1 l''.\n  apply (Hlength l') x H2.\n  apply (Hlength l'') x H1 l''.\n  apply (Hlength l) x H1 lQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  rewrite IHinsertion_length;trivial.\n  apply (H0 l);trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H1;trivial.\n  apply H1;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "1 l2.\n  generalize l1;clear l1.\n  induction l2;intros.\n  inversion H.\n  inversion H.\n  subst a.\n  subst x0.\n  subst l.\n  subst l2.\n  inversion H0.\n  subst x0.\n  subst l.\n  subst l''.\n  exists l'.\n  tauto.\n  subst x0.\n  subst l'.\n  subst a.\n  subst l1.\n  inversion H0.\n  subst x0.\n  subst l''.\n  subst l0.\n  elim (IHl2 l x H4 l' H3).\n  intro l3;intros.\n  elim H1;clear H1;intros.\n  elim (insertion_trans A l3 l' x H2 l4 y H6).\n  intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 12697,
                "proof_end_offset": 12967,
                "proof": "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\nintros.\napply is_permutation_reverse_impl_is_permutation.\nrewrite rev_involutive.\nrewrite rev_involutive.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply H0.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply H0.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply H0.\n  assumption.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_impl_is_permutation.\n  apply is_permutation_impl_is_permutation.\n  apply is_permutation_or_sym.\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  induction l'.\n  simpl in |- *.\n  apply is_permutation_l.\n  apply is_permutation_imp_left.\n  eapply incl_is_permutation.\n  apply H1.\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l') (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_l with (l:=l) (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_permutation_symmetry.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_l with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_l with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_l with (l:=l'); trivial.\n  apply is_permutation_impl_is_permutation_reverse with (l:=l'); trivial.\n  apply is_Qed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  inversion H.\n  simpl.\n  apply in_or_app_iff.\n  apply is_permutation_reverse_impl_is_permutation_l.\n  apply is_permutation_right.\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_impl_is_permutation_l with l.\n  apply is_permutation_reverse_impl_is_permutation_l with l.\n  apply is_permutation_comm.\n  apply is_permutation_trans with l.\n  apply is_permutation_comm.\n  apply H0.\n  assumption.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply is_permutation_impl_is_permutation_reverse.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_comm.\n  apply is_permutation_impl_is_permutation.\n  apply is_permutation_impl_is_permutation.\n  apply is_permutation_left.\n  apply is_permutation_impl_is_permutation_l.\n  apply is_permutation_left.\n  apply H0.\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_comm.\n  apply is_permutation_rev.\n  apply is_permutation_rev.\n  apply is_permutation_rev.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_impl_is_permutation_reverse.\n  apply is_permutation_imp_is_permutation_reverse.\n  apply is_permutation_impl_is_permutation_reverse.\n  apply is_permutation_right.\n  apply is_permutation_comm.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 13186,
                "proof_end_offset": 13460,
                "proof": "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\nProof.\ninduction 1.\nsimpl.\nintros.\napply head_insertion.\nintros.\nsimpl.\napply tail_insertion.\napply IHinsertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply is_permutation_cons_conv.\n  apply H.\n  assumption.\n  assumption.\n  assumption.\n  apply H0.\n  assumption.\n  assumption.\n  assumption.\n  apply H0.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply is_permutation_trans.\n  apply insert_trivial.\n  apply insert_trivial.\n  apply insert_trivial.\n  apply insert_trivial.\n  apply insert_trivial.\n  apply insert_trivial.\n  apply insert_trivial.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply is_permutation_nil.\n  apply (sorted_cons_nil_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (x::xs)).\n  apply (sorted_cons_right (Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply (sorted_app_inv A (x:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=l) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=x) (l:=xQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply insert_app.\n  apply insertion_append.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction xs;intros.\n  rewrite app_nil_r.\n  rewrite app_nil_r.\n  trivial.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply is_permutation_cons_left.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right_right.\n  apply insert_right.\n  apply insert_right.\n  apply insert_right_right.\n  apply insert_right_right_left.\n  apply insert_right.\n  apply insert_right_right_right.\n  apply insert_right_right.\n  apply insert_right_right_right.\n  apply insert_right_right_right.\n  apply insert_right_left.\n  apply insert_right_right_right_right_right.\n  apply insert_right_right_right.\n  apply insert_right_right_right_right.\n  apply insert_right_right_right_right_right.\n  apply insert_right_right_right_right_right.\n  apply insert_right_right_right_rightQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply (is_permutation_or_is_permutation A (x::xs)).\n  apply is_permutation_right_rev.\n  apply H.\n  apply (H (x::xs)).\n  apply H.\n  apply (H0 (x::xs)).\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply (H0 (x::xs)).\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply (H0 (x::xs)).\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply insert_is_permutation.\n  apply insertion_cons_rev.\n  apply insert_is_permutation_l.\n  apply insertion_cons_rev.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_cons_nil_conv A (x::xs)).\n  apply (is_permutation_cons_app_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_cons_conv A (x::xs)).\n  apply (is_permutation_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\n",
                "context_tokens": 672,
                "proof_start_offset": 13801,
                "proof_end_offset": 14387,
                "proof": "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\nProof.\ninduction 1;intros.\nexists (cons x0 xs).\nsimpl.\nsplit.\nsubst x;subst l;auto.\napply head_insertion.\ndestruct xs.\ndiscriminate H1.\nsimpl in H1.\ninjection H1;clear H1;intros.\nelim (IHinsertion _ _ _ H0 _ H1).\nintro xss;intros.\nelim H3;clear H3;intros.\nexists (cons a xss).\nsimpl.\nsplit.\nsubst y;subst l';auto.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl in H.\n  simpl.\n  destruct (nil_is_permutation_elim _ _ _ H).\n  simpl.\n  apply sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  destruct (Compare_dec.lt_dec x y).\n  intro.\n  rewrite H.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl.\n  apply cons_is_permutation.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  applyQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl.\n  apply insert_nil.\n  apply insert_nil.\n  apply IHis_permutation_ass.\n  apply insert_nil.\n  apply IHis_permutation_ass.\n  apply IHis_permutation_ass.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  simpl.\n  apply insert_insertion.\n  intros.\n  apply insert_insertion.\n  apply IHis_permutation_r.\n  apply H1.\n  apply insert_insertion.\n  apply H0.\n  apply insert_insertion.\n  apply IHis_permutation_r.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply insert_insertion_permutation_r.\n  apply H1.\n  apply H2.\n  apply insert_insertionQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl in *.\n  split.\n  simpl.\n  apply insert_nil.\n  apply insert_nil.\n  apply H.\n  apply insert_nil.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros.\n  simpl.\n  auto.\n  simpl.\n  intro.\n  rewrite <- H1 in H0.\n  inversion_clear H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply HQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl.\n  apply (app_nil_or_is_permutation_l _ _ _ _ H H).\n  simpl.\n  repeat intro.\n  apply H0.\n  apply (app_nil_or_is_permutation_r _ _ _ _ _ H).\n  apply H1.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1; intros.\n  simpl.\n  apply sorted_sorted_nil.\n  simpl.\n  apply insert_nil.\n  apply H1.\n  apply insert_nil.\n  apply H2.\n  apply H0.\n  apply insert_cons_right.\n  apply H2.\n  apply insert_cons_right.\n  apply H2.\n  apply H0.\n  apply insert_cons_right.\n  apply H1.\n  apply insert_cons_right.\n  apply H2.\n  apply insert_cons_right.\n  apply H2.\n  apply H3.\n  apply insert_cons_right.\n  apply H2.\n  apply insert_cons_right.\n  apply H3.\n  apply H2.\n  apply insert_cons_right.\n  apply H3.\n  apply H3.\n  apply insert_cons_right.\n  apply H2.\n  apply insert_cons_right.\n  apply H3.\n  apply H3.\n  apply insert_cons_right.\n  apply H3.\n  apply H2.\n  apply insert_cons_right.\n  apply H3.\n  apply H3.\n  apply insert_cons_right.\n  apply H3.\n  apply H1.Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  apply H.\n  apply (H (fun x => In xss) (H (f xss) (f xss)) (f xss)).\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\nLemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\n",
                "context_tokens": 677,
                "proof_start_offset": 14389,
                "proof_end_offset": 15125,
                "proof": "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\nProof.\ninduction 1.\nintros.\ndestruct xs1;try (discriminate H).\nexists (nil (A:=A)).\nsplit.\napply nil_is_permutation.\nreflexivity.\nintros.\ndestruct xs1;try (discriminate H1).\nsimpl in H1.\ninjection H1;clear H1;intros.\nsubst x.\nelim (IHis_permutation _ _ _ H1).\nintro xs2.\nintros.\nelim H2;clear H2;intros.\nsubst l'.\nelim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\nintros.\nelim H3;clear H3;intros.\nexists x.\nsplit;auto.\neapply cons_is_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_l.\n  apply is_permutation_cons_nil.\n  apply (is_permutation_l (is_permutation_cons_nil A (map f xs1)) (is_permutation_r (is_permutation_cons_nil A (map f xs1))) in H.\n  apply is_permutation_l.\n  apply (is_permutation_cons_r (is_permutation_cons_nil A (map f xs1)) (is_permutation_l (is_permutation_cons_nil A (map f xs1))) in H.\n  apply H.\n  apply (is_permutation_cons_r (is_permutation_cons_nil A (map f xs1))) in H.\n  apply H.\n  apply (is_permutation_l (is_permutation_cons_nil A (map f xs1)) in H.\n  apply H.\n  apply (is_permutation_l (is_permutation_cons_nil A (map f xs1))) in H.\n  apply H.\n  apply (is_permutation_cons_l (is_permutation_cons_nil A (map f xs1))) in H.\n  apply H.\n  apply (Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  auto.\n  rewrite app_nil_r.\n  simpl.\n  apply (is_permutation_cons_app_inv_r _ _ _ _ H2).\n  apply (is_permutation_l1_app_inv_r _ _ _ _ _ H2).\n  apply (is_permutation_cons_inv_r _ _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ _ H2).\n  apply (is_permutation_cons_inv_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _ _ _ H2).\n  apply (is_permutation_cons_r _ _Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  auto.\n  simpl.\n  apply insert_insertion.\n  apply IHis_permutation_cons_nil.\n  apply insert_insertion.\n  auto.\n  simpl.\n  apply insert_insertion.\n  auto.\n  intro xss.\n  simpl.\n  apply insert_insertion.\n  auto.\n  intro xss.\n  simpl.\n  apply insert_insertion.\n  auto.\n  intro xss.\n  simpl.\n  apply insert_insertion.\n  auto.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_map.\n  apply is_permutation_map.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_l.\n  apply is_permutation_map.\n  apply incl_cons_hd.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_1 with (l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l)(l:=l) (l':=l)(l:=l)(l:=l)(l:=l)(l':=l)).\n  apply is_permutation_1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H0.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H0.\n  apply H3.\n  apply H3.\n Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  apply (is_permutation_l_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nil_nilQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_r.\n  apply is_permutation_l.\n  apply is_permutation_cons_nil_reverse with (y:=x)(y:=x)(y:=x)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y:=y)(y:=y)(y:=y)(y:=y:=y)(y:=y)(Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_l with (x:=xs1) (l:=l0) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x2) (l:=x3) (l:=x3) (l:=x3) (l:=x2) (l:=x3) (l:=x3) (l:=x2) (l:=x3) (l:=x3) (l:=x3) (l:=x4) (l:=x3) (l:=x4) (l:=x4) (l:=x5) (l:=x2) (l:=x2) (l:=x4) (l:=x2) (l:=x2) (l:=x2) (l:=x3) (l:=x2) (l:=x2) (l:=x3) (l:=x3) (l:=x3) (l:=x4) (l:=x2) (l:=x3Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_map.\n  apply is_permutation_map.\n  apply is_permutation_map.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H2.\n  apply H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ")(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 15959,
                "proof_end_offset": 16380,
                "proof": "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\nProof.\ninduction 1.\nexists (nil (A:=A)).\nexists l.\nsplit;try reflexivity.\nelim IHinsertion.\nintro l1.\nintro.\nelim H0.\nintro l2;intros.\nelim H1;clear H1;intros.\nexists (cons y l1).\nexists l2.\nsubst l;subst l'.\nsplit;try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1; intros.\n  simpl in H.\n  destruct l; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destructQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl.\n  intros.\n  apply (app_comm (a :: l0)).\n  apply app_ass.\n  apply cons_is_permutation.\n  apply H.\n  auto.\n  apply cons_is_permutation.\n  apply H.\n  auto.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1;intros.\n  simpl.\n  rewrite app_nil_l.\n  simpl.\n  apply app_nil_l.\n  simpl.\n  apply app_nil_l.\n  simpl.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_r.\n  apply app_nil_Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  intros.\n  destruct l'; simpl in H.\n  destruct l'; simpl in H.\n  inversion H; clear H; subst.\n  apply cons_is_permutation_nil.\n  apply H2.\n  apply (H2 l l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l l' l' l' l' l' l' l' l' l' l l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l'' l'' l' l' l' l'' l'' l l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l''.\n  simpl in H1.\n  injection H1; clear H1; intros.\n  rewrite <- H3; apply H1.\n  apply (H2 l l' l l' l'' l'' l'' l'' l'' l'' l'' l l'' l'' l'' lQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl.\n  simpl.\n  split; auto.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\n  apply app_nil_end.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1; intros.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_cons.\n  apply cons_nil.\n  apply cons_Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1; intros.\n  apply cons_is_permutation.\n  apply cons_is_permutation_l.\n  apply H.\n  apply cons_is_permutation.\n  apply H.\n  apply app_ass.\n  apply cons_is_permutation_l.\n  apply H.\n  apply cons_is_permutation.\n  apply H.\n  apply cons_is_permutation_r.\n  apply H.\n  apply app_ass.\n  apply cons_is_permutation_r.\n  apply H.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply H.\n  apply H.\n  apply app_ass.\n  apply H.\n  apply H.\n  apply H.\n  apply in_app.\n  apply H.\n  apply H.\n  apply in_app.\n  apply H.\n  apply in_app.\n  apply H.\n  apply in_app.\n  apply H.\n  applyQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  auto.\n  intros.\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct l'; try (discriminate H).\n  destruct lQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  simpl in *.\n  injection H; clear H; intros.\n  subst x.\n  case_eq (x::l0); intro.\n  apply (IHis_permutation_cons _ _ _ H0).\n  intro l'.\n  destruct l'.\n  simpl.\n  injection H; clear H; intros.\n  subst x.\n  case_eq (x::l0); intro.\n  apply (IHis_permutation_cons _ _ _ H0).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H1).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H0).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H1).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H1).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H1).\n  intro l'.\n  apply (IHis_permutation_cons _ _ _ H1).\n  intro l'.\n  apply (Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl.\n  split.\n  subst.\n  simpl.\n  apply app_nil_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_permutation.\n  apply cons_is_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\nLemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (nil (A:=A)).\n  exists l.\n  split;try reflexivity.\n  elim IHinsertion.\n  intro l1.\n  intro.\n  elim H0.\n  intro l2;intros.\n  elim H1;clear H1;intros.\n  exists (cons y l1).\n  exists l2.\n  subst l;subst l'.\n  split;try reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 16382,
                "proof_end_offset": 16713,
                "proof": "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\nProof.\ninduction 1.\napply perm_nil.\nelim (insertion_append_decompose _ _ _ _ H0).\nintro l1;intros.\nelim H1.\nintro l2;intros.\nelim H2;clear H2;intros.\nsubst l';subst l''.\napply Permutation_cons_app.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  simpl; auto.\n  induction 1.\n  simpl in *.\n  induction l;auto.\n  simpl in *.\n  induction l';auto.\n  simpl.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.\n  induction l';auto.\n  simpl in *.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  intros.\n  destruct l.\n  simpl in *.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.\n  rewrite <- app_nil_or in H.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  simpl.\n  apply Permutation_nil.\n  auto.\n  intros.\n  inversion H1.\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminate H).\n  destruct l';try (discriminateQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  simpl in |- *.\n  simpl in |- *.\n  intros.\n  rewrite <- (Permutation_app_comm l l' l' l'); auto.\n  intro.\n  elim H0; clear H0; intros.\n  rewrite <- (Permutation_app_comm l l' l'); auto.\n  intro.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  auto.\n  intros.\n  elim (Permutation_In_dec _ _ _ H x).\n  intro l0.\n  elim (Permutation_In_dec _ _ _ H0); intro l1.\n  elim (Permutation_In_dec _ _ _ H0).\n  intro l2.\n  apply H.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.\n  apply Permutation_app.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  simpl.\n  intros.\n  elim (list_exists_nil (A:=A)).\n  simpl.\n  rewrite app_nil_r.\n  apply Permutation_nil.\n  intros.\n  elim (list_exists_nil (A:=A)).\n  simpl.\n  rewrite app_nil_r.\n  apply Permutation_nil.\n  intros.\n  elim H0; clear H0; intros.\n  exists (cons x0 l1).\n  exists (cons y0 l2).\n  split; try reflexivity.\n  destruct (list_exists_nil (A:=A)).\n  exists l1.\n  split; try reflexivity.\n  elim H0; clear H0; intros.\n  exists (cons y0 l2).\n  exists (cons y0 l2).\n  split; try reflexivity.\n  destruct (list_exists_nil (A:=A)).\n  exists l2.\n  split; try reflexivity.\n  destruct (list_exists_nil (A:=A)).\n  exists l1.\n  split; try reflexivity.\n  destruct (list_exists_nil (A:=A)).\n  exists l1.\n  split; try reflexivity.\n  destruct (list_exists_nil (A:=A)).\n Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  intros.\n  apply (list_In_cons l l'); try reflexivity.\n  simpl.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_cons l' l'); try reflexivity.\n  apply (list_In_Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply perm_trans with (l' := l).\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l).\n  apply Permutation_trans with (l' := l').\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l).\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l).\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l').\n  apply Permutation_sym.\n  apply perm_trans with (l' := l').\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l').\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l').\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (l' := l').\n  apply Permutation_sym.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  simpl.\n  auto.\n  elim (list_is_permutation_or _ _ l l').\n  intro l; destruct l'; simpl; auto.\n  apply H.\n  apply Permutation_app.\n  assumption.\n  assumption.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  intros.\n  apply permutation_impl_Permutation.\n  apply permutation_impl_Permutation.\n  apply permutation_impl_Permutation.\n  apply permutation_impl_Permutation.\n  apply Permutation_app.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans with (a :: l').\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintro.\nintroQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H; elim H; intros n0 H1; elim H1; intros n1 H2; elim H2; intros n2 H3;\n rewrite H3; apply mult_le_compat_r; assumption.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n rewrite (mult_assoc n m).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_comm m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc m n).\n rewrite (mult_assoc mQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_comm.\n apply mult_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_assoc.\n apply mult_assoc.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_assoc_reverse.\n apply mult_comm.\n apply mult_assoc_reverse.Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n destruct (mult_lemma1 n m) as [H|H].\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n rewrite (mult_comm n m).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm m n).\n rewrite (mult_comm mQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros n m; case (mult_lemma1 n m H); intros H0;\n    case (mult_lemma2 n m H0); intros H1;\n      [ left; apply (mult_lemma1 n m H1); assumption\n      | right; apply (mult_lemma2 n m H1); assumption\n      | right; apply (mult_lemma2 n m H1); assumption ].\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply (mult_lemma1 n m H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n H).\n rewrite (mult_comm m n HQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction n.\n  simpl in |- *.\n  intros.\n  apply (mult_lemma1 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n mQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  induction n;simpl;auto with arith.\n  elim H;trivial.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  applyQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  apply plus_le_compat.\n  rewrite <- mult_comm.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n  apply mult_le_compat.\n  rewrite <- mult_assoc.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma1.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  rewrite H0.\n  simpl in |- *.\n  apply mult_le_compat_l;auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;auto with arith.\n  simpl in H.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\n  simpl in H.\n  apply plus_le_reg_l with m;auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in H.\n  apply plus_le_reg_l with m;auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in |- *.\n  apply plus_le_reg_l with m;auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in H.\n  apply plus_le_reg_l with m;auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in |- *.\n  apply plus_le_reg_l with m; auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in |- *.\n  apply plus_le_reg_l with m;auto with arith.\n  rewrite H0.\n  auto with arith.\n  simpl in |- *.\n  apply plus_le_reg_l with m; auto with arith.\n  rewrite H0.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  elim H0; trivial.\n  rewrite <- H0.\n  trivial.\n  intro.\n  rewrite H1.\n  trivial.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  induction n.\n  tauto.\n  simpl in H.\n  unfold lt in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n  unfold lt in H.\n  apply le_S_n.\n  simpl in H.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma2; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n  apply mult_lemma3; assumption.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_lemma3.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_lemma3.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_comm.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_comm.\n  assumption.\n  simpl in |- *.\n  rewrite mult_assoc.\n  apply mult_comm.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_assoc.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\n",
                "context_tokens": 502,
                "proof_start_offset": 1721,
                "proof_end_offset": 2052,
                "proof": "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nProof.\nintros n m.\ncase n.\nleft;trivial.\nintros.\nright.\ndestruct m.\nrewrite mult_comm in H.\ndiscriminate.\ndestruct m;trivial.\nassert ((S n0)<(S n0)*(S (S m))).\napply mult_lemma3;intros;auto with arith.\nrewrite <- H in H0.\nelim (lt_irrefl (S n0) H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H0.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assertQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl.\n  tauto.\n  simpl in H.\n  left.\n  assert (n = S m);try omega.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl in H.\n  left.\n  assert (n = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl in H.\n  left.\n  assert (S m = S m);try omega.\n  rewrite H.\n  auto with arith.\n  rewrite H.\n  auto with arith.\n  assert (n = S m);try omega.\n  assert (S m = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl in H.\n  left.\n  assert (S m = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl in H.\n  left.\n  assert (S m = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl in H.\n  left.\n  assert (S m = S m);try omega.\n  rewrite plus_comm.\n  induction m.\n  simpl.\n  assert (SQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl.\n  assert (n = S m);try omega.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  apply mult_plus_compat.\n  omega.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  elim H;clear H;intros.\n  assert (O < n);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m*n);try omega.\n  rewrite <- H.\n  auto with arith.\n  assert (n = m*n);try omega.\n  rewrite <- H.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H1.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H1.\n  auto with arith.\n  assert (n = m);try omega.\n Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  elim (mult_lemma1 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma2 n m); intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma3 n m);intros.\n  elim (mult_lemma2 n m);intros.\n  elim (mult_lemma3 n m);intros.\n  elim (mult_lemma3 n m); intros.\n  elim (mult_lemma2 n m); intros.\n Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  elim H0;trivial.\n  elim H0;trivial.\n  simpl in |- *; tauto.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  simpl in |- *; tauto.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  assert (n = m);try omega.\n  rewrite H.\n  auto with arith.\n  left.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite H.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite <- H0.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite H.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  right.\n  assert (n = m);try omega.\n  rewrite <- H.\n  auto with arith.\n  assert (n = m);try omega.\n  rewrite <- H.\n Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  elim H0;trivial.\n  simpl;auto.\n  elim H0;trivial.\n  simpl;auto.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elimQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  right.\n  split;auto with arith.\n  elim H;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\n",
                "context_tokens": 628,
                "proof_start_offset": 2054,
                "proof_end_offset": 2503,
                "proof": "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\nProof.\ninduction n;simpl;intros;try discriminate.\ninduction m.\nrewrite mult_comm in H.\nsimpl in H;discriminate.\nassert ((S n)<=((S n)*(S m))).\napply mult_lemma1;discriminate.\nassert (((S n)*(S m))=((S m)+n*(S m))).\nreflexivity.\nrewrite H1 in H0.\nrewrite H in H0.\nassert ((S n)=1).\nomega.\nsplit;trivial.\ninversion H2.\nrewrite H4 in H.\nsimpl in H.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  reflexivity.\n  elim H0.\n  simpl.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_n.\n  assumption.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply le_S_Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma2.\n  unfold not in |- *; intro.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  intros.\n  apply (le_Sn_S m); assumption.\n  apply (le_Sn_S m); assumption.\n  elim H0;trivial.\n  elim H0;trivial.\n  intros.\n  apply (le_Sn_S m); assumption.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_lemma3;auto with arith.\n  apply mult_inverse.\n  apply mult_inverseQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  elim H0;trivial.\n  simpl in |- *; tauto.\n  elim H0;trivial.\n  intros.\n  elim H0;trivial.\n  intros.\n  left.\n  rewrite mult_comm in H0.\n  discriminate.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  induction m.\n  reflexivity.\n  simpl.\n  assert (n = S (S (S (S (S (S (S (S (S n)))))).\n  apply mult_lemma3;auto with arith.\n  rewrite H0.\n  rewrite plus_comm.\n  apply plus_le_compat_l.\n  apply le_n_O.\n  assumption.\n  assumption.\n  simpl.\n  assert (n = S (S (S (S (S (S (S n)))))).\n  apply mult_le_compat_l.\n  apply le_n_O.\n  assumption.\n  simpl.\n  assert (n = S (S (S (S (S (S n))))).\n  apply plus_le_compat_l.\n  apply le_n_O.\n  assumption.\n  rewrite <- H0.\n  rewrite plus_comm.\n  apply le_n_O.\n  assumption.\n  simpl.\n  assert (n = S (S (S (S (S (S (S (S (S n))))).\n  apply mult_le_compat_l.\n  apply le_n_O.\n  assumption.\n  simpl in |-Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  trivial.\n  simpl.\n  trivial.\n  intros.\n  assert (n = S n0); try omega.\n  rewrite <- H0.\n  auto with arith.\n  rewrite <- H0.\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl.\n  assert (n = S n0);try omega.\n  rewrite mult_comm.\n  induction m.\n  apply plus_le_compat_r.\n  assumption.\n  apply plus_le_compat_l.\n  assumption.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.\n  rewrite mult_comm in H0.\n  discriminate.\n  simpl in |- *.Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  trivial.\n  simpl in |- *.\n  assert (n = m);try omega.\n  rewrite mult_comm.\n  rewrite H.\n  rewrite mult_assoc.\n  induction n0.\n  simpl in |- *.\n  assert (n = S m);try omega.\n  rewrite mult_comm.\n  rewrite H.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2505,
                "proof_end_offset": 2662,
                "proof": "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\ninduction y;intros;rewrite plus_comm;simpl.\nauto with arith.\nrewrite plus_comm.\napply IHy.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  apply mult_le_reg_l with y;trivial.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_r with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_r with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with y;trivial.\n  rewrite <- H.\n  apply plus_le_compat_l with yQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite plus_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_comm in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assoc in H.\n  rewrite mult_assocQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite plus_comm.\n  induction y;simpl;intros.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply mult_le_compat_l.\n  assumption.\n  rewrite H.\n  apply plus_le_compat_l.\n  assumption.\n  rewrite H.\n  apply mult_le_compat_l.\n  assumption.\n  rewrite H.\n  apply plus_le_compat_l.\n  assumption.\n  rewrite H.\n  apply plus_le_compat_l.\n  assumption.\n  rewrite H.\n  apply le_n_O.\n  assumption.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm.\n  induction y.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite mult_assoc.\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (plus_comm (S n)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (plus_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (plus_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite mult_assocQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm.\n  induction y;simpl;auto with arith.\n  apply mult_minus_lemma1.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_minus_distr_l.\n  apply mult_minus_lemma3.\n  apply mult_minus_distr_l.\n  apply mult_minus_lemma3.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite plus_comm in H.\n  rewrite mult_comm in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_comm x) in H.\n  rewrite (mult_comm y) in H.\n  rewrite (mult_commQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compatQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm.\n  apply plus_minus_distr_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compatQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).\n  generalize (mult_minus_distr y x).Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  case (le_lt_eq_dec x y); [left|left];trivial.\n  rewrite plus_comm in H.\n  simpl in H.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2664,
                "proof_end_offset": 2918,
                "proof": "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\nintros.\ninduction a.\nsimpl.\ntrivial.\nreplace (S a*n) with (n+a*n);try (auto with arith).\nrewrite plus_comm.\nrewrite plus_minus_lemma1.\nsimpl.\nrewrite <- minus_n_O;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  apply mult_le_compat_l.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply leQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  apply mult_lemma1;assumption.\n  simpl in |- *.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHnQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\n  simpl.\n  apply IHn.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite plus_comm.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHnQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_r.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_r.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_r.\n  apply le_plus_compat_l.\n  apply le_plus_compat_r.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plus_compat_l.\n  apply le_plusQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  apply IHx.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction n.\n  simpl.\n  rewrite plus_comm.\n  apply IHn.\n  simpl.\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma1.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma3.\n  apply mult_minus_lemma3.\n  apply mult_Qed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  apply mult_le_compat_l;trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  apply le_trans with (S n);trivial.\n Qed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite plus_comm.\n  rewrite (mult_comm a n).\n  apply IHn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 2920,
                "proof_end_offset": 3619,
                "proof": "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\nProof.\ninduction a.\nintros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\nintros b n H.\nrewrite mult_comm;simpl;rewrite mult_comm;intro.\nassert (n*a = n*b-n).\napply plus_minus;auto.\nassert (a*n=(b-1)*n).\nrewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\nassert (a=(b-1)).\napply (IHa (b-1) n);trivial.\nrewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\ndestruct b;simpl in H3.\nrewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\nrewrite <- minus_n_O in H3;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply IHx.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  apply lt_le_trans with (S n);try apply le_n_Sm.\n  apply le_n_n.\n  apply le_n_Sn.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_n.\n  apply le_n_Sn.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite multQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  auto.\n  simpl.\n  assert (n = S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))).\n  rewrite H0.\n  rewrite (plus_comm (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))).\n  rewrite H0.\n  rewrite (plus_comm (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))).\n  rewrite H0.\n  rewrite (plus_comm (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))).\n  rewrite H0.\n  rewrite H0.\n  rewrite (plus_comm (Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\n  apply mult_lemma3;trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  assert (n = O)->\n  trivial.\n  rewrite plus_comm.\n  simpl.\n  rewrite <- plus_assoc.\n  apply le_n_Sm.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  simpl.\n  rewrite plus_comm.\n  simpl.\n  apply IHx.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_le_compat_l.\n  apply IHn.\n  apply le_trans with (n*a);try assumption.\n  rewrite plus_comm.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);try assumption.\n  apply le_trans with (n*a);Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  simpl.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  apply mult_minus_lemma1.\n  assumption.\n  assumption.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  rewrite mult_comm.\n  apply plus_le_compat_l.\n  rewrite mult_comm.\n  apply le_trans with (S (S n));try omega.\n  rewrite mult_comm.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S n));try omega.\n  apply le_trans with (S (S (S n)));Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x;simpl.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply lt_O_Sn.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma1;assumption.\n  rewrite <- (mult_comm y z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z tQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl.\n  rewrite plus_comm.\n  rewrite (mult_comm y z t).\n  rewrite plus_comm;simpl;rewrite (mult_comm z t).\n  rewrite <- (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (mult_comm z t).\n  rewrite (Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl.\n  rewrite <- plus_assoc.\n  rewrite plus_comm.\n  rewrite <- plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite (plus_comm (b-1)).\n  rewrite <- plus_assoc.\n  rewrite <- (plus_comm (b-1)).\n  rewrite <- plus_assoc.\n  rewrite <- (plus_comm (b-1)).\n  rewrite <- plus_assoc.\n  rewrite (plus_comm (b-1)).\n  rewrite <- mult_assoc.\n  rewrite (plus_comm (b-1)).\n  rewrite <- plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- (plusQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma1;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma2;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma2;assumption.\n  apply mult_lemma2;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma1;assumption.\n  apply mult_lemma2;assumption.\n  apply mult_lemma2;assumption.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;simpl;intros;rewrite plus_comm;simpl;rewrite plus_comm;simpl;rewrite plus_comm;rewrite plus_comm;simpl;rewrite plus_comm;rewrite <- plus_comm;simpl;rewrite mult_comm;rewrite plus_comm;rewrite <- plus_comm;simpl;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite mult_comm;simpl;rewrite plus_comm;\nsimpl;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;simpl;\nrewrite (mult_comm (b-1));trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x;simpl;intros;try discriminate.\n  rewrite mult_comm;simpl;rewrite mult_comm;rewrite mult_comm;simpl;rewrite mult_comm;rewrite (mult_comm z);trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl;auto.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  rewrite mult_comm;simpl;rewrite mult_comm;rewrite (mult_comm x y);trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x;simpl.\n  rewrite mult_comm;simpl;rewrite <- mult_plus_distr_l;rewrite (mult_comm a n);trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm b n);trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm b n);trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm b n);trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm b n);trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl;auto.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm z (b-1)).\n  rewrite <- mult_assoc.\n  rewrite (mult_comm z (b-1)).\n  rewrite <- mult_assoc.\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (mult_comm z (b-1)).\n  rewrite (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  unfold S.\n  elim a.\n  intros.\n  rewrite mult_comm.\n  apply S_eq;auto with arith.\n  rewrite (mult_comm b n);trivial.\n  rewrite (mult_comm n (a-S b));trivial.\n  rewrite (mult_comm a (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite <- H3 in H0;rewrite (mult_comm b (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite (mult_comm a (a-S b));trivial.\n  rewrite (mult_comm b (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite (mult_comm b (a-S b));trivial.\n  rewrite (mult_comm b (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite (mult_comm a (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite (mult_comm a (a-S b));trivial.\n  destruct b;simpl in H3.\n  rewrite (mult_comm b (a-S b));trivial.\n  destruct bQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply plus_le_compat_l.\n  apply lt_O_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_plus_distr_l;trivial.\n  assert (x=z).\n  rewrite <- (le_plus_minus z y);rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);rewrite <- (le_plus_minus z y);trivial.\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus z y);trivial.\n  assert (y=z).Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply plusQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ";rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply minus_mult_lemma2;auto with arith.\n  rewrite <- minus_minus;rewrite minus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_minus_lemma2 x y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+z).\n  apply (le_minus_lemma2 x y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+y-x+z).\n  apply (lt_minus_lemma2 x y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+y+z).\n  apply (le_minus_minus y y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+y+z).\n  apply (le_minus_lemma2 x y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+y).\n  apply (lt_minus_minus y z);rewrite mult_comm;simpl;rewrite minus_minus;trivial.\n  assert (y=z+x+y).\n  apply (le_minus_minus y z);rewrite mult_comm;simpl;rewrite minusQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (lt_minus_lemma2 x y z);rewrite (le_minus_lemma2 x y z);rewrite (le_minus_lemma2 x y z);rewrite (le_minus_lemma2 y z);rewrite (le_minus_lemma2 y z);trivial.\n  assert (y=z+(x-z)+z).\n  rewrite <- (le_minus_minus y z);rewrite (le_minus_minus_minus y z);trivial.\n  assert (y=z).\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  apply le_minus_le.\n  applyQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;simpl;rewrite minus_minus_reverse;trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (le_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply mult_minus_lemma2;auto with arith.\n  apply plus_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_r;auto with arith.\n  apply le_minus_le_compat_l;auto with arith.\n  apply plus_le_compat_l;auto with arith.\n  apply plus_le_compat_l;auto with arith.\n  apply plus_le_compat_l;auto with arith.\n  apply le_minus_le_compat_l;auto with arith.\n  apply le_minus_le_compat_l;auto with arith.\n  apply plus_le_compat_l;auto with arith.\n  apply le_minus_le_compat_r;auto with arith.\n  apply le_minus_le_compat_r;auto with arith.\n  apply plus_le_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite plus_minus;rewrite <- minus_minus_minus;trivial.\n  rewrite plus_minus;rewrite <- minus_minus;trivial.\n  rewrite <- minus_minus;trivial.\n  apply le_trans with (S (S (S (S n))).\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply minus_mult_lemma2;auto with arith.\n  apply lt_minus_lemma1;auto with arith.\n  apply lt_minus_lemma1;auto with arith.\n  apply lt_minus_lemma2;auto with arith.\n  apply lt_minus_lemma2;auto with arith.\n  apply le_minus_lemma2;auto with arith.\n  apply lt_minus_lemma1;auto with arith.\n  apply lt_minus_lemma2;auto with arith.\n  apply le_minus_lemma2;auto with arith.\n  apply le_minus_lemma2;auto with arith.\n  apply le_minus_minus_lemma1;auto with arith.\n  apply le_minus_lemma2;auto with arith.\n  apply le_minus_minus_lemma2;auto with arith.\n  apply le_minus_minus_lemma2;auto with arith.\n  apply le_minus_minus_lemma2;auto with arith.\n  apply le_minus_mult_l;auto with arith.\n  apply le_minus_minus_lemma2;auto with arith.\n  apply le_minus_minus_lemma2;auto with arith.\n  apply le_minus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (lt_plus_minus x y);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).\n  rewrite (lt_plus_minus y z);try (auto with arith).Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus x y);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus y z);try (auto with arith).\n  rewrite <- (lt_minus y z);try (auto with arith).\n  rewrite <- (le_minus y z);try (auto with arith).\n  rewrite <- (lt_plus_minus y z);try (auto with arith).\n  rewrite <- (lt_minus yQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus x y z);try (auto with arith).\n  rewrite minus_minus_minus;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite (le_minus z y);trivial.\n  rewrite <- (le_plus_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivialQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_minus;trivial.\n  rewrite <- (le_plus_minus z y);trivial.\n  apply plus_minus_lemma2;auto.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_lemma2;auto.\n  apply plus_minus_lemma2;auto.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_reverse;auto.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_lemma2;auto.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_lemma2;auto.\n  rewrite <- (le_minus z y);trivial.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_lemma2;auto.\n  rewrite <- (le_minus z y);trivial.\n  apply plus_minus_reverse;auto.\n  rewrite <- (le_minus z y);trivial.Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite minus_minus_minus;rewrite minus_minus;rewrite <- minus_minus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y);try (auto with arith).\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).\n  rewrite (lt_minus_minus y z);try (auto with arith).Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus y z);trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (lt_plus_minus z y);try (auto with arith).\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite <- (le_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite <- (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite <- (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (lt_minus_minus z y);trivial.\n  rewrite (ltQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus y z);trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_minus;rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_eq_dec a b);intro.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma1 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.\n  rewrite (minus_minus_lemma2 b a);trivial.Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite (le_minus_minus b a);trivial.\n  rewrite (le_minus_minus b a);trivial.\n  rewrite (le_minus_minus b a);trivial.\n  apply le_minus_minus.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (lt_plus_minus a b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_plus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec b b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_lt_minus_minus b b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus b b);trivial.\n  case (le_eq_dec a b);intro.\n  rewrite (lt_minus_minus_minus b b);trivial.\n  caseQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite <- (le_plus_minus b a);trivial.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);trivial.\n  rewrite (le_minus b a);Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_lemma2 b a);trivial.\n  rewrite <- (le_minus_minus_minus_lemma2 b a);trivial.\n  rewrite <-Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  apply minus_le_elim.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\n",
                "context_tokens": 375,
                "proof_start_offset": 1374,
                "proof_end_offset": 1542,
                "proof": "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nunfold is_gcd.\nintros.\nelim H;elim H0;intros.\napply divides_antisym;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b.\nunfold is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, is_gcd,\n  is_gcd, is_gcd, isQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d a b.\ndestruct (mod_unique _ _ H) as (a,b).\napply gcd_unique with (d' := d').\nexact (gcd_unique _ _ _ H).\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n  intros d d' a b.\n  case (le_or_lt d d d).\n  intro H.\n  case (le_or_eq (gcd d' a) (gcd d' a)).\n  intro H.\n  rewrite H.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H1.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m := a).\n  rewrite H1.\n  apply gcd_unique with (m := a).\n  rewrite H0.\n  apply gcd_unique with (m :=Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintro d.\nrewrite <- (div_unique _ _ (div_unique _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ (div_unique _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ _ (div_unique _ _ _ _ (div_unique _Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n intros d d' a b.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (c:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (c:=c'); auto with arith.\n apply gcd_unique with (c:=c'); auto with arith.\n apply gcd_unique with (c:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (b:=c'); auto with arith.\n apply gcd_unique with (c':=c'); auto with arith.\n apply gcd_uniqueQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n intros d' a b.\n destruct (le_or_lt d d' a).\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := d').\n apply divide_refl.\n (* a < b *)\n apply divide_trans with (d' := dQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d' a b; case (le_lt_dec a b); intros H.\n left; assumption.\n right; assumption.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\nrewrite gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_unique.\napply gcd_Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n intros.\n apply gcd_unique with (m := m) (b := (p + a)).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).\n apply gcd_unique with (m := b).Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n intros.\n apply gcd_unique with (d' := (b, (b, (c, d)))).\n apply gcd_unique with (d' := (c, (b, (c, d)))).\n apply gcd_unique with (d' := (c, (c, (c, d)))).\n apply gcd_unique with (d' := (c, (b, (c, (c, d)))).\n apply gcd_unique with (d' := (c, (c, (d, (d, (d, d)))).\n apply gcd_unique with (d' := (c, (c, (d, (d, (d, d)))).\n apply gcd_unique with (d' := (c, (c, (d, (d, (d, d)))).\n apply gcd_unique with (d' := (c, (d, (d, (d, (d, d)))).\n apply gcd_unique with (d' := (c, (d, (d, (d, d)))).\n apply gcd_unique with (d' := (c, (d, (d, (d, (d, d)))).\n apply gcd_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\n",
                "context_tokens": 457,
                "proof_start_offset": 1571,
                "proof_end_offset": 1763,
                "proof": "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H;intros.\nsplit.\nred;red in H0;tauto.\nintros.\napply H1.\nred;red in H2;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply divides_antisym;auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0; intros.\n  apply or_sym; auto.\n  elim H0Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_symQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply H.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H;intros.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;auto.\n  apply gcd_unique;Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0;intros.\n  apply H1; auto.\n  apply H1; auto.\n  apply H0; auto.\n  apply H1; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H0; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H;Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply H0.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n  assumption.\n  apply (gcd_sym b d').\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;elim H; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0; intros.\n  apply gcd_unique;auto.\n  elim H0;Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intro; elim H0;intros.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n  apply (H0 n);auto.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0;intros.\n  apply gcd_unique;auto.\n  apply divide_refl.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\n",
                "context_tokens": 545,
                "proof_start_offset": 1783,
                "proof_end_offset": 1947,
                "proof": "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nunfold is_gcd.\nintro.\nsplit.\nred;split;[apply zero_max_div | apply divides_refl].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H0.\n  red;intro;intro;apply H;apply H0.\n  red;intro;apply H0.\n  red;intro;apply H;apply H0.\n  red;intro;apply H;apply H0.\n  red;intro;apply H0.\n  red;intro; apply H0.\n  red;intro;apply H0.\n  red;intro;apply H0.\n  red;intro; apply H1.\n  red;intro; apply H1.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red; intro; apply H1.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red; intro; apply H0.\n  red; intro; apply H1.\n  red;intro; apply H0.\n  red; intro; apply H1.\n  red; intro; apply H0.Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H1.\n  apply gcd_sym;apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_unique with (P := fun (q : nat), (q : nat), q = r /\\ (q * r)).\n  apply gcd_left_strong; auto.\n  elim H; intros.\n  apply H1.\n  apply gcd_unique with (P := fun (q : nat), (q * r) => q = q).\n  apply gcd_left_strong; auto.\n  elim H; intros.\n  apply H0.\n  apply gcd_sym; auto.\n  elim H; intros.\n  apply gcd_unique with (P := fun (q : nat), (q * r) => q = q).\n  apply gcd_left_strong; auto.\n  elim H; intros.\n  apply H0.\n  apply gcd_unique with (P := fun (q : nat), q = r /\\ (q * r) = q).\n  apply gcd_left_strong; auto.\n  elim H; intros.\n  apply H0.\n  apply gcd_unique with (P := fun (q : nat), q = r /\\ (q * r) = r).\n  apply gcd_leftQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_sym; auto.\n  apply gcd_refl.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; autoQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intro.\n  apply H0.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intro.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n  apply gcd_unique; auto.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n  apply gcd_sym;auto.\n  elim H0;intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\n",
                "context_tokens": 615,
                "proof_start_offset": 1967,
                "proof_end_offset": 2130,
                "proof": "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\nunfold is_gcd.\nintros.\nsplit.\nred;split;[apply divides_refl | apply one_min_div].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H;intros.\n  apply gcd_zero with 1; trivial.\n  red;intro;apply gcd_zero with 1; trivial.\n  red;intro;apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcd_zero with 1; trivial.\n  red;intro; apply gcdQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;intro; apply H.\n  apply H0.\n  red;intro; apply H0.\n  apply H0.\n  red;intro; apply H.\n  apply H0.\n  red;intro; apply H0.\n  apply H0.\n  red;intro; apply H0.\n  apply H0.\n  red;intro; apply H0.\n  apply H0.\n  red;intro; apply H1.\n  apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  apply H0.\n  red;intro; apply H0.\n  red;intro; apply H0.\n  red; intro; apply H0.\n  apply H0.\n  red;intro; apply H0.\n  red; intro; apply H0.\n  red; intro; apply H1.\n  apply H0.\n  red; intro; apply H0.\n  apply H0.\n  red;intro; apply H0.\n  red; intro; apply H1.\n  apply H0.\n  red; intro; apply H0.\n  red; intro; apply H0.\n  red; intro; applyQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym; assumption.\n  apply H.\n  apply gcd_one.\n  apply H.\n  apply H.\n  apply gcd_one.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n  apply gcd_left.\n  apply H.\n Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;intro.\n  unfold is_gcd.\n  split.\n  red;intro.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_sym; auto.\n  intros.\n  apply H1.\n  apply gcd_refl.\n  apply gcd_sym; auto.\n  apply gcd_refl.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_refl.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  applyQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  case (le_lt_or_eq a (gcd a (gcd a (gcd a (gcd a b))).\n  intros.\n  elim H; intros.\n  apply (gcd_sym a H0).\n  apply gcd_sym; apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym;Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H;intros.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intro.\n  apply H.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_sym;auto.\n  apply mod_symQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\n",
                "context_tokens": 697,
                "proof_start_offset": 2174,
                "proof_end_offset": 2759,
                "proof": "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\nintros.\nunfold is_gcd.\nsplit;intro.\nelim H0;intros.\nsplit.\nred in H1;red.\nelim H1;intros.\nsplit;try tauto.\napply divides_minus;trivial.\nunfold is_cd;intros.\napply H2;red;elim H3;intros.\nsplit;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nelim H0;unfold is_cd;intros.\nsplit.\nsplit;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nintros.\nelim H3;intros;apply H2.\nsplit;try (apply divides_minus);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim H; intros.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\n  apply mod_unique;auto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  case (divide_dec a b); trivial.\n  intros.\n  elim H; intros.\n  apply H; trivial.\n  apply H0; trivial.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H1.\n  red; intro.\n  apply H0.\n  apply H0.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H0.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  apply H0.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H0.\n  red; intro.\n  apply H0.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply mod_unique with d; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\n  apply gcd_divide; trivial.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  apply gcd_unique; assumption.\n  apply gcd_unique; assumption.\n  unfold is_gcd.\n  intros.\n  apply H.\n  red;split; trivial.\n  elim H0; intros.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply HQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  applyQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro; apply H.\n  apply H0.\n  red;intro; apply H0.\n  apply H.\n  red;intro; apply H1.\n  apply H0.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H2.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  red;intro; apply H2.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  red; intro; apply H2.\n  apply H1.\n  red;intro; apply H1.\n  apply H1.\n  red;intro; apply H1.\n  red;intro; apply H1.\n Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  intros.\n  apply H1.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;auto.\n  red;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\n",
                "context_tokens": 739,
                "proof_start_offset": 2781,
                "proof_end_offset": 2923,
                "proof": "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nintros.\nunfold is_cd.\nsplit;try tauto.\nsplit;apply divides_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  apply H1.\n  red;intro.\n  elim H0;intros.\n  apply H1.\n  red;intro.\n  elim H0;intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  apply H1.\n  red;intro.\n  elim H0; intros.\n  apply H2.\n  red;intro.\n  elim H0; intros.\n  apply H2.\n  red;intro.\n  elim H0; intros.\n  apply H3.\n  red;intro.\n  elim H1; intros.\n  apply H3.\n  red;intro.\n  elim H1; intros.\n  apply H1.\n  red;intro.\n  elim H1; intros.\n  apply H3.\n  red;intro.\n  elim H1; intros.\n  apply H4.\n  red;intro.\n  elim H1; intros.\n  apply H1.\n  red;intro.\n  elim H1; intros.\n  apply H4.\n  red;introQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  apply H1.\n  red;intro.\n  elim H0;intros.\n  apply H1.\n  red;intro.\n  elim H1; intros.\n  apply H1.\n  red;intro.\n  elim H2; intros.\n  apply H3.\n  red;intro.\n  elim H2; intros.\n  apply H4.\n  red;intro.\n  elim H4; intros.\n  apply H1.\n  red;intro.\n  elim H2; intros.\n  apply H4.\n  red;intro.\n  elim H2; intros.\n  apply H5.\n  red;intro.\n  elim H1; intros.\n  apply H5.\n  red;intro.\n  elim H4; intros.\n  apply H5.\n  red;intro.\n  elim H4; intros.\n  apply H5.\n  red;intro.\n  elim H1; intros.\n  apply H5.\n  red;intro.\n  elim H1; intros.\n  apply H4.\n  red;intro.\n  elim H4; intros.\n  apply H4.Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  elim H0; intros.\n  apply H0.\n  split; try tauto.\n  intro.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  split; try tauto.\n  intro.\n  elim H0; intros.\n  apply H1.\n  split; try tauto.\n  intro.\n  elim H0; intros.\n  apply H2.\n  split; try tauto.\n  apply or_sym; tauto.\n  apply or_sym; tauto.\n  intro.\n  elim H0; intros.\n  apply H1.\n  split; try tauto.\n  intro.\n  elim H0; intros.\n  apply H2.\n  split; try tauto.\n  intro.\n  elim H0; intros.\n  apply H1.\n  split; try tauto.\n  intro.\n  elim H1; intros.\n  apply H2.\n  split; try tauto.\n  intro.\n  elim H1; intros.\n  apply H3.\n  split; try tauto.\n  intro.\n  elim H1; intros.\n  apply H3.\n  split; try tauto.\n  intro.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  apply H1.\n  apply (H1 n).\n  red;intro.\n  elim H0; intros.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  apply H1.\n  apply (H1 n).\n  red; intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  split.\n  red;intro.\n  elim H0Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nunfold is_gcd.\n  intros.\n  split;intro.\n  elim H0;intros.\n  elim H0;intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  elim H1; intros.\n  split; try tauto.\n  split.\n  red;intro.\n  elim H1; intros.\n  split; try tauto.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H2; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H3Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  split;intro.\n  elim H0;intros.\n  split;auto.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H1;intros.\n  split;auto.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0; intros.\n  apply H1.\n  red;intro; elim H0;intros.\n  apply H1.\n  red;intro; elim H0; intros.\n  apply H1.\n  red;intro; elimQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  split.\n  apply mod_refl.\n  apply mod_refl.\n  apply mod_refl.\n  apply mod_refl.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_refl.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;trivial.\n  apply mod_sym;Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;intro.\n  elim H0; intros.\n  apply H1.\n  split;intro.\n  split;intro.\n  split;intro.\n  split;intro.\n  elim H0; intros.\n  split;intro.\n  elim H1; intros.\n  apply H2.\n  split.\n  elim H0; intros.\n  split;intro.\n  elim H0; intros.\n  apply H4.\n  split;intro.\n  elim H1; intros.\n  apply H5.\n  split;intro.\n  split;intro.\n  elim H0; intros.\n  split;intro.\n  elim H0; intros.\n  split;intro.\n  split;intro.\n  elim H1; intros.\n  split;intro.\n  elim H0; intros.\n  split;intro.\n  elim H0; intros.\n  split;intro.\n  elim H1; intros.\n  split;intro.\n  elim H1; intros.\n  split;intro.\n  elim H2; intros.\n  split;intro.\n  elim H1; intros.\n  elim H2; intros.\n  apply H2.\n  split;intro.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  apply H;red;intro; apply H;red;intro; apply H;red;intro; apply H;red;intro; apply H;red;intro; apply H;red;intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red;intro; apply H;red;intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red;intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red; tauto.\n  apply H;red;intro; apply H;red;intro; apply H;red; tauto.\n  apply H;red;Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  apply H1;red;intro.\n  elim H0; intros.\n  apply H2;red;intro.\n  elim H0; intros.\n  apply H1;red;intro.\n  elim H0; intros.\n  apply H1;red;intro.\n  elim H0; intros.\n  apply H1;red;intro.\n  elim H0; intros.\n  apply H1;red;intro.\n  elim H0; intros.\n  apply H2;red;intro.\n  elim H0; intros.\n  apply H2;red;intro.\n  elim H0; intros.\n  apply H1;red;intro.\n  apply H0;red;intro.\n  elim H0; intros.\n  apply H2;red;intro.\n  elim H0; intros.\n  apply H3;red;intro.\n  elim H0; intros.\n  apply H4;red;intro.\n  elim H0; intros.\n  apply H2;red;intro.\n  elim H0; intros.\n  apply H4;red;intro.\n  elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 2965,
                "proof_end_offset": 3080,
                "proof": "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H1; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim HQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;try tauto.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H0;intros.\n  split;try tauto.\n  elim H1;intros.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  elim H0; intros.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  apply H2.\n  elim H0; intros.\n  apply H1.\n  apply H2.\n  apply H1.\n  elim H0; intros.\n  apply H2.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H2.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  apply H2.\n  apply H0.\n  elim H0; intros.\n  apply H2.\n  apply H2.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  apply H.\n  elim H0; intros.\n  apply H0.\n  elim H1; intros.\n  apply H2.\n  elim H; intros.\n  apply H4.\n  apply H3.\n  elim H3; intros.\n  apply H0.\n  elim H0; intros.\n  apply H4.\n  apply H4.\n  apply H0.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply (prime_abs_or_intro H).\n  apply H;red;intro.\n  apply (prime_abs_or_intro H).\n  apply H0;red in |- *;intro.\n  apply (prime_abs_or_intro H).\n  apply H0;red;intro.\n  apply (prime_abs_or_intro H).\n  apply H0;red;intro.\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_or_intro H).\n  apply (prime_abs_intro H).\n  apply (prime_abs_intro H).\n  apply (primeQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold not in |- *.\n  intros.\n  case (prime_or_dec a b); intros.\n  exists (S a); intuition.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  unfold is_gcd.\n  split;intro.\n  apply H0;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H0;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n  apply H1;red;intro.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_sym;trivial.\n  elim H0; intros.\n  split; trivial.\n  apply H1.\n  apply gcd_sym;trivial.\n  apply H0.\n  apply gcd_sym;trivial.\n  apply H0.\n  apply gcd_sym;trivial.\n  apply H0.\n  apply gcd_sym;trivial.\n  apply H0.\n  apply gcd_sym;trivial.\n  apply H.\n  apply gcd_sym;trivial.\n  apply H.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  intros.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  intros.\n  apply gcd_sym; assumption || apply modulo_divide; assumption || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  unfold is_gcd.\n  split;auto || apply modulo_divide; assumption.\n  apply modulo_divide; assumption.\n  unfold is_Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\n",
                "context_tokens": 731,
                "proof_start_offset": 3102,
                "proof_end_offset": 3217,
                "proof": "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;intros;tauto.\n  unfold not in |- *;intro.\n  elim H;intros;apply H0.\n  split;try tauto.\n  split;auto.\n  split;try tauto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n  split;auto.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;intro;tauto.\n  elim H;intro;clear H0;intros.\n  split;try tauto.\n  apply gcd_refl.\n  split;try tauto.\n  split;try tauto.\n  apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym; apply gcd_sym; apply gcd_sym;apply gcd_sym;\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H;intros.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n  apply H;red;intro.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  elim H0; intros.\n  elim H0; intros.\n  apply H0.\n  assumption.\n  assumption.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;intros; tauto.\n  apply gcd_divide;eauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split;intro; elim H;intros.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\n  apply gcd_symQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split;intro.\n  elim H0;intros.\n  split;intros.\n  split;intro.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split;intro.\n  elim H;intros.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H2.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H2.\n  elim H1;intros.\n  apply H0.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  apply H2.\n  elim H2;intros.\n  apply H1.\n  elim H3; intros.\n  apply H3.\n  elim H3; intros.\n  apply H3.\n  elim H3; intros.\n  apply H2.\n  elim H3; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H1; intros.\n  apply H3.\n  elim H0; intros.\n  apply H1.\n  elim H4; intros.\n  apply H4.\n  elim H1; intros.\n  apply H5.\n  elim H4; intros.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;intros;tauto.\n  elim H;intros.\n  split;intro.\n  red in H0;apply H;red;auto.\n  apply H0.\n  red;intro.\n  elim H0; intros.\n  split;intro.\n  red in H1;apply H0;red;auto.\n  red;intro.\n  elim H1;intro.\n  apply H2.\n  red;intro.\n  apply H3.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H1.\n  red;intro.\n  apply H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3393,
                "proof_end_offset": 3478,
                "proof": "Lemma Rwf : well_founded R.\nProof.\nunfold R.\napply (well_founded_ltof (nat*nat) f).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Rwf : well_founded R.\nProof.\n  intro.\n  apply (H x).\n  apply H.\n  apply H.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold f; intros.\n  elim H; intros.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma Rwf : well_founded R.\n  intro.\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n  apply (well_founded_induction_ind (fun x => x=f)).\n Qed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  unfold R; intros.\n  apply H0.\n  split.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  unfold f, f, f; simpl; intuition.\n  split;intros.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold f; intros.\n  apply (H x); trivial.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply HQed.",
                    "Lemma Rwf : well_founded R.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold f; intros.\n  case (f x); intros.\n  destruct (f x); intros.\n  exists (f x0); trivial.\n  exists (f (f x0) (f x0)).\n  exists (f x0).\n  exists (f x0).\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma Rwf : well_founded R.\n  intro.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  intro.\n  elim H; intros.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ".\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\n",
                "context_tokens": 724,
                "proof_start_offset": 3573,
                "proof_end_offset": 4309,
                "proof": "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nexists (snd x);apply gcd_zero.\nelim (H (S n,snd x-S n)).\nsimpl;intro d;intro.\nexists d.\nelim (gcd_minus d (S n) (snd x));try (auto with arith).\nsimpl.\nomega.\nrewrite e;exists (snd x);apply gcd_refl.\ndestruct (snd x).\nexists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n)).\nsimpl;intro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_minus d (S n) (fst x));try (auto with arith).\nsimpl.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (Build_gcd (fst x) (snd x)).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) fQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd; intros.\n  elim H; intros.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros x y.\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd.\n  intros.\n  case (is_gcd (gcd x y)); intro.\n  exists (min (gcd x y)); intros.\n  split.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H0Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  destruct (le_or_lt x y) as [H|H].\n  left.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  left.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  apply H.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  right.\n  rewrite H.\n  assumption.\n  assumption.\n  assumption.\n  left.\n  rewrite HQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros x.\n  destruct (eq_dec x x) as [Hle|Hnle].\n  left; assumption.\n  left; assumption.\n  right; assumption.\n  left; assumption.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold f in |- *.\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (natQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd.\n  intros.\n  split.\n  red;intro.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd;intros;apply (H (snd x)).\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4346,
                "proof_end_offset": 4496,
                "proof": "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod (a,b)).\nsimpl;intro d;intro;exists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b.\n  case (le_lt_dec (fst a) (snd b)).\n  intros a b.\n  case (le_lt_lt_dec (fst a) (snd b)).\n  intros a.\n  case b.\n  destruct (le_lt_eq_dec (fst a) (snd b))).\n  (* 0 < 0 < 0 *)\n  apply gcd_unique.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_exists.\n  apply gcd_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b.\n  case (le_lt_dec (fst a) (snd b));intro.\n  case s;intro.\n  case s;intro.\n  case (le_lt_dec (fst a) (snd b));intro.\n  case s;intro.\n  case s;intro.\n  case s;intro.\n  case (le_lt_eq_dec (fst a) (fst b));intro.\n  case s;intro.\n  case s;intro.\n  case (le_lt_eq_dec (fst a) (fst a));intro.\n  case s;intro.\n  case s;intro.\n  case s;intro.\n  case (le_lt_eq_dec (fst a) (fst b));intro.\n  case s;intro.\n  case s; intro.\n  case s; intro.\n  case s;intro.\n  case s;intro.\n  case s; intro.\n  case (le_eq_lt_dec (fst a) (fst b));intro.\n  case s; intro.\n  case s; intro.\n  case (le_eq_lt_dec (fst a) (fst b));intro.\n  case s; intro.\n Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists.\n  apply gcd_exists_prod.\n  apply gcd_exists.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_prod_l.\n  apply gcd_exists_prod_l.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_l.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_l.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_l.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_prod_r.\n  apply gcd_exists_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold is_gcd; intros; apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (snd x) (snd x) (snd x)))}}.\n  apply (induction_ind2 (nat*nat) f (fun x:nat => {Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfold is_gcd in |- *.\n  apply gcd_exists_prod; auto.\n  unfoldQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x)))))).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x)))))).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)))}}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)))).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)));intro.\n  exists d.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x))))))).\n  apply (induction_ltof2 (Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\n  apply gcd_exists_prod; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4634,
                "proof_end_offset": 4785,
                "proof": "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\nintros.\nunfold gcd.\ngeneralize (gcd_exists a b).\nintro;elim s;intro d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;trivial.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;trivial.\n  exists d;trivial.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod a b).\n  simpl;intro d;exists d;trivial.\n  exists d.\n  apply gcd_is_gcd.\n  assumption.\n  destruct (gcd_exists_prod a b).\n  exists d.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  simpl;intro d; exists d.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  assumption.\n  exists d.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n  assumption.\n  apply gcd_is_gcd.\n  assumption.\n Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod a b);intro H; elim H; clear H.\n  apply gcd_is_gcd;trivial.\n  elim (gcd_exists_prod a b);intro H; elim H; clear H.\n  apply gcd_is_gcd;trivial.\n  apply gcd_is_gcd;trivial.\n  apply gcd_is_gcd;trivial.\n  apply gcd_is_gcd;trivial.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  destruct (gcd_exists_prod a b).\n  destruct (gcd_exists_prod a b).\n  destruct (gcd_exists_prod a b).\n  exists (a, b).\n  exists (a, b).\n  exists (a, b).\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists a.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists a.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists b.\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists a.\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcd.\n  exists (a, b).\n  split.\n  apply gcd_is_gcdQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro; elim d;intro.\n  apply gcd_is_gcd; trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro.\n  exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro.Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d; exists d;trivial.\n  exists (snd a);apply gcd_is_gcd.\n  simpl in |- *;intro d;Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists b;trivial.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elim (gcd_exists_prod a b);intros.\n  exists (gcd a b);trivial.\n  elimQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro;exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d;intro; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a b)).\n  simpl;intro d; exists d;trivial.\n  elim (gcd_exists_prod (a,b) (gcd a bQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod a b);intro.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite H0.\n  apply gcd_is_gcd; trivial.\n  rewrite H0.\n  apply gcd_is_gcd; trivial.\n  rewrite H0.\n  apply gcd_is_gcd; trivial.\n  rewrite H0.\n  apply gcd_is_gcd; trivial.\n  rewrite H0.\n  apply gcd_is_gcd; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 4948,
                "proof_end_offset": 5077,
                "proof": "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto with *.\n  apply rel_prime_antisym; auto.\n  apply rel_prime_antisym; auto.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  elim H; intro H.\n  case (eq_lt_dec (gcd a b)).\n  trivial.\n  apply rel_prime_sym; trivial.\n  apply rel_prime_sym; trivial.\n  apply rel_prime_sym; trivial.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_exists a b).\n  intro; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  intros; elim s;intro d;trivial.\n  introsQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  apply (rel_prime_sym a b).\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  applyQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime b).\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  exists (rel_prime a b).\n  apply rel_prime_sym.\n  destruct (rel_prime_dec a b) as [H|H].\n  exists (rel_prime a b).\n  apply rel_prime_symQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_exists a b).\n  intro; elim H.\n  generalize (gcd_exists a b).\n  intro; elim H0.\n  intros.\n  exists (a + b);apply gcd_refl.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;auto.\n  intros.\n  exists (a + b);apply gcd_is_gcd;Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_exists a b).\n  intro; elim H; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim (gcd_exists a b);intro.\n  elim H; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewrite (gcd_exists a b);trivial.\n  elim H0; intro.\n  apply H.\n  rewriteQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_exists_prod a b).\n  intro; elim (gcd_exists_prod a b).\n  intro; elim (gcd_exists_prod a b).\n  intros a b H; elim (gcd_exists_prod a b).\n  intros a b H0; elim (gcd_exists_prod a b).\n  intro; elim H0; elim H0; clear H0; intro H1.\n  exists a; apply gcd_sym; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists a; apply gcd_is_gcd; assumption.\n  exists aQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_exists a b).\n  intro; elim s;intro d;trivial.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\n",
                "context_tokens": 738,
                "proof_start_offset": 5126,
                "proof_end_offset": 5240,
                "proof": "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;apply gcd_one.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros a.\n  elim (gcd_exists_prime a); trivial.\n  intros.\n  elim H; trivial.\n  intros.\n  elim H0; trivial.\n  intros.\n  elim H0; trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime2 a 1).\n  apply (rel_prime_2 a 1).\n  apply (rel_prime_1 a 1).\n  apply (rel_prime2 a 1).\n  applyQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  generalize (rel_prime_sym a b).\n  intro; elim H; intro; elim H; intro; subst.\n  elim (gcd_exists_prod a 1);trivial.\n  elim (gcd_exists_prod a 1);trivial.\n  elim (gcd_exists_prod a 1);trivial.\n  elim H0; intro.\n  apply gcd_exists_prod_0.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elim H0; intro.\n  exists 1;trivial.\n  elimQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  apply rel_prime_sym;trivial.\n  apply rel_prime_sym;trivial.\n  apply rel_prime_sym;trivial.\n  apply rel_prime_sym;trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros; apply rel_prime_0; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime_1; assumption.\n  apply rel_prime2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime2; assumption.\n  apply rel_prime_2; assumption.\n  apply rel_prime2; assumption.\n  apply rel_prime2; assumption.\n  apply rel_prime2; assumption.Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.\n  apply gcd_unique;trivial.\n  intros.Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros a; elim (rel_prime_1 a);intro H0; elim H0; intros H1;\n      [ apply H1; exists 1; auto with arith | auto with arith ].\n  intros; elim H0; intros H1; elim H1; intros H2;\n      [ apply H1; exists 1; auto with arith | auto with arith ].\n  intros; elim H0; intros H2; elim H1; intros H3;\n      [ apply H2; exists 1; auto with arith | auto with arith ].\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  apply gcd_left.\n  applyQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros; apply gcd_is_gcd;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\n",
                "context_tokens": 696,
                "proof_start_offset": 5309,
                "proof_end_offset": 6031,
                "proof": "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (quo_is_quo a d (gcd_div_l d a b H));intro.\ngeneralize (quo_is_quo b d (gcd_div_r d a b H));intro.\nunfold is_gcd;split;unfold is_cd.\nsplit;apply one_min_div.\nintros.\nelim H3;intros.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H6 in H1.\nrewrite H7 in H2.\nassert (divides d (d*d')).\nred in H;elim H;intros.\napply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\nelim H8;intros.\nexists x.\napply mult_lemma6 with d;trivial.\nrewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  generalize (gcd_exists_prod d (gcd_exists_prod d (gcd_exists_prod d (gcd_exists_prod d (gcd_exists_prod d (gcd_exists_prod d (gcd_prod d (gcd_exists_prod d (gcd_prod d (fst_prod d (fst_prod d (snd_prod d)))) d (gcd_exists_prod d (snd_prod d (snd_prod d (fst_prod d)))))).\n  intros.\n  generalize (gcd_exists_prod d (gcd_exists_prod d (gcd_exists_prod d (gcd_prod d (fst_prod d (fst_prod d (fst_prod d (fst_prod d (fst_prod d)))) d (gcd_exists_prod d (snd_prod d (snd_prod d (fst_prod d (snd_prod d)))))).\n  intros.\n  exists (snd (fst (snd (fst (fst (snd (snd (fst (fst (snd (snd (snd (fst (fst (snd (snd (snd (snd (fst (snd (snd (snd (fst (fst (snd (snd (snd (fst (snd (snd (Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  apply gcd_unique.\n  apply (rel_prime_sym (r:=r)).\n  unfold rel_prime.\n  destruct (gcd_exists_prod (r:=r)).\n  apply gcd_unique.\n  apply H.\n  apply gcd_divide_l.\n  apply H.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  apply gcd_inv_rel_prime; assumption.\n  apply H.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  elim (gcd_exists a b);intro.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym;apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_r; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a b);intro.\n  apply gcd_sym; apply gcd_inv_l; assumption.\n  elim (gcd_exists a bQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  generalize (gcd_exists a b);intro.\n  case (gcd_exists a b);intro.\n  exists (fst a);apply gcd_sym.\n  trivial.\n  exists (snd a); apply gcd_sym;apply gcd_sym.\n  trivial.\n  exists (snd a); apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym.\n  apply gcd_divide_l.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros; apply gcd_rel_prime.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply mod_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply divQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros.\n  generalize (gcd_exists a b);intro.\n  generalize (gcd_exists a b);intro.\n  generalize (gcd_exists a b);intro.\n  generalize (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (gcd_exists a b);intro.\n  rewrite (Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  intros; apply gcd_sym; trivial.\n  rewrite H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 6065,
                "proof_end_offset": 6268,
                "proof": "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nunfold is_gcd.\nintros.\nelim H0;intros.\nintro.\nelim H1;intros.\nelim H5;intros.\nrewrite H3 in H6;simpl in H6;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (mod_exists_prod d (gcd_non_zero d p) (gcd_non_zero d p)).\n  intro; elim (gcd_non_zero d p).\n  intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intro q';intro.\n  rewrite H7 in H4.\n  apply gcd_is_gcd; assumption.\n  intros.\n  elim H4;intro; elim H4;intro q';intro.\n  rewrite H7 in H5.\n  rewrite H7 in H5.\n  rewrite H7 in H5.\n  apply gcd_is_gcd; assumption.\n  intros.\n  elim H5;intro q';intro.\n  rewrite H7 in H5.\n  rewrite H8 in H5.\n  apply gcd_is_gcd; assumption.\n  intros.\n  elim H5;intro q';intro.\n  rewrite H7 in H5.\n  rewrite H7 in H5.\n  apply gcd_is_gcd; assumption.\n  intros.\n  elim H5;intro q';intro.\n  rewrite H8 in H5.\n  rewrite H7 in H5.\n  rewrite <- H6 in H5Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  elim (gcd_exists_prod (r, (r, (r, (r, r)) q))).\n  simpl;intro d;intro d;trivial.\n  intro; rewrite H1 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  rewrite H2 in H2.Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_exists_prod (q,q) (q, q)).\n  intro; elim q;intro.\n  elim H;intro;intro.\n  elim H5;intro.\n  exists x.\n  apply mult_le_compat.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.\n  apply le_trans with (d*p).\n  rewrite H9; auto with arith.Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  unfold rel_prime.\n  intros.\n  generalize (gcd_exists_prod d p).\n  intro;elim H;intro q;intro.\n  exists x;apply gcd_sym;trivial.\n  elim H1;intro.\n  exists x;apply gcd_sym;trivial.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_exists d p).\n  intro; elim H.\n  intros.\n  apply (gcd_is_gcd (gcd_is_gcd (gcd_is_gcd d p) q));intro.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd d p) q);intro.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd d p) q);intro.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd d p) q);intro.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd d p) q);intro.\n  elim H0;intros.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd d p) q);intro.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_is_gcd a p) q);intro.\n  elim H0;intros.\n  apply (gcd_is_gcd (gcd_isQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (H d);intro.\n  generalize (H d);intro.\n  generalize (H d);intro.\n  generalize (H d);intro.\n  generalize (H0 d);intro.\n  generalize (H d);intro.\n  generalize (H0 d);intro.\n  generalize (H0 d);intro.\n  generalize (H0 d);intro.\n  generalize (H0 d);intro.\n  generalize (H1 d);intro.\n  generalize (H0 d);intro.\n  generalize (H0 d);intro.\n  generalize (H1 d);intro.\n  generalize (H0 d);intro.\n  generalize (H1 d);intro.\n  generalize (H1 d);intro.\n  generalize (H0 d);intro.\n  generalize (H1 d);intro.\n  generalize (H1 d);intro.\n  generalize (H2 d);intro.\n  generalize (H0 d);intro.\n  generalize (H1 d);intro.\n  generalize (H2 d);intro.\n  generalize (H1 d);intro.\n  generalize (H1 d);intro.\n  generalize (H1 d);intro.\n  generalize (H2 d);intro.\n  generalize (H2 dQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  generalize (div_exists_prod d p q).\n  intro; elim H;intros.\n  apply gcd_is_gcd;auto.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (Zis_gcd_is_gcd d p q);intro.\n  apply (gcd_is_gcd p q);trivial.\n  rewrite <- H0;auto with arith.\n  rewrite <- H1;auto with arith.\n  apply H2;red;split;[exists q';rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  elim H8;intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  elim H9;intros.\n  exists x.\n  apply mult_lemma;trivial.\n  apply H9;red;split;[exists q';rewrite H9;ring | exists q';rewrite H9;ring].\n  elim H9;intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  elim H10;intros.\n  exists x.\n  apply mult_lemma;trivial.\n  intros.\n  elim H10;intros.\n  exists x.\n  applyQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_exists d p).\n  intro; elim H;intro d;trivial.\n  elim H;intro;intro q;trivial.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_is_gcd (r,p)).\n  intro; elim H;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H5; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H6; intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\n",
                "context_tokens": 700,
                "proof_start_offset": 6472,
                "proof_end_offset": 6772,
                "proof": "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\nelim (gcd_minus ((u+v)*x-v*y) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros; apply is_gcd_1;trivial.\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_r x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_l x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_r x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_l x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_r x y H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_r x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_l x y H0 H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_r x y H1).\n  apply le_trans with (2*x);trivial.\n  rewrite (div_0_rQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (mod_spec_l d a b H);intro.\n  generalize (mod_spec_l d a b H);intro.\n  unfold is_gcd.\n  apply divide_factor_l;trivial.\n  apply divide_factor_r;trivial.\n  rewrite mult_comm;trivial.\n  apply divide_factor_r;trivial.\n  rewrite mult_comm;trivial.\n  apply divide_factor_r;trivial.\n  rewrite mult_comm;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  rewrite mult_comm;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factor_r;trivial.\n  apply divide_factorQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (mod_eq_strong d (gcd a b) H);intro.\n  elim H;intros.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  rewrite H3.\n  rewrite H5.\n  rewrite H4.\n  rewrite H4.\n  rewrite H3.\n  rewrite H5.\n  rewrite H5.\n  rewrite H6.\n  rewrite H6.\n  rewrite H5.\n  rewrite H5.\n  rewrite H5.\n  rewrite H5.\n  rewrite H5.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6.\n  rewrite H6Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros x y u v.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-v) x y u v);intro.\n  generalize (mod_unique (u*x-Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (div_eq_compat_l d a b H);intro.\n  generalize (div_eq_compat_l d a b H);intro.\n  unfold is_gcd.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  apply H2;red;split;[exists q;rewrite H1;ring | exists q;rewrite H2;ring].\n  intros.\n  elim H2;intros.\n  apply H3;red;split;[exists q;rewrite H2;ring | exists q;rewrite H2;ring].\n  intros.\n  apply H2;red;split;[exists q;rewrite H3;ring | exists q;rewrite H3;ring].\n  intros.\n  apply H3;red;split;[exists q;rewrite H3;ring | exists q;rewrite H2;ring].\n  intros.\n  apply H3;red;split;[exists q;rewrite H3;ring | exists q;ring].\n  intros.\n  apply H4;red;split;[exists q;rewrite H3;ring | exists q;rewrite H2;ring].\n  intros.\n  apply H4;red;split;[existsQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_isQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  apply gcd_sym;trivial.\n  apply gcd_divide;trivial.\n  apply gcd_divide;trivial.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (mod_eq a b H0);intro.\n  generalize (mod_eq a b H0);intro.\n  generalize (mod_eq a b H0);intro.\n  generalize (mod_eq a b H0);intro.\n  generalize (mod_eq a b H1);intro.\n  generalize (mod_eq a b H1);intro.\n  generalize (mod_eq b H1);intro.\n  generalize (mod_eq a b H1);intro.\n  generalize (mod_eq b H1);intro.\n  generalize (mod_eq a b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_eq b H2);intro.\n  generalize (mod_Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (mod_unique a b H);intro.\n  generalize (mod_unique a b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique a b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique a b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;split;unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;auto.\n  generalize (mod_unique b H);intro.\n  unfold is_gcd;auto.\n  generalize (mod_uniqueQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  apply gcd_sym;trivial.\n  rewrite <- H1;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n",
                "context_tokens": 700,
                "proof_start_offset": 6774,
                "proof_end_offset": 7070,
                "proof": "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\nProof.\nintros.\nelim (gcd_minus (v*y-(u+v)*x) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*x)/y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_l;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;rewrite <- minus_minus_distr_r;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;trivial.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- minus_Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v*y)*x-v*y) x y H);intros.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- (mult_assoc u (u+v*x-v) x y H0 H0);trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- (mult_assoc u (u+v) x y H0 H0);trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- (mult_assoc u (u+v) x y H0);trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- (mult_assoc u (u+v) x y H0);trivial.\n  apply H2.\n  rewrite mult_assoc;rewrite <- (mult_assoc u (u+v) x y H0);trivial.\n  apply H2.\n  rewrite mult_assoc;rewrite <- (mult_assoc u (u+v) x y H0);trivial.\n  apply H3.\n  rewrite <- (mult_assoc u (u+v) x y H0).\n Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- plus_assoc;rewrite <- minus_minus_distr_r;trivial.\n  apply (div_pos x y H H0).\n  rewrite mult_plus_distr_r;rewrite <- plus_assoc;rewrite <- minus_minus_distr_l;trivial.\n  apply (div_pos x y H H0).\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div_l x y z z z H);intros.\n  apply H0.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewrite <- (mult_assoc u).\n  rewriteQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div_l (u*x-v)*x-v*x*v) x y H);intros.\n  rewrite mult_plus_distr_l;rewrite <- mult_plus_distr_l;rewrite <- mult_assoc;rewrite <- mult_assoc;trivial.\n  rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_assoc;trivial.\n  apply le_trans with (d*x-v*x*v*x*v*y).\n  rewrite mult_plus_distr_l;rewrite <- mult_assoc;rewrite <- mult_assoc;trivial.\n  apply le_trans with (d*x-v*x*v*x*v*x*v*y).\n  rewrite mult_plus_distr_l;rewrite <- mult_assoc;rewrite <- mult_assoc;trivial.\n  apply le_trans with (d*x-v*x*v*x*v*x*v*x*v).\n  rewrite mult_plus_distr_l;rewrite <- mult_assoc;trivial.\n  apply le_trans with (d*x-v*x*v*x*v*x*vQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*x)/y).\n  intros.\n  apply H0.\n  rewrite mult_assoc;rewrite <- minus_minus_mult_distr_r;rewrite <- minus_minus_minus_distr_r;trivial.\n  rewrite <- minus_minus_minus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_minus_distr_r;trivial.\n  apply (inv_lt_compat_l ((u+v*x)+y) x y).\n  intros.\n  apply H1.\n  rewrite mult_assoc;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- plus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_l.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_l.\n  rewrite <- minus_minus_distr_r;rewrite <- minus_minus_distr_r.\n  rewrite <- minus_minusQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*x) x y H);intros.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- mult_assoc;rewrite <- plus_assoc;rewrite <- mult_assoc;apply mult_lt_compat_l;trivial.\n  assumption.\n  rewrite mult_plus_distr_r;rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_assoc;apply mult_lt_compat_l;trivial.\n  assumption.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- mult_assoc;rewrite <- mult_assoc;apply mult_le_compat_l;trivial.\n  assumption.\n  assumption.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- mult_assoc;rewrite <- mult_assoc;apply mult_le_compat_l;trivial.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)+x*v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- plus_assoc;rewrite <- H1;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  apply bezout_aux1;auto with arith.\n  rewrite mult_plus_distr_r;rewrite <- plus_assoc;rewrite <- minus_minus_distr_l;trivial.\n  rewrite <- plus_assoc;rewrite <- minus_minus_distr_r;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\n",
                "context_tokens": 677,
                "proof_start_offset": 7098,
                "proof_end_offset": 8538,
                "proof": "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nright;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\nelim (H (S n,snd x-S n));try (intro;simpl).\nelim a;intro y;intro.\nleft;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nright;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nrewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\ndestruct (snd x).\nleft;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n));try (intro;simpl).\nelim a;intro y;intro.\nright;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nleft;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  apply bezout_aux1.\n  apply bezout_aux2.\n  apply bezout_aux2.\n  apply be Coupet_aux1.\n  apply be WORKED_Le.\n  apply be Corporation and_le_intro.\n  apply be beyond_true.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_false.\n  apply is_false.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_false.\n  apply is_true.\n  apply is_true.\n  apply is_true.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_true.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_false.\n  apply is_true.\n  apply is_true.\n  apply is_false.\n  apply is_false.\n  apply is_trueQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_div_r (u*x) x y H);intros.\n  apply H2.\n  rewrite mult_assoc;rewrite <- minus_minus_mult_distr_r;rewrite <- minus_minus_inverse;trivial.\n  apply H2.\n  rewrite mult_assoc;rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite mult_assoc;rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H1.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H4.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivial.\n  apply H3.\n  rewrite <- minus_minus_inverse;trivialQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0; intros.\n  apply H1.\n  rewrite mult_comm;rewrite <- minus_minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H0 H0 H1).\n  rewrite mult_comm; rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H0 H1).\n  rewrite mult_comm; rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H0 H1).\n  rewrite mult_assoc;rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H0 H1).\n  rewrite mult_comm; rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H0 H1).\n  rewrite mult_comm; rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (u*x-v) x y H1).\n  rewrite mult_comm; rewrite <- minus_minus_elim; trivial.\n  apply (is_gcd (Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  apply bezout_aux1.\n  apply be Bit_aux2.\n  apply be8687_exists_prod.\n  apply beerbenz_aux1.\n  apply beerbenz_aux2.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux2.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux2.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux2.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux2.\n  apply beerbenz_aux2.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenz_aux1.\n  apply beerbenzQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0;intros.\n  apply H1.\n  rewrite H1 in H1.\n  rewrite <- H0 in H1.\n  apply H1.\n  apply H1.\n  rewrite <- H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H0 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply H1.\n  rewrite <- H1 in H1.\n  apply HQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  apply H1.\n  rewrite mult_comm; rewrite <- minus_minus_distr_r;rewrite <- minus_minus_mult_distr_r;trivial.\n  apply le_trans with (m-x); auto with arith.\n  rewrite <- minus_minus_minus_distr_r;rewrite <- minus_minus_minus_distr_r;trivial.\n  apply le_trans with (m-x); auto with arith.\n  rewrite <- minus_minus_minus_distr_r;rewrite <- minus_minus_minus_distr_r;trivial.\n  apply le_trans with (m-x); auto with arith.\n  rewrite <- minus_minus_distr_r; rewrite <- minus_minus_distr_r;trivial.\n  apply le_trans with (m-x); auto with arith.\n  rewrite <- minus_minus_distr_r; rewrite <- minus_minus_distr_r;trivial.\n  apply le_trans with (m-x); auto with arith.\n  rewrite <- minus_minus_distr_r; rewrite <- minus_minus_distr_r;trivial.\n  apply le_trans with (mQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_minus ((u+v)*x-v*x)=x.\n  apply H0.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;rewrite <- minus_minus_mult_distr_r;trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;rewrite <- minus_minus_distr_l;trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;trivial.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l;trivial.\n  apply H1.\n  rewrite mult_minus_distr_r;rewrite <- minus_minus_distr_l;trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;trivial.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minusQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H;intros.\n  apply H0.\n  rewrite mult_comm;rewrite <- minus_minus_minus; try (auto with arith).\n  apply le_trans with (pred (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_true.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_false.\n  apply be beyond_false.\n Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0; intros.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H2.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H3.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H3.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H4.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H3.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H3.\n  rewrite <- H0;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- H0;auto with arith.\n  apply H4.\n  rewrite <- H1;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- H1;auto with arith.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\nLemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\n",
                "context_tokens": 690,
                "proof_start_offset": 8563,
                "proof_end_offset": 8967,
                "proof": "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros.\nelim (bezout_exists_prod (a,b));intro.\nelim a0;destruct x;simpl;intros.\nleft;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\nelim b0;destruct x;simpl;intros.\nright;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  unfold ltof.\n  intros.\n  case (le_eq_dec a 0);intros.\n  right;apply beerbenz;auto with arith.\n  left;apply beerbenz;auto with arith.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_div (a*u-b) a b);intros.\n  elim (gcd_div (a*u-b) a b);intros.\n  exists ((a, b));simpl;rewrite <- (div_mod (a*u-b)); auto.\n  elim b;intro b;intro.\n  left;exists ((a, b));simpl;rewrite <- (div_mod (a*u-b)); auto.\n  left;exists ((a, b));simpl;rewrite <- (div_mod (a*u-b)); auto.\n  left; exists ((a, b);simpl;rewrite <- (div_mod (a*u-b)); auto.\n  right; exists ((a, b);simpl;rewrite <- (div_mod (a*u-b)); auto.\n  left; exists ((a, b);simpl;rewrite <- (div_mod (a*u-b)); auto.\n  left; exists ((a, b);simpl;rewrite <- (div_mod (a*u-b)); auto.\n  left; exists ((a, b);simpl;rewrite <- (div_mod (a*u-b)); auto.\n  rightQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_correct (a*u-a) (a*u-a) b H);intros.\n  apply H0.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H0.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H1.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H1.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H1.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H0.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  rewrite (div_comm (a*u-a) (a*u-a) H);trivial.\n  apply H0.\n Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_unique (a*u-b*u) a b H0 H1).\n  apply (rec_correct a b).\n  intros.\n  rewrite (div_Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim H; intro.\n  left; exists (a * b);simpl;rewrite <- minus_n_O; rewrite plus_comm;trivial.\n  right; exists (a * b);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_one.\n  elim b;intro.\n  left;exists ((a*u-b));simpl;rewrite <- minus_n_O;rewrite plus_comm;trivial.\n  elim b;intro.\n  right;exists ((a*u-b));simpl;rewrite <- minus_n_O;rewrite plus_comm;trivial.\n  elim b;intro.\n  left;exists (a*u-b);simpl;rewrite <- minus_n_O;rewrite plus_comm;trivial.\n  elim b;intro.\n  left;exists ((a*u-b));simpl;rewrite <- minus_n_O;rewrite plus_comm;trivial.\n  elim b;intro.\n  right;exists ((a*u-b));simpl;rewrite <- minus_n_O;rewrite plus_comm;trivial.\n  elim b;intro.\n  right;exists ((a*u-b));simpl;rewriteQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros a b.\ncase (lt_eq_dec (a*u));intro.\nrewrite <- (le_le_le_iff (a*u));trivial.\nrewrite <- (le_le_lt_iff (a*u));trivial.\napply (a*(is_gcd (a*u-b) a b));trivial.\nrewrite <- (le_le_lt_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_le_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_le_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_le_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivial.\nrewrite <- (le_lt_iff (a*u));trivialQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros a b.\n  elim (gcd_opp (a*u) a b);intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b)) a b);intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b)) a b);intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b)) a b);intros.\n  apply (a*(is_gcd (a*u-b) a b);intros.\n  apply (a*(is_gcd (a*u-b)) a b);intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b) a b));intros.\n  apply (a*(is_gcd (a*u-b)Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_exists_exists_prod (a*u-b) a b);intros.\n  exists ((snd a)*(fst a)*(fst a)*(snd a)) (snd a)).\n  simpl;rewrite <- (div_unique a b);trivial.\n  apply (a*(a*(a*(a*(a*(a*(a*(a*(a*(b*(a*(a*(a*(b*(a*(a*(a*(a(a*(a(a*(b*(a*(a*(a*(a)))));)))));)))).\n  rewrite (div_unique a b);trivial.\n  apply (a*(a*(a*(a*(a*(a*(a*(a*(b*(a*(b*(a*(a*(a*(a*(a*(a*(a*(a*(a*(b*(a*(a*(a*(a*(a*(a*(a*(a*(a)))));)))));))));))));))));)))));\n    [apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  case (eq_dec (fst x) (fst y));intro.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  rightQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_div (a*u-a) a b);intros.\n  elim H;intros.\n  right;exists ((a/u)+u);simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro; elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n  right;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro; elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n  left;exists ((a/u));simpl;rewrite <- plus_n_O;trivial.\n  elim b;intro.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\n",
                "context_tokens": 708,
                "proof_start_offset": 9005,
                "proof_end_offset": 9380,
                "proof": "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (bezout_exists a b);intro.\nelim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\nelim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (Zis_gcd_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_euclid_for_euclid_for_euclid_for_euclid_euclid_for_euclid_for_euclid_for_euclid_for_euclid_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim ( Bezout_exists_prod (a,b) (a,b)).\n  elim ( Bezout_exists_prod (a,b) (a,b)).\n  intros.\n  destruct ( Bezout_exists_prod (a,b) (a,b)).\n  exists (a,b).\n  simpl;rewrite <- minus_n_O;rewrite plus_comm;apply le_O_Sn.\n  elim b;intro.\n  left;exists (a, b).\n  split;auto.\n  elim b;intro.\n  left;exists (a, b).\n  split;auto.\n  elim b;intro.\n  right;exists (a, b).\n  split;auto.\n  elim b;intro.\n  right;exists ((a, b)).\n  split;auto.\n  elim b;intro.\n  left;exists (a, b).\n  split;auto.\n  elim b;intro.\n  left;exists (a, b).\n  split;auto.\n  elim b;intro.\n  right;exists (a, b).\n  split;auto.\n  elim b;intro.\n  left;exists (a, b).\n  split;auto.\n  elim bQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim ( Bezout_exists_prod (a,b*u-b*u) a b);intro.\n  elim b;intro.\n  destruct a;destruct x;simpl;intros.\n  right;exists (a1,b);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim b;intro;apply (is_gcd (a1,b)).\n  elim b;intro.\n  left;exists (a1,b);simpl;rewrite <- plus_n_O;rewrite <- plus_comm;simpl;apply gcd_zero.\n  elim b;intro.\n  left;exists ((a1,b);simpl;rewrite <- mult_comm;simpl;apply gcd_zero.\n  elim b;intro.\n  right;exists 0;rewrite mult_comm;rewrite <- plus_comm;simpl;apply gcd_zero.\n  elim b;intro.\n  right;exists 0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intro.\n  left;exists (a1,b);simpl;rewrite <- mult_comm;simpl;apply gcd_zero.\n  elim b;intro.Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ndestruct (is_gcd a b);intros.\ndestruct (is_gcd a b);intros.\ndestruct b;simpl;rewrite <- mult_comm;rewrite (mult_comm b);trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim ( Bezout_exists_prod (a,b*u-b*u) a b);intros.\n  elim ( Bezout_exists_prod (a,b*u-b*u));intro.\n  elim b;intro.\n  left;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\n  right;exists a;split;auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ndestruct (non_gcd d a b);intro.\ndestruct (non_gcd d a b);intro.\ndestruct (non_gcd d a b);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a b);intro.\ndestruct (non_gcd d a b);intro.\ndestruct (non_gcd d b);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d b);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (non_gcd d a);intro.\ndestruct (Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim (bezout_exists_prod (a,b*u-b*u-b*u)).\n  intro.\n  elim H; intros.\n  elim H; intros.\n  left; exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left; exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  right;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  left;exists O;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b;intros.\n  right;existsQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim (bezout_exists_prod (a,b*u-a));intro.\n  elim b;intro.\n  left;exists (a,a);simpl;rewrite <- minus_n_O;rewrite <- plus_n_O;rewrite <- plus_n_O;rewrite <- plus_comm;simpl;apply gcd_one.\n  elim b;intro.\n  left;exists O;rewrite mult_comm;rewrite <- plus_comm;simpl;apply gcd_zero.\n  elim b;intro.\n  right;exists O;rewrite mult_comm;rewrite <- plus_comm;apply gcd_zero.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  exists (a, b).\n  split; [apply (is_gcd (a,b)).\n  intros.\n  exists (a, b).\n  split; [apply (is_gcd (a,b)).\n  intros.\n  elim ( Bezout_exists_prod (a,b)).\n  intro.\n  exists (a, b).\n  split; [apply (is_gcd (a,b)).\n  intros.\n  exists (a, b).\n  split; [apply (is_gcd (a,b)).\n  intros.\n  exists (a, b).\n  split; [apply (is_gcd (a,b)).\n  intros.\n  existsQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim (euclid_exists_prod (a,b)).\n  apply (intro _ _ H0).\n  apply (intro _ _ H0).\n  apply (intro _ _ H0).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H1).\n  apply (intro _ _ H1).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (intro _ _ H2).\n  apply (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\n",
                "context_tokens": 704,
                "proof_start_offset": 9434,
                "proof_end_offset": 10062,
                "proof": "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\napply bezout;trivial.\nelim H;intro u;intro H0.\nelim H0;intro v;intro.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H2;intros.\nelim H3;intro q;intro.\nelim H4;intro q';intro.\nrewrite H5 in H1;rewrite H6 in H1.\ncase H1;intro.\nexists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nexists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim b;intro.\n  left;exists a;auto.\n  elim b;intro.\n  left;exists a;auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H;intros.\nelim H; intros.\nelim H;intros.\nelim H;intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H;Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (bezout_exists_prod a b);intro.\n  elim (bezout_exists_prod a b);intro.\n  elim b;intro; elim b0;intro.\n  right;exists b;split;auto.\n  elim b0;intro; elim b0;intro; elim b0;intro.\n  right;exists b0;split;auto.\n  elim b0;intro; elim b0;intro.\n  right;exists b0;split;auto.\n  elim b0;intro.\n  left;exists b0;split;auto.\n  elim b0;intro; elim b0;intro.\n  left;exists b0;split;auto.\n  elim b0;intro; elim b0;intro.\n  right;exists b0;split;auto.\n  elim b0;intro; elim b0;intro.\n  left;exists b0;split;auto.\n  elim b0;intro.\n  left;exists b0;split;auto.\n  elim b0;intro.\n  right;exists b0;split;auto.\n  elim b0;intro.\n  right;exists b0;split;auto.\n  elim b0;intro;Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (bezout_exists a b);intro.\n  elim b0;intro.\n  left;exists (a*u);simpl;rewrite <- plus_n_O;rewrite plus_comm;rewrite <- plus_n_O;simpl;apply gcd_comm.\n  elim b0;intros.\n  left;exists (a*u);simpl;rewrite <- plus_n_O;rewrite plus_comm;apply gcd_sym.\n  elim b0;intros.\n  left;exists (a*u);simpl;rewrite <- plus_n_O; rewrite plus_comm;simpl;apply gcd_comm.\n  elim b0;intros.\n  left;exists (a*u);simpl;rewrite <- plus_n_O;rewrite <- plus_comm;apply gcd_sym.\n  elim b0;intros.\n  left;exists (a*u);simpl;rewrite <- plus_n_O;rewrite mult_comm;simpl;apply gcd_comm.\n  elim b0;intros.\n  left;exists (a*u);simpl;rewrite <- plus_comm;apply gcd_sym.\n  elim b0;intros.\n  left; exists (a*u);simpl;Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfoldQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro y; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro y; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n        intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n          intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n          intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n          intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n          elim HQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim H; intro.\n  left; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  left; exists 1;auto.\n  right; exists 1;auto.\n  left;exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\n  right; exists 1;auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros a b.\n  elim (bezout_exists a b);intro.\n  elim a0;intros.\n  left;exists (0,a0);simpl;rewrite <- plus_n_O;rewrite <- plus_n_O;rewrite plus_comm;simpl;apply gcd_sym.\n  elim b;intros.\n  right;exists (0,a0);simpl;rewrite <- plus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_sym.\n  elim b;intros.\n  left;exists (1,a0);simpl;rewrite <- plus_n_O;rewrite <- plus_comm;simpl;apply gcd_sym;apply gcd_sym.\n  elim b;intros.\n  left;exists (1,a0);simpl;rewrite <- plus_n_O;rewrite plus_comm;apply gcd_sym;apply gcd_sym.\n  elim b;intros.\n  left;exists (1,a0);simpl;rewrite <- plus_n_O; rewrite plus_comm;apply gcd_sym.\n  elim b;intros.\n  right;exists (1,a0);simpl;rewrite <- plus_comm;apply gcdQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (divide_0_l a);intro.\n  left;exists (a*a);simpl;rewrite <- H;trivial.\n  elim b;intro.\n  left;exists a;exists b;split;trivial.\n  elim b;intro.\n  right;exists a;exists b;split;trivial.\n  elim b;intro.\n  right;exists a;exists b;split;trivial.\n  elim b;intro.\n  right;exists a;exists b;split;trivial.\n  elim b;intro.\n  left;exists a;exists b;split;trivial.\n  elim b;intro.\n  left;exists b;exists b;split;trivial.\n  elim b;intro.\n  left;exists b;exists b;split;trivial.\n  elim b;intro.\n  right;exists b;exists b;split;trivial.\n  elim b;intro.\n  left;exists a;exists b;split;trivial.\n  elim b;intro.\n  left;exists b;exists b;split;trivial.\n  elim b;intro.\n  left;exists b;exists b;split;trivial.\n  elim b;intro.\n  right;exists b;exists b;Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (bezout_exists a b);intro.\n  elim b0;intro.\n  elim b0;intro; elim H0;intro; elim H0;intro.\n  right;exists b0;rewrite mult_comm;rewrite (mult_comm b0);trivial.\n  elim b0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H0;intro; elim H1;intro; elim H1;intro; elim H0;intro; elim H1;intro; elim H1;intro; elim H1;intro; elim H2;intro; elim H3;intro; elim H4;intro; elim H4;intro; elim H5;intro; elim H5;intro; elim H4;\nexists v; split;apply (gcd_unique d (a*u-b*u) a b);trivial.\n  elim b0;intro; elim H1;intro; elim H0;intro; elim H0;intro; elim H2;intro; elim H3;intro;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 10097,
                "proof_end_offset": 10866,
                "proof": "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nunfold is_gcd;unfold is_cd.\nintros.\nelim H;intros.\nelim H0;intros.\nsplit.\nelim H2;intro q;intro.\nelim H3;intro q';intro.\nrewrite H4;rewrite mult_assoc.\nrewrite H5;rewrite mult_assoc.\nsplit;[exists q;trivial | exists q';trivial].\nintros.\nelim H4;intros.\nelim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\nintro u;intro.\nelim H7;intro v;intro.\nelim H5;intro q;intro.\nelim H6;intro q';intro.\ncase H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  apply gcd_mult;intro.\n  rewrite (mult_comm a b);trivial.\n  elim a0;intro H1.\n  elim H1;intro H2;rewrite H2 in H2.\n  elim H2;intro H3;rewrite H2 in H2.\n  elim H3;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n  elim H4;intro H4;rewrite H2 in H2.\n Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_exists_prod (a,b) (n*a) (n*b)).\n  intros.\n  elim (gcd_exists_prod (a,b) (n*a) (n*b)).\n  intros.\n  elim (gcd_exists_prod (a,b) (n*a) (n*b))).\n  intros.\n  elim H;intro H; elim H;intro H0.\n  elim H0;intro H0; elim H0;intro H0.\n  elim H0;intro H0; elim H0;intro H0.\n  elim H0;intro H0; elim H0;intro H1; elim H0;intro H1.\n  elim H0;intro H0; elim H0;intro H1; elim H1;intro H2.\n  elim H0;intro H1; elim H1;intro H1.\n  elim H0;intro H1; elim H1;intro H2; elim H2;intro H3.\n  elim H0;intro H2; elim H3;intro H3; elim H3;intro H4; elim H4;intro H4;\n  elimQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim n;intro n0;intro n0;intro n0;intro n1;intro n1;intro n2;intro n3;intro n4;intro n4;intro n4;intro n4;intro n5;intro n6;intro n6;intro n7;intro n7;intro n7; elim n8;intro n8;intro n8;intro n9;intro n9;intro n10;intro n9;intro n10;intro n10; elim n8;intro n9;intro n10;intro n10; elim n10;intro n10;intro n10; elim n11; intro n11;\nintro n1; elim n1;intro n2;intro n4; elim n4;intro; elim n4;intro n10;\nintro n1; elim n4;intro n5; elim n5;intro n6; elim n5;intro n7;\nintro n1; elim n5;intro n6; elim n6;intro; elim n5; intro; elim n6;\nintro n1; elim n6;intro; elim n5;intro; elim n6Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim H;intro;apply gcd_sym;trivial.\n  elim H;intro.\n  elim H;intro.\n  elim H0;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H0;intro.\n  elim H0;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  elim H0;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  elim H0;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  apply (gcd_unique d (a*a));intro.\n  elim H1;intro.\n  apply (gcd_unique d (a*aQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_exists_prod (n*a) (n*a)) (n*a)).\n  intros.\n  elim H;intro n; elim n;intro.\n  elim H1;intro n; elim H1;intro H2.\n  rewrite H2 in H1; rewrite H1 in H1.\n  apply (gcd_unique d (a*b*a) a b);trivial.\n  elim b;intro H1;rewrite H1 in H1.\n  apply (gcd_unique d (a*a) (n*b) a b);trivial.\n  elim b;intro H1;rewrite H1 in H1.\n  apply (gcd_unique d (a*a) b);trivial.\n  elim b;intro H1;rewrite H1 in H1; rewrite H1 in H1.\n  apply (gcd_unique d (a*a) b);trivial.\n  elim b;intro H2;rewrite H2 in H1.\n  apply (gcd_unique d (a*b) b);trivial.\n  elim b;intro H2;rewrite H2 in H1.\n  apply (gcd_unique d (a*a) bQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_exists_prod (a,b) (n*a) (n*b)).\n  intros.\n  elim H0;intro H1; elim H1;intro H2; elim H2;intro H3;\n    intros; elim H3;intro H4;\n      intros; elim H4;intro H5;\n        intros; elim H4;intro H5;\n          intros; elim H4; intros; elim H5; intros; elim H5;\n            intros; elim H5; intros; elim H6; intros; elim H6;\n            intros; elim H6; intros; elim H6; intros; elim H6;\n            intros; elim H6; intros; elim H7;\n              intros; elim H7; intros; elim H7; intros; elim H7;\n              intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n                intros; elim H7; intros; elim H8; intros; elim H7;\n                intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n                    intros; elim H8; intros; elim HQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nintros.\napply ( gcd_mult_strong (a*a) (b*a) (n*b));auto.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_unique a b);intro.\n  elim H;intro;elim H;intro H0.\n  elim H0;intro H0; elim H0;intro H1; elim H0;intro H2.\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd in H0;\n  unfold is_gcd in H0;unfold is_gcd in H0;unfold is_gcd inQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim H;intro.\n  rewrite H0 in H0.\n  elim H0;intro H0;intros.\n  exists (q*u-b*u);rewrite mult_comm.\n  apply gcd_mult_strong;auto.\n  intros.\n  elim H0;intro H0; elim H0;intro H0;intros.\n  apply H0;intro H0; elim H0;intros.\n  apply H0;intro H0; elim H0;intros.\n  elim H0;intro H0; elim H0;intros.\n  rewrite H0 in H1; rewrite H1 in H1; rewrite H1 in H1.\n  elim H0;intros.\n  exists (q*u-b*u);rewrite mult_comm.\n  apply gcd_mult_strong;auto.\n  intros.\n  elim H0;intro H0; elim H0;intros.\n  apply H0;intro H0; elim H0;intros.\n  apply H0;intro H0; elim H0;intros.\n  rewrite H0 in H1; rewrite H0 in H1; rewrite H1 in H1.\n  case H1;intro H1; rewriteQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "formulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 10903,
                "proof_end_offset": 11396,
                "proof": "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros.\nelim (bezout 1 a d H);intro u;intro.\nelim H1;intro v;intro.\nelim H0;intro q;intro.\ncase H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  unfold rel_prime; simpl;intro.\n  elim H;intro.\n  elim H;intros.\n  elim H0;intro H1;rewrite H2;rewrite H3;rewrite H3;trivial.\n  elim H0;intro.\n  elim H1;intros.\n  elim H1;intro.\n  elim H2;intro;rewrite H3;rewrite H3;rewrite H3;trivial.\n  elim H0;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H6;Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim (rel_prime a d);intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H8;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H9;intro.\n  elim H9;intro.\n  elim H9Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\n  intros.\n  elim (divide_0_l (a*b) d);intro.\n  elim H;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim HQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim H; intro.\n  elim H; intro.\n  elim H1; intro.\n  elim H2; intro.\n  apply H3.\n  elim H3; intro.\n  elim H4; intro.\n  elim H4; intro.\n  apply H4.\n  elim H4; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  apply H5.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H7; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elimQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim (rel_prime a d);intro.\n  elim H7;intro.\n  elim (rel_prime a d);intro.\n  elim H7;intro; elim H7;intro.\n  elim H8;intro q';intro.\n  elim H8;intro.\n  rewrite H9 in H9; rewrite H10 in H10.\n  elim H9;intro.\n  elim H9;intro.\n  rewrite H9 in H10; rewrite H10 in H11.\n  elim H10;intro.\n  elim H9;intro.\n  elim H10;intro.\n  elim H10;intro.\n  rewrite H9 in H10; rewrite H10 in H10.\n  elim (rel_prime a d);intro.\n  elim H10;intro.\n  elim H10;intro.\n  elim H11;intro.\n  elim H11;intro.\n  elimQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  apply le_trans with (m*a*b).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*a).\n  apply le_trans with (m*Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\n  intros d a b d H.\n  elim H;intro d;intro H; elim H;intro H.\n  elim (divide_0_l a);intro H;elim H;intro H; elim H;intro H.\n  apply H;intro H;elim H;intro H.\n  elim H;intro H;intro H.\n  elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H.\n  apply H;intro H; elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H;\n    elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H;\n      elim H;intro H; elim H;intro H; elim H;intro H;\n        elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H;\n        elim H;intro H; elim H;intro H; elim H;intro H;\n          intro H; elim H;intro H; elim H;intro H; elim H; intro H;\n          elim H;intro H; elim HQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\n  intros.\n  elim H;intro; elim H;intros.\n  split;intro.\n  split;intro.\n  elim H0;intro.\n  elim H1;intro; elim H1;intro.\n  elim H0;intro; elim H1;intro.\n  rewrite H1 in H1; rewrite H1 in H1; discriminate.\n  apply le_trans with (a*b); trivial.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  rewrite H2; rewrite H2 in H1; discriminate.\n  apply le_trans with (a*b); trivial.\n  elim H0;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2; intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H2;intro.\n  elim H4;intro.\n  rewrite H4; rewrite H2 in H1; discriminate.\n  apply le_trans with (a*b); trivial.Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim (rel_prime a b);intro.\n  elim H;intro H;intro H; elim H;intro H.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H1;intro H2.\n  elim H2;intro H3;intro H3.\n  elim H3;intro H4;intro H4; elim H4;intro H5; elim H4;intro H4;\n    [exists (q'*u-a*u));rewrite mult_minus_distr_r;rewrite mult_comm;trivial.\n  elim H3;intro H4; elim H4;intro H4; elim H4;intro H5;\n    [ exists (q'*u-a*u));rewrite mult_minus_mult_distr_r;rewrite mult_assoc;trivial.\n  exists (q'*u-a*u);rewrite mult_minus_distr_l;rewrite mult_comm;trivial.\n  exists (q'*u-a*u);rewrite mult_plus_distr_l;rewrite mult_assoc;trivial.\n  exists (q'*u-a*u);rewrite mult_assoc;Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim H;intro.\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (b*(a*b) d).\n  apply le_trans with (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\nTheorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro u;intro.\n  elim H1;intro v;intro.\n  elim H0;intro q;intro.\n  case H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 11456,
                "proof_end_offset": 13305,
                "proof": "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nintros.\ngeneralize (quo_rem_euclide a b H);intro.\nred;split;intro.\nrewrite H0 in H1.\nelim H1;intros.\nunfold is_gcd;unfold is_cd.\nelim H2;intros.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nreplace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\nassert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\nrewrite <- H6;rewrite minus_plus;trivial.\nrewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\nexists (q-q'*(quotient_euclide a b H));trivial.\nrewrite <- H7;trivial.\nintros.\nelim H6;intros.\napply H3.\nunfold is_cd;split;try tauto.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nrewrite H10.\nreplace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H9;trivial.\nunfold is_gcd;unfold is_cd.\nunfold is_gcd in H1;unfold is_cd in H1.\nelim H1;intros.\nelim H2;intros.\nrewrite H0.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H7.\nreplace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H6;trivial.\nintros.\napply H3.\nsplit;try tauto.\nelim H6;intros.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nassert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\nrewrite minus_plus;trivial.\nrewrite H9 in H11.\nexists (q-q'*(quotient_euclide a b H)).\nrewrite mult_minus_lemma2;rewrite mult_assoc.\nrewrite <- H10;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim H;intro H;intro H; elim H;intro H;clear H.\n  rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;rewrite H;trivial.\nQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nunfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H0;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nunfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro H0;intro H0; elim H0;intro H0;\n  [ intro H0; elim H0;intro H0; elim H0;intro H0;\n    [ intro H0; elim H0;intro H0; elim H0;intro H0;\n      [ intro H0; elim H0;intro H0; elim H0;intro H0;\n        [ intro H1; elim H0; intro H1; elim H0; intro H0;\n          [ intro H1; elim H1; intro H0; elim H0; intro H1;\n            [ intro H1; elim H1; intro H1; elim H1; intro H1;\n              [ intro H1; elim H1; intro H1; elim H1; intro H1;\n              [ intro H1; elim H1; intro H2; elim H1; intro H1;\n                [ intro H1; elim H1; intro H1; elim H1; intro H1;\n                [ intro H1; elim H1; intro H2;\n                [ intro H1; elim H1;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold gcd in H; rewrite gcd_sym; rewrite H; rewrite H;trivial.\n  elim H;intro H.\n  elim H;intro H0;intro H0; elim H0;intro H0.\n  elim H0;intro H0; intro H1; elim H0;intro H1.\n  elim H1;intro H1; elim H2;intro H2.\n  elim H2;intro H2; elim H2;intro H2; elim H2;intro H3.\n  elim H2;intro H3; elim H2; intro H3; elim H3;intro H3.\n  elim H3; intro H4; elim H4;intro H4; elim H4; intro H4.\n  elim H4; intro H5; elim H4; intro H5; elim H4; intro H5; elim H5; intro H6.\n  elim H5; intro H6; elim H7; intro H8; elim H6; intro H7.\n  elim H6; intro H8; elim H9; intro H9; elim H9; intro H9; elim H9; intro H9;\n    elim H10; introQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n  unfold gcd.\n  intros.\n  elim (bezout 1 a d H);intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H2Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n  unfold gcd; intros.\n  elim (bezout 1 a d H);intro H; elim H;intros; elim H;intro.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H1.\n  elim H0;intro H1;intro H2; elim H2;intro H2;\n    intro H3; elim H3;intro H4; elim H4;intro H4;\n      intro H4; elim H4; intro H4; elim H5;intro H4;\n      intro H5; elim H4; intro H5; elim H4; intro H5;\n          intro H5; elim H5; intro H5; elim H5; intro H5;\n          intro H6; elim H6; intro H7; elim H7; intro H8;\n          elim H6; intro H7Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro.\n  elim H;intro H1;intro H2.\n  elim H0;intro H2;intro H3.\n  elim H2;intro H3;intro H4;rewrite H4; rewrite H4; rewrite H4; rewrite H4; rewrite H4;\n    rewrite H5; rewrite H5; rewrite H5; rewrite H5; rewrite H4;\n    rewrite H6; rewrite H6; rewrite H6; rewrite H6;\n    rewrite H6; rewrite H; rewrite H6; rewrite H6; rewrite H;\n    rewrite H6; rewrite H6; rewrite H6; rewrite H; rewrite H6;\n    rewrite H; rewrite H; rewrite H6; rewrite H; rewrite H;\n    rewrite H6; rewrite H; rewrite H; rewrite H;\n    rewrite H6; rewrite H; rewrite H;\n    rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n    rewrite H; rewrite H; rewrite H; rewrite H;\n    rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n    rewrite H; rewrite H; rewrite H;\n    rewrite H;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro H;intro H; elim H;intro H; elim H;intro H; elim H;intro H;elim H;intro H; elim H;intro H; elim H;intro H;elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H; elim H; intro H; elim H;\nelim H;intro H; elim H;intro H; elim H; intro H; elim H; intro H; elim H;\nelim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\nelim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n elim H; intro H; elim H; intro H; elim H; intro H; elim H; elim H; intro H;\n elim H; intro H; elim H; intro H; elim H; introQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n  unfold gcd; intros.\n  elim (euclid_is_gcd d a b);intro.\n  elim H;intro.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H0.\n  elim H0;intro H0;intro H1; elim H0;intro H1.\n  elim H0;intro H1;intro H2; elim H1;intro H2.\n  elim H1;intro H2; elim H2;intro H2; elim H2;intro H3.\n  elim H2;intro H2; elim H2;intro H3; elim H2;intro H4.\n  elim H3;intro H4; elim H2;intro H4; elim H3;intro H4; elim H4;intro H4;\n    intro H4; elim H4; intro H5; elim H4;intro H5; elim H4; intro H5.\n  elim H5;intro H5; elim H5; intro H4; elim H4; intro H5; elim H5;\n    intro H5; elim H5; intro H6; elim H5; introQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold gcd in H; unfold is_gcd in H;\n  split;intro H;elim H;intros.\n  elim H;intros.\n  elim H0;intro H0; elim H0;intro H1; elim H0;intro H2;intro H2.\n  elim H0;intro H0; elim H0;intro H0; elim H0;intro H1; elim H1;intro H2;\n  elim H1;intro H1; elim H2;intro H1; elim H2;intro H1; elim H1;intro H2;\n    elim H3;intro H2; elim H2;intro H3; elim H3;intro H3;\n    elim H4;intro H4; elim H4;intro H4; elim H4;intro H4;\n    elim H4;intro H5; elim H4;intro H4; elim H4;intro H4;\n    elim H5;intro H5; elim H4;intro H4;\n      elim H5;intro H4; elim H4;intro H5; elim H5;intro H5;\n        elim H5;intro H5; elim H4;introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\nLemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  intros.\n  generalize (quo_rem_euclide a b H);intro.\n  red;split;intro.\n  rewrite H0 in H1.\n  elim H1;intros.\n  unfold is_gcd;unfold is_cd.\n  elim H2;intros.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  replace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\n  assert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\n  rewrite <- H6;rewrite minus_plus;trivial.\n  rewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\n  exists (q-q'*(quotient_euclide a b H));trivial.\n  rewrite <- H7;trivial.\n  intros.\n  elim H6;intros.\n  apply H3.\n  unfold is_cd;split;try tauto.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  rewrite H10.\n  replace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 13371,
                "proof_end_offset": 14277,
                "proof": "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof;unfold f;intros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ncase (eq_nat_dec (fst x) 0);intro.\nrewrite e;exists (snd x);apply gcd_zero.\nelim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\nintro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_euclide d (snd x) (fst x) n);auto.\ngeneralize (rem_euclide (snd x) (fst x) n);try omega.\nrewrite e;exists (snd x);apply gcd_refl.\ncase (eq_nat_dec (snd x) 0);intro.\nrewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\nintro d;intro.\nexists d.\nelim (gcd_euclide d (fst x) (snd x) n);auto.\ngeneralize (rem_euclide (fst x) (snd x) n);try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x (c + c) H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x (c + c) H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x H);intro.\n generalize (mod_unique_lemma x x (c + c) H);intro.\n generalize (mod_unique_lemma x (c + c) H);intro.\n generalize (mod_unique_lemma xQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n generalize ( gcd_exists_prod_bis x H);intro.\n rewrite H0;trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n destruct (gcd_exists_prod_bis x y H0);intros.\n apply H0;trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros x.\ngeneralize (divide_1_l x).\nintro.\ndestruct x.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_exists_prod_bis; trivial.\napply gcd_Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  apply gcd_exists_prod_bis; trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros.\ngeneralize (divide_1_l (fst x) (snd x)).\ndestruct (divide_1_l (fst x) (snd x)).\nrewrite <- H1;trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x))).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x))).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x)).\nintros.\ngeneralize (div_exists_prod_bis x (snd x) (snd x))).\nintros.\ngeneralize (div_exists_prod_bis xQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros x.\ngeneralize (mod_unique_pos x H);intro.\ngeneralize (mod_unique_pos x H);intro.\ngeneralize (mod_unique_pos x H);intro.\nrewrite H0; rewrite H1;trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  generalize (mod_unique_unique x y H);intro.\n  case (mod_unique_unique_inf x y H);intros.\n  rewrite <- H;trivial.\n  rewrite <- H1;trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcd_exists_prod_bis.\n  apply gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 730,
                "proof_start_offset": 14326,
                "proof_end_offset": 14485,
                "proof": "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\nexists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x)}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d a b) x}).\n  apply (induction_ltof2 (nat*nat) f (fun x:natQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.\n  apply gcd_exists_bis.Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ind_bis a b).\n  intros a b.\n  case (eq_nat_dec (fst x) (snd x));intro.\n  rewrite e;exists (fst x);trivial.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (fst x);trivial.\n  elim (gcd_eucl a b (snd x));auto.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  apply gcd_sym.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  apply gcd_sym.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  apply gcd_sym.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  apply gcd_sym.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  apply gcd_sym.\n  elim (gcd_eucl a b (snd x) n);auto.\n  intro d; exists d.\n  applyQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x)))}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)))}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)))}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x)))}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x) (snd x)))}).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => {d:nat | (is_gcd d (fst x) (snd x) (snd x) (snd x)))}).Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x) 0.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (induction_ltof2 (nat*nat) f (fun x:nat => x + d) x).\n  apply (inductionQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\n  apply gcd_exists_bis; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\n",
                "context_tokens": 729,
                "proof_start_offset": 14549,
                "proof_end_offset": 14831,
                "proof": "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros.\nunfold rel_prime.\ngeneralize (gcd_is_gcd a b);intro.\ncase (eq_nat_dec (gcd a b) 1);intro.\nleft;rewrite e in H;trivial.\nright;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a,b);apply gcd_exists_prod_bis;auto.\n  elim (gcd_exists_prod_bis (a,Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  destruct (rel_prime_dec a b);simpl;intros.\n  exists (a*b).\n  rewrite <- (gcd_exists_prod_bis a b);trivial.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  assumption.\n  elim (gcd_exists_prod_bis a b);auto.\n  intros.\n  exists d;trivial.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intro d;simpl;intros.\n  exists d;trivial.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (snd x);apply gcd_le_trans with (a+b);trivial.\n  elim (gcd_exists_prod_bis (a,b))).\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.\n  intros.\n  exists (snd x); apply gcd_unique.Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intro d;simpl;intro.\n  exists (a+d).\n  split.\n  split.\n  apply gcd_is_gcd.\n  apply gcd_exists_left_l.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcd.\n  apply gcd_is_gcdQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b);intros.\n  exists (a,b);auto.\n  exists (a,b);auto.\n  exists (a,b);auto.\n  exists (a,b);auto.\n  exists (a,b);auto.\n  exists (a,b);auto.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b);intros.\n  exists (S b);trivial.\n  intros.\n  exists (S b);trivial.\n  intros.\n  exists (S b);trivial.\n  intros.\n  exists (S b);trivial.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis a b);intros.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);trivial.\n  exists (a, b);simpl;trivial.\n  exists (a, b);trivial.\n  exists (a, b);simpl;trivial.Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (a, (a, b));split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);split;auto.\n  exists (a, b);splitQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intro b;simpl;intro.\n  elim b;intros.\n  exists 0;trivial.\n  exists 1;trivial.\n  exists 1;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\n",
                "context_tokens": 721,
                "proof_start_offset": 14887,
                "proof_end_offset": 15621,
                "proof": "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\nintros.\nsplit.\nsplit;try (apply one_min_div).\nintros.\nelim H1;intros.\ncase (rel_prime_dec b d');intro.\nassert (divides c d').\napply gauss with b;trivial.\nelim H0;intros.\napply H6;unfold is_cd;tauto.\ngeneralize (gcd_is_gcd b d');intro.\nassert ((gcd b d')<>1).\nintro;apply n.\nunfold rel_prime;rewrite <- H5;trivial.\ngeneralize (gcd_div_l (gcd b d') b d' H4);intro.\ngeneralize (gcd_div_r (gcd b d') b d' H4);intro.\nassert (divides a (gcd b d')).\napply divides_trans with d';[apply H2 | apply H7].\nelim H5.\napply divides_antisym.\napply one_min_div.\nelim H;intros;apply H10;unfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  right.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite <- (gcd_is_gcd a b c);intro.\n  caseQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply relQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply rel_prime_mult;apply rel_prime_mult;auto.\n  left;intro;apply n;apply (gcd_unique (gcd a b) 1 a);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a);trivial.Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply (rel_prime_mult a b c);trivial.\n  left;apply (rel_prime_mult a b c);trivial.\n  right;intro;apply n;apply (rel_prime_mult a b c);trivial.\n  right;intro;apply n;apply (rel_prime_mult a b c);trivial.\n  right;intro;apply n;apply (rel_prime_mult a b c);trivial.\n  left;intro;apply n;apply (rel_prime_mult a b c);trivial.\n  right;intro;apply n;apply (rel_prime_mult a b c);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  destruct (rel_prime_dec (gcd a b) 1);intro.\n  left;rewrite e;exists_prime;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a);trivial.\n  left;intro;apply n;apply (gcd_unique (gcd a b) 1 a);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply rel_prime_correct;auto.\n  apply relQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  right;intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  right;intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  left;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n  right;intro;rewrite e;exists (snd x);apply gcd_refl.\n Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply (rel_prime_mult a b c);trivial.\n  apply rel_prime_mult;trivial.\n  rewrite <- H0;trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply rel_prime_correct;intros.\n  apply H.\n  apply (rel_prime_correct a b);auto.\n  intros.\n  apply (rel_prime_correct a b);auto.\n  intros.\n  apply H.\n  apply (rel_prime_correct a b);auto.\n  intros.\n  apply H.\n  apply (rel_prime_correct a b);auto.\n  intros.\n  apply (rel_prime_correct b b);auto.\n  intros.\n  apply H.\n  apply (rel_prime_correct a b);auto.\n  intros.\n  apply H.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_correct b);auto.\n  intros.\n  apply (rel_prime_Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e;exists (snd x);apply gcd_zero.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x);apply gcd_zero.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  left;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;intro;rewrite e;exists (snd x) in H;trivial.\n  right;introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\n",
                "context_tokens": 718,
                "proof_start_offset": 15677,
                "proof_end_offset": 15983,
                "proof": "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\nintros.\nsplit;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  unfold rel_prime; rewrite <- H; trivial.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n intros.\n apply le_trans with (rel_prime a b);trivial.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n applyQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  case (gcd_exists_prod a b);intro.\n  left.\n  apply H;unfold rel_prime in |- *;rewrite <- H0;trivial.\n  left.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H0;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  left.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  left.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  left.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfold is_gcd in |- *;rewrite <- H0;trivial.\n  right.\n  apply H;unfoldQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  case (gcd_exists_prod_bis (a,b) a);intro.\n  left;rewrite e;exists (a,b).\n  intro d;apply H2;unfold is_cd;tauto.\n  right;intro;apply H11;unfold is_cd;tauto.\n  right;intro;apply H11;unfold is_cd;tauto.\n  right;intro;apply H11;unfold is_cd;tauto.\n  left;intro;apply H11;unfold is_cd;tauto.\n  left;intro;apply H11;unfold is_cd;tauto.\n  right;intro;apply H11;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  right;intro;apply H12;unfold is_cd;tauto.\n  rightQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim H;intros.\n  apply H.\n  unfold rel_prime.\n  apply H.\n  unfold rel_prime in |- *;rewrite <- H5;trivial.\n  elim H0;intros.\n  elim H1;intros.\n  apply H0.\n  unfold rel_prime in |- *;rewrite <- H6;trivial.\n  elim H1;intros.\n  apply H2.\n  unfold rel_prime in |- *;rewrite <- H6;trivial.\n  elim H3;intros.\n  elim H3;intros.\n  apply H4;unfold rel_prime in |- *;rewrite H7;trivial.\n  elim H3;intros.\n  apply H5;unfold rel_prime in |- *;rewrite <- H5;trivial.\n  elim H3;intros.\n  elim H4;intros.\n  apply H5;unfold rel_prime in |- *;rewrite <- H6;trivial.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  apply H4;unfold rel_prime in |- *;rewrite <- H5;trivial.\n  elim H4;intros.\n  apply H4;unfold rel_prime in |- *;Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim H; intros; elim H; intros.\n  elim H1; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  elim H1; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H2; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H0; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\n  elim H0; intros.\n  apply H1; unfold is_scalar;tauto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply le_trans with (gcd a b);auto with *.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply mod_le.\n  apply mod_le.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  assumption.\n  apply gcd_divide.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  unfold rel_prime in H.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e;exists (snd x);trivial.\n  left;rewrite e;exists (snd x);trivial.\n  left;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  left;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  left;rewrite e;exists (snd x);trivial.\n  right;rewrite e;exists (snd x);trivial.\n  left;rewrite e;exists (snd x);trivial.\n  right;rewrite e;existsQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim H; intros.\n  apply H0;unfold rel_prime; rewrite H;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  case (gcd_exists_prod a b);intro.\n  left;rewrite e in H;trivial.\n  left;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  left;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  left;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 16024,
                "proof_end_offset": 16251,
                "proof": "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\ninduction n;simpl;intros.\nunfold rel_prime;apply gcd_sym;apply gcd_one.\ngeneralize (IHn H);intro.\napply rel_prime_mult;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (rel_prime a (power d a)).\n  left;rewrite <- H0;simpl;trivial.\n  left;rewrite <- H1;simpl;trivial.\n  left;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  left;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  left;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n  right;rewrite <- H1;simpl;trivial.\n Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split;try (apply one_min_div_eq;trivial);trivial.\n  intros.\n  apply H;unfold is_cd;tauto.\n  intros.\n  apply H;unfold is_cd;tauto.\n  intros.\n  apply H;unfold is_cd;tauto.\n  intros.\n  apply H;unfold is_cd;tauto.\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  elim H0; intros.\n  apply H1;unfold is_cd;tauto.\n  intros.\n  elim H0; intros.\n  apply H1;unfold is_cd;tauto.\n  elim H0; intros.\n  apply H1;unfold is_cd;tauto.\n  intros.\n  elim H1; intros.\n  apply H1;unfold is_cd;tauto.\n  intros.\n  elim H1; intros.\n  apply H2;unfold is_cd;tauto.\n  intros.\n  elim H0; intros.\n  apply H1;unfold is_cd;tauto.\n  intros.\n  elim H2; intros.\n  apply H2;unfold is_cd;tauto.\n  intros.\n  apply H2;unfold is_cd;tauto.\n  intros.\n  elim H2; intros.\n  apply H3;unfold is_Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split;try (apply one_min_div).\n  intros.\n  exists a.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_prime.\n  apply H;unfold is_rel_primeQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (rel_prime_dec a (power d n)).\n  left;rewrite e in H;trivial.\n  right;intro;apply n; apply (gcd_is_gcd a (n - n)).\n  right;intro;rewrite e in H;trivial.\n  left;intro;apply n;apply (gcd_is_gcd a (n - n)).\n  left;intro;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_is_gcd a (n - n)).\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_is_gcd a (n - n)).\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n  right;intro;rewrite e in H;trivial.\n Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_primeQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)) (gcd a n);intro d;simpl;intros.\n  elim H1;intros; apply H2;unfold is_rel_prime;rewrite H0;trivial.\n  elim H1;intros.\n  case (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  apply H3;unfold is_rel_prime;rewrite H0;trivial.\n  elim H1;intros.\n  case (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  apply H3;unfold is_rel_prime;rewrite H1;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  apply H3;unfold is_rel_prime;rewrite H1;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  apply H3;unfold is_rel_prime;rewrite H1;trivial.\n  apply H3;unfold is_rel_prime;rewrite H0;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  apply H3;unfold is_rel_prime;rewrite H1Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_primeQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  elim H;intros; elim H0;intros.\n  elim H1;intros; elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4; intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\n",
                "context_tokens": 723,
                "proof_start_offset": 16300,
                "proof_end_offset": 16486,
                "proof": "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ndestruct n;simpl;intros.\ninversion H.\nelim (mult_rel_prime a d (power d n));auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  split;intros;apply (power_rel_prime a (gcd a n)).\n  elim H;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3; intros.\n  elim H3;intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5;Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a n);intro.\n  case (eq_nat_dec (gcd a n) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply H0;unfold is_rel_prime;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  case (eq_nat_dec (gcd a n) 1);intro.\n  left;rewrite e in H;trivial.\n  left;intro;apply H0;unfold is_rel_prime;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  case (eq_nat_dec (gcd a n) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply H0;unfold is_rel_prime;trivial.\n  generalize (gcd_is_gcd a n);intro.\n  case (eq_nat_dec (gcd a n) 1);intro.\n  left;rewrite e in H;trivial.\n  left;intro;apply H0;unfold is_rel_prime;trivial.\n  right;intro;apply H0;unfold is_rel_primeQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  case (gcd_is_gcd a (gcd a b));intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply H;unfold is_gcd in H.\n  left;rewrite e in H;trivial.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  left;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfold is_gcd in H.\n  right;intro;apply H;unfoldQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  split;intro.\n  apply pred_le.\n  apply prime_rel_prime;apply gcd_sym;trivial.\n  apply prime_rel_prime;apply gcd_sym;trivial.\n  rewrite H;trivial.\n  rewrite H;trivial.\n  rewrite H;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply (H d n).\n  rewrite (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; assumption.\n  apply H0.\n  apply (H d n).\n  rewrite (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply H0.\n  apply (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply (H d n).\n  rewrite (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\n  apply (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; assumption.\n  apply (H d n).\n  rewrite (H d n).\n  unfold rel_prime; apply gcd_sym; apply gcd_sym; apply gcdQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply (prime_div a n);trivial.\n  apply (prime_div a n);trivial.\n  apply (prime_div a n);trivial.\n  apply (prime_div b n);trivial.\n  apply (prime_div a n);trivial.\n  apply (prime_div a n);trivial.\n  apply (prime_div b n);trivial.\n  apply (prime_div a n);trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  rewrite <- (mult_1_r (n>0)).\n  rewrite <- (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite <- (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite <- (mult_1_r (n>0)).\n  rewrite <- (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_2_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n  rewrite (mult_1_r (n>0)).\n Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply power_rel_prime with a;auto.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a b);intro.\n  apply prime_mult;trivial.\n  generalize (gcd_is_gcd a bQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime; apply gcd_sym;apply gcd_sym;apply gcd_sym; trivial.\n  apply H.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply (div_divide a n);trivial.\n  apply (div_divide a n);trivial.\n  apply (div_divide a n);trivial.\n  apply (div_divide a n);trivial.\n  apply (div_divide a n);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\nLemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  destruct n;simpl;intros.\n  inversion H.\n  elim (mult_rel_prime a d (power d n));auto.\nQed.\n\n(** if n>0 and m>0 then gcd(a^n,b^m)=1 iff gcd(a,b)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 16545,
                "proof_end_offset": 16906,
                "proof": "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\nsplit;intro.\napply power_rel_prime with m;trivial;apply rel_prime_sym;apply power_rel_prime with n;trivial;apply rel_prime_sym;trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power;apply rel_prime_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime.\n  apply H;unfold is_gcd, divide_prime, divide_prime;trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_prime;trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_prime;trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_prime;trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_trivial.\n  apply H;unfold is_gcd, divide_prime, divide_trivial.\n  apply H;unfoldQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply power_rel_prime; assumption.\n  apply powerQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime with (power d n);auto.\n  apply power_rel_prime;auto.\n  generalize (IHn H);intro.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime_mult;trivial.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;intro.\n  apply H0;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H0;unfold is_cd;tauto.\n  apply H0;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H1;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H0;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H1;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H1;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H1;unfold is_cd;tauto.\n  generalize (IHn a b m H1);intro.\n  apply H1;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H0;unfold is_cd;tauto.\n  generalize (IHn a b m H0 H1);intro.\n  apply H1Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_primeQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  case (div_mod a b);intros.\n  apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym; apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym;apply gcd_sym; apply gcd_sym; apply gcd_sym;\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime.\n  apply power_rel_prime.\n  apply power_rel_prime.\n  apply power_rel_prime.\n  apply power_rel_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply power_rel_prime.\n  apply power_prime.\n  apply exp_0.\n  apply power_rel_prime.\n  apply powerQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply power_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply mod_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply div_rel_prime.\n  apply div_prime.\n  apply div_prime.\n  apply mod_rel_prime.\n  apply mod_prime.\n  apply div_rel_prime.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\n",
                "context_tokens": 275,
                "proof_start_offset": 1044,
                "proof_end_offset": 1166,
                "proof": "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_simpl_lemma.\n apply square_lemma.\n apply square_mult_simpl_lemma.\n apply square_simpl_lemma.\n apply square_mult_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_lemma.\n apply square_mult_simpl_lemma.\n apply square_mult_simpl_lemma.Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n unfold square, square, square, square, square, square, square, square, square, square, square.\n intros.\n generalize ( square_mult_1_l a b H); intro.\n apply square_mult_upper_bound; auto with zarith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b Ha.\ndestruct (le_dec a b) as [Ha|Ha].\nleft; rewrite H; auto.\nleft; rewrite H; auto.\nleft; rewrite H; auto.\nright; rewrite H; auto.\nright; rewrite H; auto.\nright; rewrite H; auto.\nright; rewrite H; auto.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b Ha Hb.\n rewrite (square_correct (a*b)); trivial.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros.\n apply square_mult_lemma.\n apply le_plus_minus_l.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n applyQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b Ha Hb.\n unfold square.\n rewrite (square_correct (a*b)).\n apply square_mult_lemma; auto.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros; apply square_mult_lemma; auto.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros.\n unfold square.\n unfold square.\n apply mult_le_compat_r.\n rewrite <- (mult_1_r b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_1_l b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_r b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_1_r b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_distr_r b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_assoc b).\n rewrite <- (mult_distr_l b).\n rewrite <- (mult_assoc b).\n rewrite <-Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros.\n unfold square.\n unfold square.\n unfold square.\n apply square_mult_lemma; simpl; auto with zarith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b Ha.\n apply (square_correct a b Ha).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 1331,
                "proof_end_offset": 1483,
                "proof": "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\ninduction n;simpl;trivial.\nintros;rewrite (IHn x y);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  apply power_mult_lemma1.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n.\n  simpl; auto with arith.\n  apply mult_le_compat_l.\n  simpl; auto with arith.\n  rewrite IHn.\n  rewrite (mult_comm x).\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  rewrite (power_mult_lemma1 n x y H).\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  Proof.\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  induction n.\n  - reflexivity.\n  - intros.\n    simpl.\n    rewrite (power_pos_plus_full _ x).\n    destruct (power_pos_plus_full _ x) as [n' [H1 H2]].\n    apply (power_pos_plus_full _ _ H1).\n  - intros.\n    simpl.\n    rewrite (power_pos_plus_full _ _ x).\n    destruct (power_pos_plus_full _ x) as [n' [H1 H2]].\n    apply (power_pos_plus_full _ _ H1).\n  - intros.\n    simpl.\n    rewrite (power_pos_plus_full _ _ x).\n    destruct (power_pos_plus_full _ x) as [n' [H1 H2]].\n    apply (power_pos_plus_full _ _ H1).\n  - intros.\n    simpl.\n    rewrite (power_pos_plus_full _ _ x).\n    destruct (power_pos_plus_full _ x) as [n' [H1 H2]].\n    apply (power_pos_plus_full _ _ H1).\n  - intros.\n    simpl.\n    rewrite (Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  Proof.\n   induction n as [| n Hrec]; intros; ring.\n  simpl in |- *.\n  case (power_pos (x*y)); intros.\n  rewrite H; ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold power.\n  intros.\n  apply power_mult_lemma1.\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewrite <- (pow_plus_distr_r n (x*y)).\n  rewriteQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  case (power_le_dec x y); trivial.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.\n  simpl in |- *; intros.\n  elim n; trivial.Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold power.\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  intros.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1485,
                "proof_end_offset": 1642,
                "proof": "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\nProof.\ninduction n;simpl;intros.\nauto with arith.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  intros.\n  rewrite (power_plus_lemma1 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);ring.\n  rewrite (power_plus_lemma2 n m x);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\n",
                "context_tokens": 483,
                "proof_start_offset": 1644,
                "proof_end_offset": 1799,
                "proof": "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\nProof.\ninduction n;simpl;intros.\ninversion H.\nexists (power x n);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros.\n  case (power_nat x); intros.\n  simpl; auto with arith.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;auto with arith.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;auto with arith.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\n",
                "context_tokens": 536,
                "proof_start_offset": 1801,
                "proof_end_offset": 2053,
                "proof": "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\nProof.\ninduction n;simpl;intros.\ninduction m;simpl;auto with arith.\nrewrite IHm;ring.\nrewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;auto with arith.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;auto.\n  simpl;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;auto with arith.\n  intros; rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;auto with arith.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;trivial.\n  intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x m);ring.\n  rewrite IHn;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\n",
                "context_tokens": 619,
                "proof_start_offset": 2055,
                "proof_end_offset": 2202,
                "proof": "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\ninduction n;simpl;intros.\ndiscriminate.\ncase (mult_lemma2 x (power x n) H);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  rewrite (power_1_l x);ring.\n  rewrite (power_1_l x);ring.\n  rewrite (power_1_l x);ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  rewrite (power_plus_one n (power x n)) at 1.\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power x n)).\n  rewrite (power_plus_one n (power xQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  rewrite (IHn x n);ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  apply power_le_lemma1.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  intros.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_l.\n  rewrite power_plus_distr_r.\n  rewrite power_plus_distr_l.Qed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  intros.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_l n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_r n (power x n)) at 1.\n  rewrite (power_plus_one_l n (power x n)) at 1.\n  rewrite (power_plus_one_l n (power x n)) at 1.\n  rewrite <-Qed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  apply (power_mult_lemma1 n x y);ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  intros; elim n;simpl;intros.\n  simpl;ring.\n  apply IHn;ring.\n  rewrite IHn;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\n",
                "context_tokens": 692,
                "proof_start_offset": 2237,
                "proof_end_offset": 2543,
                "proof": "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\ninduction m;simpl;try omega;intros.\ndestruct m;simpl;try omega.\nsimpl in IHm.\nassert (1 < p*(power p m)).\napply IHm;auto with arith.\nrewrite mult_comm.\napply lt_trans with (1*p);try omega.\napply mult_lt_compat_r;try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  rewrite (power_S_eq p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_1 p);simpl;rewrite <- IHn;ring.\n  apply (power_le_gt_0Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  simpl;auto with arith.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  discriminate.\n  case (mult_lemma2 y (power x n) H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y (power x n) H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y (power y n) H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y n);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y (power x n) H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y n H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y n H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y n H);auto.\n  rewrite <- (power_nat_S p) at 1.\n  case (mult_lemma2 y n H);auto.\n Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x p);auto.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ringQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  rewrite (power_S_S n) in H.\n  apply (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n m);auto with arith.\n  rewrite (power_S_le n mQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  apply (power_le_reg_l 0 m H).\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_le.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_trans with (power x n);auto with arith.\n  rewrite <- (power_plus_assoc _ H).\n  apply power_le_compat.\n  apply le_Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  rewrite <- (power_S_m_equiv p m);rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_m_equiv p m);auto.\n  rewrite <- (power_S_equiv p m);auto.\n  rewrite <- (power_S_equiv p m);auto.\n  rewriteQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\n  rewrite <- IHn;ring.\n  rewrite <- IHn;ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p m);auto with arith.\n  rewrite (IHn p mQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\n",
                "context_tokens": 740,
                "proof_start_offset": 2560,
                "proof_end_offset": 2661,
                "proof": "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\ninduction n;simpl;trivial.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros;try omega.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < n*m).\n  apply (IHn x y);auto with arith.\n  apply IHn;auto with arith.\n  apply (IHn x y);auto with arith.\n  apply (IHn x y);auto with arith.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  rewrite (power_one n);simpl;auto with arith.\n  simpl;auto with arith.\n  apply mult_lt_compat_l.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  apply mult_lt_compat_l.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one (S n));simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simpl;auto with arith.\n  rewrite <- (power_one n);simplQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  inversion H.\n  simpl;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  unfold power, power.\n  intros.\n  case (power_pos n);intros.\n  case (power_pos n);intros.\n  rewrite (IHn n);intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_pos p n));intros.\n  rewrite (IHn (power_posQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  discriminate.\n  case n;simpl;intros.\n  rewrite (IHn _ H0);ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y y);ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  simpl;trivial.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHnQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  unfold power.\n  intros.\n  case (mult_lemma2 x n H);intros.\n  rewrite (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).\n  simpl;try omega.\n  rewrite <- (power_pos x).Qed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  simpl;try omega.\n  rewrite <- (power_plus_distr_l n).\n  rewrite <- (power_plus_distr_l n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_l n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_distr_l n).\n  rewrite <- (power_plus_distr_r n).\n  rewrite <- (power_plus_Qed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  intros; destruct n.\n  reflexivity.\n  apply power_le;auto with arith.\n  apply power_le;auto with arith.\n  apply mult_lt_compat_r;try omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": ".  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\nLemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;trivial.\n  rewrite IHn;ring.\nQed.\n\n(** if x>1 and x^m | x^n then m<=n *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2701,
                "proof_end_offset": 3361,
                "proof": "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\nintros.\ncase (le_lt_dec m n);trivial.\nintro.\ngeneralize (le_plus_minus n m);intro.\nrewrite H1 in H0;try omega.\nelim H0;intro q;rewrite power_plus_lemma1;intro.\nassert (1=(power x (m-n))*q).\napply mult_lemma6 with (power x n).\nintro;generalize (power_zero n x H3);omega.\nrewrite mult_assoc;rewrite <- H2;ring.\nsymmetry in H3;elim (mult_lemma5 (power x (m-n)) q H3);intros.\ncase (eq_nat_dec (m-n) 0);intro;try omega.\nassert (x=1);try omega.\napply divides_antisym;[apply one_min_div | rewrite <- H4;apply power_divides_lemma1;omega].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn xQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  trivial.\n  elim H; simpl;try omega.\n  trivial.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  trivial.\n  simpl;try omega.\n  trivial.\n  destruct m;simpl;try omega.\n  trivial.\n  trivial.\n  simpl;try omega.\n  trivial.\n  destruct m;simpl;try omega.\n  trivial.\n  trivial.\n  destruct m;simpl;try omega.\n  trivial.\n  destruct m;simpl;try omega.\n  trivial.\n  trivial.\n  simpl;try omega.\n  trivial.\n  trivial.\n  simpl;try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl;try omega.\n  trivial.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simpl; try omega.\n  trivial.\n  trivial.\n  simplQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn xQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  trivial with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewriteQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite IHn;ring.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y n);ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;trivial.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn x y);ring.\n  rewrite (IHn y y);ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  rewrite IHn;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  intros n0 H.\n  exists 0%nat.\n  split.\n  apply le_trans with (2 * q * q * q * q + 1).\n  apply le_trans with (2 * q * q * q + 1).\n  apply le_trans with (2 * q * q * q * q + 1).\n  apply le_trans with (2 * q * q * q + 1).\n  apply le_trans with (2 * q * q * q + 1).\n  apply le_trans with (2 * q * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2 * q * q + 1).\n  apply le_trans with (2 * q + 1).\n  apply le_trans with (2Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intro.\n  exists 1%nat.\n  split.\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * b)).\n  apply (mult_comm (a * bQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intros n; case (le_gt_dec n 1); intro H1;\n    [ intros H2; exists (S n); split; assumption | idtac ] ].\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply (le_trans _ _ H).\n apply le_trans with (n := 0).\n assumption.\n apply le_trans with (m := 0).\n assumption.\n apply le_trans with (n := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumption.\n apply le_trans with (m := 1).\n assumptionQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold modulo, modulo.\n intros n H.\n rewrite (abs_eq (b*q)).\n destruct (Z_eq_dec (b*q)).\n rewrite (abs_eq (b*q)).\n destruct (Z_eq_dec (b*q)).\n apply Zgt_lt.\n rewrite (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\n apply (abs_eq (b*q)).\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; intros;\n elim n; simpl in |- *; intros; elim n; simpl in |- *; intros;\n elim n; simpl in |- *; intros; elim n; simpl in |- *; intros;\n elim n; simpl in |- *; intros; elim n; simpl in |- *; intros; elim n; simpl in |- *;\n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *;\n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; \n intros; elim n; simpl in |- *; intros; elim n; simpl in |- *; \n intros; elim n;Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n    intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n      intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n       intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n          intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n          intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n          intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n          intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim HQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply (non_zero_or_zero b).\n apply H.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  intros.  exists 1.  split; assumption.\n  simpl in |- *.  intros.  exists 1.  split; assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n intro.\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_P_eq_dec n 1).\n rewrite (eq_nat_of_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists 0%nat.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists n.\n  auto with arith.\n  intros.\n  elim H.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H0.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H0.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H0.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H0.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zero_min_div n).\n  auto with arith.\n  intros.\n  elim H1.\n  exists (zeroQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply lt_le_weak.\n  apply le_trans with (S (S (S (S (S n)))) (S (S n)) (S (S (S n))))\n   (S (S (S (S n))))\n   (S (S (S (S (S n)))) (S (S (S (S (S n))))\n   (S (S (S (S (S (S n)))) (S (S (S n))))\n   (S (S (S (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S n))))\n   (S (S (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S (S (S n))))\n   (S (S (S (S (S n)))) (S (S (S (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S (S (S n))))\n   (S (S (S (S (S n)))) (S (S (S (S n)))) (S (S (S (SQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n  apply (same_zero_min_div n).\n Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (n := n).\n  apply le_trans with (S n).\n  apply le_n_S.\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_n_S.\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_n_S.\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_n_S.\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_n_S.\n  apply le_trans with (S n).\n  applyQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (m := n).\n  apply (le_trans _ _ (le_S _ _ H)).\n  apply lt_le_trans with (m := n).\n  apply le_lt_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  applyQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  exists 0%nat.\n  apply le_trans with (m := n).\n  apply le_O_Sn.\n  apply le_O_Sn.\n  apply le_n_Sn.\n  apply le_O_Sn.\n  apply le_Sn_n.\n  apply le_trans with (m := n).\n  apply le_O_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_trans with (m := n).\n  apply le_O_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_trans with (m := n).\n  apply le_n_Sn.\n  apply le_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_trans with (m := n).\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply leQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply (lt_trans_n_O _ H).\n  apply (lt_trans_n_O _ H).\n  apply (le_trans_O_n _ _ H).\n  apply le_lt_trans with (m := n).\n  apply le_lt_trans with (m := n).\n  apply le_lt_n_S.\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_lt_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_lt_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (mQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply pred_le_dec.\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S (S n)).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply le_trans with (S n).\n  apply leQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists O.\n  auto with arith.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply prime_refl.\n  apply prime_refl.\n  apply prime_refl.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with q; assumption.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with q; assumption.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans.\n  apply prime_sym.\n  apply prime_sym.\n  apply (prime_sym _ _ (prime_sym _ _)).\n  apply primeQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  case (prime_dec a 0).\n  intro.\n  case (prime_dec a 0).\n  intro.\n  case H.\n  intro.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  elim H.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists (S n).\n  apply prime_refl.\n  apply prime_refl.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.\n  apply prime_trans with (S n).\n  apply prime_sym.Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_dec a b).\n  apply (prime_is_prime_dec a b).\n  apply (prime_is_dec a b).\n  apply (prime_is_prime_decQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  elim H.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  case (prime_dec a b); intros.\n  exists 1.\n  auto with arith.\n  intros.\n  apply (divide_refl a); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  elim H.\n  apply le_refl.\n  apply prime_sym.\n  apply (euclid a b).\n  apply (euclid b).\n  apply (euclid a b).\n  assumption.\n  assumption.\n  apply (euclid a b).\n  assumption.\n  apply (euclid a b).\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  apply (euclid a b).\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply (prime_le_dec a b); auto with arith.\n  intros.\n  apply (prime_le_dec a b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arith.\n  intros.\n  apply (prime_le_dec b); auto with arithQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply mod_sym.\n  apply prime_trans with b.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym a b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym a); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (prime_antisym b); assumption.\n  apply (primeQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro H; elim H;intro H; elim H;intro H; elim H;intro H;\n    [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n        [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n        [ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n          [ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n          [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n          [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n          [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n            [ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n                [ intro H; elim H; intro H; elim H; intro H; elim H; intro H;\n                [ intro H; elimQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply prime_sym.\n  apply prime_sym.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply (prime_le_trans _ _ (prime_le_weak _ _ H)).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_le_weak _ _ H).\n  apply (prime_Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply gcd_refl.\n  apply H.\n  elim H; intro H; elim H0; intro H0.\n  elim H0; intro H1; elim H1; intro H2; elim H2; intro H3;\n    elim H0; intro H4; elim H4; intro H5;\n      elim H4; intro H5; elim H5; intro H6;\n        elim H5; intro H5; elim H6; intro H6;\n          elim H5; intro H7; elim H8; intro H7;\n          elim H8; intro H8; elim H8; intro H9;\n            elim H9; intro H9; elim H9; intro H9;\n              elim H9; intro H9; elim H9; intro H9;\n                elim H9; intro H9; elim H10; intro H9;\n                elim H10; intro H9; elim H10; intro H9;\n                elim H9; intro H9; elim H9; intro H10;\n                elim H10; intro H9; elim H10; intro H10;\n                elim H10; intro H9; elim H10; intro H10Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H2; intro.\n  elim H2; intro.\n  elim H3; intro.\n  elim H3; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elimQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro H; elim H;intro H; elim H; intro H1; elim H; intro H2;\n    [ intro H1; elim H1; intro H2; elim H2; intro H3;\n      [ intro H3; elim H3; intro H4; elim H3; intro H4;\n          [ intro H5; elim H4; intro H5; elim H5; intro H6;\n          [ intro H5; elim H5; intro H5; elim H5; intro H5;\n          [ intro H6; elim H5; intro H5; elim H6; intro H6;\n          [ intro H5; elim H6; intro H6; elim H7; intro H7;\n          [ intro H6; elim H7; intro H6; elim H7; intro H8;\n            [ intro H6; elim H7; intro H9; elim H9; intro H9;\n            [ intro H9; elim H9; intro H9; elim H9; intro H10; elim H9;\n              [ intro H9; elim H10; intro H9; elim H10; intro H11; elim HQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro q; elim H;intro q';intro q'; elim H';intro q'.\n  elim H0; intro q'; intro q'; elim H'.\n  elim H0; intro q'; elim H0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n    elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n    elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0;\n      intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n      elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0;\n      intro q'; elim H'0; intro q'; elim H'0; intro q'0';\n      elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0;\n      intro q'; elim H'0; intro q'; elim H'0; intro q'; elimQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro.\n  elim H0;intro.\n  elim H1;intro.\n  rewrite H1.\n  elim H1;intro.\n  elim H0;intro.\n  elim H1; intro.\n  elim H1; intro.\n  rewrite H2.\n  elim H1; intro.\n  elim H1; intro.\n  rewrite H2.\n  elim H2; intro.\n  elim H2; intro.\n  elim H3; intro.\n  elim H2; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H5; intro.\n  rewrite H5.\n  elim H3; intro.\n  rewrite H4.\n  elim H4; intro.\n  elim H5; intro.\n  rewrite H5.\n  elim H5; intro.\n  rewrite H5.\n  elim H5; intro.\n  rewrite H5.\n  elim H5; intro.\n  rewrite H5.\n  elim H6; intro.\n  elim H6; intro.\n  rewrite H6.\n  elim H6; intro.\n  rewrite H6.\n  elim H6; intro.\n  rewrite H5.\n  elim H5; intro.\n  rewrite H6.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2349,
                "proof_end_offset": 2501,
                "proof": "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\nintros.\nred.\nintro.\napply H.\napply divides_antisym;trivial.\napply one_min_div.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  apply (le_le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ H).\n  apply (le_not_le _ _ HQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  case (le_or_lt 0 a); intro H1; elim H1; intro H2;\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm b); apply H2.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm b); apply H1.\n  rewrite (mult_comm a b); apply H2.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply H1.\n  rewrite (mult_comm a b); apply HQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H;intro q; elim q;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim H6;intro.\n  elim HQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  apply (div_1 a); auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H;intro q';intro.\n  elim H;intro.\n  elim H0;intro.\n  elim H0;intro.\n  rewrite H2 in H2; rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;\n    rewrite <- plus_comm in H2;simpl in H2;rewrite plus_comm in H2;\n    rewrite <- mult_assoc in H2;simpl in H2; rewrite plus_comm in H2;\n    rewrite <- plus_comm in H2;simpl in H2; rewrite plus_comm in H2;\n      rewrite <- plus_comm in H2;simpl in H2; rewrite plus_comm in H2;\n      rewrite <- plus_assoc in H2; rewrite <- plus_comm in H2;\n      rewrite <- plus_comm in H2; rewrite <- plus_comm in H2;\n      rewrite <- plus_assoc in H2; rewrite <- plus_comm in H2;\n      rewrite <- plus_comm in H2; rewrite <- plus_assoc in H2;\n      rewrite <- plus_comm in H2; rewrite <- plus_comm in H2;\n      rewrite <- plus_comm in HQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  apply (prime_le_weak a b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  apply (prime_le_weak b).\n  applyQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'.\n  elim H0;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  apply (mod_intro a);intro.\n  elim H;intro.\n  elim H0;intro.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  rewrite H1 in HQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H;intro q;intro q; elim H;intro q; intro.\n  rewrite H2 in H;rewrite (mult_comm a b) in H;rewrite H; assumption.\n  elim (mult_lemma1 a b);intros.\n  rewrite H4 in H;rewrite (mult_comm b (q * q)); assumption.\n  elim (mult_lemma1 a b);intros.\n  rewrite H5 in H; rewrite (mult_comm b (q * q)); assumption.\n  elim (mult_lemma1 a b);intros.\n  rewrite H5 in H; rewrite (mult_comm b (q * q)); assumption.\n  elim (mult_lemma1 a b); intros.\n  rewrite H5 in H; rewrite (mult_comm b (q * q)); assumption.\n  elim (mult_lemma2 a b); intros.\n  rewrite H5 in H; rewrite (mult_comm a (q * q)); assumption.\n  elim (mult_lemma2 a b); intros.\n  rewrite H5 in H; rewrite (mult_comm b (q * q)); assumption.\n  elim (mult_lemma2 a b); intros.\n  rewrite H5 in H; rewriteQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  apply (rel_prime_dec a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "s *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2544,
                "proof_end_offset": 2770,
                "proof": "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nexists (q+q').\nrewrite H1;rewrite H2.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply prime_trans with (b*(d' * d')).\n  apply mult_le_reg_l with (d' * d').\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * d')).\n  apply (mult_le_reg_l (d' * dQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply (prime_le a b); auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply (gcd_sym a b); auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H;intro.\n  rewrite H0; assumption.\n  elim H0; intro.\n  rewrite H0; assumption.\n  elim H0; intro.\n  rewrite H2 in H2.\n  elim H2; intro.\n  rewrite H3 in H2.\n  elim H3; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H3 in H2.\n  elim H3; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H2 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n  elim H2; intro.\n  rewrite H4 in H2.\n Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H;intro q; elim H0;intro q; elim H0; intro q;\n    rewrite <- H2 in H2;\n      rewrite (mult_comm a b) in H2;\n        rewrite (mult_comm a b) in H2;\n        rewrite (mult_comm a b) in H2;\n        rewrite (mult_comm a b) in H2;\n        rewrite (mult_comm a b) in H2; rewrite (mult_comm a b) in H2;\n          rewrite (mult_comm b b) in H2;\n            rewrite (mult_comm a b) in H2; rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm b b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm a b) in H2;\n            rewrite (mult_comm b b) in H2;\n            rewrite (multQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply (gcd_sym a d a).\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H;intro q; elim H0;intro q; elim H0; intro q; elim H0; intro q; elim q; intros q0; elim q0;\n    intro q0'; elim q0; intro q0'; elim q0'; intro q0'; elim q0'; intro q0'; elim q0';\n    intro q0'; elim q0'; intro q1'; elim q0'; intro q1'; elim q0'; intro q2';\n    elim q0'; intro q1'; elim q1'; intro q1'; elim q1'; intro q2';\n    elim q0'; intro q2'; elim q0'; intro q3'; elim q3';\n    intro q4'; elim q1'; intro q4'; elim q4'; intro q4';\n    elim q0'; intro q4'; elim q4'; intro q4'; elim q4';\n    intro q4'; elim q4'; intro q4'; elim q4'; intro q4'; elim q4';\n    intro q4'; elim q4'; intro q4'; elim q4';\n    intro q4'; elim q4'; intro q4'; elim q4'; intro q5';\n   Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  case (le_or_lt a d); intro.\n  elim H0;intro.\n  rewrite H1 in H1.\n  elim H1;intro.\n  elim H0;intro.\n  rewrite H2 in H1.\n  elim H1;intro.\n  rewrite H3 in H1.\n  elim H1;intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H1 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  rewrite H4 in H1.\n  elim H1; intro.\n Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply not_le_elim; intro.\n  apply H.\n  apply (divide_trans (mult_comm d a b) (mult_comm (plus a b) d) (mult_comm (plus b d) d)).\n  apply (divide_trans (mult_comm d a b) (mult_comm (plus b d) d)).\n  apply (divide_trans (mult_comm d a) (mult_comm (plus b d) d)).\n  apply (divide_trans (mult_comm (plus b d) d)).\n  apply (divide_trans (mult_comm (mult b d) d).\n  apply (divide_trans (mult_comm (mult b d) d)).\n  apply (divide_trans (mult_comm (mult c d) d).\n  apply (divide_trans (mult_comm (mult b d) d)).\n  apply (divide_trans (mult_comm (mult b d) d)).\n  apply (divide_trans (mult_comm (mult b d) d)).\n  apply (divide_trans (mult_comm (mult b d) d)).\n  apply (divide_trans (mult_comm (mult b d)).\n  apply (Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  case (le_or_eq a b).\n  left.\n  elim H;intro.\n  elim H0;intro.\n  rewrite H1 in H1; rewrite H2 in H1; discriminate.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\n",
                "context_tokens": 732,
                "proof_start_offset": 2801,
                "proof_end_offset": 2971,
                "proof": "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nexists (b * q).\nrewrite H0.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  apply not_le_trans with (n:=n) (q:=a).\n  rewrite (Zmult_comm a d).\n  apply (Zmult_comm a d).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm a d).\n  rewrite (Zmult_comm (n:=a)).\n  rewrite (Zmult_comm a d).\n  rewrite (ZmultQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H;intro q;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro qQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n  intro q'; elim q; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n  intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q''; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n    intro q'; elim q'; intro q'; elim q'; intro q';Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  apply mod_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_sym;trivial.\n  apply or_symQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H;intro q;intro q;intro q';intro q';intro q'.\n  elim H0;intro q';intro q';intro q'0; elim H0; intro q'.\n  elim H1; intro q';intro q'0; elim H1; intro q'.\n  elim H1; intro q'0; elim H2; intro q'; elim H2; intro q'0; elim H3; intro q'.\n  elim H2; intro q'; elim H3; intro q'; elim H3; intro q'; elim H3; intro q'.\n  elim H3; intro q'; elim H3; intro q'; elim H4; intro q'0; elim H3; intro q'.\n  elim H3; intro q'; elim H4; intro q'0; elim H3; intro q'0; elim H4; intro q';\n    elim H4; intro q'0; elim H5; intro q'1; elim H5; intro q'1;\n      elim H5; intro q'1; elim H6; intro q'; elim H5; intro q'1;\n        elim H4; intro q'; elim H5Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q; elim H; intro q';intro.\n  exists (q+q').\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q;intro q; elim q; intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';introQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n  apply mod_mult.\n Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1.\n  rewrite H2.\n  rewrite H1.\n  rewrite H2.\n  rewrite H3.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3014,
                "proof_end_offset": 3325,
                "proof": "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H1;rewrite H2.\nexists (q'-q).\nrewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro q;intro q; elim q;intro.\n  elim H0; intro q'; elim q';intro.\n  elim H0; intro q'; elim q';intro q';intro.\n  elim H0; intro q'; elim q';intro.\n  elim H1; intro q'; elim q';intro.\n  elim H1; intro q'; elim q';intro.\n  elim H1; intro q'1; elim q';intro.\n  elim H1; intro q'; elim H2; intro q'; elim q';intro.\n  elim H2; intro q'; elim H3; intro q'; elim H3; intro q'; elim H4; intro q';\n    elim q'; intro q'; elim q'; intro.\n  elim H4; intro q'; elim q'; intro q'; elim H4; intro q';\n    elim H4; intro q'; elim H4; intro q'; elim H4; intro q';\n    elim H4; intro q'; elim H4; intro q'; elim H4; intro q';\n    elim H4; intro q'; elim H4; intro q'; elim H4; intro q';\n    elim H4; intro qQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro q;intro q; elim H;intro.\n  exists (b * d).\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intros.\n  elim H0; intro q'; elim H0; intro q'; elim q; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q';\n elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q';\n elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q';\n elim q'; intro q'; elim q'; intro q'; elim q'; intro q'; elim q';\n intro q'; elim q'; intro q'; elim q'; intro q'; elim q'; intro q'';\n elim q'; intro q'0'; elim q'; intro q'0; elim q'; intro q'0';\n elim q'; intro q'0'; elim q'; intro q'0'; elim q'; intro q';\n elim q'; intro q'; elim q'; intro q'0';\n elim q'; intro q'0'; elim q'; intro q'0Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro q0; elim H0; intro q0; elim H0; intro q0;\n    elim H1; intro q0; elim H0; intro q0; elim H0; intro q0;\n      elim H1; intro q0; elim H1; intro q0; elim H1; intro q1;\n          elim H1; intro q1; elim H1; intro q1; elim H1; intro q0; elim H1;\n            intro q1; elim H1; intro q1; elim H1; intro q1; elim H2;\n            intro q2; elim H3; intro q2; elim H3; intro q2; elim H3;\n            intro q2; elim H3; intro q3; elim H4; intro q3; elim H4;\n            intro q4; elim H4; intro q1; elim H4; intro q1; elim H4;\n            intro q1; elim H4; intro q2; elim H4; intro q2; elim H4;\n            intro q2; elim H4; intro qQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro.\n  elim H0;intro.\n  apply H0; elim H0;intro.\n  apply (divide_trans (b-a)).\n  apply H0; elim H0;intro.\n  elim H0; intro.\n  elim H0; intro.\n  apply H1; assumption.\n  elim H0; intro.\n  apply H1; assumption.\n  elim H0; intro.\n  apply (divide_trans (b-a)).\n  apply H0; elim H0; intro.\n  elim H1; intro.\n  apply (divide_trans (b-a)).\n  apply H0; assumption.\n  apply H0; elim H0; intro.\n  apply (divide_trans (b-a)).\n  apply H1; assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H; intro q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q0; elim q0; intro q1; elim q1; intro q2; elim q2;\n intro q1; elim q2; intro q3; elim q3; intro q3; elim q3;\n intro q4; elim q4; intro q4; elim q4; intro q4; elim q4;\n intro q5; elim q4; intro q5; elim q5; intro q5; elim q5;\n intro q5; elim q6; intro q6; elim q6; intro q6;\n elim q6; intro q6; elim q6; intro q7; elim q7;\n intro q5; elim q6; intro q6; elim q7; intro q6; elim q6;\n intro q7; elim q7; intro q7; elim q7; intro q8; elim q7;\n intro q8;Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold prime.\n  intros.\n  elim H; intro q; elim H0; intro q';intro q'.\n  rewrite H0 in H2.\n  elim (mult_lemma1 q' H2);intro q';intro q'.\n  rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q';intro q'.\n  rewrite H1; rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q'; intro q'.\n  rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q'.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q'.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q'.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  elim (mult_lemma1 q' H2);intro q'.\n  rewrite H2 in H2.\n  elim (mult_lemma2 q' H2);intro q'.\n  rewrite H2 in H2.\n  elim (Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro q; elim H0;intro q;intro q'.\n  elim H1;intro q';intro q'; elim H1; intro q'; intro q'.\n  elim H0; intro q'; elim H1; intro q'.\n  rewrite H2 in H1; rewrite H2 in H1; rewrite <- H1; assumption.\n  rewrite H1; rewrite H0; rewrite H0; rewrite H0; assumption.\n  rewrite H0; rewrite H0; assumption.\n  rewrite H1; assumption.\n  rewrite H0; assumption.\n  rewrite H1; assumption.\n  rewrite H0; assumption.\n  rewrite H0; assumption.\n  rewrite H0; assumption.\n  rewrite H1; assumption.\n  rewrite H1; assumption.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H; intro.\n  elim H0; intro q';intro.\n  elim H0; intro.\n  exists (q' * q').\n  rewrite H1.\n  ring.\n  intros.\n  elim H0; intro q'; elim H1; intro q';intro.\n  exists (q' * q').\n  rewrite H1.\n  ring.\n  intros.\n  elim H0; intro q'; elim H1; intro q';intro.\n  elim H1; intro q'; elim H1; intro q';intro.\n  exists (q' * q').\n  rewrite H1.\n  ring.\n  intros.\n  elim H0; intro q'; elim H1; intro q'; elim H1; intro q';intro.\n  exists (q' * q').\n  rewrite H1.\n  ring.\n  intros.\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q'; elim H1; intro q';intro.\n  exists (q' * q').\n  rewrite H1.\n  ring.\n  intros.\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q'; intro.\n  exists (q'Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  intros.\n  elim H;intro q; elim H;intro q';intro.\n  exists (q+q').\n  rewrite H0.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\n",
                "context_tokens": 730,
                "proof_start_offset": 3412,
                "proof_end_offset": 4144,
                "proof": "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\nintros.\napply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\nintro.\ncase n;intros.\nexists 0;auto with arith.\nelim (H0 ((S n0)-b)).\nintro q;intro.\nexists (S q).\nreplace (S n0) with (b+(S n0-b)).\nrewrite p;rewrite plus_comm;auto with arith.\nsymmetry.\napply le_plus_minus.\nelim H1;intros.\nrewrite H2.\nreplace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\napply mult_le_compat_r.\ndestruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\nsimpl;auto with arith.\ndestruct b.\nelim H1;simpl;intros;discriminate.\nomega.\napply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q''';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro qQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros a b.\n  elim H;intro q';intro q';intro.\n  elim H0;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'.\n  elim H0;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';introQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q;intro q; elim H0;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'4';intro q';intro q'5;intro q';intro q'7; elim q';intro q';intro q';intro q';intro q';Qed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q';intro q';intro.\n  elim H0;intro q';intro q';intro.\n  elim H0;intro q';intro.\n  elim H1;intro q';intro.\n  elim H1;intro q';intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elimQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q;intro q'.\n  elim H0;intro q';intro q'0; elim H0;intro.\n  elim H0;intro q'1; elim H0;intro.\n  elim H1;intro q'1; elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H4;intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H6;intro.\n  elim HQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro.\n  rewrite H1 in H1; rewrite H1; assumption.\n  apply (mult_le_compat_l (b-a) (b-a));auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'.\n  elim H'0;intro q';intro q';intro q';intro q';intro q';intro q';intro q'.\n  rewrite H'0; rewrite (mult_comm d' q); rewrite (mult_comm d' (q'-q)); auto with arith.\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q)).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  apply (mult_comm d' (q'-q')).\n  applyQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q';intro q'.\n  elim H; intro q';intro q'; elim H'0; intro q';intro.\n  elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n  elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0;\n    intro q'; elim H'0; intro q'; elim H'1; intro q'; elim H'0; intro q'; elim H'0;\n      intro q'; elim H'0; intro q'; elim H'0; intro q'1; elim H'0; intro q';\n      elim H'0; intro q'; elim H'0; intro q'; elim H'1; intro q'; elim H'0; intro q'; elim H'0;\n          intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro qQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H;intro q';intro.\n  elim H0;intro q';intro q';intro q'.\n  elim H0;intro q';intro q'.\n  elim H0;intro q';intro q';intro q'.\n  elim H0; intro q';intro q'0.\n  elim H0;intro q';intro q'0; elim H0; intro q'0.\n  elim H0; intro q';intro q'0; elim H1; intro q'0; elim H1; intro q'0.\n  elim H1; intro q'; intro q'0; elim H0; intro q'1.\n  elim H0; intro q'; elim H1; intro q'0; elim H1; intro q'1; elim H1; intro q'1.\n  elim H1; intro q'0; elim H1; intro q'1; elim H1; intro q'1; elim H1; intro q'0;\n    elim H1; intro q'1; elim H1; intro q'1; elim H1; intro q'1;\n    elim H1; intro q'1; elim H1; intro q'Qed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q';intro q';intro q'.\n  elim H'0;intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q'';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';intro q';introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": ".\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\n",
                "context_tokens": 727,
                "proof_start_offset": 4328,
                "proof_end_offset": 4482,
                "proof": "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\nintros.\nunfold quo.\ngeneralize (quo_dec a b H);intro;elim s;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  apply ( quo_is_quo (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r) (r:=r)Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  elim H;intro H;intro.\n  exists (mult b (quo a (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b)))) q))).\n  apply (r*(a/b)); trivial.\n  intros.\n  elim H0;intro H1; elim H1;intro H2; elim H2;intros.\n  exists (mult b (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b)))) q))).\n  apply (r*(a/b)); trivial.\n  intros.\n  elim H0;intro H1; elim H2;intro H2; elim H2;intros.\n  exists (mult b (complement b (complement b (complement b (complement b (complement b (complement b (complement b)))))))) q).\n  apply (r*(a/b)); trivial.\n  intros.\n  elim H0;intro H2; elim H2;intros.\n  exists (mult b (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b (complement b)))) q))).\n Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nintros.\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) (y:=x) (y:=y) (y:=y) (y:=y) H)).\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) (y:=x) (y:=y) (y:=y) H)).\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) (y:=y) H))).\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) (y:=x) (y:=y) H))).\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) H))).\napply (mod_le b (fun x:nat => (x=x) (y:=x) (y:=x) H))).\napply (mod_le b (fun x:nat => (x=x) (y:=x)Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  unfold modulo.\n  intros.\n  elim H;intro q; elim H; intro q; elim H; intro q; elim H; intro q; elim H; intro q; elim H; intro q; elim H; clear H;\n   intros q H0; elim H0; intro q; elim H0; intro q; elim H0; intro q; elim H0; intro q; elim H0;\n   intro q; elim H0; intro q; elim H0; intro q; elim H1; intro q; elim H1;\n   intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n   intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n   intro q; elim H1; intro q; elim H1; intro q; elim H1; intros q; elim H1;\n   intro q; elim H2; intro q; elim H3; intro q; elim H2;\n   intro q; elim H3; intro q; elim H3; intro q; elim H4;\n   intro q; elim H4;Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  elim H;intro q;intro q; elim H;intro q;intro q; elim H; intro q; elim H; intro q; elim H; intro q;\n elim H0; intro q; elim H0; intro q; elim H0; intro q; elim H0; intro q;\n elim H0; intro q; elim H1; intro q; elim H0; intro q; elim H0; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H2; intro q; elim H3;\n intro q; elim H2; intro q; elim H3; intro q; elim H3; intro q; elim H3;\n intro q; elim H3; intro q; elim H4; intro q; elim H5;\n intro q; elim H4; intro q; elim H5; introQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  apply (add_cancel_l (fun x:nat => (x=y) (r:=x)).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_r with (r:=x).\n  apply add_cancel_l with (r:=x).\n  apply add_cancel_r with (r:=x).\n  apply add_cancel_r with (r:=x).\n  apply add_cancel_r with (r:=x).\n  apply add_cancel_r withQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nunfold quo; intros.\nelim H;intro q;intro.\nelim H0;intro.\nelim H0;intro q; elim H0;intro q; elim H0; intro q; elim H0; intro q; elim H0; intro q; elim H0;\n intro q; elim q; intro q; elim H0; intro q; elim H0; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1; intro q; elim H1;\n intro q; elim H1; intro q; elim H1; intro q; elim H1Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  unfold quo; intros.\n  elim (H 0); intro.\n  exists (r-a).\n  rewrite H0; rewrite H; auto with arith.\n  elim (H 0); intro.\n  rewrite H0; rewrite H; auto with arith.\n  elim H1; intro.\n  rewrite H0; auto with arith.\n  elim (H0 (r-a)); auto with arith.\n  elim H2; intro.\n  rewrite H1; auto with arith.\n  elim (H0 (r-a)); auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim (H0 (r-a)); auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim H2; intro.\n  rewrite H1; auto with arith.\n  elim (H 0 (r-a)); auto with arith.\n  elim H2; intro.\n  rewrite H2; auto with arith.\n  elim (H 0 (r-a)); auto with arithQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  elim H;intro q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  apply (lt_wf_rec b (fun x:nat => (x + y)%nat)).\n  apply le_trans with (mult (r + y)%nat).\n  apply (le_mult_reg_l (r + y)%nat).\n  apply le_mult_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r + y)%nat.\n  apply mult_le_reg_l with (r := r).\n  apply mult_le_reg_l with (r := r).\n  apply mult_le_reg_l with (r := r).\n  apply mult_le_reg_l with (r := r).\n  apply mult_le_reg_l with (r := r).\n  apply mult_le_reg_l with (r := r).\n  apply mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\nLemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  unfold quo.\n  generalize (quo_dec a b H);intro;elim s;trivial.\nQed.\n\n(** if b | a then (n*a/b) = n*(a/b) *) \n",
                "context_tokens": 706,
                "proof_start_offset": 4524,
                "proof_end_offset": 5018,
                "proof": "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\nintros.\ngeneralize (quo_is_quo (a*n) b (divides_mult b a n H));intro.\ngeneralize (quo_is_quo a b H);intro.\nreplace (a*n = b * quo (a * n) b (divides_mult b a n H)) with (b*(quo a b H)*n = b * quo (a * n) b (divides_mult b a n H)) in H1.\nsymmetry;rewrite mult_comm.\napply mult_lemma6 with b;trivial.\nrewrite mult_assoc;trivial.\nrewrite <- H2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (fun n:nat => (n*a) n) a H); trivial.\n  apply (lt_wf_rec a (Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  elim H;intro H'.\n  exists (n * a); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * a); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * b); auto with arith.\n  exists (S n); auto with arith.\n  exists (S (n * b)); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * b); auto with arith.\n  exists (n * b); auto with arith.\n  exists (S (n * b)); auto with arith.\n  exists (S (n * b)); auto with arithQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (lt_wf_rec a b H);intro.\n  apply H;auto with arith.\n  rewrite <- (mult_comm a (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite (mult_comm (S n0)).\n  rewrite <- (mult_comm (S n0)).\n  rewrite <- (mult_Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (x = y)) (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_eq (b:=x)).\n  rewrite (same_not_Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (le_trans (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) H0)); trivial.\n  rewrite H0.\n  apply (le_trans (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) H0)); trivial.\n  rewrite H0.\n  apply (le_trans (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0)Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  generalize (mod_mult b a H);intro;elim s;trivial.\n  intros.\n  elim H0;intro q;elim H1;intro q;intros.\n  exists (r-p); rewrite H0.\n  rewrite H1; rewrite H2.\n  rewrite H0; rewrite H2.\n  apply (divides_minus b b (S n0));[apply mod_sym; assumption | apply mod_sym; assumption ].\n  intros.\n  exists (r-p); rewrite H0.\n  rewrite H0; rewrite H0; rewrite H2; rewrite H2.\n  rewrite H0; rewrite H1; rewrite H2; rewrite H2.\n  apply (divides_minus b (S n0));[apply mod_sym; assumption | apply mod_sym; assumption ].\n  intros.\n  exists (r-p); rewrite H0.\n  rewrite H0; rewrite H2; rewrite H2.\n  apply (divides_minus b (S n0));[apply mod_sym; assumption | apply mod_sym; assumption ].\n  intros.\n  exists (r-p); rewrite H0; rewrite H1; rewrite H2; rewrite H2; rewrite H2.Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (same_or_eq (fun x:nat => (x * y) * y) H0).\n  intro; elim H; intro.\n  rewrite H1; rewrite H2; rewrite H2; ring.\n  apply (same_or_eq (fun x:nat => (x * y) * y) H0).\n  intro; elim H0; intro.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))).\n  intros.\n  apply (sameQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (same_comp (fun p:nat => (p - p) (p - p)) (p - p)).\n  apply (same_comp (fun p:nat => (p - p) (p - p)).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p)).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_comp (fun p:nat => (p - p) (p - p))).\n  apply (same_compQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (le_trans (b*(n*a) b (divides_mult b a n H)).\n  apply (le_trans (b*(n*a) b (divides_mult b a n H))).\n  apply (le_trans (b*(n*a) b (divides_mult b a H))).\n  apply (le_trans (b*(n*a) b (divides_mult b a (S n H))).\n  apply (le_trans (b*(n*a) b (divides_mult b a (S n H))).\n  apply (le_trans (b*(n*a) b (divides_mult b (S n H))).\n  apply (le_trans (b*(n*a) b (divides_mult b a (S n H))).\n  apply (le_trans (b*(n*a) b (S n H))).\n  apply (le_trans (b*(n*a) b (S n H))).\n  apply (le_trans (b*(n*a) b (S n H))).\n  apply (le_trans (b*(n*a) b (S n H))).\n  apply (le_trans (b*(nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold quo.\n  generalize (quo_dec a b H);intro; elim H; intro r; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H);intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H);intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H);intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro; elim r; tauto.\n  unfold quo.\n  generalize (quo_dec a b H); intro;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\n",
                "context_tokens": 314,
                "proof_start_offset": 1197,
                "proof_end_offset": 1343,
                "proof": "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime.\nintro.\nelim H;intros.\ncase (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intro.\n apply False_ind.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  unfold is_prime, is_prime, is_prime, is_prime, is_prime, is_prime, not_prime, not_prime, not_prime.\n  intros; discriminate.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intro; apply not_prime_zero; apply not_prime_zero; apply not_prime_zero; apply not_prime_zero; apply not_prime_zero;\n    assumption.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n destruct (non_prime_zero_or_prime _ _ H); trivial.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n induction 1; simpl; intros; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl; trivial.\n simpl;Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  intros.\n  elim H; intro H; elim H; intro H0; elim H0; intro H0;\n    [ intros H0; elim H0; intro H1; elim H0; intro H1;\n      [ intros H1; elim H1; intro H1;\n        [ intros H2; elim H1; intro H1;\n          [ intros H2; elim H2; intro H2;\n            [ intros H3; elim H2; intro H2;\n              [ intros H3; elim H3; intro H3;\n              [ intros H4; elim H2; intro H3;\n              [ intros H4; elim H3; intro H4;\n              [ intros H4; elim H5; intro H4;\n              [ intros H5; elim H5; intro H2;\n              [ intros H5; elim H2; intro H2;\n              [ intros H6; elim H2; intro H2;\n                [ intros H5; elim H2; intro H2;\n                [ intros H6; elim H2; intro H2;\n                [ intros H6; elim H2; intro H2;\n                [ intros H6; elim H2;Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  unfold is_prime; intros; case (Z_dec p (Z_of_nat (S d)).\n  simpl; intros.\n  apply Z.le_lt_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.le_lt_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_trans with d.\n  apply Z.lt_le_Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not in |- *; intro H; elim H; auto.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  unfold is_prime, is_prime, is_prime, is_prime.\n  intros.\n  rewrite H.\n  unfold is_prime, is_prime.\n  apply prime_prime_zero.\n  apply prime_zero.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not in |- *; intro.\n apply (not_prime_zero _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\n",
                "context_tokens": 376,
                "proof_start_offset": 1372,
                "proof_end_offset": 1780,
                "proof": "Lemma is_prime_2 : (is_prime 2).\nProof.\nunfold is_prime.\nsplit.\nintro;discriminate.\nintros.\nelim H;destruct x;rewrite mult_comm.\nintro;discriminate.\nsimpl.\ncase d.\nsimpl.\nrewrite mult_comm;simpl;intro;discriminate.\nintros.\ninversion H0.\nsymmetry in H2.\ncase (plus_is_one n (x*(S n)) H2);intro.\nelim a;intros.\nleft;rewrite H1;trivial.\nelim a;intros.\nright;rewrite H1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H2 3);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 5);try (apply zero_min_div);intro; discriminate.\n  case (H 6);try (apply zero_min_div);intro; discriminate.\n  case (H 7);try (apply zero_min_div);intro; discriminate.\n  case (H 6);try (apply zero_min_div);intro; discriminate.\n  case (H 6);try (apply zero_minQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 3);try (apply zero_max_div);intro;discriminate.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 2);try (apply zero_min_div);intro;discriminate.\n  intro H0.\n  apply H1; assumption.\n  intro H0.\n  apply H1; assumption.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 2);try (apply zero_min_div);intro;discriminate.\n  rewrite H; assumption.\n  rewrite H0; assumption.\n  rewrite H0; assumption.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 2);try (apply zero_min_div);intro;discriminate.\n  case (H2 2);try (apply zero_min_div);intro;discriminate.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 4);try (apply zero_min_div);intro;discriminate.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H1 2);try (apply not_prime_zero; assumption).\n  intros.\n  case (H3 2);try (apply not_prime_zero; assumption).\n  intros.\n  case (H4 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H4 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H4 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H5 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H5 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H5 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H6 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H5 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H7 3);try (apply not_prime_zero; assumption).\n  intros.\n  case (H5 3);try (applyQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H2 3);try (apply zero_max_div);intro;discriminate.\n  apply H.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (H2 3);try (apply zero_min_div);intro;discriminate.\n  case (H2 5);try (apply zero_min_div);intro;discriminate.\n  case (H2 4);try (apply zero_min_div);intro;discriminate.\n  case (H4 5);try (apply zero_min_div);intro;discriminate.\n  case (H5 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply zero_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n  case (H2 5);try (apply succ_min_div);intro;discriminate.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\n",
                "context_tokens": 535,
                "proof_start_offset": 1852,
                "proof_end_offset": 2186,
                "proof": "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nunfold rel_prime.\nintros.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H;intros.\nelim H1;intros.\ncase (H3 d' H4);intro.\nrewrite H6;apply divides_refl.\nrewrite H6 in H5;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a; induction p.\n  simpl; reflexivity.\n  simpl; reflexivity.\n  simpl; reflexivity.\n  simpl; reflexivity.\n  simpl; reflexivity.\n  simpl; reflexivity.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  intro.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_3.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2.\n  apply not_prime_2Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  intro; discriminate.\n  simpl.\n  case p; simpl;intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case p; simpl; intros.\n  case (le_lt_eq_dec a p); intro;discriminate.\n Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intro;discriminate.\n  intros.\n  case p; try (apply pred_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_dec; assumption).\n  apply H;destruct a;try (apply succ_le_Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  intro;discriminate.\n  intros.\n  elim H;intros.\n  case (H1 3);try (apply zero_min_div);intro;discriminate.\n  apply H0.\n  right;auto.\n  intros.\n  inversion H0.\n  left;auto.\n  case (divide_intro _ H2).\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  rewrite (eq_sym p);simpl;intro;discriminate.\n  intros.\n  case (le_gt_dec (x * a)); intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intro; discriminate.\n  intros.\n  case (H1 3);try (apply succ_le_mono_r; assumption).\n  intros.\n  apply H.\n  left;rewrite mult_comm.\n  intro;discriminate.\n  elim a;intros.\n  left;rewrite mult_comm.\n  intro;discriminate.\n  right;rewrite mult_comm.\n  intro;discriminate.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_min_div);intro;discriminate.\n  case (H2 2);try (apply zero_min_div);intro;discriminate.\n  intros.\n  inversion H1;destruct x0;rewrite mult_comm;simpl;intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  apply (le_trans _ _ H1).\n  apply le_trans with (2 := H2).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H1).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H3).\n  apply le_trans with (2 := H1).\n Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  case (H (a, (b, (b, (c, d))).\n  case (le_lt_dec a p); intro;discriminate.\n  case (le_lt_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_lt_eq_dec a p); intro;discriminate.\n  case (le_eq_dec a p); intro;discriminate.\n  case (leQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; intro; discriminate.\n  case (H1 2);try (apply (prime_div_gcd_unique _ _ _ H1); trivial.\n  intro H;discriminate.\n  intro H;discriminate.\n  intro H;discriminate.\n  intro H;discriminate.\n  intro H;discriminate.\n  intro H;discriminate.\n  intro H;discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\n",
                "context_tokens": 691,
                "proof_start_offset": 2286,
                "proof_end_offset": 2466,
                "proof": "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_prime.\nintros.\nelim H;intros.\napply H2.\nelim H0;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  intros.\n  case (prime_is_prime_2 (d+p) a);intros.\n  right.\n  apply H;exists (d+p); auto.\n  apply prime_div_gcd.\n  intros.\n  apply H;exists (d+p); auto.\n  apply prime_div_gcd.\n  intros.\n  elim H0; intros.\n  elim H0; intros.\n  case (H1 d' H2);intro.\n  rewrite H1; apply prime_div_gcd.\n  intros.\n  apply H; exists (d+p); auto.\n  apply prime_div_gcd.\n  intros.\n  elim H0; intros.\n  apply H0; exists (d+p); auto.\n  apply prime_div_gcd.\n  intros.\n  elim H1; intros.\n  case (H1 d' H2);intro.\n  rewrite H1; apply prime_div_gcd.\n  intros.\n  elim H0; intros.\n  case (H1 d' H2);intro.\n  rewrite H1; apply prime_div_gcd.\n  intros.\n  elim H0; intros.\n  apply H1; exists (d+p); auto.\n  applyQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  intros.\n  case (is_prime_dec d p);intro.\n  case (is_prime_dec (a,p)).\n  intros.\n  case (is_prime_dec d p);intro.\n  elim H; intros.\n  case (le_lt_or_eq (a,p)).\n  intros.\n  left; rewrite H1;trivial.\n  right; rewrite H0;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  left; rewrite H;trivial.\n  right; rewrite H;trivial.\n  left; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  right; rewrite H;trivial.\n  left; rewrite H;trivial.\n Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  case (H0 H1);intro.\n  case (H1 H2);intro.\n  left;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  left;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  intros.\n  generalize (is_prime_1_abs_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_1_abs_strong d p a).\n  intro.\n  generalize (is_prime_1_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_2_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_1_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_2_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a) p a).\n  intro.\n  generalize (is_prime_strong (d:=a)Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intro.\n  case (gcd_spec d p);intro.\n  elim H;intros.\n  case (gcd_spec d p);intro.\n  elim H;intros.\n  left;rewrite <- H;trivial.\n  case (gcd_spec d p);intro.\n  elim H;intros.\n  right;rewrite <- H0;trivial.\n  right;rewrite <- H0;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite <- H0;trivial.\n  right;rewrite <- H0;trivial.\n  right;rewrite H;trivial.\n  left;rewrite H;trivial.\n  left;rewrite <- H0;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  left;rewrite H0;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  left;rewrite H;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H0;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H0;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  right;rewrite HQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  case (H d);intro.\n  left; assumption.\n  right; intro.\n  case (H0 d);intro.\n  left; assumption.\n  left; intro.\n  case (H0 d);intro.\n  left; assumption.\n  right; intro.\n  case (H0 d);intro.\n  left; assumption.\n  right; intro.\n  case (H0 d);intro.\n  left; assumption.\n  left; intro.\n  case (H0 d);intro.\n  right; assumption.\n  right; intro.\n  case (H0 d);intro.\n  left; assumption.\n  right; intro.\n  case (H0 d);intro.\n  left; assumption.\n  left; intro.\n  case (H0 d); intro.\n  right; assumption.\n  left; intro.\n  case (H0 d);intro.\n  left; assumption.\n  right; intro.\n  case (H0 d);intro.\n  right; assumption.\n  right; intro.\n  case (H0 d); intro.\n  right; assumption.\n  right; intro.\n  case (H0 d); intro.\n  right; assumption.\n  right; intro.\n Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  intros d p a.\n  elim a;intros.\n  left;trivial.\n  left;trivial.\n  left;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  left;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivialQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  case (le_gt_dec 0 (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (le_gt_dec (n0 + n0)).\n  intro H; discriminate.\n  intros.\n  case (Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  Proof.\n    simple induction d.\n    simpl in |- *; auto.\n    intros.\n    elim H; intros.\n    case (le_lt_or_eq (d=p) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_eq_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0));intro.\n    case (le_eq_eq (d=p0) (d=p0));intro.\n    case (le_lt_or_eq (d=p0) (d=p0Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n  apply (Z_div_gcd a b c d); trivial.\n  intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "NU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2516,
                "proof_end_offset": 2785,
                "proof": "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (gcd_is_gcd a p);intros.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\nelim H1;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  apply H0.\n  elim H; intros.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H0.\n  elim H0; intros.\n  apply H0.\n  elim H1; intros.\n  apply H1.\n  elim H0; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H; tauto.\n  elim H0; intros.\n  apply H; tauto.\n  elim H0; intros.\n  apply H; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; tauto.\n  elim H0; intros.\n  apply H0; tauto.\n  elim H0; intros.\n  apply H0; tautoQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  left; assumption.\n  left; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H0.\n  elim H0;intros.\n  elim H0; intros.\n  elim H0; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H0.\n  elim H0; introsQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H;intros.\n  apply H1.\n  elim H0;intros.\n  elim H0;intros.\n  apply H0.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1.\n  elim H0; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H2.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply HQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H0.\n  elim H1;intros.\n  elim H0; intros.\n  left.\n  rewrite mult_comm.\n  intro; discriminate.\n  intro; discriminate.\n  intro; discriminate.\n  intro; discriminate.\n  intro; discriminate.\n  intro; discriminate.\n  intro; discriminate.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H0; trivial.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  applyQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H1;intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H1; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H3; intros.\n  elim H5; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5;Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H2.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\n",
                "context_tokens": 720,
                "proof_start_offset": 2840,
                "proof_end_offset": 3139,
                "proof": "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a p);intro.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\nright;apply gauss with a;trivial.\nred in H1;elim H1;intros.\nred in H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime a p);intros.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  rewrite H1;apply gcd_divide; tauto.\n  intros.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  rewrite H0;apply gcd_divide; tauto.\n  intros.\n  rewrite H0;apply gcd_divide; tauto.\n  intros.\n  case (prime_gcd (gcd a p) a H0);intro.\n  rewrite H0;apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n  intros.\n  rewrite H0; apply gcd_divide; tauto.\n Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime p a);intros.\n  case (prime_dec (gcd a p) a H H0);intro;rewrite H1 in H0;try tauto.\n  elim H0;intros.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  left;rewrite H0;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  right;rewrite H2;trivial.\n  right;rewrite H1;trivial.\n  left;rewrite H1;trivial.\n  right;rewrite H2;trivial.\n Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime_dec a p);intro.\n  case (prime_gcd (gcd a p) p a H H0);intro;rewrite H1 in H1;try tauto.\n  apply H2.\n  elim H0;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5; intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elimQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  apply H.\n  elim H; intros.\n  apply H0.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  elim H0; intros.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  apply H.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  apply H.\n  elim H1; intros.\n  apply H2.\n  apply H.\n  apply H1.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  apply H1.\n  elim H2; intros.\n  apply H2.\n  apply H1.\n  elim H2; intros.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H.\n  elim H1; intros.\n  apply H1.\n  apply H1.\n  apply H.\n  apply HQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime p);intros.\n  case (prime_gcd (gcd a p) p a H H0);intro;rewrite H1 in H;try tauto.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply primeQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H2; intros.\n  elim H4Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  case (prime_dec a p);intro;rewrite H2 in H; try tauto.\n  elim H;intros.\n  case (H0 2);intro.\n  left;rewrite <- H1;trivial.\n  left;rewrite <- H1;trivial.\n  elim H0;intros.\n  right;rewrite <- H1;trivial.\n  elim H0;intros.\n  elim H0;intros.\n  left;rewrite <- H1;trivial.\n  elim H0;intros.\n  right;rewrite <- H1;trivial.\n  elim H0;intros.\n  elim H0;intros.\n  left;rewrite <- H1;trivial.\n  elim H0;intros.\n  right;rewrite <- H1;trivial.\n  elim H0;intros.\n  left;rewrite <- H0;trivial.\n  elim H0;intros.\n  right;rewrite <- H0;trivial.\n  elim H0;intros.\n  right;rewrite <- H1;trivial.\n  elim H0;intros.\n  left;rewrite <- H1;trivial.\n  elim H0;intros.\n  left;rewrite <- H1;trivial.\n  elim H0;intros.\n Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) p a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime p);intros.\n  case (prime_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H0);intro;rewrite H1;trivial.\n  case (prime_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H1);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H1);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H1);intro.\n  case (prime_gcd (gcd a p) p a H0);intro.\n  case (prime_gcd (gcd a p) p a H1);intro.\n  case (prime_gcd (gcdQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime_2 a p);intros.\n  case (prime_gcd a p);intros.\n  left;rewrite H0 in H1;inversion H1.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\n",
                "context_tokens": 729,
                "proof_start_offset": 3196,
                "proof_end_offset": 3355,
                "proof": "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\nunfold square.\nintros;case (prime_mult p a a H H0);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) p a H H0);intro;rewrite H0 in H.\n  left.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) p a H0);intro;rewrite H0 in H.\n  left;apply H.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) a H H0);intro;rewrite H0 in H.\n  right;apply H.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) a H H0);intro;rewrite H0 in H.\n  right;apply H.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H0 in H.\n  right;apply H.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H0 in H.\n  right; apply HQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime p a);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5; intros.\n  elimQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) p a H);intro;rewrite H1 in H.\n  case (prime_gcd (gcd a p) p a H);intro;rewrite H1 in H.\n  case (prime_gcd (gcd a p) p a H);intro;rewrite H1 in H.\n  left;apply H;trivial.\n  left;apply H;trivial.\n  right;apply H;trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) p a H0);intro;rewrite H1 in H1;try tauto.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4;intros.\n  elimQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime p a);intro.\n  case (prime_gcd (gcd a p) a H);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H0);intro;rewrite H1 in H1;tryQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime p a);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply H1.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4; intros.\n  elim H5;intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H5Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) p a H1);introQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_dec (gcd a p) a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  apply H3.\n  elim H1;intros.\n  apply H1.\n  elim H2;intros.\n  apply H3.\n  elim H1;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H4;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H4.\n  elim H1;intros.\n  apply H3.\n  elim H4;intros.\n  apply H4.\n  elim H1;intros.\n  apply H3.\n  elim H3; intros.Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime a p);intro.\n  case (prime_gcd (gcd a p) a H H0);intro;rewrite H2 in H1;try tauto.\n  rewrite H1;simpl;intro;discriminate.\n  case (prime_gcd (gcd a p) p a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H1 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p) a H1);intro;rewrite H2 in H1;try tauto.\n  case (prime_gcd (gcd a p)Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  intros.\n  generalize (gcd_is_prime p a);intro.\n  case (prime_prime_dec (gcd a p) p a H H0);intro;rewrite H1 in H.\n  case (prime_dec (gcd a p) a H0);intro;rewrite H1 in H.\n  elim H0;intros.\n  case (prime_dec (gcd a p) a H0);intro;rewrite H1 in H.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7; intros.\n  elim H8;intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3388,
                "proof_end_offset": 3666,
                "proof": "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\ninduction n;simpl;intros.\nelim H;intros.\nelim H1;apply divides_antisym;trivial;apply one_min_div.\ncase (prime_mult p x (power x n) H H0);trivial.\nintro;apply IHn;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  generalize (prime_mult x n);intro.\n  case (prime_mult x n);intro.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5; intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  case (prime_mult x n);intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro; rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite mult_comm.\n  intro;rewrite multQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  generalize (gcd_is_prime p);intro.\n  case (prime_mult_exists x n);intros.\n  case (prime_mult_exists x n);intro.\n  intros.\n  case (prime_mult_exists x n);intro.\n  exists x1.\n  intros.\n  apply H0.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H0;intros.\n  apply H1.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H1.\n  elimQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  case (prime_mult p n);intro.\n  left;auto.\n  left;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold pred.\n  intros.\n  generalize (H0 x0).\n  case (prime_mult x x0);intros.\n  exists (S n).\n  intros.\n  rewrite H1;trivial.\n  case (prime_mult x0);intros.\n  exists (S n).\n  intros.\n  apply H1.\n  elim H0;intros.\n  case (prime_mult y x1);intros.\n  exists (S n).\n  intros.\n  apply H2.\n  elim H0;intros.\n  exists (S n).\n  intros.\n  apply H2.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H3.\n  elim H1; intros.\n  elim H3; intros.\n  apply H3.\n  elim H4; intros.\n  apply H3.\n  elim H1; intros.\n  elim H4; intros.\n  apply H4.\n  elim H3; intros.\n  apply H4.\n  elim H4; intros.\n  apply H5.\n  elim H3; intros.\n  apply H4.\n  elim H4; intros.\n  apply H5.Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  apply prime_power.\n  apply prime_exp.\n  assumption.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  generalize (prime_power x);intro.\n  case (prime_mult x n);intro.\n  left;apply prime_mult;trivial.\n  intros.\n  case (prime_mult x n);intro.\n  right;apply prime_mult;trivial.\n  left;apply prime_mult;trivial.\n  right;apply prime_mult;trivial.\n  right;apply prime_mult;trivial.\n  right;apply prime_mult;trivial.\n  right;apply prime_mult;trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold prime.\n  intros.\n  apply H.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_multQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\n  apply prime_power_lt; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 3668,
                "proof_end_offset": 4798,
                "proof": "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\ninduction q;simpl;intros.\napply one_min_div.\nrewrite power_plus_lemma1 in H0.\nassert (divides x (power p q)).\napply IHq;trivial.\nelim H0;intros;exists ((power p n)*x0).\nrewrite H2;ring.\nelim H2;intros.\nrewrite H3 in H0.\nrewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\nelim H0;intros.\nassert ((power p (q*n))<>0).\nintro.\ngeneralize (power_zero (q*n) p H5).\nintro.\napply not_prime_zero.\nrewrite H6 in H;trivial.\nrewrite <- mult_assoc in H4.\ngeneralize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\nintro.\nassert (exists n':nat,n=(S n')).\ninversion H1;[exists 0 | exists m];trivial.\nelim H7;intro n';intro.\nrewrite H8 in H6;simpl in H6.\nassert (divides x0 p).\ncase (prime_mult p x0 (power x0 n'));trivial.\nrewrite H6.\nexists ((power p n')*x1);ring.\nintro.\napply prime_power with n';trivial.\nelim H9;intros.\nrewrite H10 in H3.\nrewrite H3.\nexists x2;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_power_q n);intro.\n  case (prime_mult p x (power x n) H);intro.\n  elim H0; intros.\n  elim H1; intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H2; intro.\n  elim H2; intro.\n  elim H3; intro.\n  elim H3; intro.\n  elim H3; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H8; intro.Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p x (power x n) H H0);intro; rewrite H0 in H0;try tauto.\n  apply prime_prime_mult;trivial.\n  apply prime_power_q;trivial.\n  apply prime_power_p;trivial.\n  apply prime_power_p;trivial.\n  apply prime_power_q;trivial.\n  apply prime_power_prime;trivial.\n  apply prime_power_prime;trivial.\n  apply prime_power_prime;trivial.\n  apply prime_power_prime;trivial.\n  apply prime_prime_prime;trivial.\n  apply prime_power_prime;trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p x);intro.\n  case (prime_mult p x);intro;trivial.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2; intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3; intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim HQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p n);intro.\n  case (prime_mult p x (power x n) H);trivial.\n  intro; apply H;trivial.\n  case (prime_mult p x (power x n) H);trivial.\n  intro; apply H;trivial.\n  intro; apply H0;trivial.\n  intro; apply H0;trivial.\n  intro; apply H;trivial.\n  intro; apply H;trivial.\n  intro; apply H0;trivial.\n  intro; apply H0;trivial.\n  intro; apply H;trivial.\n  intro; apply H0;trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p x);intro.\n  case (prime_mult p x);intro.\n  rewrite H1;trivial.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H4; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6;Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elimQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_mult p x (power x n) H0);intro;rewrite H0;rewrite H1;trivial.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2; intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3; intros.\n Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p x (power x n) H0);intro.\n  case (prime_mult p x (power x n) H H0);intro;rewrite H0;trivial.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H1; intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H4; intros.\n  elim H5;Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_div_strong a p);intro.\n  case (prime_mult p x (power x n) H0);intro;rewrite H0 in H1; try tauto.\n  elim H1;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5; intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elimQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_prime p x);intro.\n  case (prime_mult p x (power x n) H0);intro.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  intro; absurd (p > 0); trivial.\n  introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\n",
                "context_tokens": 719,
                "proof_start_offset": 4831,
                "proof_end_offset": 5126,
                "proof": "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\nintros;intro.\nelim H;intro p;intro.\nelim H1;intros.\nelim H3;intros.\nunfold is_prime in H0.\nelim H0;intros.\nunfold is_prime in H4.\nelim H4;intros.\ncase (H7 p H5);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a p.\n  elim (prime_mult a p);intros; exists p; trivial.\n  apply prime_power_pos.\n  unfold is_prime.\n  rewrite (prime_mult a p); simpl in |- *.\n  elim H0; intros.\n  elim H0; intros.\n  apply prime_power_pos.\n  rewrite (prime_mult a p); simpl in |- *.\n  elim H0; intros.\n  rewrite H2; assumption.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros.\n  elim H; intros; exists a; auto with zarith.\n  elim H1; intros.\n  elim H1; intros.\n  rewrite H2; trivial.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H3; trivial.\n  elim H2; intros.\n  elim H2; intros.\n  rewrite H3; trivial.\n  elim H3; intros.\n  elim H3; intros.\n  rewrite H3; trivial.\n  elim H3; intros.\n  rewrite H4; trivial.\n  elim H3; intros.\n  rewrite H3; trivial.\n  elim H3; intros.\n  rewrite H3; trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros.\n  apply prime_prime.\n  rewrite (prime_mult a).\n  rewrite (prime_mult a).\n  rewrite (prime_mult a).\n  rewrite (prime_mult b).\n  rewrite (prime_mult a).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult b).\n  rewrite (prime_mult bQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  elim H; intros; elim H; intros.\n  rewrite H0 in H0; discriminate.\n  intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  elim H0; intros.\n  rewrite HQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a p.\n  destruct (prime_mult a p); [intros; discriminate | ].\n  apply prime_div;auto.\n  elim H1;intros.\n  elim H1; intros.\n  rewrite H4.\n  apply prime_div;auto.\n  elim H1; intros.\n  elim H1; intros.\n  rewrite H4.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H4.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H4.\n  apply prime_div;auto.\n  elim H1; intros.\n  elim H1; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H2; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H1; intros.\n  rewrite H5.\n  apply prime_div;auto.\n  elim H1Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  generalize (gcd_is_prime p a);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_mult a p);intro.\n  case (prime_multQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  exists (power p);trivial.\n  elim H;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2;intros.\n  elim H2; intros.\n  elim H3;intros.\n  elim H4; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5;Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a p.\n  elim H; intros.\n  elim H0; intros.\n  elim H0; intros.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply HQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a.\n  generalize (prime_div a p H); intro.\n  generalize (prime_div a p H); intro.\n  generalize (prime_div a p H); intro.\n  generalize (prime_div a p H); intro.\n  generalize (prime_div a p H); intro.\n  generalize (prime_div a p H); intro.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite H3 in H1.\n  rewrite (mult_assoc (power p n) (power p n) (power p (p*n))).\n  apply Zmult_lt_compat_l.\n  apply Zmult_lt_compat_l.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\n",
                "context_tokens": 713,
                "proof_start_offset": 5187,
                "proof_end_offset": 5475,
                "proof": "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\nintros.\nsplit;try tauto.\nintro d';intro.\nassert (is_gcd d' d' p).\nunfold is_gcd;unfold is_cd.\nsplit;[split;[apply divides_refl | tauto] | tauto].\neapply H0;apply H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intro p.\n  elim H;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H2;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5; intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  induction 1;simpl;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  applyQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  induction n;simpl;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2; intros.\n  elim H2; intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H1; intros.\n  elim H5; intros.\n  elim HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intros.\n  unfold is_prime in |- *.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1;auto.\n  elim H0;intros.\n  apply H1;auto.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  elim H0;intros.\n  apply H1;auto.\n  elim H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H1;auto.\n  elim H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elim H0;intros.\n  apply H0;auto.\n  elimQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; case (gcd_dec p a);intro.\n  elim H;intro p;intros.\n  elim H;intros.\n  elim H0;intros.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; pattern p, (p) at 1 in |- *; rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_prime p);\n  rewrite (gcd_prime p); rewrite (gcd_Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;case (gcd_prime p a);intros.\n  elim H1;intros.\n  elim H2;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  elim H4;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  elim H4;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  elim H5;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  elim H4; intros.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H5; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4; assumption.\n  apply H4Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\n  intros; elim H;intro p;intro p.\n  elim H;intro p;intro p.\n  elim H0;intro p;intro p.\n  elim H0;intros.\n  elim H0;intro p;intro p.\n  elim H0;intros.\n  elim H1;intro p;intro p.\n  elim H1;intro p;intro p.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intro p;intro p.\n  elim H2;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intro p.\n  (* p<>0 *)\n  intros; elim H0;intros.\n  unfold is_prime in H.\n  elim H0;intros.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H2.\n  unfold is_prime in H1.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H1.\n  elim H1; intros.\n  elim H0;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  apply H2.\n  unfold is_prime in H1.\n  elim H1; intros.\n  unfold is_prime in H1.\n  elim H1; intros.\n  unfold is_prime in H1.\n  elim H1; intros.\n  unfold is_prime in H1.\n  elim H2; intros.\n  unfold is_prime in H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 5536,
                "proof_end_offset": 5890,
                "proof": "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\nsplit;intros.\nelim H;intros.\nsplit;try tauto.\nintros.\ncase (eq_nat_dec d 1);intro;try tauto.\ncase (eq_nat_dec d p);intro;try tauto.\nelim (H1 d n n0 H2).\nelim H;intros.\nsplit;try tauto.\nintros;intro.\nelim (H1 a H4);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  apply gcd_nonneg; tauto.\n  intro d';intro.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim H0;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H1.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H1.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0; intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0; intros.\n  apply H1.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  apply H1.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  apply H1.\n  unfold is_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  generalize (gcd_prime_nonneg a p H).\n  intro; elim H;intros.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\n  apply prime_cond; assumption.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  elim H;intro.\n  (* n = n *)\n  apply prime_le;intro.\n  apply prime_le;intro.\n  apply H;apply H1;apply H2.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H;apply H2.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H;apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H;apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0;apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_le;intro.\n  apply H0.\n  (* n = n *)\n  apply prime_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  generalize (prime_is_prime_1 p H).\n  intro.\n  elim H;intros.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  generalize (gcd_prime a).\n  intro.\n  generalize (gcd_prime a).\n  intro.\n  generalize (gcd_prime a).\n  intro.\n  apply H0;auto.\n  intro.\n  apply H0;auto.\n  intro.\n  apply H0;auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  elim H;intros.\n  apply (not_prime_prime a);auto.\n  apply (not_prime_not_prime a);auto.\n  apply (not_prime_not_prime a);auto.\n  apply (not_prime_not_prime a);auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  elim H;intro p;intro.\n  apply H;intro p.\n  elim H0;intro.\n  apply H;intro H0;intro H0;subst;auto.\n  apply H;intro H0;intro H0;subst;auto.\n  apply H;intro H0;intro H0;subst;auto.\n  apply H;intro H0;intro H0;subst;auto.\n  apply H;intro H0;subst;auto.\n  apply H;intro H0;intro H0;subst;auto.\n  apply H;intro H0;subst;auto.\n  apply H;intro H0;subst;auto.\n  apply H;intro H0;subst;auto.\n  apply H;intro H0;subst;auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  split;try tauto.\n  intro d';intro H.\n  elim H0;intros.\n  unfold not in |- *; intro.\n  apply (H (le_n_O _ _ H0)).\n  apply H0.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  elim H;intro p.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -2 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -2 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -1 *)\n  apply prime_prime; assumption.\n  (* p = -2 *)\n  apply prime_prime; assumption.\n  (* p = -2Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  elim H;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p;intro p; elim p;intro p;intro p;intro p;intro p;intro p;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\n",
                "context_tokens": 734,
                "proof_start_offset": 5951,
                "proof_end_offset": 6368,
                "proof": "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintro.\ncase (divides_nat n);intro.\nelim s;intros.\nright;intro.\nunfold is_prime in H.\nelim H;intros.\nelim (H1 x);try tauto.\ncase (eq_nat_dec n 1);intro.\nright;unfold is_prime;tauto.\nleft;unfold is_prime.\nsplit;trivial.\nintros.\ncase (eq_nat_dec d 1);try tauto.\ncase (eq_nat_dec d n);try tauto;intros.\nelim (n0 d n3 n2 H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro; elim H;intro.\n  split;intro.\n  split;intro.\n  rewrite H;intro.\n  rewrite H;intro.\n  elim (H1 (prime_or_prime p x));intro.\n  elim H0;intros.\n  exists x;auto.\n  intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  applyQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro; elim H;intro n.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply H2.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H.\n  apply H1.\n  apply H.\n  apply H.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; elim H;intro p.\n  apply prime_pos.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  apply prime_pos.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  apply prime_pos.\n  apply prime_pos.\n  apply Z.le_trans with (n0 + 1).\n  assumption.\n  apply prime_pos.\n  apply Z.le_trans with (S (S n)).\n  assumption.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  apply prime_pos.\n  assumption.\n  apply Z.le_trans with (S n0).\n  assumption.\n  apply prime_pos.\n  assumption.\n  apply Z.le_trans with (S n0).\n  assumption.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  apply Z.le_trans with (S n0).\n  assumption.\n  apply prime_pos.\n  apply Z.le_trans with (S n0).\n  assumption.\n  apply prime_pos.\n  assumption.\n  apply prime_pos.\n  assumption.\n  applyQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  split;try tauto.\n  intros.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  apply H0.\n  unfold is_prime in H0.\n  elim H0;Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; elim H;intro H;intro H;intro H;elim H;intro H;clear H;intro H;clear H;intro H;clear H;intro H;clear H;intro H;clear H;intros H;clear H;intro H;clear H;\nsplit;try tauto.\n  intros.\n  case (eq_nat_dec d q).\n  elim H;intros.\n  elim H;intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H1;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H1;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0;auto.\n  intros.\n  apply H0Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H;intros.\n  split;auto.\n  elim H0;intros.\n  split;auto.\n  intros.\n  elim H;intros.\n  split;auto.\n  apply H2.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply HQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; apply prime_prime_prime; auto.\n  elim H;intros.\n  elim H;intros.\n  split;try tauto.\n  intros; elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  elim H0;intros.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  apply H0;intro.\n  elim H0;intros.\n  apply H1;intro.\n  elim H1;intros.\n  apply H;intro.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  apply H;intro.\n  apply H;intro.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  elim H0;intros.\n  apply H;intro.\n  elim H0;intros.\n  apply H0;intro.\n  elim H0;intros.\n  apply H;intro.\n  elim HQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros n; elim H;intros.\n  apply prime_double; apply H0.\n  elim H;intros.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0;intros.\n  apply prime_double; apply H0.\n  elim H0; intros.\n  apply prime_double; apply H0.\n  elim H0; intros.\n  apply prime_double; apply H0.\n  elim H0; intros.\n  apply prime_double; apply H0.\n  elim H0; intros.\n  apply prime_double; apply H0.\n  elim H0; intros.\n  apply primeQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ".\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\n",
                "context_tokens": 711,
                "proof_start_offset": 6458,
                "proof_end_offset": 7237,
                "proof": "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\nintro.\napply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\ncase (eq_nat_dec n0 1);try tauto;intro.\ncase (eq_nat_dec n0 0);intro.\nleft;exists 2.\nsplit;[apply is_prime_2 | rewrite e;apply zero_max_div].\ncase (divides_nat n0);intro.\nelim s;intro d;intro.\nelim p;intros.\nelim H2;intros.\nassert (d<n0).\ngeneralize (divides_le n0 d n2 H4);omega.\ncase (prime_dec d);intro.\nleft;exists d;tauto.\nelim (H d H5 n3);try tauto.\nintro.\nelim a;intro q;intro.\nleft;exists q.\nsplit;try tauto.\napply divides_trans with d;try tauto.\nelim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  apply H0.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\n  apply prime_prime_gt; auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  exists (power p n0).\n  elim H;intros.\n  apply H.\n  exists (power p n0).\n  elim H;intros.\n  apply H0.\n  exists (power p n0).\n  elim H;intros.\n  apply H0.\n  exists (power p n0).\n  elim H;intros.\n  apply H0.\n  exists (power p n0).\n  elim H0;intros.\n  apply H1.\n  exists (power p n0).\n  elim H;intros.\n  elim H0;intros.\n  apply H0.\n  exists (power p n0).\n  elim H;intros.\n  apply H0.\n  exists (power p n0).\n  elim H0;intros.\n  apply H0.\n  exists (power p n0).\n  elim H0;intros.\n  apply H0.\n  exists (power p n0).\n  elim H0;intros.\n  apply H1.\n  exists (power p n0).\n  elim H0;intros.\n  apply H0.\n  exists (power p n0).\n  elim H0;intros.\n  apply H1.\n  exists (power p n0Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  apply H;auto.\n  apply H;auto.\n  elim H;intros.\n  apply H0;auto.\n  apply H;auto.\n  apply H0;auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H.\n  apply H1Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  elim (H0 x);try tauto.\n  intros.\n  elim (H1 x);try tauto.\n  intros.\n  elim (H1 x);try tauto.\n  intros.\n  elim (H1 x);try tauto.\n  intros.\n  elim (H2 x);try tauto.\n  intros.\n  elim (H2 x);try tauto.\n  intros.\n  elim (H2 x);try tauto.\n  intros.\n  elim (H3 x);try tauto.\n  intros.\n  elim (H3 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (H4 x);try tauto.\n  intros.\n  elim (Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  unfold is_prime in H.\n  elim (classic (exists a, is_prime a /\\ ~ is_prime a).\n  intros.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim (classic (exists a, is_prime a /\\ ~ is_prime a).\n  intros.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  split; try tauto.\n  intros.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H0; intros.Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (prime_dec n 1);intro.\n  right;intro.\n  unfold is_prime;tauto.\n  right;intro.\n  unfold is_prime;tauto.\n  right;intro.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply (H1 x H1).\n  unfold is_prime;tauto.\n  right;intro.\n  unfold is_prime;tauto.\n  right;intro.\n  unfold is_prime;tauto.\n  right;intro.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime;tauto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  rewrite H1.\n  destruct (H1 x) as (p,(p,(H1,H2))).\n  rewrite H1.\n  rewrite <- H1.\n  apply H2.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  apply prime_prime_le; auto.\n  apply prime_prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n  apply prime_gt; auto.\n  apply prime_gt; auto.\n  apply prime_le; auto.\n  apply prime_gt; auto.\n  apply prime_le; auto.\n  apply prime_le; auto.\n Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H2 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H2 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H2 x);try tauto.\n  elim (H3 x);try tauto.\n  elim (H3 x);try tauto.\n  elim (H3 x);try tauto.\n  elim (H3 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H1 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H5 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);try tauto.\n  elim (H4 x);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\nLemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  apply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\n  case (eq_nat_dec n0 1);try tauto;intro.\n  case (eq_nat_dec n0 0);intro.\n  left;exists 2.\n  split;[apply is_prime_2 | rewrite e;apply zero_max_div].\n  case (divides_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\n",
                "context_tokens": 710,
                "proof_start_offset": 7333,
                "proof_end_offset": 8614,
                "proof": "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\nintros n p H.\napply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\ncase (divides_dec n0 p);intro.\ngeneralize (quo_is_quo n0 p d);intro.\nelim (H0 (quo n0 p d)).\nintro m;intros.\nexists (m+1).\nelim p0;intros.\nelim H3;intros.\nrewrite H5 in H2;rewrite mult_assoc in H2.\nrewrite plus_comm.\nsplit;simpl.\nexists x;trivial.\nrewrite plus_comm;simpl.\nrewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\nelim H6;intros.\nrewrite H2 in H7.\nassert (p<>0).\nintro.\nrewrite H8 in H.\napply not_prime_zero;trivial.\nassert ((power p m)*x=(power p m)*p*x0).\napply mult_lemma6 with p;trivial.\nrewrite mult_assoc;rewrite H7;ring.\nrewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\napply H4.\nrewrite plus_comm;simpl.\nexists x0;trivial.\nrewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\nintro.\napply H1;rewrite H2;rewrite H3;trivial.\nelim H.\nintros.\ndestruct p;omega.\nintro;apply H1.\nrewrite H2;rewrite H3;ring.\nexists 0;simpl.\nsplit.\napply one_min_div.\nrewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intro.\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n)) (p+n))).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n)) (p+n))).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n)) (p+n))).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n))) (p+n)).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n))) (p+n)).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n)) (p+n)).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+n)) (p+n))).\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p) -> (p+nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  case (prime_dec n 1);intro.\n  left;unfold is_prime;tauto.\n  left;unfold is_prime;tauto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  apply (lt_wf_rec n (fun n:nat => ~ (n+p:nat)(n+p:nat)(n+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p:nat)(m+p)(m+p:nat)(m+p:nat)(m+p)(m+p:nat)(m+p:nat)(m+p:nat)(m+pQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros n p.\n  case (eq_nat_dec n 0);intro.\n  right;intro.\n  left;intro.\n  unfold is_prime in H;tauto.\n  elim (lt_irrefl n).\n  intros.\n  apply H;auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p H; case (prime_dec n p);intro.\n  right;intro.\n  case (prime_dec n p);intro.\n  left;exists 0.\n  split;try tauto.\n  case (prime_dec n0);intro.\n  right;exists 1.\n  split;try tauto.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime;tauto.\n  right;unfold is_prime;tauto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (prime_dec n 1);intro.\n  right;intro.\n  elim (H1 n0 H0);auto.\n  elim H0;auto.\n  left;intro.\n  elim (H2 n0 H1);auto.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  left;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  left;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  right;intro.\n  elim H0;auto.\n  leftQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intro.\n  case (prime_dec n0);intro.\n  left;exists 1.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec n0 1);try tauto.\n  left;auto.\n  left;auto.\n  left;auto.\n  left;auto.\n  left;auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intro.\n  case (prime_dec n p);intro.\n  left;exists (m+p).\n  split;auto.\n  split;auto.\n  elim (prime_dec n0);intro.\n  left;exists (m+p).\n  split;auto.\n  split;auto.\n  elim (prime_dec n0);intro.\n  left;exists (m+p).\n  split;auto.\n  elim (prime_dec n0);intro.\n  right;exists (m+p).\n  split;auto.\n  apply prime_pos_lt;auto.\n  elim (prime_dec n0);intro.\n  right;exists (m+p).\n  split;auto.\n  elim (prime_dec n0);intro.\n  right;exists (m+p).\n  split;auto.\n  elim (prime_dec n0);intro.\n  left;exists (m+p).\n  split;auto.\n  elim (prime_dec n0);intro.\n  right;exists (m+p).\n  split;auto.\n  elim (prime_dec n0);intro.\n  right;exists (m+p).\n  split;auto.\n  elim (prime_dec n0Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (eq_nat_dec n 0);intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  left;unfold is_prime in H0.\n  elim H0;intros.\n  elim H1;intros.\n  assert (d=n0).\n  generalize (divides_le_0 n0 d n0 H1);omega.\n  case (eq_nat_dec d n);intro.\n  left;unfold is_prime in H1.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  assert (d=n0).\n  generalize (H3 d n0 H3);omega.\n  case (eq_nat_dec d n0);intro.\n  right;intro.\n  unfold is_prime in H2.\n  elim H2;intros.\n  elim H3;intros.\n  elim H2;intros.\n  assert (d=n0).\n  generalize (divides_le_0 n d n0 H4);omega.\n  case (eq_nat_dec d n0);intro.\n  left;unfold is_prime in H2.\n  elim H3;Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros n p.\n  case (le_gt_dec n 1);intro.\n  left;unfold is_prime;tauto.\n  left;unfold is_prime;tauto.\n  right;unfold is_prime;tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\nLemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\n  case (divides_dec n0 p);intro.\n  generalize (quo_is_quo n0 p d);intro.\n  elim (H0 (quo n0 p d)).\n  intro m;intros.\n  exists (m+1).\n  elim p0;intros.\n  elim H3;intros.\n  rewrite H5 in H2;rewrite mult_assoc in H2.\n  rewrite plus_comm.\n  split;simpl.\n  exists x;trivial.\n  rewrite plus_comm;simpl.\n  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\n  elim H6;intros.\n  rewrite H2 in H7.\n  assert (p<>0).\n  intro.\n  rewrite H8 in H.\n  apply not_prime_zero;trivial.\n  assert ((power p m)*x=(power p m)*p*x0).\n  apply mult_lemma6 with p;trivial.\n  rewrite mult_assoc;rewrite H7;ring.\n  rewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\n  apply H4.\n  rewrite plus_comm;simpl.\n  exists x0;trivial.\n  rewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\n  intro.\n  apply H1;rewrite H2;rewrite H3;trivial.\n  elim H.\n  intros.\n  destruct p;omega.\n  intro;apply H1.\n  rewrite H2;rewrite H3;ring.\n  exists 0;simpl.\n  split.\n  apply one_min_div.\n  rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.\n\n(** if n>1 then there is a prime number p and two integers m and q with m>0 and q<n such that n=p^m*q and gcd(p,q)=1 *)\n",
                "context_tokens": 686,
                "proof_start_offset": 8736,
                "proof_end_offset": 10293,
                "proof": "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros.\ncase (prime_dec n);intro.\nexists n;exists 1;exists 1;simpl.\nsplit;try tauto.\nsplit;try omega.\nsplit;try ring.\nsplit;try omega.\napply gcd_sym;apply gcd_one.\nelim (not_prime_impl_prime_divides n n0);intro;try tauto.\nelim a;intro p;intro.\nelim p0;intros.\nelim (nat_factor n p H1).\nintro m;intro.\nelim p1;intros.\nexists p;exists m;exists (quo n (power p m) H3).\nsplit;trivial.\nsplit.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nsplit.\napply (quo_is_quo n (power p m) H3).\ngeneralize (gcd_is_gcd p (quo n (power p m) H3));intro.\nassert ((gcd p (quo n (power p m) H3))=1).\ncase (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\napply gcd_sym;trivial.\nintro.\nrewrite H6 in H5;elim H5;intros.\nelim H7;intros.\nelim H4;rewrite plus_comm;simpl.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nelim H10;intros.\nrewrite H12 in H11.\nexists x;rewrite H11;ring.\nrewrite H6 in H5;trivial.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nsplit;trivial.\nrewrite H7;rewrite mult_comm;apply mult_lemma3.\nintro.\napply H;rewrite H7.\nrewrite H8;ring.\nred;apply power_lt.\ndestruct p.\nelim (not_prime_zero H1).\ndestruct p;try omega.\nelim H1;tauto.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros.\n  elim n.\n  simpl in |- *; intros.\n  elim H2;intros.\n  assert (m=n0).\n  generalize (le_not_le n0 n0 H3);intro.\n  rewrite <- (mult_comm m n0 H3 H3);intro.\n  elim H3;intros.\n  rewrite H3 in H3; rewrite mult_comm in H2.\n  elim H3; intros.\n  rewrite H3 in H3; rewrite mult_comm in H2.\n  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\n  elim H3; intros.\n  rewrite H3 in H3; rewrite mult_comm in H2.\n  elim (mult_comm p (power p m) p);intro.\n  rewrite <- (mult_comm m n0 H3);intro.\n  rewrite <- (mult_comm m n0 H3);intro.\n  elim H3; intros.\n  rewrite H3 in H3; rewrite mult_comm in H2.\n  elim (mult_comm p (power p m) p);intro.\n  rewrite <- (mult_comm (power p m));intro.\n  elim H3; introsQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p H0.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | (is_prime p n)) /\\ (forall m:nat, (is_prime p m)*(n=m))).\n  intros n p H0.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | (is_prime p m)*(n=0))).\n  intros n p H1.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | (is_prime p m)*(n=0)) /\\ (forall m:nat, (is_prime p m)*(n=0))) /\\ (forall m:nat, (is_prime p m)*(n=m))) /\\ (forall m:nat, (is_prime p m)*(n=m))) -> (forall m:nat, (is_prime p m)*(n=m))) -> (forall m:nat, (forall m:nat, (is_prime p m)*(n=m))) -> {m:nat | (is_prime p m)*(n=0)) /\\ (forallQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply nat_factor_prime; auto.\n  apply nat_factor_prime; auto.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n destruct (le_lt_dec n p);intro.\n rewrite <- (mult_comm p (power p n));auto.\n rewrite <- (mult_comm p (power p m));auto.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p H.\n  apply (le_wf_ind n (fun n:nat => n <> 0 -> {m:nat & (is_prime p m)*q}).\n  intros n H.\n  apply H.\n  rewrite (mult_comm (power p m) (power p (S n)) (power p (S n)).\n  rewrite <- mult_assoc; rewrite H;ring.\n  apply (le_wf_rec n (fun n:nat => n <> 0 -> {m:nat & (is_prime p m)*q}).\n  intros n H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat | (is_prime p m)*q}).\n  intros n H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | (is_prime p m)*q}).\n  intros n H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & (is_prime p m)*q}).\n  intros n H0 H1.\n  apply (le_wf_ind n (fun n:nat => nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_rec n (fun m:nat => n <> 0 -> {m:nat | (is_prime p m)*(n+m)) /\\ ~ prime n /\\ ~ prime n /\\ ~ prime m /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n).\n  intros n H0.\n  apply (lt_wf_ind_rec n (fun n:nat => n <> 0 -> {m:nat | (n=0)->P | m <= n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime m /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n).\n  intros n H0 H1.\n  apply (lt_wf_ind_rec n (fun n:nat => n <> 0 -> {m:nat | (n=0)->P | m <= n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime m /\\ ~ prime nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p H.\n  apply (lt_wf_ind_r _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_ind_r _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wf_rec _ _ H).\n  apply (lt_wfQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | (n=(power p m)) /\\ ~ divides n (power p (m-1)))}}.\n  intros.\n  elim n; intros.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | (n=(power p m)) /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n}.\n  intros.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | (n=(power p m)) /\\ ~ prime n /\\ ~ prime n /\\ ~ prime n}.\n  intros.\n  elim n; intros.\n  elim n0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  exists x; assumption.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  exists x; assumption.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  elim H; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H0; intros.\n  rewrite nat_factor_prime; simpl.\n  apply prime_prime_prime_prime; simpl; trivial.\n  elim H0; intros.\n  rewrite nat_factor_prime; simpl.\n  elim (prime_is_prime p); intros.\n  elim H1; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H1; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H1; intros.\n  rewrite nat_factor_prime; simpl; trivial.\n  elim H1; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H1; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H2; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H3; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H3; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H3; intros.\n  rewrite nat_factor_prime; simpl.\n  elim H3; intros.\n  rewrite nat_factor_prime; simplQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply nat_factor_prime with (m:=n) (q:=n) (q:=n) (q:=n) (q:=n) (q:=n) (q:=n) (q:=m) (q:=n) (q:=m) (q:=m) (q:=n) (q:=n) (q:=m) (q:=m) (q:=m) (q:=n) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=m) (q:=mQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " omega.\n  apply gcd_sym;apply gcd_one.\n  elim (not_prime_impl_prime_divides n n0);intro;try tauto.\n  elim a;intro p;intro.\n  elim p0;intros.\n  elim (nat_factor n p H1).\n  intro m;intro.\n  elim p1;intros.\n  exists p;exists m;exists (quo n (power p m) H3).\n  split;trivial.\n  split.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  split.\n  apply (quo_is_quo n (power p m) H3).\n  generalize (gcd_is_gcd p (quo n (power p m) H3));intro.\n  assert ((gcd p (quo n (power p m) H3))=1).\n  case (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\n  apply gcd_sym;trivial.\n  intro.\n  rewrite H6 in H5;elim H5;intros.\n  elim H7;intros.\n  elim H4;rewrite plus_comm;simpl.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  elim H10;intros.\n  rewrite H12 in H11.\n  exists x;rewrite H11;ring.\n  rewrite H6 in H5;trivial.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  split;trivial.\n  rewrite H7;rewrite mult_comm;apply mult_lemma3.\n  intro.\n  apply H;rewrite H7.\n  rewrite H8;ring.\n  red;apply power_lt.\n  destruct p.\n  elim (not_prime_zero H1).\n  destruct p;try omega.\n  elim H1;tauto.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  trivial.\nQed.\n\n(** this compute p1^n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\n",
                "context_tokens": 720,
                "proof_start_offset": 10997,
                "proof_end_offset": 12081,
                "proof": "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintro.\ncase (eq_nat_dec n 0);intro.\nright;trivial.\ncase (eq_nat_dec n 1).\nintro;left;exists (nil (A:=nat*nat)).\nsplit;[apply nil_is_wf | simpl;trivial].\ngeneralize n0.\napply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\nelim (nat_factor_prime n1 H0 H1).\nintro p;intro.\nelim p0;intro m;intro.\nelim p1;intro q;intro.\nelim p2;intros.\nelim H3;intros.\nelim H5;intros.\nelim H7;intros.\ncase (eq_nat_dec q 1);intro.\nleft;exists (cons (p,m) nil);simpl;rewrite e in H6.\nsplit;trivial.\napply cons_is_wf;auto;try (apply nil_is_wf).\nunfold rel_prime;simpl;rewrite e in H8;trivial.\nassert (q<>0).\nintro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\nelim (H q H9 H10 n2).\nintro.\nelim a;intro l;intro.\nelim p3;intros.\nleft;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\napply cons_is_wf;auto.\nrewrite <- H12;unfold rel_prime;trivial.\nintro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros n; unfold factorisation in H.\n rewrite plus_comm.\n apply (well_founded_ind (fun p : nat => 0) p).\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction n; simpl; intros;trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros; generalize (factorisation _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction l as [|n l IH]; simpl; trivial; intros.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl; trivial.\n destruct l; simpl;Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction l.\n simpl; intros.\n apply H; auto.\n apply (is_wf (lex_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf_clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf_wf (clos_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf_wf (clos_wf (clos_wf_wf_clos_wf (closQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n  induction n as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct n as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct n as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct n as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct n as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n  destruct m as [| n IH]; simpl; trivial.\n Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros; now apply (is_wf_bound (le_trans (abs_nat (S n))).\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction l; simpl; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n  induction n.\n  - reflexivity.\n  - simpl.\n    rewrite mult_comm.\n    rewrite mult_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_assoc.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_assoc.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite <- plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite <- plus_assoc.\n    rewrite <- plus_assoc.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite <- plus_assoc.\n    rewrite plusQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n as [| n IH]; intros [|n IH]; simpl.\n- simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.\n  rewrite IH; simpl.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 12199,
                "proof_end_offset": 12539,
                "proof": "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l;simpl;try tauto.\nintro.\ncase H;intro.\ndestruct a.\nrewrite <- H0;simpl.\nexists (refactor l);trivial.\ndestruct a.\nelim (IHl H0);intros.\nrewrite H1.\nexists ((power n n0)*x0);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros x l.\n  induction l; simpl;trivial.\n  case (eq_nat_dec n 0);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.\n  rewrite plus_0_r;trivial.\n  case (eq_nat_dec n 1);intro.Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  case (eq_nat_dec (nat_dec n 0));intro.\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  right;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  left;trivial.\n  apply (lt_wf_rec n (fun n:nat => n=0 -> 0 <= N)%nat).\n  right;trivial.\n  right;trivial.\n  apply (Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intro.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros x l; induction l as [| x l IHl].\n  - simpl.\n    destruct (eq_nat_dec n 1); [left|right].\n    rewrite plus_n_O; rewrite plus_n_O; simpl; auto.\n    rewrite plus_n_O; rewrite plus_n_O; simpl; auto.\n    rewrite plus_n_O; simpl; auto.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  induction l; simpl; intros.\n  - constructor.\n    - constructor.\n      + constructor.\n      + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n        + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n          + constructor.\n         Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intros.\n  case (eq_nat_dec x 0);intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  left;trivial.\n  case (eq_nat_dec (pos x));intro.\n  left;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_dec (pos x));intro.\n  right;trivial.\n  case (eq_nat_Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  case (eq_nat_dec n 1);intro.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite <- minus_n_O.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_S.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_S_n.\n  apply le_n_n.\n  apply le_S.\n Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  case (le_gt_dec n 1);intro.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2);intro.\n  left;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  left;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro H.\n  right;trivial.\n  case (le_gt_dec n 2).\n  intro HQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  induction l; simpl; auto.\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn l).\n  rewrite (IHn lQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  induction l; simpl; intros.\n  - now apply (factorisation_level).\n    simpl.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_O.\n    rewrite <- minus_n_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\n",
                "context_tokens": 704,
                "proof_start_offset": 12623,
                "proof_end_offset": 13304,
                "proof": "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction l;simpl;intros.\nassert (p=1).\napply divides_antisym;trivial.\napply one_min_div.\nrewrite H2 in H;elim H;tauto.\ndestruct a.\ncase (divides_dec (power n n0) p);intro.\ngeneralize (prime_power p n0 n H d);intro.\nassert (n=p).\ninversion H0.\nelim H6.\nintros.\nelim H;intros.\ncase (H11 p H2);try tauto;try omega.\nexists n0;rewrite <- H3;left;trivial.\ninversion H0.\nelim (IHl H H7).\nintros;exists x;tauto.\napply gauss with (power n n0);trivial.\napply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  intros.\n  case (eq_nat_dec n 0);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (eq_nat_dec (fst l) (fst l)) as [n1|n2];intro.\n  right; trivial.\n  case (eq_nat_dec (fst l) (fst l)).\n  intro.\n  left; exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right; trivial.\n  right; trivial.\n  case (eq_nat_dec (fst l) (fst l)); intro.\n  left; exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right; trivial.\n  right; trivial.\n  case (eq_nat_dec (fst l) (snd l)); intro.\n  left; exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right; trivial.\n  right; trivial.\n  case (eq_nat_dec (fst l) (snd l)); intro.\n  right; exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  left; trivial.\n  right; trivial.\n  case (eq_nat_dec (fst l) (fst l)); intro.\n  right;Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case H;intro.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case (eq_nat_dec n 0).\n  intro.\n  case (eq_nat_dec n 0);intro.\n  left.\n  exists (list (nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  case (eq_nat_dec n 0);intro.\n  right.\n  exists (list (nat*nat)).\n  split;[apply cons_is_wf | simpl;trivial].\n  intros.\n  rewrite <- H1.\n  apply (lt_wf_rec n (fun k:nat => n <> 0 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l)}.\n  intros.\n  case (eq_nat_dec n 0);intro.\n  left.\n  exists (list (nat*nat)).\n  split;[apply cons_is_wf | simpl;trivial].\n  intros.\n  case (eq_nat_dec n 0).\n  intro.\n  right.\n  exists (list (nat*nat)).\n  split;[apply cons_is_wf | simpl;trivial].\n  intros.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite <- H2;simpl.\n  existsQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  right;trivial.\n  case (eq_nat_dec nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case l;intros.\n  case H;intro.\n  rewrite <- H0;simpl.\n  exists ((power n0) l);trivial.\n  rewrite <- H1;simpl.\n  exists (S (S (nat*nat)(S (S (nat*nat)) * (S (nat*nat))) * (S (nat*nat))).\n  split;[apply (IH (pos (nat*nat) (S (nat*nat)) (S (nat*nat))).\n  split;[apply (IH (pos (nat*nat) (S (nat*nat) (S (nat*nat))) | (S (nat*nat))).\n  split;[apply (IH (pos (nat*nat) (S (nat*nat)) (S (nat*nat))).\n  split;[apply (IH (pos (nat*nat) (S (nat) (S (nat*nat) (S (nat*nat))) | (S (nat*nat)))] ).\n  split;[apply (IH (pos (nat*nat) (S (nat*nat) (S (nat*nat) (S (nat*nat)))) | (S (nat*nat) (S (nat*natQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case H.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  left;exists (hd (map (fun x:nat => n=0 -> n=0 -> n=0 -> n=0 -> n=0 -> n=0 -> False) -> False) -> False.\n  intros p l H H0.\n  case H0;intro.\n  case (eq_nat_dec n 0);intro.\n  left;exists (tl (map (fun x:nat => n=0 -> n=0 -> n=0 -> n=0 -> False) -> False).\n  intros p l H1 H2.\n  case H2;intro.\n  left;exists (hd (map (fun x:nat => n=0 -> n=0 -> n=0 -> n=0 -> False) -> False).\n  intros p l H1 H3.\n  case (eq_nat_dec n 0);intro.\n  left;exists (tl (map (fun x:nat => n=0 -> n=0 -> n=0 -> False) -> False).\n  intros.\n  case (eq_nat_dec n 0);intro.\n  left;existsQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case H;intro.\n  left.\n  apply (H (absMod a)).\n  assumption.\n  right.\n  exists (appMod (Nat.pred n0) (mult_comm (nat*nat))(n0)).\n  rewrite mult_comm.\n  apply plus_le_compat.\n  apply plus_le_compat.\n  apply plus_le_compat.\n  apply le_le_trans with (pred (nat*nat)).\n  rewrite mult_comm.\n  apply le_trans with (pred (nat*nat)).\n  rewrite plus_comm.\n  apply le_trans with (pred (nat*nat)).\n  rewrite mult_comm.\n  apply le_trans with (pred (nat*nat)).\n  rewrite plus_comm.\n  apply le_plus_compat.\n  apply le_trans with (pred (nat*nat)).\n  rewrite plus_comm.\n  apply le_trans with (pred (nat*nat)).\n  rewrite plus_comm.\n  apply le_trans with (pred (nat*nat)).\n  rewrite plus_comm.\n  apply le_plus_compat.\n  apply le_plus_compat.\n  apply plus_le_compat.\n  apply le_trans with (predQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;induction l;simpl;try tauto.\n  intro l;Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  intros.\n  case l;intro l;intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1);intro.\n  left;exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  left;exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right;exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right;exists (cons (p,m) l);simpl;rewrite e in H;trivial.\n  right;exists (cons (p,m) l);simpl;rewrite e in H;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\n",
                "context_tokens": 714,
                "proof_start_offset": 13376,
                "proof_end_offset": 13646,
                "proof": "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;try tauto.\nintros;destruct a.\ninversion H0.\ncase (in_inv H);intros.\ninversion H8;rewrite <- H10;rewrite <- H11;try tauto.\napply IHl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros;rewrite H;simpl;trivial.\n  apply (non_zero p);trivial.\n  apply (non_zero p);trivial.\n  apply (non_zero p);trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;intros.\n  exists (nat_of_P l);simpl;trivial.\n  destruct a.\n  rewrite <- H0.\n  exists (pos (S n0) (pos (S n0))).\n  simpl;trivial.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (fun n => False));intro.\n  apply (H (Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  intros l p; induction l;simpl;intros.\n  rewrite <- H0;simpl.\n  exists (app (p,n0) (list_P p) (list_P p)).\n  apply (H0 (list_P p)).\n  apply (H0 (list_P p)).\n  apply (H0 (list_P p)).\n  apply (H0 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H0 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1 (list_P p)).\n  apply (H1Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;auto.\n  intros.\n  case (le_lt_eq_dec n0 (pair p n0) H);intro.\n  case (le_lt_eq_dec n0 (pair p n0));intro.\n  right;exists (S x).\n  split;auto.\n  elim (H0 H0);intro.\n  case (le_eq_dec n0 (pair p n0));intro.\n  right;exists (pair p n0));simpl;auto.\n  elim (le_lt_eq_dec n0 (pair p n0));intro.\n  left;exists (pair p n0));simpl;auto.\n  elim (H0 H1);intro.\n  right;exists (pair p n0);simpl;auto.\n  elim (H0 H0);intro.\n  left;exists (pair p n0);simpl;auto.\n  elim (H0 H1);intro.\n  right;exists (pair p n0);simpl;auto.\n  elim (H0 H1);intro.\n  left;exists (pair p n0);simpl;auto.\n  elim (H0 H2);intro.\n  right;exists (pair p nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  elim p;intros.\n  simpl; intros.\n  case H;intros.\n  rewrite <- H0;simpl.\n  exists (app (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (S n0 n0) n0) n0))) n0) n0)).\n  intros.\n  case H0;intros.\n  case (mult_lt_or_eq (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (S n0) n0) n0))) n0)) n0));intro.\n  case H0;intros.\n  rewrite <- H1;simpl.\n  exists (app (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (mult (S n0) n0) n0) n0))) n0))).\n  intros.\n  case H0;intros.\n  case (mult_lt_or_eq (mult (mult (mult (mult (mult (mult (mult (mult (mult (S n0) nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  assert (p=0).\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  rewrite <- (IH l);simpl;trivial.\n  intros.\n  case (le_gt_dec (power n0) p);intro.\n  left;exists (S n0);trivial.\n  rewrite <- H2;simpl;trivial.\n  intro;subst.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\n  apply (IH l);simpl;trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;intros.\n  rewrite <- H0;simpl.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply pred_pred_le_mono;auto.\n  apply pred_le_mono;auto.\n  apply pred_pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply pred_pred_le_mono;auto.\n  apply pred_le_mono;auto.\n  apply succ_pred_le_mono;auto.\n  apply pred_le_mono;auto.\n  apply pred_pred_le_mono;auto.\n  apply pred_le_mono;auto.\n  apply pred_le_mono;Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;intros.\n  destruct a.\n  left.\n  split;trivial.\n  intro;subst.\n  apply (H a);trivial.\n  left.\n  split;trivial.\n  intro;subst.\n  apply (H a);trivial.\n  apply (H a);trivial.\n  apply (H a);trivial.\n  apply (H a);trivial.\n  apply (H a);trivial.\n  apply (H a);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ";trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 13716,
                "proof_end_offset": 14282,
                "proof": "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros;try tauto.\ndestruct a.\ninversion H0;case (in_inv H);intro.\nrewrite H8 in H7;simpl in H7.\nelim (in_wf ((n0,n1)::l) p n H);trivial;intros.\nelim (mult_rel_prime q (power p n) (refactor l) H7);intros.\napply rel_prime_sym;apply power_rel_prime with n;trivial.\napply (IHl p n q m);trivial.\napply cons_is_wf;trivial.\ninversion H6;trivial.\nsimpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;trivial.\n  intros;destruct a.\n  inversion H0;rewrite <- H0;simpl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\n  apply IHl;trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  destruct a.\n  rewrite <- H0;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\n  rewrite <- H1;simpl; tauto.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  rewrite H.\n  apply H.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\n  induction l;simpl;intros.\n  assert (p=0).\n  inversion H0;clear H0.\n  assert (p=p).\n  inversion H0;clear H0.\n  apply (IHn H0).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H0).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H2).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (IHn H1).\n  apply (Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H0).\n  apply (H1 (posn0)).\n  apply H2;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\n  apply H3;trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  case (in_inv H);intros.\n  inversion H;rewrite <- H;simpl.\n  destruct (H _ H0);trivial.\n  rewrite <- H;simpl.\n  exists (pos n0);trivial.\n  case (in_inv H);intros.\n  inversion H;rewrite <- H;simpl.\n  exists (pos n0);trivial.\n  apply succ_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj;apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj;\n    apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj;\n    apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj; apply pred_inj;\n    apply pred_inj; apply predQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  apply not_wf;auto.\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind H0).\n  apply (is_wf_ind HQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  intros;destruct a.\n  rewrite <- H0;simpl;trivial.\n  elim (H (pos l) H0);intros.\n  rewrite <- H1;simpl;trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\n  apply (H (pos l) H0);trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0;rewrite <- H0;simpl;auto.\n  inversion H0;rewrite <- H1;simpl;auto.\n  inversion H0;rewrite <- H1;simpl;auto.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct b.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct b.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H1;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H0;simpl;trivial.\n  - destruct a.\n    inversion H0;rewrite <- H1;simpl;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 14570,
                "proof_end_offset": 14965,
                "proof": "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\ninduction l;intro.\napply nil_is_pwd.\ndestruct a.\ninversion H.\napply cons_is_pwd;auto.\nintros;intro.\nassert (rel_prime n n).\neapply rel_prime_wf;[apply H7 | apply H].\ngeneralize (gcd_refl n);intro.\nunfold rel_prime in H8.\nassert (1=n).\neapply gcd_unique;eauto.\nrewrite <- H10 in H3;elim H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  case (in_inv H);intro.\n  case (in_inv H);intro.\n  case (in_inv H);intro.\n  case (in_inv H);intro.\n  case (in_inv H);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H1);intro.\n  case (in_inv H0);intro.\n  case (in_inv H1);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H0);intro.\n  case (in_inv H1);intro.\n  case (in_inv H0);intro.\n  case (in_inv H1);intro.\n  case (in_inv H0);intro.\n  case (in_inv H1);intro.\n  case (inQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;simpl;rewrite <- H0;try tauto.\n  apply (is_pwd (nat*nat) (is_wf l)->(is_wf l)).\n  destruct a.\n  inversion H0;simpl;rewrite <- H0;try tauto.\n  apply (is_pwd (nat*nat) (is_wf l)).\n  apply H0;auto.\n  apply (is_pwd (nat*nat) (is_wf l)).\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;rewrite <- H0;try tauto.\n  destruct a.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct a0.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct a0.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct b.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct b.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct b.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct b.\n  inversion H0;rewrite <- H1;try tauto.\n  destruct b.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1;try tauto.\n  inversion H0;rewrite <- H1Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros;try tauto.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;intros;try tauto.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  intros.\n  induction l;simpl;introsQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  intros l.\n  apply (is_pwd l);trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  apply H.\n  intros;apply H.\n  intros;apply H.\n  apply (IHl H0).\n  intros;apply H.\n  apply (IHl H0).\n  intros;apply H.\n  apply H0.\n  apply (IHl H0).\n  intros;apply H.\n  apply (IHl H1).\n  apply (IHl H0).\n  intros;apply H.\n  apply (IHl H0).\n  apply H0.\n  apply (IHl H1).\n  apply (IHl H0).\n  intros;apply H.\n  apply (IHl H0).\n  apply (IHl H1).\n  apply (IHl H0).\n  apply (IHl H0).\n  apply (IHl H0).\n  apply (IHl H0).\n  apply (IHl H1).\n  apply (IHl H1).\n  apply (IHl H0).\n  apply (IHl H0).\n  apply (IHl H1).\n  apply (IHl H0).\n  apply (IHl H0).\n  apply (IHl H1).\n  apply (IHl H1).\n  apply (IHlQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros.\n  exists (nat*nat);trivial.\n  apply (H0 (nat*nat));trivial.\n  apply (H0 (nat*nat));trivial.\n  apply (H0 (nat*nat));trivial.\n  apply (H0 (nat*nat));trivial.\n  apply (H0 (nat*nat));trivial.\n  apply (H1 (nat*nat));trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros;try tauto.\n  destruct a;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct a;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tauto.\n  destruct b;simpl;try tautoQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  simpl;intros;destruct a.\n  inversion H;rewrite <- H;rewrite <- H;try tauto.\n  rewrite <- H0;rewrite <- H;try tauto.\n  apply IHl;trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  case (in_inv H);intros.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv H);intros;try tauto.\n  case (in_inv HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\n",
                "context_tokens": 694,
                "proof_start_offset": 15062,
                "proof_end_offset": 15834,
                "proof": "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\ninduction l;simpl;intros;try tauto.\ncase H3;intro.\nrewrite H4 in H2.\nrewrite H4 in H1;inversion H1.\ngeneralize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\nrewrite mult_comm in H2.\ngeneralize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\napply power_divides_power with p;trivial.\ndestruct p.\nelim (not_prime_zero H8).\nelim H8;omega.\ndestruct a.\ninversion H1.\napply IHl;trivial.\napply gauss with (power n0 n1);trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\napply (rel_prime_wf l p m n0 n1);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros;try tauto.\n  destruct a.\n  inversion H0;apply cons_is_pwd;auto.\n  intros;apply cons_is_pwd;auto.\n  apply cons_is_pwd;auto.\n  apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;apply cons_is_pwd;auto.\n  inversion H0;applyQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intros;unfold p;simpl;try tauto.\n  destruct a.\n  inversion H0.\n  destruct a.\n  inversion H0.\n  inversion H0.\n  apply cons_is_pwd;auto.\n  simpl in H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0;destruct H0Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intro.\n  apply (is_pwd _ _ _ H).\n  apply (is_pwd _ _ _ H).\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intros.\n  inversion H.\n  simpl.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros;simpl;try tauto.\n  simpl.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\n  apply (IHl p n m);trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros.\n  apply (app_rel_prime_wf (fun l:list (nat*nat))(p:nat)(tail:list (nat*nat))(p:nat)(tail:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat)) p}:list (nat*nat*nat) -> Prop :=\n  exists l : list (nat*nat)(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat) p),\n    exists l : list (nat*nat) (p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat))(p:list (nat*nat*nat))(Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros.\n  simpl;try tauto.\n  intros;destruct a.\n  inversion H0;auto.\n  apply cons_is_pwd;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  apply cons_is_pwd;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n  simpl;try tauto.\n  inversion H0;auto.\n Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros;try tauto.\n  apply (lt_irrefl 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 1).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0).\n  apply (le_trans 0Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intro.\n  apply (H0 h0);trivial.\n  apply (H0 h0);trivial.\n  apply H1;trivial.\n  apply (H1 h0);trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intros;subst;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "actor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\n",
                "context_tokens": 691,
                "proof_start_offset": 15927,
                "proof_end_offset": 16738,
                "proof": "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\nintros l l';intro;intro;intro;intros p n;intro.\nelim (in_wf l p n H2 H);intros.\ngeneralize (factor_divides_refactor (p,n) l H2);simpl;intro.\nrewrite H1 in H5.\nassert (divides (refactor l') p).\napply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\nelim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\ncut (n=m).\nintro;rewrite H8;trivial.\napply le_antisym.\neapply prime_power_divides_refactor;eauto.\ngeneralize (factor_divides_refactor (p,m) l' H7);simpl;intro.\nrewrite <- H1 in H8.\napply prime_power_divides_refactor with p l;auto.\nelim (in_wf l' p m);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;intros;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H4.\n  rewrite H4.\n  rewrite H5.\n  rewrite H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- HQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intro;intros;try tauto.\n  case H;intro.\n  rewrite H1 in H1;inversion H1.\n  apply (IHl l l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l' l'' l' l' l'' l'' l' l'' l'' l'' l'' l'' l'' l'' l'' l'' l''.\n  induction l;intro;try tauto.\n  case H;intro.\n  rewrite H4 in H2;inversion H2.\n  apply (IHl' l' l l' l' l'' l'' l'' l l' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l'' l''.\n  induction l';intro;Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;intros;simpl;intros;try tauto.\n  case (IHl l');intros;simpl;intros;try tauto.\n  case H1;intros;try tauto.\n  case H2;intros;try tauto.\n  case H1;intros;try tauto.\n  case H1;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H2;intros;try tauto.\n  case H3;intros;try tauto.\n  case H2;intros;try tauto.\n  case H3;intros;try tauto.\n  case H2;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3;intros;try tauto.\n  case H3Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intro;simpl;intros;try tauto.\n  case (eq_nat_dec x n); intros;try tauto.\n  case (eq_nat_dec x n0); intros;try tauto.\n  case (eq_nat_dec x n0); intros;try tauto.\n  case (eq_nat_dec x n0); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n1); intros;try tauto.\n  case (eq_nat_dec x n0); intros;try tauto.\n  case (eq_nat_dec x n0); intros;try tauto.\n  case (eq_nat_dec x n2); intros;try tauto.\n  case (eq_natQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intro.\n  rewrite (H0 n).\n  rewrite (H2 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H3 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H4 x).\n  rewrite (H5 x).\n  rewrite (H4 x).\n  rewrite (H5 x).\n  rewrite (H4 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H4 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H4 x).\n  rewrite (H5 x).\n  rewrite (H5 x).\n  rewrite (H5Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;simpl;intros;try tauto.\n  case (eq_nat_dec x 0);intros.\n  inversion H;simpl;intros;subst;apply H;trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  intros l l l' H.\n  destruct l;trivial.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;intro.\n  rewrite (IH l) in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 inQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros;simpl;intros;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;intro.\n  - simpl.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l n (list_of_P x)) at 1.\n    rewrite plus_comm.\n    rewrite <- (factorisation_unique_upto_equiv l nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 16740,
                "proof_end_offset": 16884,
                "proof": "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\ninduction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  intros l l;intro;intro;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H; elim H;intro.\n  rewrite <- H0 in H;Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l;intro;intro;intro;subst;auto.\n  case H3;intro.\n  rewrite H4 in H3.\n  rewrite H5 in H3.\n  rewrite H5 in H3.\n  rewrite H6 in H4.\n  rewrite H6 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite HQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  intros l l';intro;intro;intro;subst;auto.\n  case H;intro.\n  rewrite H0 in H0.\n  rewrite H1 in H0.\n  rewrite H1 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l;intro;intro;intros;unfold p0;intro.\n  generalize (factor_constant _ _ H);intro.\n  apply prime_power_divides with p;trivial.\n  elim (in_wf l' p n H1);intros.\n  apply H.\n  generalize (factor_constant _ _ H);intro.\n  apply prime_power_divides with p;trivial.\n  elim (in_wf l' p n H1);intros.\n  rewrite <- H1 in H1; inversion H1.\n  apply H.\n  generalize (factor_constant _ _ H1);intro.\n  apply prime_power_divides with p;trivial.\n  elim (in_wf l' p n H1);intros.\n  apply H.\n  generalize (factor_constant _ _ H1);intro.\n  apply prime_power_divides with p;trivial.\n  elim (in_wf l' p n H1);intros.\n  rewrite <- H1 in H1; inversion H1.\n  apply H.\n  generalize (factor_constant _ _ H1);intro.\n  apply prime_power_divides with p;trivial.\n  elim (in_wf l' n H1);intros.Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l;intro;intro;intros;apply pwd_impl_set;auto.\n  intros;apply pwd_impl_set;auto.\n  intros;apply pwd_impl_set;auto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H1 in H0;inversion H0.\n  apply H0.\n  rewrite H1 in H1;inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H1;inversion H1.\n  apply H0.\n  rewrite H1 in H0;inversion H1.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H0;inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H0;inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H0;inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H0; inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H1; inversion H0.\n  generalize (factor_divides_pos _ _ l H1);intro.\n  rewrite H1 in H1; inversionQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H0 in H0;Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction l;simpl;intros;try tauto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;auto.\n  case l;simpl;intros;subst;auto.\n  case l;simpl;intros;auto.\n  case l;simpl;intros;subst;auto.\n Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l' l';intro.\n  generalize (factor_factor_factor_constant _ _ _ _ _ _ _ _ _ H);intro.\n  rewrite <- (factor_factor_constant _ _ _ _ _ _ _ H);intro.\n  rewrite H0 in H1;clear H.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  assert (factor_constant (fun l0:list (nat*nat){struct l} =>\n            let (l0,l0) := H0 in\n            let (l1,l0) := H1 in\n            let (l1,l1) := H0 in\n            let (l1,l1) := H1 in\n            let (l2,l0) := H1 in\n            let (l1,l1) := H1 in\n            let (l0,l1) := H1 in\n            let (l1,l0) := H0 in\n            let (l0,l1) := H1 in\n            let (l1,l1) := H1 in\n            let (l0,l1) := H1 in\n            let (l1,l2) := H1 inQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  intros l l';intro;intro;intros p;unfold p;intro.\n  case H;intro.\n  rewrite H0 in H0;inversion H0.\n  apply H.\n  rewrite H1 in H0;inversion H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\n",
                "context_tokens": 705,
                "proof_start_offset": 16982,
                "proof_end_offset": 17483,
                "proof": "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\nintros.\nassert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\napply factorisation_unique_upto_equiv_aux;trivial.\nassert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\napply factorisation_unique_upto_equiv_aux;auto.\napply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l';simpl;intros;try tauto.\n  case H;intros;subst;auto.\n  case (in_wf l' p n H);intros.\n  rewrite H0 in H0;inversion H0.\n  case (in_wf l' p n H0 H0);intros.\n  rewrite H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H1 in H0; inversion H0.\n  rewrite <- H0 in H0; inversion HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l; simpl;intros;try tauto.\n  case (in_wf l' p0);intros.\n  elim (in_wf l' p0 n H0);intros.\n  elim (in_wf l' p0 n H2 H3);intros.\n  apply (in_wf l' p0 n H3).\n  elim (in_wf l' p0 n H3 H3);intros.\n  elim (in_wf l' p0 n H3 H3); intros.\n  elim (in_wf l' p0 n H3 H4); intros.\n  apply (in_wf l' p0 n H3 H3).\n  elim (in_wf l' p0 n H3 H3); intros.\n  apply (in_wf l' p0 n H3).\n  elim (in_wf l' p0 n H3 H4); intros.\n  elim (in_wf l' p0 n H3 H4); intros.\n  apply (in_wf l' p0 n H3 H4).\n  elim (in_wf l' p0 n H3 H4); intros.\n  apply (in_wf l' p0 n HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction 1; simpl;intros;try tauto.\n  case H;clear H;intros.\n  generalize (factorisation_unique_upto_equiv_aux l l' H H0);intro.\n  rewrite <- H0 in H1.\n  apply H1.\n  destruct (in_wf l' p) as [l' [l' [l' [l' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [l'' [A [l'' [l'' [l'' [l'' [l'' [s'' [l'' [l'' [l'' [A [l'' [A [l'' [l'' [A [A'' [B [B'' [A [B [C [B [C'' [B [C [B [C [B C]]]]]]]]]]]]]]]].\n  assert (r'' = r').\n  assert (r'' = r'').\n  apply (factorisation_uniqueQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n  induction 1;simpl;intros;try tauto.\n  case H;auto.\n  case H;auto.\n  case H;auto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H.\n  apply (IHn l);trivial.\n  apply (IHn l);trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\n  apply (IHn l');trivial.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction 1;simpl;intros;try tauto.\n  case (H (nat*nat));intro.\n  rewrite H1 in H.\n  rewrite H in H.\n  apply le_trans with (nat*nat).\n  rewrite H0.\n  apply nat_of_P_gt_succ_nat;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_P_gt_succ_nat;auto.\n  rewrite <- H1;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_P_gt_succ_nat;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_P_gt_succ_nat;auto.\n  rewrite <- H0;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_P_gt_succ_nat;auto.\n  rewrite <- H0;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_P_gt_succ_nat;auto.\n  apply pred_le_trans with (nat*nat).\n  apply nat_of_PQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n  induction l;intros;unfold factorisation_unique_upto.\n  generalize (factor_INR_fact l (pos _)), H0; intro.\n  rewrite plus_n_Sm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  case H;intro;intros p n;intro.\n  case (eq_dec p n);intros.\n  left;apply n.\n  apply n.\n  apply H.\n  apply IHn.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n  induction 1;intros;simpl;intros;try tauto.\n  case H0;intro.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1;inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H in HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n  induction 1; simpl;intros;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.\n  case l;intros;simpl;try tauto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\n",
                "context_tokens": 723,
                "proof_start_offset": 17745,
                "proof_end_offset": 17899,
                "proof": "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros.\ncase (factorisation n);intros;try tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n; induction n; simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.\n  simpl;trivial.Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intros n l;unfold factorisation; generalize (factorisation_exists _ _ _ (le_refl n));intro.\n  generalize (factorisation_exists _ _ _ (le_refl n));intro.\n  rewrite H1 in H2.\n  apply (factorisation_exists _ _ _ (le_refl n));intro.\n  apply (factorisation_exists _ _ _ (le_refl n));intro.\n  rewrite H2 in H2.\n  apply (factorisation_exists _ _ _ (le_refl n));intro.\n  rewrite H2 in H2.\n  apply (factorisation_exists _ _ _ (le_refl n));intro.\n  rewrite H2 in H2.\n  apply (factorisation_exists _ _ _ (le_refl n));intro.\n  rewrite H3 in H2.\n  apply (factorisation_exists _ _ (le_refl n));intro.\n  rewrite H3 in H2.\n  apply (factorisation_exists _ _ (le_refl n));intro.\n  rewrite H3 in H2.\n  apply (factorisation_exists _ _ (le_refl n));intro.\n  rewrite H3 in H2.\n  apply (factorQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intros.\n  assert (forall n, 0 < n -> n = 0).\n  apply factorisation_unique_upto_equiv_aux.\n  assert (forall (n:nat), 0 <= n)%nat by omega.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply factorisation_unique_upto_equiv_aux.\n  assert (forall (n:nat), 0 <= n)%nat by omega.\n  apply factorisation_unique_upto_equiv_aux.\n  assert (forall (n:nat), 0 <= n)%nat by omega.\n  apply factorisation_unique_upto_equiv_aux.\n  assert (forall (n:nat), 0 <= n)%nat by omega.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l; induction n as [| n IH]; intros; simpl.\n  - intros.\n    apply (factorisation_unique_upto_equiv_aux n l); auto.\n  - intros.\n    apply (factorisation_unique_upto_equiv_aux n l); auto.\n  - intros.\n    apply (factorisation_unique_upto_equiv_aux n l); auto.\n  - intros.\n    apply (factorisation_unique_upto_equiv n l); auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  induction n as [| n IH]; intros.\n  - exists (S n); split; auto.\n  - exists (S n); split; auto.\n  - exists (S n); split; auto.\n  - exists (S n); split; auto.\n  - exists (S n); split; auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  induction n.\n  - simpl.\n    rewrite plus_0_l.\n    simpl.\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).\n    destruct (in_wf l p).Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [ | a l]; simpl; auto.\n  destruct l as [Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  induction n; simpl;trivial.\n  apply (factorisation_unique_upto_equiv_aux n l H H).\n  apply (factorisation_unique_upto_equiv_aux n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H H).\n  apply (factorisation_unique_upto_equiv n l H).\n  applyQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  assert (forall (x n:nat)(l:list (nat*nat)(x:nat)(l:list (nat*nat)(x:list (nat*nat)),\n    (forall (x:nat)(l:list (nat*nat)(x:list (nat)) (l:list (nat)) (x:list (nat*nat)),\n    (forall (x:nat)(l:list (nat*nat)(x:list (nat*nat)),\n      (forall (x:nat)(l:list (nat*nat)(x:list (nat)) (l:list (nat*nat)),\n      (forall (x:nat)(l:list (nat*nat) x l)) (x:list (nat*nat),\n      (forall (x:nat)(l:list (nat*nat)(x:list (nat*nat)) (l:list (nat*nat)),\n      (forall (x:nat)(l:list (nat*nat)(x:list (nat*nat) l)) (x:list (nat*nat)),\n      (forall (x:nat)(l:list (nat*nat)) (l:list (nat*nat),\n     Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_sym;intros;auto.\n  apply factorisationQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\n",
                "context_tokens": 706,
                "proof_start_offset": 17978,
                "proof_end_offset": 18273,
                "proof": "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\nunfold is_factorisation;intros.\nelim H;intros.\nelim H0;intros.\napply factorisation_unique_upto_perm;auto;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  rewrite <- (factorisation_unique_upto_perm H0 H1).\n  rewrite (factorisation_unique_upto_perm H0 H1).\n  rewrite (factorisation_unique_upto_perm H0 H1).\n  rewrite (factorisation_unique_upto_perm H0 H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H2).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_upto_perm H2).\n  rewrite (factorisation_unique_upto_perm H1).\n  rewrite (factorisation_unique_Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  apply factorisation_unique_upto_perm;trivial.\n  apply (factorisation_unique_upto_perm l);trivial.\n  apply (factorisation_unique_upto_perm l);trivial.\n  apply (factorisation_unique_upto_perm l);trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l);trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.\n  apply (factorisation_unique_upto_perm l');trivial.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  destruct l' as [ | a l']; destruct l'; simpl;trivial.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factoring in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.\n  unfold is_factorisation in *.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  rewrite H1 in H1; discriminate.\n  rewrite <- H1 in H1; discriminate.\n  rewrite H2 in H1; discriminate.\n  rewrite <- H1 in H1; discriminate.\n  rewrite <- H1 in H1; discriminate.\n  rewrite <- H1 in H1; discriminate.\n  rewrite <- H1 in H1; discriminate.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros n l l' H0.\n  elim (factorisation_unique_upto_trans l l l' H1);intros.\n  elim (factorisation_unique_upto_perm_inv_upto_same l' l' H1);intros.\n  elim (factorisation_unique_upto_perm_inv_upto_same l' l' H1);intros.\n  elim (factorisation_unique_upto_trans l l' l' H2);intros.\n  elim (factorisation_unique_upto_same l' l' H2);intros.\n  elim (factorisation_unique_upto_inv_upto_same l' l' H2);intros.\n  elim (factorisation_unique_upto_inv l l' l' H2);intros.\n  elim (factorisation_unique_upto_inv_upto_same l' l' H2);intros.\n  elim (factorisation_unique_upto_inv l' l' H3);intros.\n  elim (factorisation_unique_upto_inv_upto_same l' l' H2);intros.\n  elim (factorisation_unique_upto_inv l' l' H2);intros.\n Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  elim (in_wf l p n H0);intros.\n  exists (S n).\n  apply (factorisation_unique_upto_perm_inv _ _ _ H0).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ H1).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_inv _ _ _ _ _ H2).\n  apply (factorisation_unique_upto_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_perm_inv _ _ _ _ _ H2).\n  apply (factorisation_unique_upto_inv _ _ _ _ H2).\n  apply (factorisation_unique_upto_inv _ _ _ _ _ H2).\n  apply (factorisation_uniqueQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  apply factorisation_unique_upto_perm in H;auto.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H3);intros.\n  elim (in_wf l' n H2);intros.\n  elim (in_wf l' n H3);intros.\n  elim (in_wf l' n H3);intros.\n  elim (in_wf l' n H3);intros.\n  elim (in_wf l' n H3);intros.\n  elim (in_wf l' n H3); intros.\n  elim (in_wf l' n H3); intros.\n  elim (in_wf l' n H3); intros.\n  elim (in_wf l' n H3); intros.\n  elim (in_wf l' n H3); intros.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros n l l' H; elim H; clear H; intro H.\n  elim H; clear H; intro H; elim H; clear H; intro H.\n  apply (factorisation_unique_upto_perm H).\n  intro H0; elim H; clear H; intro H0.\n  elim H; clear H; intro H0.\n  apply (factorisation_unique_upto_perm H).\n  intro H1; elim H1; clear H1; intro H1.\n  elim H; clear H1; intro H0; elim H; clear H; intro H1.\n  apply (factorisation_unique_upto_perm H1).\n  intro H1; elim H1; clear H1; intro H0.\n  apply (factorisation_unique_upto_perm H).\n  intro H2; elim H2; clear H2; intro H3.\n  apply (factorisation_unique_upto_perm H1).\n  intro H2; elim H2; clear H2; intro H2.\n  apply (factorisation_unique_upto_perm H2).\n  intro H2; elim H3; clear H2; intro H3.\n  apply (factorisation_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\nTheorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  unfold is_factorisation;intros.\n  elim H;intros.\n  elim H0;intros.\n  apply factorisation_unique_upto_perm;auto;congruence.\nQed.\n\n(** *)\n",
                "context_tokens": 652,
                "proof_start_offset": 18282,
                "proof_end_offset": 20069,
                "proof": "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintro.\ninduction l;simpl;intros.\nleft;exists 1;rewrite power_one;trivial.\ndestruct a.\nassert (n<>0);try omega.\ngeneralize (quo_rem_euclide n1 n H1);intro.\ncase (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\nrewrite e in H2;rewrite plus_comm in H2;simpl in H2.\ncase IHl;intros;trivial.\ninversion H;trivial.\nelim s;intro y;intro.\nrewrite H2.\nleft;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nelim p3;intros.\nelim H4;intros.\nelim H6;intros.\nelim H8;intros.\nright.\nexists p;exists q;exists r.\nrewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\nexists (k*(power n0 n1)).\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\ninversion H.\nrewrite H9 in H17.\nelim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\napply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\nrewrite plus_comm;auto with arith.\nright.\nexists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\nrewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\nexists (refactor l).\nelim (in_wf ((n0,n1)::l) n0 n1);intros.\nsplit;trivial.\nsplit;trivial.\ndestruct (remainder_euclide n1 n H1);try tauto;auto with arith.\nsplit;trivial.\napply rem_euclide.\nsplit;trivial.\ninversion H;trivial.\nsimpl;tauto.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct H0 as [n?].\n  simpl.\n  apply factorisation_unique_upto_perm;auto.\n  destruct H1 as [n?].\n  apply factorisation_unique_upto_perm;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factorisation n);intros;try tauto.\n  apply factorisation_unique_upto_same;auto.\n  apply factorisation_unique_upto_same;auto.\n  apply factorisation_unique_upto_same;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct H0.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_same;auto.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_perm;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  assert (forall (x n:nat)(l':list (nat*nat){x:nat & {q:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat & {Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  assert (forall (x n:nat)(l':list (nat*nat))(l':list (nat*nat))(l':list (nat*nat))(l':list (nat*nat))(l':list (nat*nat))(l':list (nat*nat))(l':list (nat*nat) l')) (x:nat),\n        (forall (x:nat)(l':list (nat*nat) l'),\n        (forall (x:nat)(l':list (nat) l':list (nat) l'),\n          (forall x:nat, (x = x -> x <> x) l'),\n          (forall x:nat, (x <> x -> x <> x) l'),\n          (forall (x:nat) l':list (nat*nat) l'),\n          (forall x:nat, (x <> x -> x <> x) l'),\n          (forall x:nat, (x <> x -> x <> x) l'),\n          (forall x:nat, (x <> x -> x <> x) l'),\n          (forall x:nat, (x <> x -> x <> x) l'),\n          (forall x:nat, (x <> x -> x <>Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros n l' H1 H2.\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H1 H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H2 H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ _ H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ _ H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ _ H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ _ H3).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ _ H2).\n  rewrite <- (factorisation_unique_upto_perm _ _ _ H3).\n  rewrite <-Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros n l' H H1 H2;inversion H1.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H3;inversion H3.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4;inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4;inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4; inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4; inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4; inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H5; inversion H4.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H5; inversion H5.\n  apply factorisation_unique_upto_perm;auto.\n  intros n l' H4; inversion H5.\n  apply factorisation_unique_upto_perm;auto.\n  intros nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  apply factorisation_unique_upto_perm;auto.\n  apply factorisation_unique_upto_permutation;auto.\n  apply factorisation_unique_upto_perm;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H1;intros.\n  apply factorisation_unique_upto_same with (p0:=p);auto.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;intros.\n  apply factorisation_unique_upto_permutation with (p1:=p);auto.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  apply factorisation_unique_upto_same with (p0:=p);auto.\n  elim H2;intros.\n  elim H2;intros.\n  apply factorisation_unique_upto_perm;auto;congruence.\n  elim H3;intros.\n  elim H2;intros.\n  apply factorisation_unique_upto_perm;auto.\n  elim H3;intros.\n  elim H4;intros.\n  apply factorisation_unique_upto_perm;auto.\n  elim H4;intros.\n  elim H4;intros.\n  apply factorisation_unique_upto_same with (p0:=p);auto.\n  elim H4;intros.\n  apply factorisation_unique_upto_perm;Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  apply (factorisation_unique_upto_same (nat*nat)).\n  unfold is_upper';auto.\n  apply factorisation_unique_upto_same.\n  apply is_set_eq_impl_permutation;intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intro.\n  induction l;simpl;intros.\n  left;exists 1;rewrite power_one;trivial.\n  destruct a.\n  assert (n<>0);try omega.\n  generalize (quo_rem_euclide n1 n H1);intro.\n  case (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\n  rewrite e in H2;rewrite plus_comm in H2;simpl in H2.\n  case IHl;intros;trivial.\n  inversion H;trivial.\n  elim s;intro y;intro.\n  rewrite H2.\n  left;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  elim p3;intros.\n  elim H4;intros.\n  elim H6;intros.\n  elim H8;intros.\n  right.\n  exists p;exists q;exists r.\n  rewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\n  exists (k*(power n0 n1)).\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  apply rel_prime_mult;trivial.\n  inversion H.\n  rewrite H9 in H17.\n  elim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\n  apply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\n  rewrite plus_comm;auto with arith.\n  right.\n  exists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\n  rewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\n  exists (refactor l).\n  elim (in_wf ((n0,n1)::l) n0 n1);intros.\n  split;trivial.\n  split;trivial.\n  destruct (remainder_euclide n1 n H1);try tauto;auto with arith.\n  split;trivial.\n  apply rem_euclide.\n  split;trivial.\n  inversion H;trivial.\n  simpl;tauto.\n  trivial.\nQed.\n\n(** let n be a natural number and m>1 then either n=x^m or there is a prime number p and three numbers q,r and k such that n = p^(q*m+r)*k with 0<r<m and gcd(p,k)=1 *)\n",
                "context_tokens": 668,
                "proof_start_offset": 20239,
                "proof_end_offset": 20661,
                "proof": "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m;intro H.\ncase (eq_nat_dec n 0);intro.\nleft;exists 0.\ndestruct m;simpl;try omega;trivial.\ngeneralize (factorisation_exists n n0);intro.\nelim H0;intro l;intro.\nelim p;intros.\nrewrite H2;apply wf_power_dec;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\n  intro.\n  destruct n;simpl;intros.\n  left;trivial.\n  left;trivial.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros n m n p.\n induction m as [| m IH]; simpl;intros.\ndestruct (eq_nat_dec (S n) (S m)) as [H|H].\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_pos_lt in H.\napply is_power_lt in H.\napply is_power_pos_lt in H.\napply is_power_lt in H.\napply is_power_pos_lt in H.\napply is_power_lt in H.\napply is_power_lt in H.\napply is_power_gt in H.\napply is_power_lt in H.\napply is_power_gt in H.\napply is_power_gt in H.\napply is_power_gt in H.\napply is_power_lt in H.\napply is_Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  destruct n as [|n IH];simpl;intros.\n  left;rewrite mult_comm.\n  destruct a.\n  destruct (eq_nat_dec (p+p)) as [q|q];simpl;intros.\n  destruct a.\n  assert (n<>0);try omega.\n  destruct a.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (n<>0);try omega.\n  destruct b.\n  assert (Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros.\n induction (is_power_dec (p,n)) as [p|p|p];simpl;intros.\n (* 1 *)\n inversion H;clear H; subst.\n (* 1 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (H 0%nat).\n (* 2 *)\n apply (HQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros n m Hn Hm.\n induction (is_power_dec n m);intros.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);intro.\n (* n = 0 *)\n case (le_gt_dec (nat_of_P n) 0);introQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  destruct n;simpl;intros.\n  left;apply (is_power_m_dec n);trivial.\n  right.\n  exists p;exists 1;trivial.\n  apply rel_prime_mult;trivial.\n  apply rel_prime_mult;trivial.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros n m n m; induction n;intros.\n  - apply rel_prime_sym;auto.\n  - apply rel_prime_sym;auto.\n  - apply rel_prime_sym;auto.\n  - apply rel_prime_sym;auto.\n  - apply rel_prime_sym;auto.\n  - apply rel_prime_sym;auto.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction n;simpl;intros.\n  left.\n  destruct a.\n  assert (n=0);try omega.\n  left.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct (IHn0 (power x (S m)) n0 n0);intros.\n  destruct H1.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct (IHn1 (power x (S m)) n0 n0);intros.\n  destruct H1.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct a.\n  assert (n=0);try omega.\n  right.\n  destruct H1.\n  assert (n=0);Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction l;simpl;intros.\n  left;exists (power (p + p)) ;trivial.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct H; try omega.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n  destruct a.\n  assert (n=0);try omega.\n Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros n m Hm Hn.\n  induction n;simpl;intros.\n  left;apply pred_ext.\n  apply rel_prime_mult;trivial.\n  left;apply rel_prime_mult;trivial.\n  right;apply rel_prime_mult;trivial.\n  right;apply rel_prime_mult;trivial.\n  right;apply rel_prime_mult;trivial.\n  right;apply rel_prime_mult;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\n",
                "context_tokens": 252,
                "proof_start_offset": 1012,
                "proof_end_offset": 1219,
                "proof": "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nelim H0;intro q;intro.\nreplace b with (b*1);try ring.\nrewrite H1.\napply mult_le_compat;try omega.\ndestruct q;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_le.\n apply mod_Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n unfold gcd.\n destruct (gcd_dec a b); trivial.\n apply gcd_le.\n apply gcd_lt.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_lt.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_le.\n apply gcd_lt.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_le.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_sym.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nunfold prime.\napply (gcd_le a b).\nrewrite <- (gcd_le b b).\napply gcd_le.\nexact (gcd_le a b).\nexact (gcd_le a b).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le a b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcd_le b c).\nexact (gcdQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b Hb.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a0 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a0 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a0 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a1 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a1 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a0 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a1 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n intros a2 b0.\n case (gcd_gt_dec a b); intro Hb; [left|right]; trivial.\n introsQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  intros; apply (Zabs_eq_dec a); apply (Zabs_eq_dec a); apply (Zabs_eq_dec b);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec b);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec b);\n  apply (Zabs_eq_dec b); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec b);\n  apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec a);\n  apply (Zabs_eq_dec a); apply (Zabs_eq_dec b);\n  apply (ZabsQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b H.\n destruct (sumbool_of_bool (gcd a b)).\n rewrite <- (gcd_0_l a b).\n rewrite <- (gcd_0_r a b).\n rewrite <- (gcd_0_l a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_0_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_l b).\n rewrite <- (gcd_1_r b).\n rewrite <- (gcd_2_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r a b).\n rewrite <- (gcd_1_r b).\n rewrite <- (gcd_2_r a b).\n rewrite <- (gcd_1_r b).\n rewrite <- (gcd_1_r bQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b H.\n case (prime_dec a b); intro H;\n   [ intro H; rewrite H | intro H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite H; rewrite H; rewrite H; rewrite H; rewrite H;\n   rewrite HQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros.\n apply (rel_mul a b); auto.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  intros a b H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply HQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  intros a b.\n  case (mod_lt a b); intros.\n  case (mod_lt a b); intros.\n  case (mod_lt a b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt a b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_lt b); intros.\n  apply (mod_ltQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\n",
                "context_tokens": 338,
                "proof_start_offset": 1256,
                "proof_end_offset": 1718,
                "proof": "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros.\napply (lt_wf_rec a (fun a:nat =>{q : nat & {r : nat | a = b * q + r /\\ r < b}})).\nintros.\ncase (le_lt_dec b n);intro.\nelim (H0 (n-b)).\nintro q;intro.\nelim p;intro r;intro.\nexists (q+1);exists r.\nsplit;try tauto.\nrewrite (le_plus_minus b n);trivial.\nelim p0;intros.\nrewrite H1;ring.\nomega.\nexists 0;exists n.\nsplit;try tauto.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H;intro q;intro q;elim q;intro q;intro q;clear q; intro q; elim q;intro q;clear q; intro q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q; intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q;intros q; elim q; intros q; elim q;\nintros q q q q q q q q q q q q qQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    rewrite q; rewrite q; rewrite q; rewrite q;\n      rewrite q; rewrite q; rewrite q; rewrite q; rewrite q;\n      rewrite q; rewrite q; rewrite q; rewrite q;\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0 q);\n      rewrite (q0 q); rewrite (q0 q); rewrite (q0Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    intros; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; elim q; intro q; elim q;\n    intros; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n    intro q; elim q; intro q; elim q; intro q; elim q; intro; elim q; intro q; elim q; intro q; elim q;\n    intros; elim q; intro q; elim q; intro q; elim q; intro; elim q; intro q; elim q;\n    intro q; elim q; intro; elim q; intro q; elim q; intro; elim q; intro; elim q; elim q; intro; elim q;\n    intro q; elim q; intro q; elim q; intro q; elim q; intro; elimQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H;intro q;intro q;intro q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q; intros q; elim q;intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; \n intros q1 q2; elim q3; intros q3; elim q4; intros q5; elim q5; intros q6; elim q7; \n intros q7 q9; elim q8; intros q10; elim q10; intros q11; elim q10; \n intros q11 q13; elim q13; intros q13; elim q13; intros q13; elim q14; intros q13; elim q14; \n intros q14; elim q14; intros q15; elim q14; intros q15; elim q14; introsQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros a b.\n  elim H0;intro q;intro q;intro q;elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro; elim q; clear q;\n  intros q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' q' qQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H;intro q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro; elim q; clear q;\n    intro q'; rewrite q'; rewrite q'; rewrite q'; rewrite q'; rewrite q';\n    rewrite H1.\n  apply mult_le_reg_l with (r2:=r); assumption.\n  apply mult_le_compat; try omega.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  apply (mult_le_reg_l (r2:=r)); assumption.\n  applyQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H;intro q;intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; elim q; intro q; elim q; intro; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n intro q; elim q; intro q; elim q; intro q; elimQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros a b.\n  elim H;intro q;intro q; elim q;intro q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q;intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q; intros q; elim q;\nintros q0; elim q0; intros q1; elim q0; intros q1; elim q0; intros q2; elim q2; intros q3; elim q3; intros q4; elim q5;\n intros q4; elim q0; intros q5; elim q1; intros q6; elim q1; intros q2; elim q3; intros q5;\n elim q0; intros q6; elim q3; intros q7; elim q1; intros q6; elim q3; intros q7;\n elim q0; intros q7; elim q1; intros q7; elim q3; intros q8; elimQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0;intro q; elim H0;intro q; elim H0;intro q; elim H1;intro q; elim H1;intro q; elim H1;intro q; elim H2; intro q;\n    elim H1;intro q; elim H2;intro q; elim H3;intro q; elim H3; intro q; elim H4;\n        intro q; elim H4; intro q; elim H4; intro q; elim H5; intro q; elim H5;\n          intro q; elim H5; intro q; elim H5; intro q; elim H5; intro q; elim H6;\n          intro q; elim H5; intro q; elim H5; intro q; elim H6;\n          intro q; elim H5; intro q; elim H6; intro q; elim H6; intro q; elim H6;\n          intro q; elim H6; intro q; elim H6; intro q; elim H6; intro q; elim H7;\n          intro q; elim H6; intro q; elim H6; intro q; elim H6;\n          intro q; elim H6; intro qQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H;intro q;intro q; elim q;intro q;intro q; elim q;intro q;intro q; elim q;intro q;intro q; elim q;intro q;intro q; elim q;intro q;intro q;\n elim q;intro q; elim q;intro q; elim q;intro q; elim q;intro q;\n elim q;intro q; elim q;intro q; elim q;intro q; elim q;intro q; elim q;intro q;\n elim q;intro q; elim q;intro q; elim q;intro q; elim q; intro q; elim q;\nintro q; elim q;intro q; elim q;intro q; elim q; intro q; elim q; intro q;\n elim q;intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n elim q; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\nintro q; elim q; intro q; elim q; intro q; elim q; intro q;\n elim q; intro q; elim q; introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\n",
                "context_tokens": 619,
                "proof_start_offset": 1941,
                "proof_end_offset": 2205,
                "proof": "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nunfold quotient_euclide;unfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  case (mod_eucl_dec a b H);intro.\n  exists 1;auto.\n  rewrite (same_minus b n);trivial.\n  rewrite (same_minus b n);trivial.\n  rewrite (same_minus b n);trivial.\n  elim p;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists (q+1);exists r.\n  split;auto.\n  rewrite (same_minus b n);trivial.\n  rewrite (same_minus b n);trivial.\n  rewrite (same_minus b n);trivial.\n  omega.\n  omega.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ a = b)).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_rec b (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun b:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ r < b).\n  intros.\n  apply (mod_unique (fun a:nat => {q : nat | a = b * q + r /\\ r < b) /\\ rQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = b * q + r /\\ r < b)}}.\n  intros.\n Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  elim H;intro q.\n  rewrite (gcd_correct a b);trivial.\n  rewrite (gcd_correct a b);trivial.\n  rewrite (gcd_correct a b);trivial.\n  rewrite (gcd_correct a b);trivial.\n  rewrite (gcd_correct b b);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct a b);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcd_correct b a);trivial.\n  rewrite (gcdQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\ r = b * r /\\ a = b)).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\ r = b * r)).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {r : nat | a = b * r /\\ a = b * r /\\Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H H);intro q;unfold quotient_eucl in |- *;\n  apply (mod_unique b a H);intro q;unfold quotient_eucl in |- *;\n  applyQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  case (le_lt_dec b n);intro.\n  rewrite H;ring.\n  rewrite H;ring.\n  rewrite H;ring.\n  rewrite H;ring.\n  rewrite H;ring.\n  rewrite H;ring.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat & {r : nat | a = b * q + r /\\ r < b}).\n  intros.\n  case (le_lt_eq_dec a b); intro.\n  elim H0; intro r; rewrite H1; ring.\n  elim H0; intro r; rewrite H1; ring.\n  elim H0; intro r; rewrite H1; ring.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b) H).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r /\\ a = b)).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ r = b * r /\\ a = b * r /\\ a = b * r).\n  intros.\n  apply (mod_unique (fun a:nat => {r : nat | a = b * r /\\ a = b * r /\\ a = b * r)).\n  intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2233,
                "proof_end_offset": 2442,
                "proof": "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\nunfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold rem.\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (le_lt_dec b n);intro.\n  elim (lt_irrefl (n-b)).\n  intro q; elim q;intro.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_plus_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_minus b n);trivial.\n  elim q;intro.\n  rewrite (le_minus b n);trivial.\n  elim q;Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold rem; intros.\n  generalize (mod_eucl_ide a b H);intro.\n  elim H0;intro H0; elim H0;intro H0.\n  tauto.\n  tauto.\n  tauto.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_lt_eq_dec b n);intro.\n  elim H;intro H; elim H;intro.\n  elim H;intro.\n  elim H;intro.\n  elim H;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H1;intro.\n  elim H4;intro.\n  elim H1;intro.\n  elim H4;intro.\n  elim H1;Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b * r /\\ r < b)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b * r)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ r < b * r /\\ r < b * r)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b * r /\\ r < b * r)).\n  intros.\n  apply (lt_wf_rec a (fun b:nat => {q : nat | a = q + r /\\ r < b * r /\\ r < b * r)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b * r /\\ r < b * r)).Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quot_eucl; unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl; unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_eucl;\n  unfold quot_euclQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold rem_eucl; unfold modulo_eucl; intros.\n  generalize (mod_small_correct b H); intros.\n  elim H;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elim p;intro.\n  rewrite (le_minus_minus b n);trivial.\n  elimQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ r < b)}).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b /\\ r < b /\\ r < b /\\ r < b)) in H.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b /\\ r < b /\\ r < b) in H.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b /\\ r < b /\\ r < b /\\ r < b)) in H.\n  intros.\n  generalize (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < b /\\ r < b /\\ r < b /\\ r < b)) in H.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = q + r /\\ r < bQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b /\\ r < b)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b /\\ r < b)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b /\\ r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b /\\ r < b)).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {r : nat | a = b * r /\\ r < b /\\ r < b /\\ r <Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  generalize (mod_eucl_ide a b H);intros.\n  elim H0;intro H1;intro H2; elim H2;intro.\n  elim p;intro.\n  elim (le_lt_or_eq _ _ H1);intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H6;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H8;intro.\n  elim H7;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H9;intro.\n  elim H9;intro.\n  elim H8;intro.\n Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quotient_eucl; unfold quotient_eucl; simpl;\n  unfold quotient_eucl; simpl;\n  unfold quotient_eucl; simpl;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of; unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of; unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of; unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfold quotient_of;\n  unfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\n",
                "context_tokens": 700,
                "proof_start_offset": 2478,
                "proof_end_offset": 3403,
                "proof": "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nrewrite H1 in H0.\ncase (lt_eq_lt_dec q q');intro.\ncase s;intro.\nrewrite (le_plus_minus q q') in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (b*(q'-q)+r' = r).\napply plus_reg_l with (b*q).\nrewrite plus_assoc;trivial.\nassert (0<(q'-q));try omega.\nassert (b<=b*(q'-q));try omega.\ncase (mult_O_le b (q'-q));intro;try omega.\nrewrite mult_comm;trivial.\nsplit;try tauto.\nrewrite <- e in H0.\nsymmetry;apply plus_reg_l with (b*q);trivial.\nrewrite (le_plus_minus q' q) in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (r'=(b*(q-q')+r)).\napply plus_reg_l with (b*q').\nrewrite plus_assoc;trivial.\nassert (0<(q-q'));try omega.\nassert (b<=b*(q-q'));try omega.\ncase (mult_O_le b (q-q'));intro;try omega.\nrewrite mult_comm;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n  intros.\n  elim H;intro.\n  rewrite H0.\n  tauto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b q H);intros.\n  generalize (mod_unique a b q H);intro.\n  generalize (mod_unique a b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);intro.\n  generalize (mod_unique b q H);Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b H);intros.\n  elim H0;intro.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b q H); intros.\n  elim (mod_unique b q r' H); intros.\n  generalize (mod_unique b q r' H); intros.\n  elim H0;intro r';intro.\n  elim H0;intro r';intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H8;intro.\n  elim H8;intro.\n  elim H9;intro.\n  elim H7;intro.\n  elim H9;intro.\n  elim HQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b q H);intros.\n  elim p;intro.\n  elim p;intro r;intro r;intro r;intro.\n  elim p;intro r;intro r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro.\n  elim r;intro r;intro r;intro r;intro r.\n  elim r;intro.\n  elim r;intro rQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  apply (lt_wf_rec a b q r); auto.\n  elim p';intro q';intro r;intro r.\n  elim p';intro r.\n  elim q';intro r'.\n  elim r;intro r';intro r.\n  elim q';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n  elim r';intro r'.\n Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  elim H;intro q;intro q.\n  rewrite <- (gcd_sym a b);trivial.\n  elim p;intro r;intro r;intro.\n  elim p;intro r;intro r.\n  tauto.\n  elim p;intro r;intro r; elim r;intro.\n  elim r;intro r;intro r; elim r;intro.\n  elim r;intro r;intro r; elim r;intro.\n  elim r;intro r;intro r.\n  elim r;intro r;intro.\n  elim r;intro r;intro r.\n  elim r;intro r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim rQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.\n  generalize (mod_unique b q H);intros.Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n intros.\n  generalize (mod_unique a b q H);intros.\n  elim p;intro.\n  elim p;intro q;intro r.\n  elim r;intro r;intro r;intro r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro r;intro r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro r;intro r.\n  elim r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro r;intro r.\n  elim r;intro r.\n  elim r;intro r.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n  elim r;intro.\n Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (mod_unique a b q H);intros.\n  elim p;intro r;intro.\n  tauto.\n  elim p;intro r;intro r;intro.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \n",
                "context_tokens": 721,
                "proof_start_offset": 3449,
                "proof_end_offset": 4020,
                "proof": "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\nintros.\nred.\nsplit;intro.\ngeneralize (quo_rem_euclide a b H);intro.\ngeneralize (rem_euclide a b H);intro.\nelim H0;intro q;intro.\nassert (a=b*q+0).\nrewrite plus_comm;simpl;trivial.\nassert (0<b);try omega.\ngeneralize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\nintros;tauto.\ngeneralize (quo_rem_euclide a b H).\nrewrite H0;rewrite plus_comm;simpl.\nintro;exists (quotient_euclide a b H);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  unfold modulo, modulo, modulo, modulo.\n  destruct (mod_eucl a b H);intro.\n  rewrite (le_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (lt_minus_eq b 0);trivial.\n  elim H;intros.\n  rewrite (Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  intros.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*a);auto with arith.\n  apply mod_unique with (b*aQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  intros.\n  rewrite H1 in H.\n  case (le_eq_lt_dec b a);intro.\n  case s;intro H;intro H.\n  rewrite (le_plus_minus b a H0 H0 H0 H1).\n  rewrite (le_plus_minus b a H0 H1).\n  rewrite (le_plus_minus b a H0 H1).\n  rewrite (le_plus_minus b a H1).\n  rewrite (le_minus b a H0 H1).\n  rewrite (le_minus b a H0 H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a H1).\n  rewrite (le_minus b a HQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  generalize (mod_unique a b H);intro.\n  generalize (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);intro.\n  rewrite (mod_unique b H);introQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  intros.\n  rewrite H;trivial.\n  destruct b;intro;intro H;subst;auto.\n  rewrite (le_plus_minus a b H) in H0;try (auto with arith).\n  assert (b*(q-q)+r' = r).\n  apply (le_trans b (q-q)+r' (q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q+r) (q-q-q))).\n  apply (le_trans b (q-q-q)+r' (q-q)).\n  apply (le_trans b (q-q-q)+r' (q-q))).\n  apply (le_transQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H;trivial.\n  rewrite H;trivial.\n  apply mod_eucl_ide.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with b.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with a.\n  rewrite H;trivial.\n  apply mod_mod_unique with b.\n  rewrite H;trivial.\n  apply mod_mod_unique with b.\n  rewrite HQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  generalize (gcd_unique a b H);intros.\n  elim H;intro.\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_unique b a H).\n  destruct (gcd_unique b a H).\n  rewrite (gcd_Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n intros.\n rewrite H.\n apply mod_eucl.\n apply mod_eucl.\n apply mod_mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_unique.\n apply mod_Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H0.\n  case (le_eq_dec a b);intro.\n  rewrite (le_plus_minus b (S b)).\n  rewrite (le_plus_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (S b)).\n  rewrite (le_minus b (Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  intros.\n  rewrite H;ring.\n  rewrite H;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\n",
                "context_tokens": 735,
                "proof_start_offset": 4055,
                "proof_end_offset": 4426,
                "proof": "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\nintros.\ncase (eq_nat_dec b 0).\ncase (eq_nat_dec a 0);intros.\nrewrite e;left;apply zero_max_div.\nright;rewrite e;intro.\nelim H;intro q;intro.\nsimpl in H0;apply n;trivial.\nintro.\ncase (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (prime_dec a b);intro.\n  elim H;intro.\n  elim H0;intro.\n  rewrite H1 in H.\n  elim H0;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H1;intro.\n  elim H1;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H2;intro.\n  elim H3;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H4;intro.\n  elim H4;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H5;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H5;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H5;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H5;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim H6;intro.\n  rewrite (gcd_neg_iff a b H1);intro.\n  elim HQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  apply mod_unique;intro;apply mod_unique;intro;apply mod_unique;intro;apply mod_unique;intro;apply mod_unique;assumption.\n  apply mod_unique;intro;apply mod_unique;intro;apply mod_unique;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;intro;apply mod_unique;intro;apply mod_unique;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;intro;apply mod_unique;apply mod_intro;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;apply mod_intro;apply mod_unique;apply mod_intro;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;apply mod_intro;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;apply mod_intro;apply mod_unique;assumption.\n  rewrite <- e in H;apply mod_unique;apply mod_intro;apply mod_unique;assumption.\n  rewrite <- e in HQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (Zis_gcd_unique a b H);intro.\n  generalize (H a);intro.\n  generalize (H0 a);intro.\n  generalize (H a);intro.\n  generalize (H0 a);intro.\n  generalize (H1 a);intro.\n  generalize (H2 a);intro.\n  generalize (H2 a);intro.\n  generalize (H2 a);intro.\n  generalize (H2 a);intro.\n  generalize (H1 a);intro.\n  generalize (H3 a);intro.\n  generalize (H3 a);intro.\n  generalize (H1 a);intro.\n  generalize (H2 a);intro.\n  generalize (H2 a);intro.\n  generalize (H3 a);intro.\n  generalize (H3 a);intro.\n  generalize (H1 a);intro.\n  generalize (H3 a);intro.\n  generalize (H4 a);intro.\n  generalize (H4 a);intro.\n  generalize (H2 a);intro.\n  generalize (H2 a);intro.\n  generalize (H4 a);intro.\n  generalize (H4 a);intro.\n  generalize (H4 a);intro.\n  generalize (H5 a);Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize ( divides_dec a b H);intro.\n  elim H0;intro.\n  generalize (gcd_dec a b H);intro.\n  elim H0;intro.\n  rewrite (gcd_dec a b H);intro.\n  generalize (gcd_dec a b H);intro.\n  elim H0;intro.\n  elim H1;intro.\n  apply (gcd_dec a b H);intro.\n  elim H0;intro.\n  rewrite (gcd_dec a b H);intro.\n  elim H0;intro.\n  rewrite (gcd_dec a b H0);intro.\n  elim H0;intro.\n  apply (gcd_dec a b H);intro.\n  rewrite (gcd_dec a b H0);intro.\n  rewrite (gcd_dec a b H0);intro.\n  rewrite (gcd_dec a b H0);intro.\n  elim H0;intro.\n  rewrite (gcd_dec a b H0);intro.\n  elim H0;intro.\n  rewrite (gcd_dec a b H);intro.\n  rewrite (gcd_dec a b H0);intro.\n  rewrite (gcd_dec b H0);intro.\n  rewrite (gcdQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (divide_dec a b);intro.\n  elim H;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H2;intro.\n  elim H1;intro.\n  elim H2;intro.\n  elim H4;intro.\n  elim H3;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H4;intro.\n  elim H5;intro.\n  elim H5;intro.\n  elim H6;intro.\n  elim H5;intro.\n  elim H7;intro.\n  elim H6;intro.\n  elim H7;intro.\n  elim H7;intro.\n  elim H7;Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros a b Hb.\n  elim (H a);intro Hb;intro Hb; elim (H a);intro Hb;elim (H a);intro Hb;\nintro Hb; elim (H a);intro Hb; elim (H b);intro Hb;\nintro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\nintro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb;\n elim (H b);intro Hb; elim (H b);intro Hb;\n elim (H b);intro Hb;\n elim (H b);intro Hb;\n elim (H b);intro Hb;\n elimQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (mod_unique a b H);intro.\n  generalize (mod_unique a b H);intro.\n  elim H;intro.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\n  tauto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  elim H; intro; elim H; intro H0; elim H0; intro H0;\n   elim H0; intro H0; elim H0; intro H0;\n   elim H0; intro H0; elim H0; intro H1;\n   elim H0; intro H1; elim H1; intro H1;\n   elim H1; intro H1; elim H1; intro H2;\n   elim H1; intro H2; elim H1; intro H2;\n   elim H1; intro H1; elim H2; intro H2;\n   elim H2; intro H2; elim H2; intro H2;\n   elim H2; intro H2; elim H3; intro H3;\n   elim H3; intro H4; elim H4; intro H5;\n   elim H1; intro H2; elim H2; intro H2;\n   elim H3; intro H2; elim H2; intro H4;\n   elim H4; intro H4; elim H4; intro H5;\n   elim H4; intro H5; elim H2; intro H5;\n   elim H1; intro H5; elim HQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  generalize (mod_unique a b H);intro.\n  generalize (mod_unique a b H);intro.\n  generalize (mod_unique a b H);intro.\n  elim H0;intro.\n  rewrite (le_plus_minus a b H0);intro.\n  elim H1;intro.\n  elim H1;intro.\n  rewrite H0 in H; discriminate.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (mod_unique a b H);intro.\n  elim (mod_unique a b H);intro.\n  elim H0;intro.\n  generalize (mod_unique a b H);intro.\n  elim H0;intro.\n  apply (mod_unique a b H H0);intro.\n  elim H1;intro.\n  apply (mod_unique a b H0);intro.\n  elim H1;intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H2);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b H0 H1);intro.\n  apply (mod_unique b HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\n",
                "context_tokens": 685,
                "proof_start_offset": 4561,
                "proof_end_offset": 4980,
                "proof": "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros.\ninduction m.\nright;intros;inversion H0.\ncase (H m);intro.\nleft;exists m;split;try (auto with arith).\ncase IHm;intro.\nelim s;intro n0;intro.\nleft;exists n0;split;[omega | tauto].\nright;intros.\ninversion H0;trivial.\napply n0;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_le_S m);trivial.\n  intros.\n  generalize (lt_le_minus m p);intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  case (lt_ge_dec m 0);intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  elim H0;intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n  rewrite e;intro.\n  apply (lt_le_minus m p);trivial.\n  intro.\n Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  elim H0;intro.\n  left;apply succ_pred_lt; trivial.\n  right;rewrite e;intro.\n  elim H0;intro.\n  apply succ_pred_lt; trivial.\n  right;rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  elim H0;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H0;intro.Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (le_lt_eq_dec a (P n) 0);intros.\n  case (le_lt_eq_dec a (P n) 0);intros.\n  rewrite e;intro.\n  elim H;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;introQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite <- e;intro.\n  elim H0;intro H2; elim (divides_dec m 0);intros.\n  rewrite e;intro.\n  elim H2;intro H3; elim H3;intro H4; elim H4;intro H4;\n   [apply H4;auto with arith | right;assumption ] ].\n  case (lt_lt_eq_dec m 0);intros.\n  rewrite e;intro.\n  elim H3;intro H4; elim H4;intro H4; elim H4;intro H4;\n   [apply H4;auto with arith | right;assumption ] ].\n  elim H5;intro H4; elim H4;intro H4; elim H4;intro H4;\n   [apply H4;auto with arith | right;assumption ] ].\n  elim H3;intro H4; elim H4;intro H4; elim H4;intro H4;\n   [apply H4;auto with arith | right;assumption ] ].\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite <- (lt_n_S m);trivial.\n  case (eq_nat_dec m 0);intros.\n  rewrite <- (lt_n_S m);trivial.\n  rewrite <- (lt_n_S m);trivial.\n  apply (lt_S_n m);trivial.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  elim H;intro.\n  rewrite e;intro.\n  apply (lt_not_eq (c*q));trivial.\n  assert (0<x);try omega.\n  case (mult_O_le b (c*q));intro;try omega.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_not_eq (c*q));trivial.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_not_eq (c*q));trivial.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_not_eq (c*q));trivial.\n  apply (lt_not_eq (c*q));trivial.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  apply (lt_not_eq (cQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite e;intro;subst;auto.\n  elim H;intro.\n  apply H;auto.\n  elim H;intro.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  generalize (not_le_dec m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_le_eq m n);intro.\n  generalize (not_leQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\n  intros.\n  case (eq_nat_dec (fun m:nat => m=n)).\n  intro.\n  apply H.\n  generalize (is_pos_or_lt m n H);intro.\n  elim H;intro H0.\n  apply H0;intro.\n  rewrite H1;auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0);intros.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.\n  rewrite e;intro.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\nLemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  induction m.\n  right;intros;inversion H0.\n  case (H m);intro.\n  left;exists m;split;try (auto with arith).\n  case IHm;intro.\n  elim s;intro n0;intro.\n  left;exists n0;split;[omega | tauto].\n  right;intros.\n  inversion H0;trivial.\n  apply n0;omega.\nQed.\n\n(** forall n, either forall p, p<>1 /\\ p<>n -> not(p | n) or there is p such that p<>1 and p<>n and p | n *) \n",
                "context_tokens": 706,
                "proof_start_offset": 5092,
                "proof_end_offset": 5809,
                "proof": "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\nintros.\ncase (dec_impl_lt_dec (fun p => (p<>1)/\\(divides n p))) with n;intros.\ncase (divides_dec n n0);intro.\ncase (eq_nat_dec n0 1);intros.\nright;intro;tauto.\nleft;tauto.\nright;tauto.\nelim s;intros.\nleft;exists x.\nsplit;try tauto.\nsplit;try tauto.\nomega.\ncase (eq_nat_dec n 0);intro.\nrewrite e;left;exists 2.\nsplit;try (intro;discriminate).\nsplit;try (intro;discriminate).\napply zero_max_div.\nright;intros.\ncase (lt_eq_lt_dec p n);intro.\ncase s;intro;[red in n0;intro;apply n0 with p;tauto | auto].\nintro;generalize (divides_le n p n1 H1);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  generalize (mod_eucl_ide a b H);intro.\n  rewrite (mod_eucl_while a b H);intro.\n  case (le_lt_lt_or_eq _ _ H0);intro.\n  rewrite <- H1;apply H;trivial.\n  apply H0;trivial.\n  elim H;intro.\n  elim H0;intro.\n  elim H0;intro.\n  elim H0;intro.\n  left; exists n0;split;[omega | tauto ].\n  apply H0;trivial.\n  right;intros.\n  inversion H0;trivial.\n  elim H0;intro.\n  elim H0;intro.\n  right;exists n0;split;[omega | tauto].\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\n  apply H0;trivial.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  elim H;intro p;intro q;intro.\n  elim H0;intro;clear H0;intros p H1; elim H1;intro.\n  left;exists p;split;try (auto with arith).\n  right;intros.\n  inversion H0;trivial.\n  apply n0;omega.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (eq_nat_dec n p);intros.\n  right;apply not_true_iff_lt with (p-n));auto.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  elim H.\n  right;intro.\n  elim H0;intro.\n  right.\n  left;apply H.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply HQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (le_lt_dec (p-q));intro.\n  left;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  left;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);auto.\n  right;apply (H m);Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  generalize (mod_unique_inf a b H);intro.\n  elim H0;intro.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  apply not_le_lt_eq;auto.\n  left;auto.\n  apply not_le_lt_eq;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;autoQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (prime_dec n p);intros.\n  apply prime_dec;auto.\n  destruct (prime_dec n p);intros.\n  right;auto.\n  apply prime_dec;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (not_lt_eq_dec p 0);intro.\n  left;apply not_le_lt_eq_dec.\n  elim H;intro.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (prime_dec n p);intro.\n  left;inversion H0.\n  right;rewrite e;intro.\n  elim H0;intro.\n  right;rewrite e;intro.\n  elim H0;intro.\n  elim H1;intro.\n  left;exists n0;split;[omega | tauto].\n  right;rewrite e;intro.\n  elim H1;intro.\n  elim H1;intro.\n  left;exists n0;split;[omega | tauto].\n  left;rewrite e;intro.\n  elim H1;intro.\n  elim H1;intro.\n  right;rewrite e;intro.\n  elim H1;intro.\n  elim H1;intro.\n  left;exists n0;split;[omega | tauto].\n  right;rewrite e;intro.\n  elim H1;intro.\n  elim H1;intro.\n  right;rewrite e;intro.\n  elim H1;intro.\n  right;rewrite e;intro.\n  elim H1;intro.\n  elim H1;intro.\n  left;exists n0;split;[omega | tauto].\n  right;rewrite e;intro.\n  elim H1;intro.\n  left;exists n0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\n",
                "context_tokens": 382,
                "proof_start_offset": 1408,
                "proof_end_offset": 2212,
                "proof": "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_square;trivial.\nexists (k*(square b)).\nrewrite <- H2;ring.\nelim H3;intro n_a;intro.\nrewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\nassert (k*(b*b)=p*(n_a*n_a)).\napply mult_lemma6 with p.\nintro H5;rewrite H5 in H;apply not_prime_zero;trivial.\nrewrite mult_assoc;rewrite H2;ring.\nassert (divides b p).\napply prime_square;trivial;unfold square.\napply gauss with k.\napply rel_prime_sym;trivial.\nexists (n_a*n_a);trivial.\nassert (p=1).\nunfold rel_prime in H1.\nelim H1;intros.\napply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nelim H;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n induction p.\n (* 0 < s *)\n apply (le_lt_trans (S p)).\n apply le_lt_trans with (S p).\n apply le_trans with (S p).\n apply le_trans with (S p).\n apply le_trans with (S p).\n apply le_trans with (S p).\n apply le_plus_l.\n apply le_trans with (S p).\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_trans with (S p).\n apply le_trans with (S p).\n apply le_plus_l.\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_plus_r.\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_plus_r.\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_trans with (S p).\n apply le_plus_r.\n apply le_trans with (S pQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros. apply sqrt_prime.\n apply sqrt_pos_ir_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\n apply sqrt_nonneg.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\ninduction p.\n (* p = (q) *)\n simpl in |- *.\n apply (lt_irrefl 0).\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- le_refl.\n rewrite <- leQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b c d; apply le_lt_trans with (q*k*(square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square b) + (square bQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\ninduction p.\n (* m = n *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (* m = 0 *)\n (*Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b Ha Hb.\ndestruct (lt_lt_dec k a).\n left; rewrite (H k); rewrite (H k); trivial.\n right; apply Z.lt_trans with (S (S k)); trivial.\n left; apply Z.lt_trans with (S (S k)); trivial.\n left; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n left; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.lt_trans with (S k); trivial.\n right; apply Z.Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b; destruct (eq_decidable_point_equality p k); trivial.\n apply (square_non_prime_aux p k a b); trivial.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\ndestruct (le_lt_dec a b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a <= b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k b).\n (* a < b *)\napply (le_lt_trans k a b).\n (* a < b *)\napply (le_lt_trans k b).\n (* a < b *)\napply (le_lt_trans k b).\n (* a < b *)\napply (le_lt_trans k b).\n (* a < b *)Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n destruct (le_gt_dec 0 p).\n left. apply le_lt_trans with (2*k); [ | apply le_0_n ].\n right. apply le_lt_trans with (2*k); [ | apply le_0_n ].\n left. apply le_lt_trans with (2*k); [ | apply le_0_n ].\n right. apply le_lt_trans with (2*k); [ | apply le_0_n ].\n right. apply le_lt_trans with (2*k); [ | apply le_lt_trans with (2*k); [ | apply le_0_n ].\n right. apply le_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_lt_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_trans with (2*k); [ | apply le_transQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\ninduction p.\n (* 1 < q *)\n intros.\n rewrite <- (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S q)).\n rewrite (lt_O_eq (S qQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "t (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\nLemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\n",
                "context_tokens": 696,
                "proof_start_offset": 2307,
                "proof_end_offset": 3364,
                "proof": "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\nintro.\nrewrite H3 in H5.\nreplace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\nrewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\nassert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\napply mult_lemma6 with (square (gcd a b)).\nunfold square.\ngeneralize (gcd_non_zero (gcd a b) a b H1 H2);intro.\nintro;apply H6.\ncase (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\nrewrite <- H5;ring.\napply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply prime_square;trivial.\n  elim H;intro n_a;intro.\n  rewrite H4 in H1; rewrite H1 in H1; elim H1; intro n_a.\n  rewrite H1 in H1; rewrite square_mult_minus_1 in H1; unfold square in H1;\n    rewrite (mult_comm n_a) in H1; unfold square in H1;\n      rewrite (mult_comm n_a) in H1; unfold square in H1;\n        rewrite (mult_comm n_a) in H1; unfold square in H1;\n          rewrite (mult_comm n_a) in H1; unfold square in H1;\n            rewrite (mult_comm n_a) in H1; unfold square in H1;\n            rewrite (mult_comm n_a) in H1; unfold square in H1;\n            rewrite (mult_comm n_a) in H1; unfold square in H1;\n            rewrite (mult_comm n_a) in H1; unfold square in H1;\n            rewrite (mult_comm n_a) in H1; unfold square in H1;\n           Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply (fun p k a b => (a * (square a b)) k (a * (square b))).\n  intro.\n  elim H;intro n_a;intros.\n  rewrite H1; ring.\n  apply (fun p k a b => (a * (square b)) k (a * (square b)) k (a * (square b))).\n  intro.\n  elim H0;intros.\n  rewrite H0 in H2; rewrite H2 in H2; rewrite H2 in H2; rewrite H2 in H2;\n    rewrite H2 in H2; rewrite H2 in H2; rewrite H2 in H2; rewrite H2 in H2;\n      rewrite H2 in H2; rewrite H2 in H2;\n      rewrite H2 in H2; rewrite H2 in H2; rewrite H2 in H2;\n        rewrite H2 in H2; rewrite H2 in H2;\n        rewrite H2 in H2; rewrite H2 in H2;\n        rewrite H2 in H2; rewrite H2 in H2;\n        rewrite H2 in H2; rewrite H2 in H2;\n        rewrite H2 in H2; rewrite HQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n  intros.\n  unfold rel_prime in H.\n  elim H;intros.\n  apply mod_prime_ir_div; auto.\n  apply div_prime_ir_rat; auto.\n  rewrite <- H2;ring.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_squareQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply sqrt_prime_irrat.\n  apply prime_square;trivial.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply le_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply le_trans with k.\n  apply rel_prime_sym;trivial.\n  apply le_trans with k; trivial.\n  apply rel_prime_sym;trivial.\n  apply le_trans with k.\n  apply rel_prime_sym;trivial.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\n  apply lt_leQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (H1 : (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (b=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (b=p) \\/ (a=p) \\/ (b=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (a=p) \\/ (b=p) \\/ (b=p) \\/ (a=p) \\/ (b=p) \\/ (a=p) \\/ (b=p) \\/ (a=p) \\/ (a=pQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply div_prime_ir_aux; trivial.\n  apply mod_prime_ir_rat; trivial.\n  apply mod_prime_ir_rat; trivial.\n  apply mod_prime_ir_rat; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply div_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply mod_ir_bound; trivial.\n  apply mod_prime_ir_bound; trivial.\n  apply modQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n  intros.\n  generalize (Z.le_le_dec a p); case (le_dec a p); intro.\n  rewrite H4 in H; discriminate.\n  elim H; intro n_a; intro.\n  rewrite H4 in H; discriminate.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\n",
                "context_tokens": 720,
                "proof_start_offset": 3417,
                "proof_end_offset": 3629,
                "proof": "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros.\nreplace p with (p*1);try (auto with arith).\napply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime_1 a b H0);intro.\n  intro.\n  generalize (gcd_is_prime_1 a b H0);intro.\n  intro.\n  generalize (gcd_is_prime_2 a b H0);intro.\n  intro.\n  rewrite H2 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  rewrite H0 in H0;rewrite H1 in H0;rewrite <- H0; ring.\n  apply (add_cancel_l (gcd a b) (gcd_is_prime a b) H0)).\n  apply (add_cancel_l (gcd a b) (gcd_is_prime a b));trivial.\n  rewrite H0 in H0;rewrite <- H0; ring.\n  apply (add_cancel_l (gcd a b) (gcd_is_prime a b));trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros; apply (is_prime_le_1 _ H); assumption.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\n  intro.\n  apply prime_square;trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  rewrite H3 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H3 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H4 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewrite H5 in H; apply not_prime_sym; trivial.\n  intro.\n  rewriteQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n  rewrite (gcd_is_gcd a b);intro.\n Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n intro; apply H;intro.\n rewrite H3 in H0.\n apply gcd_is_gcd.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  generalize (gcd_is_prime_1 p).\n  intro.\n  generalize (gcd_is_prime_1 p).\n  intro.\n  rewrite H3 in H.\n  replace (square (first a) (gcd a b) (gcd_div_r (gcd a b) b)) with (square (div a b) (gcd a b)).\n  trivial.\n  rewrite <- H0;ring.\n  rewrite H1 in H.\n  replace (square a b) with (square (div a b) (gcd a b)); trivial.\n  rewrite H1 in H.\n  replace (square a b) with (square (div b) (gcd a b)).\n  trivial.\n  rewrite <- H0;ring.\n  rewrite H1 in H.\n  replace (square a b) with (square (div a b)).\n  trivial.\n  rewrite <- H0;ring.\n  rewrite H1 in H.\n  replace (square a b) with (square (div a b) (gcd b) (gcd_div_r (gcd a b) b)); trivial.\n  rewrite <- H1;ring.\n  rewrite H1 in H.\n  replace (square a b) withQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  rewrite H0 in H0; apply not_prime_0;trivial.\n  generalize (gcd_is_prime a b);intro.\n  intro.\n  rewrite H0 in H0; apply not_prime_zero;trivial.\n  intro.\n  rewrite H0 in H0; apply not_prime_zero;trivial.\n  intro.\n  rewrite H0 in H0; apply not_prime_zero;trivial.\n  intro.\n  rewrite H0 in H0; apply not_prime_zero;trivial.\n  intro.\n  rewrite H0 in H0; apply not_prime_zero;trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  generalize (gcd_is_prime p);intro.\n  intro.\n  rewrite H3 in H1.\n  rewrite (gcd_is_prime p);intro.\n  rewrite H4 in H1.\n  rewrite (gcd_is_prime p);intro.\n  apply (gcd_is_prime p);intro.\n  rewrite H5 in H1.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcd_is_prime p);intro.\n  rewrite (gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3719,
                "proof_end_offset": 3854,
                "proof": "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\nintros.\napply sqrt_prime;trivial.\napply is_prime_2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n  intros.\n  apply sqrt_prime_ir_rat;auto.\n Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n  apply sqrt_nonneg; try assumption.\n Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  generalize (gcd_is_prime p q);intro.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_pos_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_ir_rat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_prime_irrat; trivial.\n  intro.\n  rewrite <- (sqrt_comm (p*q)).\n  apply sqrt_pos_irrat; trivial.\n  intro.\n  rewriteQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  unfold sqrt; simpl.\n  apply div_prime_irrat;trivial.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply (div_unique (gcd a b) (gcd_div_r (gcd a b) (gcd a b) H2));auto with zarith.\n  apply (div_unique (gcd a b) (gcd_div_r (gcd a b) (gcd_div_r a b) H2));auto with zarith.\n  apply div_unique with (gcd a b);auto with zarith.\n  apply div_unique with (gcd a b);auto with zarith.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) (gcd_div_l (gcd a b) b) H2));auto with zarith.\n  apply div_unique with (gcd a b);auto with zarith.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) (gcd_div_r a b) H2));auto with zarith.\n  apply div_unique with (gcd a b);auto with zarith.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) (gcd_div_r (gcd a b) H2));auto with zarith.\n  apply (gcd_non_Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  destruct (lt_dec q q) as [H|H].\n  destruct (lt_dec q q) as [H|H].\n  apply H0.\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\n  apply rel_prime_sym;auto.\n  apply (sqrt_prime_irrat (gcd a b) (gcd_div_r (gcd a b) a b H2));auto.\n  apply H0.\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\n  apply div_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_unique;auto).\n  exists (q*q);try (apply div_uniqueQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  generalize (le_not_le_eq _ _ (lt_0_sqr p q));intro.\n  intro.\n  rewrite <- (mult_1_l q);apply lt_0_sqr.\n  apply lt_le_trans with (q*q);[assumption | auto with arith].\n  rewrite <- (mult_1_l q);apply lt_0_sqr.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n  intros.\n  generalize (square_is_prime_2 p q);intro.\n  intro.\n  generalize (square_is_prime_2 q);intro.\n  intro.\n  rewrite <- H3 in H0.\n  apply lt_le_trans with (q*q); try (auto with arith).\n  apply (sqrt_prime_irrat (q*q)); try assumption.\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  generalize (sqrt_2_ex p q);intro.\n  intro.\n  apply (eq_dec (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": ".\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\n",
                "context_tokens": 694,
                "proof_start_offset": 3878,
                "proof_end_offset": 5151,
                "proof": "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_power with n;trivial.\ngeneralize (power_divides_lemma1 r p H1);intro.\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite <- H4;exists (q*k*(power b n));ring.\nassert (divides b p).\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite power_mult_lemma1 in H4.\nassert ((power p n)=(power p (r+(n-r)))).\nrewrite <- le_plus_minus;try (auto with arith).\nrewrite H7 in H4;rewrite power_plus_lemma1 in H4.\nassert ((power p r)<>O).\nintro.\napply not_prime_zero.\nassert (p=O).\napply power_zero with r;trivial.\nrewrite H9 in H;trivial.\nrewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\nassert (divides (power p (n-r)) p).\napply power_divides_lemma1;apply minus_lt_lemma1;trivial.\napply prime_power with n;trivial.\napply gauss with k;try (apply rel_prime_sym;trivial).\nrewrite H9;apply divides_mult;trivial.\nelim H3;intros.\nelim H;intros.\napply H9;apply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) a b H0));auto.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) n) (gcd_div_r (gcd a b) n) a b H0));auto.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) n) (gcd_div_r (gcd a b) n) a b H1));auto.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) n) a b H2));auto.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) n) a b H2);auto.\n  apply (is_prime2_non_zero (gcd a b) (gcd_div_r (gcd a b) n) H2);auto.\n  apply (is_prime2_non_zero (gcd a bQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans with (S m);try assumption.\n  apply le_trans withQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  rewrite <- H.\n  apply le_trans with (q*k*(p*k)); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply lt_trans with (q*k); try assumption.\n  apply lt_le_trans with (q*k); try assumption.\n  apply lt_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply lt_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_trans with (q*k); try assumption.\n  apply le_Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply le_lt_trans with (p*k*(p*k)*(q*k)*(q*k)+n*m+n*m+n) by auto.\n  apply le_lt_trans with (p*k*(p*k)+n*m+n*m+n).\n  apply lt_trans with (p*k*(p*k)+n*m+n).\n  apply le_lt_trans with (p*k+n*m).\n  apply lt_trans with (q*k*k).\n  apply le_trans with (q*k).\n  apply lt_trans with (q*k).\n  apply le_trans with (q*k).\n  apply le_trans with (q*k); auto.\n  apply le_trans with (q*k).\n  apply lt_trans with (q*k); auto.\n  apply le_trans with (q*k); auto.\n  apply le_trans with (q*k); auto.\n  apply le_trans with (q*k); auto.\n  apply lt_trans with (q*k); auto.\n  apply le_trans with (q*k); auto.\n  applyQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  rewrite <- (mult_comm (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply sqrt_prime;trivial.\n  apply lt_le_trans with (n*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  apply le_trans with (m*k);try (auto with arith).\n  applyQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply H.\n  apply le_trans with (power a n);try assumption.\n  apply (le_trans (power a n));try assumption.\n  apply le_trans with (power a n);try assumption.\n  apply le_trans with (power a n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply le_trans with (power b n);try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply (le_trans (power b n));try assumption.\n  apply (le_trans (power b n));Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (le_lt_trans (fun p q:nat => p * q) a b n r).\n  rewrite <- (Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (is_prime_2 _ H).\n  apply H1.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply lt_O_Sn.\n  apply H0.\n  apply le_trans with (S (S (pred (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\nLemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_power with n;trivial.\n  generalize (power_divides_lemma1 r p H1);intro.\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite <- H4;exists (q*k*(power b n));ring.\n  assert (divides b p).\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite power_mult_lemma1 in H4.\n  assert ((power p n)=(power p (r+(n-r)))).\n  rewrite <- le_plus_minus;try (auto with arith).\n  rewrite H7 in H4;rewrite power_plus_lemma1 in H4.\n  assert ((power p r)<>O).\n  intro.\n  apply not_prime_zero.\n  assert (p=O).\n  apply power_zero with r;trivial.\n  rewrite H9 in H;trivial.\n  rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\n  assert (divides (power p (n-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\n",
                "context_tokens": 698,
                "proof_start_offset": 5286,
                "proof_end_offset": 6579,
                "proof": "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\nassert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\nassert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\nrewrite power_mult_lemma1 in H8;rewrite H8 in H4.\nrewrite power_mult_lemma1 in H9;rewrite H9 in H4.\nrewrite mult_lemma7 in H4.\nassert ((power (gcd a b) n)<>O).\nintro.\ngeneralize (power_zero n (gcd a b) H10);intro.\napply (gcd_non_zero (gcd a b) a b);trivial.\ngeneralize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\nfold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\napply nth_root_irrat_aux;trivial.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_P p).\n  rewrite (eq_nat_of_PQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply sqrt_prime;trivial.\n  apply sqrt_prime;trivial.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n rewrite <- le_plus_minus; try (apply pred_le_0_compat;trivial).\n rewrite H0 in H;rewrite H0 in H;rewrite <- H0;subst;trivial.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply (is_prime_1 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_1 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime_2 q).\n  apply (is_prime2 q).\n  apply (is_prime_2 q).\n  apply (Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply le_trans with (power p (S n)).\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_trans with (power p (S n)).\n  apply le_plus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_minus_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply le_minus;trivial.\n  apply le_trans with (power p (S n)).\n  apply leQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (div_unique _ _ _ _ H).\n  apply div_unique with (S n);trivial.\n  apply le_trans with (S n);trivial.\n  rewrite H9 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H5;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H4 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H5 in H4;rewrite H4 in H5Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply lt_trans with (power p (n-p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=p)).\n  apply (prod_le_reg_l (p:=pQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply le_lt_trans with (m*(p - p)+1);try (auto with arith).\n  apply le_lt_trans with (m*(p - p)+1);try (auto with arith).\n  rewrite H2;apply mod_le;auto with arith.\n  rewrite H2;apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  rewrite H2;apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  rewrite H1;apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n  apply mod_le;auto with arith.\n Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply (lt_not_eq (Qpositive_le_dec (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))))))) (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))) (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\nTheorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\n",
                "context_tokens": 691,
                "proof_start_offset": 6627,
                "proof_end_offset": 7532,
                "proof": "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nrewrite power_plus_lemma1 in H4.\nassert (divides a (power p q)).\napply prime_power_qn with n;try (auto with arith);try omega.\nexists ((power p r)*k*(power b n)).\nrewrite <- H4;ring.\nassert (0<n);try omega.\nelim H5;intro a';intro.\nrewrite H7 in H4.\nrewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\nassert ((power p (q*n))<>0).\nintro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\nrewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\ngeneralize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\nfold (power p r * k * power b n <> power a' n).\napply nth_root_irrat;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  generalize (pred_inv_prod (fun p k a b => (power p k * power (quo b (gcd a b) (gcd_div_l (gcd a b) k a b) H5))).\n  intros.\n  apply (H (power_zero (gcd a b) n (gcd_div_r (gcd a b) n (gcd_div_r (gcd a b) n (gcd_div_r a b) n (gcd_div_l (gcd_r (gcd a b) n (gcd_div_r (gcd a b) n) b H5))).\n  intros.\n  apply (H (power_zero (gcd a b) n (gcd_div_r (gcd a b) n (gcd_div_r (gcd a b) n (gcd_div_r (gcd a b) n (gcd_div_r (gcd a b) n (gcd_r (gcd_r a b) n) (gcd_div_r (gcd a b) n (gcd_r (gcd_r a b) n))) n) H H1).\n  intros.\n  apply (H (power_zero (gcdQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime b);intro.\n  generalize (div_is_prime a b);intro.\n  generalize (div_is_prime aQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\n generalize (div_is_prime p k a b n q r H0 H1 H2).\ngeneralize (div_is_prime p k a b n q r H0 H1 H2).\nunfold eq_prime in H.\nelim H; intros.\napply (H (p*k));auto with arith.\napply (H (p*k));auto with arith.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (well_founded_induction_ind_ind_rec_ind_ind_rec_ind_ind_ind_rec_ind_rec_ind_ind_ind_ind_rec_ind_ind_ind_ind_rec_ind_ind_rec_ind_rec_ind_ind_ind_ind_ind_ind_ind_rec_ind_ind_ind_ind_rec_ind_ind_ind_rec_ind_ind_ind_ind_ind_ind_rec_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_indQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))) p)))) n) r)).\n  apply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))) p))) n) r)) n)).\n  apply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n generalize (gcd_is_prime (gcd a b) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) n) n) (div_is_prime p) n) n) H1 H2 H3.\n intros.\n generalize (gcd_is_prime (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) n) n) (div_is_prime p) n) H1 H2 H3.\n intros.\n generalize (gcd_is_prime (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) n) n) H1 H2 H3.\n intros.\n generalize (gcd_is_prime (gcd_is_prime p) (gcd_is_prime p) (gcd_is_prime p) n) (gcd_is_prime p) n) HQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (proj1 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos p q)).\n apply (proj2 (pred_pos pQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  generalize (gcd_is_prime p k a b n q r H0 H1 H2).\n  generalize (gcd_is_prime p k a b n q r H0 H1 H2).\n  generalize (gcd_is_prime p k a b n q r H2);intro.\n  generalize (gcd_is_prime p k a b n q r H2);intro.\n  apply (gcd_non_zero (gcd a b) k a b);trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) k a b);trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) k b);trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) k a);trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) k b);trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) k b);trivial.\n  apply (gcd_non_zero (gcd a b) k b);trivial.\n  apply gcd_rel_Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  generalize (size_gt_0 p (gcd_is_prime p k a b n q r H0);intro.\n  rewrite <- (mult_comm k a b n q r H0).\n  apply (mult_cancel_l (p*n)+k*(power b n) (gcd_is_prime p k a b n)).\n  apply mult_cancel_r; trivial.\n  apply le_trans with (q*n-m*(n+p)+k*(power b n) (p+p)+k*(power b n) r).\n  apply (mult_cancel_l (p*n)+k*(power b n) (p+n)+k*(power b n) r).\n  apply (mult_cancel_r (p*n)+k*(n)+k*(power b n) (p+p+p+p)).\n  apply mult_cancel_r; trivial.\n  apply lt_le_trans with (q*n-m+p+p).\n  apply (mult_cancel_r (p*n+p)+k*(power b n) (p+p+p)).\n  apply (mult_cancel_r (Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  generalize (div_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) b) H0));intro.\n  apply (gcd_non_zero (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b))) n) H0))).\n  apply (gcd_non_zero (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b))) n) H0)).\n  apply (gcd_non_zero (gcd_is_prime (gcd a b) (gcd_is_prime (gcd a b) (gcd_is_prime (gcd b) (gcd_is_prime (gcd a b)))) n) H0)).\n  apply (gcd_non_zero (gcd_is_prime (gcd a b)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": " b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\nTheorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\nQed.\n\n(** let x and n be two numbers such that n > 0, then either the n-th root of x is a natural number of it is not rationnal *)\n",
                "context_tokens": 706,
                "proof_start_offset": 7659,
                "proof_end_offset": 8047,
                "proof": "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\ncase (is_power_m_dec x n H);intro;try tauto.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nright;intros.\nassert (x=(power p (q*n+r))*k);try tauto.\nrewrite H1;apply nth_root_irrational;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  elim H; intro H0; elim H0; intro H1.\n  elim (power_non_zero (gcd a b) n H); intro H2; elim H2; intro H3;\n  rewrite H2; ring.\n  rewrite <- (mult_assoc (power p (q*n)) (power b (p*n)) (power b (p*n))) in H2;\n  rewrite (mult_assoc (power p (q*n)) (power b (p*n)) (power b (p*n)) (power b (p*n))) in H2;\n  rewrite (mult_assoc (power p (q*n))) in H2; rewrite H2;\n  rewrite (mult_assoc (power p (q*n)) (power b (p*n)) (power b (p*n))) in H2;\n  rewrite (mult_assoc (power p (q*n)) (power b (p*n))) in H2;\n  rewrite H2; ring.\n  rewrite <- (mult_assoc (power_mult p (q*n)) (power b (p*n))) in H2;\n  rewrite (mult_assoc (Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  intro.\n  apply (lt_irrefl (power (q*n)).\n  apply not_le_lt_trans with (power (q*n)).\n  apply not_le_lt_trans with (power (q*n)).\n  apply not_le_lt_trans with (power (q*n)).\n  apply not_le_trans with (power (q*n)).\n  apply not_le_trans with (power (q*n)).\n  apply not_le_trans with (power (q*n)).\n  apply not_lt_trans with (power (q*n)).\n  apply not_lt_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (power (q*n)).\n  apply not_trans with (Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  generalize (le_gt_dec a (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite mult_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  unfold nat_rect at 1.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  unfold nat_rect at 1.Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  apply (H (power_pos x n) (le_S_n (S (S n))) H0 H1)).\n  apply (H (power_pos y n) H0 H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply H0.\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_pos y n) H1).\n  apply (H (power_posQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n intros.\n apply (lt_irrefl _ H).\n apply (lt_irrefl _ H0).\n apply (lt_irrefl _ H0).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H0).\n apply (lt_irrefl _ H0).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H2).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\n apply (lt_irrefl _ H1).\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  intro.\n  rewrite <- mult_n_O.\n  rewrite plus_comm.\n  rewrite (mult_comm (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n)) in H4.\n  rewrite <- (mult_assoc (power p (q*n)) in H4.\n  rewrite <- (mult_assoc (power p (q*n)) in H4.\n  rewrite <- (mult_assoc (power p (q*n)) in H4.\n  rewrite <- (mult_assoc (power p (q*n))) in H4.\n  rewrite <- (mult_assoc (power p (q*n)) in H4.\n  rewrite <- (mult_assoc (Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  apply minus_le_n_Sm with n;try (auto with arith).\n  apply mult_le_compat_l.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  apply (lt_irrefl (power (x+x) (power b n))).\n  apply H0.\n  apply H1.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  generalize (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))) x))) x) 0 H5)).\n  rewrite <- H5;ring.\n  assert (0<n);try omega.\n  elim H5;intro H5.\n  rewrite H7 in H5.\n  rewrite (mult_assoc (power_lemma (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))) x) 0)) 0 H5))).\n  rewrite <- H5;ring.\n  assert (0<n);try omega.\n  elim H5;intro H5.\n  rewrite H6 in H5.\n  rewrite (mult_assoc (power_lemma (proj2 (proj2 (proj2 (proj2 (proj2 (projQed."
                ]
            }
        ]
    }
}