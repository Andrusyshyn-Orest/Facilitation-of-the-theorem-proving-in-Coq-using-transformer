{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 8,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "32c2695d0f5f0b6117529f2eaa7f240b95cc42eb"
    },

    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold not.\n      destruct x.\n      destruct y.\n      reflexivity.\n      destruct y.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destruct z.\n      destructQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros; apply H.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      inversion H.\n      simpl.\n      destruct H.\n      destruct H.\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (H x0).\n      destruct (HQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      split; intros.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n      apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.\n    apply L.Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Weak in |- *. intros. apply H. exact H. Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction l.\n      - simpl.\n        destruct a; simpl; auto.\n        destruct a; simpl; auto.\n        destruct a; simpl; auto.\n        destruct b; simpl; auto.\n        destruct a; simpl; auto.\n        destruct b; simpl; auto.\n        destruct a; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simpl; auto.\n        destruct b; simplQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction l.\n      destruct l.\n        simpl in H.\n        simpl in H.\n        destruct H.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        apply H0.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct H.\n        subst.\n        simpl.\n        destruct HQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction l; simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L a); simpl; auto.\n      destruct (L aQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Weak.\n      unfold Sub.\n      unfold Sub.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq. unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq.\n      unfold Eq. unfold Eq.\n      unfold Eq.\n      unfold EqQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof using.\n    apply (well_founded_induction_l).\n    intros x.\n    destruct l.\n    simpl.\n    rewrite H.\n    apply T.eq_refl.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros y l x z H. apply X. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; induction l; simpl; intros x z Hz;\n      [ left; assumption | right; assumption ].\n      destruct YZ as [w YW ZW].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z Hz; elim z; simpl; intros z Hz; elim Hz; simpl;\n    intros y z Hz Hz; elim Hz; simpl; intros z Hz.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz Z.\n      apply S_star with (y := z); assumption.\n      destruct Z.eq_dec x z; [ left; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption | right; assumption ].\n      destruct Z.eq_dec x z; [ right; assumption |Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H0; destruct l; simpl; intros y z Hz; try discriminate.\n      apply S_star with y; assumption.\n      destruct YZ as [w YW ZW].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; destruct l; simpl in *; intros x z Hz HzZ.\n      apply S_star with z; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz YZ; apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; destruct l; simpl; intros x z Hz ZZ.\n      apply S_star with y; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_lt_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_lt_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_le_dec; assumption.\n      destruct Z.lt_geQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H; destruct l; simpl; intros x z Hz ZZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H H0 H1; apply H1.\n      apply H1.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz ZZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      destruct l; simpl; intros x y H; try discriminate.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y z H.\n      destruct l; simpl; intros x z Hz ZZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l; destruct l; simpl; intros x z HintvZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY ZZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z XY ZZ.\n      apply S_star with z; assumption.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l; destruct l; simpl; intros x y Hz ZZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros; destruct l; simpl; intros x z XYZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros; destruct l; simpl; intros x z Hz ZZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l; destruct l; simpl; intros x z Contra YZ.\n      apply S_star with x; assumption.\n      apply S_star with x; assumption.\n      apply S_star with x; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tau with y; auto.\n      destruct H; simpl in *; intros x z Hz.\n      apply S_star with y; assumption.\n      destruct YZ as [w YW ZW ZW].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY ZZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XZ.\n      apply S_star with y; assumption.\n      destruct YZ as [w YY]].\n      exists w; auto.\n      apply S_star with y; assumption.\n      destruct YZ as [w YY WZ].\n      exists w; auto.\n      destruct YZ as [w YY WZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z Hz.\n      apply S_star with y; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x z H.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l2.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l2.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l0.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l2.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l2.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l1.\n      apply H.\n      intros y l2.\n      apply H.\n      intros y l2.\n      apply H.\n      introsQed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tau with y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z XY ZZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (weak_tau with y; assumption).\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.\n      destruct (T x y); auto.Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H0.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H0.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H0.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tau with y; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tau with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz ZZ.\n      apply (H 0); simpl; intros x z HzZ.\n      apply (H 0); simpl; intros x z HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.\n      apply (H 0); simpl; intros x HzZ.Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz ZZ.\n      apply R.lt_trans with z; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply (well_founded_induction_ind_type_ind_type_ind_type_ind_type_ind_type_ind_type_ind_type_ind_type_type_ind_type_type_ind_type_type_ind_type_type_type_ind_type_type_ind_type_type_type_ind_type_type_type_ind_type_type_type_ind_type_type_type_type_ind_type_type_type_type_ind_type_type_type_type_type_ind_type_type_type_ind_type_type_type_type_type_ind_type_type_type_type_type_type_ind_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; destruct l; simpl; intros x z Hz ZZ.\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H z Hz ZZ).\n      apply (H z z Hz ZZ).\n      apply (H z Hz ZZ).\n      apply (H z z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H z Hz ZZ).\n      apply (H y z Hz ZZ).\n      apply (H z Hz ZZ).\n      apply (H z Hz ZZ).\n      apply (Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; destruct l; simpl; intros x z HXZ.\n      apply (H x y); assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply (H x y); assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n      apply (H x y); assumption.\n      destruct YZ as [w YWZ].\n      exists w; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HYZ.\n      apply H0; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Hz.\n      apply H0.\n      apply H1.\n      apply H1.\n      apply H1.\n      apply H2.\n      apply H2.\n      apply H2.\n      apply H2.\n      apply H2.\n      apply H2.\n      apply H3.\n      apply H3.\n      apply H3.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; destruct l; simpl; intros x z Hz; lapply YZ;\n        [ apply X; assumption | apply X; assumption ].\n      exists w; auto.\n    Qed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  simple induction xs; intros; discriminate.\n  simpl in |- *.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversion_clear H.\n  intros.  inversionQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nsimple induction 2.\nintros.\napply H.\napply in_map_iff.\nassumption.\nassumption.\n\nintros.\napply in_map_iff in |- *.\nassumption.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff in |- *.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff in |- *.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff in |- *.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintros.\napply in_map_iff.\nassumption.\nintrosQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  unfold ex_intro.  intro.  elim H.  intro.  simpl in |- *.  intro.  elim H.  intro.  simpl in |- *.  intro.  simpl in |- *.  intro.  rewrite H0 in H1.\n  elim (andb_prop _ _ H1).  intro.  elim H1.  intro.  simpl in |- *.  intro.  rewrite H0 in H1.\n  elim (andb_prop _ _ H1).  intro.  simpl in |- *.  intro.  rewrite H1 in H1.\n  elim (andb_prop _ _ H1).  intro.  simpl in |- *.  intro.  rewrite H1 in H1.\n  elim (andb_prop _ _ H1).  intro.  simpl in |- *.  intro.  rewrite H1 in H1.\n  elim (andb_prop _ _ H1).  intro.  simpl in |- *.  intro.  rewrite H1 in H1.\n  elim (andb_prop _ _ H1).  intro.  simpl in |- *.  intro.  rewrite H1 in H1.\n  elim (andb_prop _ _ H1Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\nunfold ex_intro.\nelim (H a).\nintros a0 H0.\nelim (H a0).\nintros a0 H1.\napply H1.\nintros a0 H2.\nelim (H a0).\nintros a0 H2.\nelim (H1 a0).\nintros a0 H3.\nelim (H2 a0).\nintros a1 H4.\nelim (H2 a).\nintros a1 H4.\nelim (H2 a).\nintros a2 H5.\nelim (H2 a).\nintros a0 H5.\nelim (H1 a).\nintros a2 H6.\nelim (H5 a0).\nintros a2 H6.\nelim (H6 a0).\nintros a3 H6.\nelim (H6 a0).\nintros a4 H6.\nelim (H5 a0).\nintros a5 H6.\nelim (H6 a).\nintros a5 H6.\nelim (H6 a0).\nintros a2 H6.\nelim (H6 a0).\nintros a1 H6.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n intros.\n elim (option_sum _ _ (fun a : A => b = f a) xs).\n intros.\n split.\n assumption.\n assumption.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f b xs.\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalize (map_in f b).\n  generalizeQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nsimple induction 1; simpl in |- *.\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a).\nintros.\napply (IHm (fun a : A => f a = f a)).\nelim (IHm (fun a : A => f a = f a).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nelim (IHm (fun a : A => f a = f a)).\nintros.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros.\nelim (option_map f xs).\nelim (option_map f xs).\nintro H.\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a0).\nelim (H a).\nelim (H a0).\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f b xs.\n  split.\n  apply (H (map f xs)).\n  exact (H (map f xs)).\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  simple induction xs; intros; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 l1 H'0; elim H'0; auto.\nintros a0 l H'1; elim H'0; auto.\nintros H'1; elim H'0; auto.\nintros a0 l1 H'1; elim H'1; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'0; elim H'0; auto.\nintros a0 l H'1; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H' H'0 H'1.\nelim H'0; auto.\nintros a0 l0 H'1; elim H'0; auto.\nintros H'2; elim H'0; auto.\nintros H'3; elim H'0; auto.\nintros H'3; elim H'0; auto.\nintros H'3; elim H'0; auto.\nintros H'4; elim H'0; auto.\nintros H'4; elim H'0; auto.\nintros H'5; elim H'0; auto.\nintros H'5; elim H'0; auto.\nintros H'4; elim H'0; auto.\nintros H'5; elim H'0; auto.\nintros H'5; elim H'0; auto.\nintros H'5; elim H'0; auto.\nintros H'6; elim H'0; auto.\nintros H'6; elim H'0; auto.\nintros H'6; elim H'0; auto.\nintros H'6; elim H'0; auto.\nintros H'6Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H' H'0 H'1; elim H'0;\n [ intros H'0; clear H'0 | intros H'0; clear H'0 ].\nelim H'; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l2 H'2; elim H'0; auto.\nintros a0 l2 H'2; elim H'0; auto.\nintros a0 l2 H'0; elim H'0; auto.\nintros a1 l1 H'0; elim H'0; auto.\nintros a1 l2 H'1; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H' H'0; elim H'0; auto.\nintros H'1; elim H'0; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E0 E0; elim E; auto.\nintros a0 E0; elim E; auto.\nintros a0 E0; elim E; auto.\nintros a0 E1; elim E; auto.\nintros a0 E1 E0; elim E; auto.\nintros a0 E1 E1; elim E; auto.\nintros a0 E1 E2; elim E; auto.\nintros a0 E1 E2; elim E; auto.\nintros a0 E1 E2; elim E1; auto.\nintros a0 E1 E2; elim E2; auto.\nintros a0 E2 E3Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H' H'0; elim H'0; auto.\nintros a0 l0 H'1; elim H'0; auto.\nintros a0 l0 H'1; elim H'1; auto.\nintros a0 l1 H'2; elim H'2; auto.\nintros a0 l1 H'2; elim H'2; auto.\nintros a1 l1 H'2; elim H'2; auto.\nintros a0 l1 H'2; elim H'2; auto.\nintros a0 l1 H'2; elim H'2; auto.\nintros a1 l1 H'2; elim H'2; auto.\nintros a1 l1 H'2; elim H'2; auto.\nintros a1 l2 H'1; elim H'2; auto.\nintros a1 l2 H'2; elim H'2; auto.\nintros a1 l2 H'2; elim H'2; auto.\nintros a1 l2 H'2; elim H'2; auto.\nintros a1 l2 H'2; elim H'Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 l1 H'1; elim H'1; [ intros H'2; clear H' | intros H'1; clear H'1 ]; \n auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'; elim H'; intros H'1 H'2; elim H'2;\n [ intros H'3; clear E H'0 | intros H'3; clear E H'0 ]; \n auto.\nintros a0 l H'0 H'1; elim H'0; auto.\nintros a0 l H'0; elim H'1; auto.\nintros a0 l H'1; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'0.\nelim H'; auto.\nintros a0 l1 H'1; elim H'; auto.\nintros a0 l2 H'2; elim H'2; auto.\nintros a0 l2 H'0; elim H'0; auto.\nintros a1 l2 H'2; elim H'0; auto.\nintros a0 l2 H'3; elim H'1; auto.\nintros a1 l2 H'3; elim H'1; auto.\nintros a0 l3 H'0; elim H'0; auto.\nintros a1 l3 H'0; elim H'0; auto.\nintros a1 l3 H'0; elim H'0; auto.\nintros a0 l3 H'0; elim H'0; auto.\nintros a1 l3 H'0; elim H'0; auto.\nintros a1 l3 H'0; elim H'0; auto.\nintros a1 l3 H'0; elim H'0; auto.\nintros a0 l3 H'0; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'0; elim H'0; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E0; elim E; auto.\nintros a1 E; elim E; auto.\nintros a1 E0 E0; elim E; auto.\nintros a1 E0; elim E0; auto.\nintros a1 E0; elim E0; auto.\nintros a1 E0 E1; elim E0; auto.\nintros a1 E1 E1; elim E0; auto.\nintros a1 E1 E1 E2; elim E0; auto.\nintros a2 E2 E3; elim E0; auto.\nintros a3 E1 E2; elim E0; auto.\nintros a2 E3 E4; elim E0; auto.\nintros a4 E5 E6 E6; elim E1;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l H'; elim H'; auto.\nintros a l H'; elim H'; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E0 E0; elim E; auto.\nintros a0 E0 E0; elim E; auto.\nintros a0 E1; elim E; auto.\nintros a0 E1 E1; elim E; auto.\nintros a0 E1 E1; elim E; auto.\nintros a0 E1 E2; elim E; auto.\nintros a0 E1 E1; elim E; auto.\nintrosQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l H'; elim (map_rev l); simpl in |- *; auto with datatypes.\nintros a l H'; elim H'; auto with datatypes.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros a0 E; elim E; auto with datatypes.\nintros aQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'0; elim H'0; intros H'1; clear H'0; auto.\nintros a l1 H'1 H'1; elim H'1; intros H'2 H'2; clear H'1; auto.\nexists a; split; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 l H'0; elim H'0; simpl in |- *; auto.\nintros a0 l1 H'1; elim H'0; simpl in |- *; auto.\nintros a0 l1 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'2; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'2; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'2; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'2; elim H'1; simpl in |- *; auto.\nintros a0 l2 H'2;Qed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l H' H'0; elim H'0; simpl in |- *; auto.\nintros a l H'0; elim H'0; simpl in |- *; auto.\nintros a l H'0; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'0; elim H'; auto.\nintros a0 l0 H'1; elim H'0; intros H'2 H'3; clear H'0.\nexists a0; split; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'0; elim H'0; simpl in |- *; auto.\nintros a0 l H'1; elim H'1; simpl in |- *; auto.\nintros a0 l0 H'2; elim H'1; auto.\nintros a0 l0 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l1 H'2; elim H'1; simpl in |- *; auto.\nintros a0 l1 H'1; elim H'1; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'0; elim H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H'0; elim H'0; auto.\nintros a0 l0 H'1; elim H'0; auto.\nintros a0 l1 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l2 H'1; elim H'0; auto.\nintros a0 l2 H'2; elim H'0; auto.\nintros a0 l3 H'0; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintros a0 l3 H'1; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintros a0 l4 H'1; elim H'0; auto.\nintrosQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 a1 l H'0; elim H'0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 l0 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l2 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'0; elim H'0; auto.\nintros a1 l2 H'Qed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l H'; elim H'; auto.\nintros a l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 l0 H'; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 E; rewrite <- E; simpl in |- *; auto.\nintros a0 E; rewrite <- E; simpl in |- *; auto.\nintros a0 E; rewrite <- E; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0; auto.\nintros a0 l1 H'1; elim H'0; auto.\nintros a0 l1 H'1; elim H'1; auto.\nintros a0 l1 H'1; elim H'1; auto.\nintros a0 l2 H'2; elim H'2; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'; elim H'; auto.\nintros a0 l1 H' H'0; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a1 E; elim E; auto.\nintros a0 E0; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim EQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H'; elim H'; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'1; elim H'1; auto.\nintros a0 l0 H'1; elim H'1; auto.\nintros a0 l1 H'1; elim H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\nelim H'0; intros a0 E; elim E; intros H'1 E; clear E H'0.\nexists a0; split; auto.\nrewrite <- H'; simpl in |- *; auto.\nintros a0 l0 H' H'0.\nelim (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; intros a1 E; elim E; intros H'2 E; clear E H'1.\nexists a0; split; auto.\nrewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H'0; elim H'0; simpl in |- *; auto.\nintros a0 l0 H'1 H'2 H'3; rewrite <- H'; simpl in |- *; auto.\nintros a0 l0 H'1 H'2 H'3; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H'; elim H'0; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H'0; elim l; simpl in |- *; auto.\nintros a0 l0 H'1; elim H'1; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'1; auto.\nintros a0 l0 H'1; elim H'1; auto.\nintros a0 l0 H'1; elim H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0; elim H'0; auto.\nintros a0 l0 H'1; elim H'1; auto.\nintros a0 l1 H'0; elim H'0; auto.\nintros H'1; elim H'1; auto.\nintros a0 l0 H'1; elim H'1; auto.\nintros H'2; elim H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H' H'1; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; simpl in |- *; auto.\nintros a0 l0 H' H'1; elim H'1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\nProof.\n  split.\n  exact (fun x => x).\nDefined.",
                    "Definition zeroP : Term -> Prop.\nVariables (f : M1 -> M2).\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M' : nat.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat.\nHypothesis M : nat -> nat -> nat.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M : nat -> Prop.\nHypothesis M' : nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M' : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M : nat -> nat.\nHypothesis M :Defined.",
                    "Definition zeroP : Term -> Prop.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroP : Term.\nCoercion zeroPDefined.",
                    "Definition zeroP : Term -> Prop.\nVariables (A : Type) (R : relation A).\n\nDefinition M2 := zeroP.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x -> is_zeroP x.\n\nDefinition is_zeroP : Term -> Prop :=\n  forall x : A, is_zeroP x ->Defined.",
                    "Definition zeroP : Term -> Prop.\nVariable P : Term -> Prop.\nVariable P : Term -> Prop.\nVariable P : Term -> Prop.\nVariable P : Term -> Prop.\nVariable P : Term -> Prop.\nVariable P_type : P -> Term -> Prop.\nVariable P_type : forall P : Term -> Prop, P_type P.\n\nVariable P_type : forall P : Term -> Prop, P_type P.\nVariable P_type : forall P : Term -> Prop, P_type P.\nHypothesis P_type_refl : P_type P_type.\nHypothesis P_type_refl : P_type P_type.\nHypothesis P_type_refl : P_type P_refl.\nHypothesis P_type_refl : P_type P_refl.\nHypothesis P_type_trans : P_type P_refl.\nHypothesis P_type_refl : P_type P_refl.\nHypothesis P_type_refl : P_type P_refl.\nHypothesis P_type_refl : P_refl.\nHypothesis P_type_refl : P_type P_refl.\nHypothesis P_type_refl : P_type P_refl.\nHypothesisDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\n  exact: Term.Value.\nDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\n  exact (fun x => (A * mon x)).\nDefined.",
                    "Definition zeroP : Term -> Prop.\nVariable A : Type.\nVariable f : A -> A.\nVariable g : A -> A.\nVariable g : A -> A.\nVariable g : A -> A.\nVariable g : A -> A.\nVariable g : A -> A.\nVariable h : A -> A.\nVariable h : A -> A.\nVariable h : A -> A.\n\nVariable h : A -> A.\nHypothesis h : A.\n\nLet h := h h.\n\nLet h_1 : h h := h h.\nLet h_1 : h h := h h.\n\nLet h_2 : h h := h h.\n\nLet h_2 : h h := h h.\nLet h_2 : h := h h.\nLet h_3 : h h := h h.\n\nLet h_3 : h h := h h.\n\nLet h_4 : h_4 = h.\nProof h_4.\n\nLet h_4 : h_4 = h_4.\nProof h_4.\n\nLet h_4 : h_4 = h_4.\nProof h_4.\n\nLet h_4_Defined.",
                    "Definition zeroP : Term -> Prop.\n\nVariable R : Term -> Prop.\n\nDefinition zeroP : Term -> Prop :=\n  forall x : Term, R x -> R x.\nDefinition zeroP : Term -> Prop :=\n  forall x : Term, R x -> R x.\nDefinition zeroP : Term -> Prop :=\n  forall x : Term, R x -> R x.\nDefinition zeroP : Term -> Prop :=\n  forall x : Term, R x -> R x.\nDefinition zeroP : Term -> Prop :=\n  forall x : Term, R x -> R x.\n\nDefinition oneP : Term -> Prop :=\n  forall x : Term, R x -> exists x : Term, R x x.\n\nDefinition oneP : Term -> Prop :=\n  forall x : Term, R x -> exists x : Term, R x x.\nDefinition oneP : Term -> Prop :=\n  forall x : Term, R x -> exists x : Term, R x x.\n\nDefinition oneP : Term -> Prop :=\n  forall x : Term, R x -> exists x : Term, R x x.\n\nDefinition is_oneP : Term -> Prop :=\n  forall x : Term, exists x : Term, R x x.\n\nDefinitionDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\nsimpl.\nred in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.Defined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros H'; case H'.\nintros a b'; exact (eqA a b /\\ b' = b').\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intro; red in |- *;\n red in |- *; red in |- *; red in |- *; red in |- *; red in |- *;\n red in |- *; red in |- *; intro; red in |- *; red in |- *; intros; red in H'; red in |- *;\n red in |- *; red in |- *; intro; red in H'; red in |- *;\n red in |- *; red in |- *; intro; red in H'; red in |- *;\n red in |- *; red in |- *; red in |- *; intro; red in |- *; red in |- *;\n red in |- *; intro; red in |- *; red in |- *; red in |- *;\n intros; red in |- *; red in |- *; red in |- *; intro; red in H';\n red in |- *; red in |- *; intro; red in |- *; red in |- *;\n red in |- *; red in |- *; intro; red in |- *; red in |- *;\n red in |- *; intro; red in |- *; red in |- *;\n red in |- *; intro; red in |- *;Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred in |- *; red in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *; red in |- *; intros.\nsimpl in |- *;Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nred.\nred.\nred in |- *.\nintros a H'1; exact (eqA a A0).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nintros a H'1; exact (eqA a a a).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nred.\nsimpl in |- *.\nred in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nsimpl in |- *.\nred in |-Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nsimpl in |- *.\nintros a a' H'1; case H'1.\nintros a' H'2; exact (eqA a a'1).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nred in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; intros; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; intros; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; intros; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; intros; red in |- *; red in |- *; intros;\n [ red in |- *; intros; red in |- *; red in |- *; intros;\n [ red in |- *; red in |- *; intros; red in |- *; red in |- *; intros; red in |- *;\n [ red in |- *; intros; red in |- *; red in |- *; intros; red in |- *;\n [ red in |- *; intros; red in |- *; red in |- *; intros; red in |- *;Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred.\nred.\nred.\nred.\nred.\nred in |- *.\nintros a H'1; exact (eqA a a').\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros H'; case H'.\nintros a H'; exact (eqA a a).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros x0; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros a' H'1; exact (eqA a'1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros x H'; exact (eqA_sym _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x;Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nintros a' H'2; exact (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\n  intros x; case x; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n  intros H'; case H'.\nintros a H'0; case H'.\nintros a' H'0; case H'0.\nintros b' H'1; case H'0.\nintros b' H'1; case H'0.\nintros b'0 H'2; case H'0.\nintros b'1; case H'0.\nintros b'0 H'2; case H'0.\nintros b'1; case H'0.\nintros b'1 H'2; case H'0.\nintros b'2 H'3; case H'0.\nintros b'0 H'3; case H'0.\nintros b'0 H'3; case H'0.\nintros b'1 H'3; case H'0.\nintros b'1 H'4; case H'0.\nintros b'1 H'4; case H'0.\nintros b'1 H'2; case H'0.\nintros b'1 H'2; case H'0.\nintros b'1 H'3; case H'0.\nintros b'2 H'4; caseDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a' H'1; case H'.\nintros a' H'2; case H'.\nintros a' H'2; case H'.\nintros a' H'3; case H'.\nintros a' H'4; case H'.\nintros a' H'4; case H'.\nintros a' H'5; case H'.\nintros a' H'6; case H'.\nintros a' H'7; case H'.\nintros a' H'8; case H'.\nintros a' H'9; case H'.\nintros a' H'9; case H'.\nintros a' H'9; case H'.\nintros a' H'10; case H'.\nintros a' H'10; case H'9.\nintros a' H'9; case H'.\nintros a' H'10; case H'.\nintros a' H'10; case H'.\nintros a' H'11; case H'.\nintros a' H'10; case H'.\nintros a' H'11; case H'.\nintros a' H'11; case H'.\nintros a' HDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a H'1; case H'.\nintros a' H'2; exact (eqA a a'1).\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a' H'1; apply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a' H'1; case H'1; case H'2; auto.\nintros a' H'2; case H'2; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs).\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a' H'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'0; case H'.\nintros a'Defined.",
                    "Definition T2M : Term -> mon n.\n  exact (A * mon n)%type.\n \nDefinition t1 : Term -> mon (A * mon n)%type.\n  exact (A * mon n)%type.\n \nEnd Term.\nDefined.",
                    "Definition T2M : Term -> mon n.\n  exact (A * mon (A * mon n)%type.\nEnd Term.\n\nTheorem M1 : Term -> Term -> Term.\nred in |- *.\nintros x; case x; case x; simpl in |- *; intuition.\nintros H'; apply H'.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a' H'0; case H'0.\nintros a' H'1; case H'0.\nintros a'0; case H'1.\nintros a'0; case H'0.\nintros a'0; case H'0.\nintros a'0; case H'1.\nintros a'0; case H'1.\nintros a'0; case H'1.\nintros a'0; case H'0.\nintros a'0; case H'0.\nintros a'0; case H'0.\nintros a'0; case H'1.\nintros a'1; case H'0.\nintros a'1; case H'1.\nintros a'0; case H'1.\nintros a'0; case H'0.\nintros a'0; case H'0.\nintros a'0; case H'1.\nintros a'0; case H'0.\nintros a'1; case H'1.\nintros a'0; case H'0.\nintros a'0; case H'0.\nintros aDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nred in |- *.\nintros x; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y H'; case x'; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nsimpl in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *.\nsimpl in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H' H'0; case H'.\nintros a b; exact H'.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; intros a b H' H'0; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; unfold eqT in |- *; intros x y z H'0; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nred in |- *; intros x y H'0; case H'0.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nred in |- *; intros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nred in |- *; unfold eqTerm in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; simpl in |- *.\nintros b H'0; case (eqmon_dec n c2); intros; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *.\nintros b; case b; simpl in |- *; intuition.\nintros a0 b2 c3.\ncase (eqA_dec b1 b2); intros eqAZ1; auto.\nintros b0 b1 b2 c3.\ncase (eqA_dec b1 c2); intros A; auto.\nintros A; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nintros b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *.\nintros b H' H'0; elim H'; intros H'0 H'1; clear H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros b H; elim H; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros x; case x; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x0; case x0; simpl in |- *; auto.\nintros x1; case x0; simpl in |- *; auto.\nintros x1; case x0; simpl in |- *; auto.\nintros x1; case x1; simpl in |- *; auto.\nintros x1; case x1; simpl in |- *; auto.\nintros x1; case x0; simpl in |- *; auto.\nintros x1; case x1; simpl in |- *; auto.\nintros x1; case x1; simpl in |- *; auto.\nintros x2;Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintros b H'; elim H'; intros H'0 H'1; clear H'; auto.\nintros b H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros a b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := B0); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case H'; simpl in |- *.\nintros b H'; case H'; simpl in |- *; auto.\nintros b H'0; case H'; simpl in |- *; auto.\nintros b H'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'; simpl in |- *; auto.\nintros b'0 H'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'0; simpl in |- *; auto.\nintros b' H'0; case H'0; simpl in |- *; auto.\nintros b' H'0; case H'0; simpl in |- *; auto.\nintros b'0 H'1; case H'0; simpl in |- *; auto.\nintros b'0; case H'; simpl in |- *; auto.\nintros b' H'0; case H'0; simpl in |- *; auto.Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case H'; simpl in |- *.\nintros b H'; case H'; simpl in |- *; intuition.\nintros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := b0); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintros a b H'; case b; simpl in |- *; auto.\nintros b H'; case b; simpl in |- *; auto.\nintros b H'; case b; simpl in |- *; auto.\nintros b H'; case b; simpl in |- *; auto.\nintros b' H'; case b; simpl in |- *; auto.\nintros b' H'; case b; simpl in |- *; auto.\nintros b' H'; case b; simpl in |- *; auto.\nintros b' H'; case b; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros b' H'; case b'; simpl in |- *; auto.\nintros H'; case b'; simpl in |- *; auto.\nintros H'; case b'; simpl in |- *; auto.\nintros n' H'; case b';Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros b H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros b H'; case b; simpl in |- *.\nintros H'0 b' H'0; case H'0; intros H'1; clear H'.\nexists a; exists b'; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'; case H'; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'; case H'; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := B0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ cs) with (y := B0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _Qed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintros b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := b); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'; case H'; simpl in |- *.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros a b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'1; clear H'.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros a b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'1 H'2; clear H'.\nintros a b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'0 H'1; clear H'.\nintros b H'; elim H'; intros H'1; clear H'.\nintros b H'; elim H'; intros H'1; clear H'.\nintrosQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case a; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case a; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *.\nintros a b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *.\nintuition.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H'0; case H'; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b; case b; simpl in |- *; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; intros b1 c2; intros b3 c4;\n apply (plusA b3, c3).\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *.\nintros b H'; case b; simpl in |- *.\nintros b H'; case b; simpl in |- *.\nintros b1 b2 c3; case b; simpl in |- *.\nintros b2 c3; case b; simpl in |- *.\nintros c3 e3; case b; simpl in |- *.\nintros c4 e1; case b; simpl in |- *.\nintros c5 e6; case b; simpl in |- *.\nintros c5 e6; case b; simpl in |- *.\nintros c6 e7; case b; simpl in |- *.\nintros c6 e7; case c; simpl in |- *.\nintros c6 e7; case c; simpl in |- *.\nintros c6 e7; case c; simpl in |- *.\nintros c7 e7; case c; simpl in |- *.\nintros c8 e9; case c; simpl in |- *.\nintros c9 e10; case c; simpl in |- *.\nintros c9 e9; case c; simpl in |- *.\nintros c9 e9; case c; simpl in |- *.\nintros c10 e9; caseQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros b H'; apply (R_eqTerm_r a); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; intros b1 c2; intros b3 c3;\n exact (plusA b1 c2); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; intros b3 c4; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; intros; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; intros b3 c4; intros b4 c5;\n apply (R_multTermr a b3, c2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; intros b; case b; simpl in |- *; auto.\nintros b a0 m1 m2 H1 H2; split; auto.\nintros a0 m1 m2 H1; split; auto.\nintros a0 m2 H1; split; auto.\nintros a1 m1 H2; split; auto.\nintros a1 m2 H2; split; auto.\nintros a1 m2 H1; split; auto.\nintros a2 m1 H1; split; auto.\nintros a2 m2 H2; split; auto.\nintros a3 m3 H1; split; auto.\nintros a3 m3 H1; split; auto.\nintros a3 m3 H1; split; auto.\nintros a3 m3 H2; split; auto.\nintros a4 m3 H1; split; auto.\nintros a4 m3 H2; split; auto.\nintros a4 m3 H2; split; auto.\nintros a4 m4 H2; split; auto.\nintros a5 m4 m4 H1; split; auto.\nintros a5 m4Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1; case m1; simpl in |- *; auto.\nintros a1 m2 H1; case m2; simpl in |- *; auto.\nintros a1 m2 m3 H2; case m3; simpl in |- *; auto.\nintros a2 m3 H1; case m3; simpl in |- *; auto.\nintros a3 m4 m4 H1; case m4; simpl in |- *; auto.\nintros a4 m5 m4 H1; case m4; simpl in |- *; auto.\nintros a4 m4 H2; case m4; simpl in |- *; auto.\nintros a4 m4 H1; case m4; simpl in |- *; auto.\nintros a4 m4 m4 H2; case m4; simpl in |- *; auto.\nintros a4 m4 H1; case m4; simpl in |- *; auto.\nintros a4 m4 H2; case m4; simpl in |- *; auto.\nintros a4 m4 H1; case m4; simpl in |- *; auto.\nintrosQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 B0); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1; elim H1; intros b3 c3; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; elim H1; intros a3 c4; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; intros b0 e; case b; simpl in |- *; auto.\nintros a1 b2 c3; case b0; simpl in |- *; auto.\nintros a2 m1 a3 m3 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ cs) with (y := plusA a3 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a3 B0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := plusA a3 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs)Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a b H'; case b; simpl in |- *; auto.\nintros a1 b2 m1 m2 H' H1 H'2 H'0 H'1 H'2 H'0 H'1 H'2 H'1 H'2 H'2 H'0 H'2 H'0 H'1 H'2 H'2 H'3 H'3 H'0 H'0 H'1 H'2 H'0 H'3 H'1 H'0 H'1 H'2 H'2 H'2 H'2 H'3 H'4'4 H'3 H'4'5 H'4'5 H'5 H'6 H'7 H'7 H'8 H'8 H'9 H'9 H'10 H'11 H'10 H'11 H'12 H'12 H'13 H'13 H'14 H'15 H'16 H'16 H'17 H'17 H'17 H'1 H'1 H'2 H'2 H'3 H'4 H'5 H'6 H'7 H'7Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a b H'; case H'; simpl in |- *; auto.\nintros a b H'; case H'; simpl in |- *; auto.\nintros a1 m2 a3 m1 a3 m1 a3 m2 H1 H2; split; auto.\nintros a1 m3 m4 a4 m1 a4 m3 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a3 A0); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a b H'; case b; simpl in |- *; auto.\nintros a1 m1 m2 H'0; split; auto.\nintros a1 m1 H'0; split; auto.\nintros a2 m2 H'0; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c H; case b; simpl in |- *; auto.\nintros a1 m1 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 B0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c H' H'0; elim H'0; intros H'1; elim H'1; intros H'2; clear H'0.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; case H; auto.\nintros a1 m1 a2 m2 H1; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; case H'; intros H'0;\n [ intros H'1 H'2; apply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b; case b; simpl in |- *; auto.\nintros a b c H'; case b; simpl in |- *; auto.\nintros a b c H'; case b; simpl in |- *; auto.\nintros a b c H'; case b; simpl in |- *; auto.\nintros a' b' H'; case b; simpl in |- *; auto.\nintros a' b' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' b' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case b'; simpl in |- *; auto.\nintros a' H'; case bQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c H; elim H; auto.\nintros a b c H; elim H; auto.\nintros a b H; elim H; auto.\nintros a b c H; elim H; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c H H'; elim H'; auto.\nintros a b c H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\nintros a2 m1 a3 m2 H1 H2; split; auto.\nintros a3 m1 a3 m2 H1 H2; split; auto.\nintros a3 m3 m3 H1; split; auto.\nintros a4 m1 a4 m3 H1 H2; split; auto.\nintros a4 m1 a4 m3 H1 H2; split; auto.\nintros a4 m1 m3 H1 H2; split; auto.\nintros a4 m2 H1; split; auto.\nintros a4 m1 a4 m2 H1 H2; split; auto.\nintros a4 m3 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nintros a c; case b; simpl in |- *; auto.\nintros a c; case b; simpl in |- *; auto.\nintros b c; case b; simpl in |- *; auto.\nintros a0 m1 a2 m2 a3 m2 H H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a3 A0); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ cs) with (y := plusA a3 A0); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (y := plusA a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ cs) with (yQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; intros y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; intros b c2; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nintuition.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H1 H2; case H1; intros H2.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; case m1; case m2; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; case m1; case m2; intros; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; intros; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nintros m2 m3 H0; case m2; simpl in |- *; auto.\nintros m3 H1; case m3; simpl in |- *; auto.\nintros m4 m4 H1; case m4; simpl in |- *; auto.\nintros m5 m4 H1; case m4; simpl in |- *; auto.\nintros m5 m4 H1; case m4; simpl in |- *; auto.\nintros m5 m4 H2; case m4; simpl in |- *; auto.\nintros m6 m4 H1; case m4; simpl in |- *; auto.\nintros m7 m4 H2; case m4; simpl in |- *; auto.\nintros m7 m8 H1; case m4; simpl in |- *; auto.\nintros m8 H1; case m4; simpl in |- *; auto.\nintros m8 H1; case m4; simpl in |- *; auto.\nintros m8 H1; case m4; simpl in |- *; auto.\nintros m8 H1; case m4; simpl in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H1 H2; case H1; intros a b2 c3; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; simpl in |- *; auto.\nintros a b H; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nintros a1 b2 c2; case b1; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H1 H2; case H1; intros H2;\n auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nintros a b H1 H2; elim H1; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; case H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case a; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 a1; case a1; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nintros a b c d; case b; simpl in |- *; auto.\nintros a b c d; case b; simpl in |- *; auto.\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; case b; simpl in |- *; auto.\nintros a b c d; case b; simpl in |- *; auto.\nintuition.\nintuition.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; simpl in |- *; auto.\nintuition.\nQed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x w H.\n  pose proof (lift_TVar _ _ H) as H0.\n  pose proof (lift_TVar _ _ _ H) as H1.\n  pose proof (lift_TVar _ _ _ H) as H1.\n  pose proof (lift_TVar _ _ _ H1) as H2.\n  pose proof (lift_TVar _ _ _ H1) as H2.\n  pose proof (lift_TVar _ _ H2) as H2.\n  pose proof (lift_TVar _ _ H1) as H2.\n  pose proof (lift_TVar _ _ H2) as H3.\n  pose proof (lift_TVar _ _ _ H2) as H3.\n  pose proof (lift_TVar _ _ H2) as H3.\n  pose proof (lift_TVar _ _ H2) as H3.\n  pose proof (lift_TVar _ _ H2) as H3.\n  pose proof (lift_TVar _ _ H2) as H3.\n  pose proof (lift_TVar _ _ _ H2) as H3.\n  pose proof (Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k.\n  destruct (S x) eqn:S; simpl in S; auto.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewrite subst_open_var_env.\n  rewriteQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k.\n  rewrite <- (subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x.\n  apply (proj2_sig (SVar x)); auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x; induction w; simpl; auto.\n  destruct (IHk x); simpl in *; auto.\n  destruct (IHk x); simpl in *; auto.\n  destruct (IHk x); simpl in *; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x; induction x; simpl; auto.\n  repeat intro; auto.\n  repeat intro; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x.\n  assert (H0 : (S x) = (S x)).\n  {\n    pose proof (lift_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k x.\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_equal (f x)).\n  apply (eq_refl_Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros w k.\n  apply (subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_subst_substQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  induction u.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\n  - inversion H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  simpl_lift_goal.\n  intros.\n  rewrite subst_TVar; auto.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  simpl_lift_goal.\n  reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros w k t1 t2.\n  induction t1; simpl; auto.\n  destruct t2; simpl; auto.\n  destruct t1; simpl; auto.\n  destruct t2; simpl; auto.\n  destruct t1; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w k t.\n  induction t as [| k t]; simpl; auto.\n  intros.\n  apply H.\n  apply (IH _ H).\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  destruct w; simpl_lift_goal.\n  apply (IH _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w k t.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w k t.\n  induction t; simpl; intros;\n    [rewrite (IH k t); auto with arith | simpl; auto with arith ].\n  rewrite (IH k t); auto with arith.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w k t.\n  eapply (TAbs (lift w k) t).\n  constructor. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs. apply TAbs.Qed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros w k t.\n  induction t; simpl; intros.\n  reflexivity.\n  destruct a. reflexivity.\n  destruct a. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  simpl_lift_goal.\n  destruct (subst_TVar v k x); simpl.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.Qed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  eauto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros.\n  simpl_subst_rule.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_goal.\n  reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  simpl_subst_env.\n  destruct (TPi t1 t2) as (x,t1).\n  destruct (TPi t2 t1) as (x,t2).\n  eapply (TPi t2 t2).\n  eapply (TPi t2 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t2 t2).\n  eapply (TPi t2 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t2 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t1 t2).\n  eapply (TPi t2 t).\n  eapply (TPi t2 t).\n  eapply (TPi t2 t).\n  eapplyQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  destruct H.\n  eapply (typing_weakening TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbs TAbsQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction 1; intros.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbs.\n  apply TAbsQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  unfold red; intros.\n  rewrite <- (subst_TVar _ _ H0).\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply substTVar.\n  apply subst_TVar.\n  apply substTVar.\n  apply subst_TVar.\n  apply substTVar.\n  apply substQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; intros.\n  apply (H x); auto.\n  apply (H0 x); auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  eapply red_weakening; eauto.\n  eapply red_weakening; eauto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; auto.\n  apply subst_weakening with (TVar x); auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; intros.\n  - apply (subst_weakening T). auto.\n  - apply subst_weakening. auto.\n  - apply subst_weakening. auto.\n  - apply subst_weakening. auto.\n  - apply subst_weakening. auto.\n  - apply subst_weakening. auto.\n  - apply subst_weakening. auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  eapply (well_founded_induction); eauto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  apply (well_founded_induction_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_type_induction_typeQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  induction H; auto.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVarQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  apply H0 in H1; destruct H2.\n  subst.\n  apply H1 in H1; destruct H2.\n  subst.\n  apply H1 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H2; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct H2.\n  subst.\n  apply H2 in H1; destruct HQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x0 H0.\n  induction 1; intros; subst; simpl_env; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) as k.\n  remember (TVar k) asQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  induction H; subst; simpl_lift_goal.\n  - intros.\n    apply (IH (fun x => True)).\n    apply IH; eauto.\n    apply IH; eauto.\n  - intros.\n    apply IH; eauto with subst; simpl_lift_goal.\n  - intros.\n    apply IH; eauto with subst; simpl_lift_goal.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x.\n  destruct (TVar k); subst; simpl_env; auto.\n  econstructor; eauto with lc.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x; induction k; simpl; intros; auto.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVar.\n  apply TVarQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.\n  apply subst_TVar.\n  simpl.Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x.\n  unfold open in *.\n  intros k x.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k0 x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n  intros k x0.\n  unfold open in *.\n Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H0.\n  induction H; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H0. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  induction H; eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction 1; intros; subst; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto; simpl_env_ind; auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H; subst; simpl_lift_goal;\n  econstructor; eauto with subst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion H0; subst.\n  eapply subst_set_closed; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion H. auto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion H. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion H. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H; subst.\n  eapply H.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H2.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n Qed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H0; subst.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H; intros; subst; auto.\n  Case \"typing_var\".\n    simpl.\n    repeat split; auto.\n    apply IHtyping.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T.\n  induction H; intros; subst; auto.\n  destruct (IHtyping_var _ _ _ _ H0 H1) as [x0 [y0 [z [H1 H2]]]].\n  assert (y0 = x0) by (eapply H0; eauto).\n  assert (y0 = x0) by (eapply H0; eauto).\n  assert (y0 = x0) by (eapply H1; eauto).\n  assert (y0 = x0) by (eapply H0; eauto).\n  assert (y0 = x0) by (eapply H1; eauto).\n  assert (y0 = x0) by (eapply H1; eauto).\n  assert (y0 = x) by (eapply H0; eauto).\n  assert (y0 = x0) by (eapply H2; eauto).\n  assert (y0 = x0) by (eapply H2; eauto).\n  assert (y0 = x0) by (eapply H2; eauto).\n  assert (y0 = x0) by (eapply H1; eauto).\n  assert (y0 = x0) by (eapply H0; eauto).\n  assert (Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H.\n  + (* E' *)\n    inversion H.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n    inversion H1.\n    (* E' *)\n   Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H.\n  - intros.\n    apply H0.\n    apply H1.\n    apply H2.\n  - intros.\n    apply H1.\n    apply H1.\n  - intros.\n    apply H2.\n  - intros.\n    apply H1.\n  - intros.\n    apply H2.\n  - intros.\n    apply H0.\n  - intros.\n    apply H2.\n  - intros.\n    apply H1.\n  - intros.\n    apply H1.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T T.\n  induction 1; intros; subst; simpl_env; try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n  try solve [apply subst; auto];\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H; subst; eauto.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.\n  Case \"typing_induction\" H; subst.Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  destruct (H x U E').\n  destruct (H x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E' E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x U E' E').\n  destruct (H0 x U E' E').\n  destruct (H0 x U E').\n  destruct (H0 x U E' E').\n  destruct (H0 x U E').\n  destruct (H0 x U E' E').\n  destruct (H0 x U E').\n  destruct (H0 x U E' E').\n  destruct (H1 x U E').\n  destruct (H0 x U E').\n  destruct (H0 x UQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  inversion H.\n  subst.\n  destruct (IHtyping u e0 t2); auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H; intros; subst; auto.\n  Case \"typing_case\".\n    pick fresh y and apply typing_abs.\n    apply H0.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H0.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H2.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply H1.\n    apply HQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  pose proof (lookup_lookup x t1 E1).\n  pose proof (lookup_lookup x t1 E2).\n  pose proof (lookup_lookup x t2 E1).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t2 E2).\n  pose proof (lookup_lookup x t3 E2).\n  pose proofQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros. inversion H.\n  destruct H0 as [ | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | | [ | ] | [ | ] | | | [ | ] | | [ | ] | | | | ];\n  try (try (rewrite <- H; auto; fail 2)).\n  destruct H0 as [ | [ | ] | [ | ] | [ | ] | | [ | ] | | | ];\n  try (rewrite <- H; auto; fail 2)).\n  destruct H0 as [ | [ | ] | [ | ] | [ | ] | [ | ] | | | [ | ] | | [ | ] | | | | | | | ];\n  try (rewrite <- H; auto; fail 2)).\n  destruct H0 as [ | [ | ] | [ | ] | [ | ] | | | [ | ] | | | | [ | ] | | | | ];\n  try (rewrite <- H; auto; fail 2).\n  destruct H0 as [ | [ | ] | [ | ] | [ | ] | | | | [ | ] | | | | ];Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros. inversion_closed.\n  apply H1 in H2.\n  apply H2 in H3.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H3.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H3 in H2.\n  apply H3 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in HQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction H; intros.\n  + subst.\n    apply (IHAbs t1 t2 t3).\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHAbs.\n    apply IHQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction H; intros; subst; simpl_lift_goal.\n  destruct (lookup x t1); destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t1); destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t1); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t1); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t1); simpl_lift_goal;\n  destruct (lookup x t1); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup x t2); simpl_lift_goal;\n  destruct (lookup xQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  induction H; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros.\n  destruct (lookup x T1 E E) as [x [y' [T1 [T2 [T2 T3]]].\n  destruct (lookup x T2 E) as [x' [y' [T3 T4]]].\n  subst.\n  assert (t1 = t2). subst t2.\n  subst t2.\n  subst t2.\n  subst t2.\n  subst t2.\n  subst t3.\n  subst.\n  apply H0.\n  eauto with lookup_insert_insert.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction E; intros; subst; auto.\n  (* 2 *)\n  auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  unfold subst_idx.\n  destruct (j E).\n  + eauto using type_preservation.\n    eauto using type_preservation.\n    eauto using type_preservation.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction H; simpl; intros; subst; inversion_closed; try apply H0.\n  (* General version of the typing derivation. *)\n  simpl in *.\n  rewrite subst_env_open_var_eq.\n  auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction H; subst; simpl_env_goal;\n  (* 2 *)\n  (* 2 *)\n  intros.\n  destruct (H0 t1).\n  exists (x0,x0).\n  repeat split; auto.\n  apply (H0 t1); auto.\n  (* 2 *)\n  intros.\n  destruct (H0 t2).\n  exists (x0,x1).\n  repeat split; auto.\n  apply (H0 t1); auto.\n  (* 2 *)\n  intros.\n  destruct (H0 t2).\n  exists (x0,x1).\n  repeat split; auto.\n  apply (H0 t1); auto.\n  (* 2 *)\n  intros.\n  destruct (H0 t2).\n  exists (x0,x1).\n  repeat split; auto.\n  apply (H1 t2); auto.\n  (* 4 *)\n  intros.\n  destruct (H0 t2).\n  exists (x0,x1).\n  repeat split; auto.\n  apply (H0 t2); auto.\n  (* 5 *)\n  intros.\n  destruct (H0 t2).\n  exists (x0,x1).\n  repeat split; auto.\n  apply (HQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  (* General *)\n  (* General *)\n  intros t1 E H0.\n  (* TODO: this works, this works. *)\n  unfold subst_i.\n  apply (H1 E) in H.\n  destruct (eq_dec i j).\n  (* the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case. *)\n  (* General *)\n  intros t1 E' H1.\n  (* TODO: this case, this case, the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case of the case. *)\n  (* 2.2.2.2.3.3.3.3.3.3.3.3.3.3.4.3.4.3.5.3.2.3.3.3.3.3.4.5.Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction t1; intros; subst; simpl_env; eauto with pts.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 E T.\n  induction E; intros; subst; eauto with subst.\n  (* General *)\n  subst.\n  (* General *)\n  destruct (IHtyping1 E E) as (x & E & E).\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping2 E E) as (x & E & E').\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping1 E E') as (x & E & E).\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping1 E E') as (x & E & E').\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping2 E E') as (x & E & E).\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping1 E E') as (x & E & E').\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping1 E E') as (x & E & E').\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping1 E E') as (x & E & E').\n  exists x; auto.\n  (* General *)\n  destruct (IHtyping2 EQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_env_open_tm; eauto with pts.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  inversion H.\n  subst.\n  apply (IHAnnTyping _ E E); auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction H; intros; subst.\n  - auto.\n  - intros.\n    destruct (IHForall_dec _ _ _ H0) as (t2 & E & E).\n    + intros.\n      destruct (IHForall_dec _ _ _ H0) as (t3 & E).\n      + intros.\n        eapply E; eauto.\n      + intros.\n        eapply E; eauto.\n      + intros.\n        eapply E; eauto.\n      + intros.\n        eapply E; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\ninduction x; simpl; intros.\n- rewrite <- plus_n_O; auto.\n- rewrite <- plus_n_O; auto.\n- rewrite <- plus_n_O; auto.\n- rewrite <- plus_n_O; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\ndestruct x; simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros. apply (one_plus_x_minus_one_left _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\ndestruct x.\ndestruct x.\nsimpl.\nrewrite <- (same_seq x).\nreflexivity.\nreflexivity.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros x.\ninduction x as [| x]; simpl; auto.\nauto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct x; simpl. auto.\ndestruct xQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n intros.\n destruct (x == x0) eqn:E; auto.\n destruct (x == x0) eqn:E; auto.\n destruct (x == x0) eqn:E; auto.\n destruct (x == x1) eqn:E; auto.\n destruct (x == x1) eqn:E; auto.\n destruct (x == x2) eqn:E; auto.\n destruct (x == x2) eqn:E; auto.\n destruct (x == x2) eqn:E; auto.\n destruct (x == x2) eqn:E; auto.\n destruct (x == x2) eqn:E; auto.\n destruct (x == x3) eqn:E; auto.\n destruct (x == x4) eqn:E; auto.\n destruct (x == x4) eqn:E; auto.\n destruct (x == x4) eqn:E; auto.\n destruct (x == x4) eqn:E; auto.\n destruct (x == x5) eqn:E; auto.\n destruct (x == x4) eqn:E; auto.\n destruct (x == x4) eqn:E;Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\ninduction x; simpl; intros.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x; destruct y; simpl; auto.\n+ destruct x;Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\ninduction x; simpl.\n- destruct x; simpl; auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\n- destruct x; simpl. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  unfold raw_insert.\n  destruct (inf_insert (Some a) (Some a)) as [ | [ | ] | [ | ] | ] ];\n  repeat rewrite <- (rev_involutive (Some a)).\n  rewrite <- (rev_involutive (Some a)).\n  apply raw_insert_zero.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  induction e; simpl; auto.\n  inductionQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; try solve [right; omega | right; omega].\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  induction o; simpl; intros.\n  + (* step *)\n      destruct (raw_insert_zero _ _ _ _ H) as (x &? &? &? &? &? &? &? &? &?);\n      [ auto | | simpl; auto ].\n    + (* step *)\n      destruct (raw_insert_zero _ _ _ _ H) as (x &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &? &?Qed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. apply raw_insert_zero.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  induction o; simpl; intros; auto.\n  destruct (M.add_0 o e); auto.\n  destruct (M.add_0 o e); auto.\n  destruct (M.add_0 o e); auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  induction o; simpl; intros; auto.\n  destruct (raw_insert_zero _ _ _ _ H) as (s & J & J & _).\n  apply (raw_insert_zero _ _ _ _ J).\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction o; simpl; auto.\n  destruct (e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted, e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted, e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sorted), e.(sortedQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  apply raw_insert_nonnil.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  apply raw_insert_nil.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. apply raw_insert_cons. apply raw_insert_nil.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction x; simpl; auto.\n  intros.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct (a0 a); simpl; auto.\n  destruct a;Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_insert.\n  destruct (raw_insert 0 o e).\n  + rewrite raw_insert_spec.\n    apply raw_insert_spec; auto.\n  + rewrite raw_insert_spec.\n    apply raw_insert_spec; auto.\n  + rewrite raw_insert_spec.\n    apply raw_insert_spec; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction o; simpl.\n  - auto.\n  - simpl. rewrite IHs.\n    auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction o; simpl; intros;\n    try (rewrite (PTree.gempty a); auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_insert; simpl.\n  destruct (dec_witness x o).\n  - simpl.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n    rewrite IHs.\n   Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct o; reflexivity. (* Move *)\n  simpl.\n  destruct o; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity. (* Move this *)\n  auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  assert (forall x, In x (insert x o e)) by (intros; contradiction).\n  destruct (In_dec x (insert x o e)); auto.\n  destruct (In_dec x (insert x o e)); auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  assert (forall x, In x (insert x o e) <-> In x (insert x o e)).\n    intros.\n    destruct (raw_insert x o e).\n    - contradiction.\n    - contradiction.\n    - contradiction.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\n  destruct (m == x0); [left|right]; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct o; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\n  apply raw_insert_zero.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct (In_dec x o). subst.\n  reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct o; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct (find_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_Qed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct o; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup; simpl; intros.\n  destruct (find x s); simpl; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  induction x; simpl; intros; auto.\n  rewrite raw_insert_zero in *. congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; auto.\n  destruct o; auto.\n  destruct o; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup; destruct x.\n  rewrite raw_insert_one_right.\n  auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x.\n  simpl.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_zero in *. congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold lookup; simpl.\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (find x (Some a)); auto.\n  (* Move *)\n  destruct (findQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct a; reflexivity.\n  rewrite raw_insert_zero in *. congruence.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros A x a.\n  destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros A x a H; induction a; simpl; reflexivity.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_one_right. auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  induction a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simplQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros A x a; destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; reflexivity.\n  unfold lookup.\n  simpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros; destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  apply lookup_empty_None.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction o; simpl; intros.\n  - destruct o; simpl; try congruence.\n    + destruct o; simpl; try congruence.\n    + destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruence.\n      destruct o; simpl; try congruenceQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct o; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction o; simpl; auto.\n  destruct o; simpl; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct o; simpl; auto.\n  rewrite raw_insert_bing. reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction e; simpl; intros; try discriminate.\n  repeat rewrite Forall_forall; reflexivity.\n  apply insert_bing.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros A x y e.\n  destruct o; simpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  unfold lookup; intros.\n  destruct x; simpl; try solve [ subst; auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct o; simpl; try solve [ auto].\n  destruct oQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eautoQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  rewrite lookup_empty_None. auto.\n  (* The following lemmas are safe. *)\n  simpl.\n  rewrite lookup_empty_None. auto.\n  (* We can't use the following lemmas about the [find] *)\n  simpl. rewrite find_empty_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_NoneQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simplQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* The next case is not-zero. *)\nProof.\n  intros.\n  destruct x; simpl; try solve [ omega | ].\n  destruct y; destruct e; simpl; try solve [ omega | ].\n  destruct y; destruct e; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simpl; try solve [ omega | ].\n  destruct y; simplQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; destruct e; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].\n  destruct y; simpl; try solve [ eauto].Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* The next case. *)\nProof.\n  intros.\n  destruct x; destruct y; simpl; try solve [ omega | apply get_insert_b_in; auto].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [ eauto ].\n  destruct o; simpl; try solve [Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros. unfold lookup, lookup; simpl.\n  rewrite lookup_empty_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_NoneQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup at 1.\n  destruct x; destruct y; simpl; try solve [discriminate].\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None_None. eauto with omega.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup.\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o; simpl; try solve [ eauto].\n  destruct o;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\ndestruct (f a); auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros; apply map_empty.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct f; auto.\n  destruct g; auto.\n  destruct g; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestruct (map_empty A).\ndestructQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  unfold map.\n  rewrite map_empty.\n  reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  induction f; simpl; auto.\n  destruct o; simpl; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros; apply map_empty.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  apply map_empty.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct f; simpl.\n  destruct (f x); simpl.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewrite map_nil.\n  rewriteQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros; apply map_empty.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros; subst; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros; induction x; simpl; intros; auto.\n  - rewrite (insert_b _ _ _ H); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (find_lookup x e).\n  - rewrite lookup_empty.\n    auto.\n  - rewrite lookup_empty. auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros; unfold lookup.\n  destruct (index x) eqn:e; simpl in *; try contradiction.\n  destruct (index x0); simpl in *; try contradiction; subst; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  induction x; intros; auto.\n  destruct e; simpl; auto.\n  f_equal.\n  rewrite lookup_empty_None. auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros A B f.\n  apply lookup_empty.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros; unfold lookup.\n  destruct x; simpl; try congruence; try congruence.\n  destruct x; simpl; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence;\n  destruct x; simpl; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence;\n  destruct x; simpl; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence;\n  destruct x; simpl; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence;\n  destruct x; simpl; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence; try congruence;\n  destruct x;Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (f x); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup; simpl.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (lookup x e).\n  - destruct (lookup x e).\n    + rewrite lookup_empty_None. auto.\n    + rewrite lookup_empty_None_None_None_None. auto.\n    + rewrite lookup_empty_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]? | ]; simpl in *; subst;\n  solve [ auto | congruence ].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]; simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  unfold lookup.\n  rewrite lookup_map_none.\n  rewrite lookup_empty_None.\n  rewrite lookup_empty_None_None_empty; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl in *;\n  try solve [ eauto | congruence ].\n  destruct a; simpl; try solve [ eauto | congruence ].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]?? | [ | ]? | | | | | ];\n  auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros; unfold lookup; simpl.\n  destruct (eq_dec a a); subst; auto.\n  destruct (eq_dec a a); subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | | | ]; simpl in *;\n  solve [ eauto | congruence ].\n  apply lookup_map_some.\n  rewrite lookup_empty_None. auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; destruct e; simpl; try solve [ eauto | congruence ].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ] | ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; simpl; try solve [\n    try solve [ auto];\n    try solve [ auto];\n    try solve [ congruence].\n  - (* nil *)\n    destruct (find_lookup (map f e) (raw_insert k a e)) as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map f e) (raw_insert k a e)) as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map f e) (raw_insert k a e)) as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map f e)) as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map f e) (raw_insert k a e)) as [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map f e)) as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence].\n    destruct (find_lookup (map fQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? | ]??; simpl in *; subst;\n    solve [ congruence | congruence ];\n    try match goal with H: find_insert_left _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_left _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_left _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminate H end;\n    try match goal with H: find_insert_right _ _ _ = Some _ |- _ => discriminateQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  unfold raw_insert.\n  destruct (find_map_some _ _ H) as (a & b & e & f & f & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g' & g' & g & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g' & g'.\n  exists g' & g' & g' & g' & g' & g' & g' & g' & g' & g & g' & g' & g' & g' & g & g' & g' & g' & g' & g' & g' &Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? | ]? ]; simpl in *; subst;\n    solve [\n    auto;\n    try match goal with\n      | [ H: context [nth_error _?a?b ] |- _ =>\n        assert (a = b) by (apply (insert_insert_neq a b a b) end;\n        subst;\n        try match goal with H : context [nth_error _?a?b ] |- _ =>\n           assert (a = b) by (apply (insert_insert_neq a b a b) end;\n        subst;\n        try match goal with H : context [nth_error _?a?b ] |- _ =>\n           assert (a <> b) by (apply (insert_insert_neq a b a b) end;\n        subst;\n        try match goal with H : context [nth_error?a?b ] |- _ =>\n           assert (a <> b) by (apply (insert_insert_neq a b a b) end;\n        subst;\n        try match goal with H : context [nth_error _?a?b ] |- _ =>\n           assert (a = b) by (apply (insertQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? | ]; simpl in *; subst; try solve [\n    congruence\n  | auto ].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  destruct k; simpl in *; subst; try solve [\n    congruence ].\n  destruct k; simpl in *; subst; try solve [\n    congruence ].\n  destruct k; simpl in *; subst; try solve [\n    congruence ].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? | [ | ]? | ]; simpl in *; subst;\n    solve [ congruence | congruence ].\n  inversion H; clear H; subst;\n    solve [ congruence | congruence ].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  induction x; intros; destruct e as [ | [ | ]? | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? | | ]; simpl in *; subst; try solve [\n    congruence ];\n  solve [\n    destruct a as [ | [ | ]? | ]? | ]; simpl in *; subst; try solve [\n    congruence ];\n    solve [\n    rewrite <- insert_insert_rec in * by omega; [\n    rewrite <- insert_insert_rec in * by omega; [\n    rewrite <- insert_rec_ent_aux in * by omega; [\n    rewrite <- insert_rec_ent_aux in * by omega; [\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_aux in * by omega; [\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_aux in * by omega; [\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_aux in * by omega;\n    rewrite <- insert_rec_ent_auxQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  assert (forall a, k <= s -> raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a)))))))) = true) /\\\n  (forall a, k <= s -> raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k a (raw_insert k aQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct a.\n  - destruct (p a); auto.\n  - destruct (p a); auto.\n  - destruct (p a); auto.\n  - destruct (p a); auto.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; intros; simpl.\n  - auto.\n  - destruct a; simpl.\n    - destruct a; simpl.\n      - destruct a; simpl.\n      - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n        - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct ( a); simpl.\n          - destruct ( a); simpl.\n          - destruct ( a); simpl.\n          - destruct a; simpl.\n          - destruct ( a); simpl.\n          - destruct a; simpl.\n          - destruct ( a); simpl.\n          - destruct a; simpl.\n          - destruct a; simpl.\n          - destruct ( a); simpl.\n          - destruct a; simpl.\n          - destruct ( a); simpl.\n          - destructQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct k; simpl in *; subst; try solve [\n    congruence\n    | auto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto\n    | eauto ].\n    | eauto ].\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. unfold raw_insert.\n  destruct k; [ | elimtype False; omega ].\n  destruct (raw_insert k a (raw_insert k a e) (raw_insert k a e)); simpl in *; subst; try solve [\n    congruence ].\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  (* Case [s <> 0]. *)\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  (* Case [s <> 0]. *)\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  destruct (raw_insert k a e); simpl in *; subst; try solve [\n    congruence ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ |Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; intros; simpl in *; try solve [\n    try solve [ auto | congruence ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct (find_map_some _ _ _ H); clear H; subst; try solve [\n    congruence ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct (find_map_none _ _ _ H); clear H; subst; try solve [\n    congruence ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (*Case [s <> 0Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; intros; simpl; auto.\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 1).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0).\n  (* Case [s <> 0]. *)\n  destruct (k =? 0Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; intros; destruct e as [ | [ | ]? |? | ]; simpl; try solve [\n    congruence | contradiction ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [s <> 0]. *)\n  destruct k; [ | elimtype False; omega ].\n  (* Case [Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction k; intros; simpl; auto;\n  try solve [ inv H].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (raw_insert k a (raw_insert k a e)).\n  (* Case [s <> 0]. *)\n  destruct k.\n  (* Case [s <> 0]. *)\n  (* Case [s <> 0] is not known as [s <> 0]. *)\n  destruct (raw_insert k a (raw_insert k a e)).\n  (* Case [s <> 0] is not known as [s <> 0]. *)\n  destruct (raw_insert k a (raw_insert k a e)).\n  (* Case [s <> 0] is known as [s <> 0]. *)\n  destruct (raw_insert k a e); simpl in *; subst.\n  (* Case [s <> 0] is known as [s <> 0]. *)\n  destruct (raw_insert k a e0).\n  (* Case [s <> 0] is known as [s <> 0]. *)\n  (* Case [s <> 0] is known as [s <> 0]. *)\n  destruct (raw_insert k a (raw_insert k a e0)).\n  (* Case [s <> 0]. *)\n  destruct (raw_insert k a e0).\n  (* Case [s <> 0] is known as [sQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros??????.\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct k; [ | elimtype False; omega ].\n  destruct kQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  induction e; intros.\n  reflexivity.\n  rewrite <- insert_insert_cons; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  apply insert_insert.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  apply insert_insert_not; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct a.\n  destruct a.\n  destruct (sorted_insert x a).\n  apply insert_insert_sorted. auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\nintros.\ninduction e as [| [ | ]?? | [ | ]? | [ | ]? | ]? | [ | ]? | | ]? | [ | ]? | | | | | | | ];\n  try solve [\n    try solve [\n        rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction e; simpl; intros.\n  - destruct (ins_insert x a e0).\n    - apply insert_insert_nil.\n      auto.\n  - simpl in H.\n    destruct (ins_insert x a e0).\n    - apply insert_insert_nil.\n      auto.\n    - apply insert_insert_nil.\n      auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\nintros.\ndestruct e; destruct e; simpl; intuition.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; unfold insert; simpl; intros.\n  destruct (eq_dec x a).\n  subst.\n  apply insert_insert_not_nil; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  induction e; simpl; try solve [ auto].\n  destruct a; try solve [ destruct e; try solve [ inversion e; simpl; eauto].\n  rewrite IHl.\n  apply IHl.\n  apply IHl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2 H.\n  destruct e1; simpl in *; subst; try solve [\n    rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | omega ]\n  | rewrite <- insert_insert_cons; auto | omega ]\n  | omega ]\n  | ].\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl in *; subst; try solve [\n    congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n   Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2 H.\n  destruct e1; simpl in *; subst; try solve [\n    congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    |Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  remember (insert x a1) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3) as b.\n  remember (insert x a3)Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2. generalize e1 e2; clear e1; intro.\n  apply insert_neq_insert_1 in H; destruct H as [x [e1 [e2 [e3 [e3 [e4 [e4 [e5 [e6 [e7 [e7 [e7 [e8 [e8 [e8 [e9 [e9 [e10 [e10 [e11 [e11 [e12 [e13 [e14 [e14 [e13 [e14 [e14 [e13 [e14 [e14 [e14 [e14 [e14 [e14 [e15 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [e15 [e14 [e15 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [e15 [e14 [e14 [e14 [e14 [e14 [e14 [e15 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [e14 [Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e; simpl in *; subst; try solve [\n    congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    | congruence\n    |Qed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e2 e3 H.\n  destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x b e1) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x b e1) = Some a2). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x b e1) = Some a1). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a2 e1) = Some b). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x b e1 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  - rewrite insert_eq_insert in H.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\n    destruct (le_gt_dec x2 y); [right|right]; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a2 e2) = Some a1). eauto using lookup_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  congruence.\n  destruct a1; destruct e2;\n  destruct e2;\n  destruct e1;\n  destruct e2;\n  destruct e1;\n  destruct e2;\n  destruct e2;\n  destruct e2;\n  destruct e2;\n  destruct e2;\n  destruct e2;\n  destruct e1;\n  destruct e2;\n  destruct e2;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e1;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destruct e3;\n  destructQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros; simpl; try congruence.\n  destruct (le_gt_dec x1 x2); [left|right]; simpl; congruence.\n  destruct (le_gt_dec x1 x2); [left|right]; simpl; congruence.\n  destruct (le_gt_dec x2 x2); [left|right]; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  congruence.\n  destruct (le_gt_dec x1 x2). subst. congruence.\n  destruct (le_gt_dec x1 x2). subst. congruence.\n  destruct (le_gt_dec x2 x2). subst. congruence.\n  destruct (le_gt_dec x1 x2). subst. congruence.\n  destruct (le_gt_dec x1 x2). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\n  destruct (le_gt_dec x1 x2). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\n  destruct (le_gt_dec x1 x3). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\n  destruct (le_gt_dec x1 x3). subst. congruence.\n  destruct (le_gt_dec x2 x3). subst. congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x a1 e2) = Some a1). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a2 e1) = Some a2). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros A x1 a1 a2 a2 (e1 e2 e1 e2 e3 e4 e5 e6 e7 e7 e8 e9 e10 e11 e12 e13 e13 e14 e14 e15 e15 e15 e16 e17 e18 e19 e19 e20 e19 e20 e20 e20 e20 e19 e20 e19 e19 e20 e20 e20 e20 e20 e20 e20 e19 e20 e20 e20 e20 e19 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 e20 eQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1 e2) = Some a1). eauto using lookup_insert_bing.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  + rewrite insert_neq_insert.\n    destruct (le_gt_dec x1 x2); [left|right]; auto.\n    apply insert_neq_insert_bing; auto.\n    apply insert_neq_insert_bing; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f.\n  induction e; simpl; intros; subst.\n  - rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_one in *.\n    destruct (le_gt_dec x a). subst.\n    rewrite raw_insert_oneQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; intros.\n  - auto.\n  - auto.\n  - auto.\n  - auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e H.\n  induction e; simpl; intros; try congruence; auto.\n  rewrite raw_insert_one in *.\n  case_eq (insert x a e); intros.\n  (* Subcase [x1 a1 e1] is a1, a2, a3, a4, a5, a6, a6, a7, a7, a7, a7, a8, a8, a8, a9, a10, a11, a12, a12, a13, a13, a14, b7, b8, a16, b9, a16, a16, b16, b16, b16, b17, b17, b17, b16, b18, b17, b19, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, b20, bQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros; induction a; simpl; auto.\n  (* Limal whether we can do the first argument [f x]\n    that [x = 0] is a function [x] *)\n  destruct (f x) as [x0 [y0 y1]].\n  exists (y0,y1); exists (x1,y1); split.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_one in *.\n  rewrite raw_insert_oneQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  induction e; intros; simpl; auto.\n  (*Case [x1 = x2] *)\n  destruct x2; [ congruence | ]. subst. simpl. congruence.\n  (*Case [x1 = x2] *)\n  destruct x2; [ congruence | ]. subst. simpl. congruence.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f a e H.\n  induction e; simpl; auto.\n  intros a.\n  case_eq (map f e); simpl; auto.\n  rewrite IHl; simpl; auto.\n  rewrite IHl; simpl; auto.\n  case_eq (map f e); simpl; auto.\n  case_eq (map f e); simpl; auto.\n  rewrite IHl; simpl; auto.\n  rewrite IHl; simpl; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  induction e; simpl; auto.\n  simpl in *.\n  rewrite map_insert_assoc.\n  simpl in *.\n  f_equal.\n  destruct (le_gt_dec x e); auto.\n  subst. simpl.\n  exists (insert x a e); auto.\n  destruct (le_gt_dec x e); auto.\n  subst. simpl.\n  exists (insert x a e); auto.\n  destruct (le_gt_dec x e); auto.\n  subst. simpl.\n  exists (insert x a e); auto.\n  apply insert_neq_insert_3; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e H.\n  induction H.\n  simpl in *.\n  destruct a.\n  destruct a.\n  destruct a.\n  destruct a.\n  destruct a0.\n  simpl in *.\n  destruct H.\n  subst.\n  exists a0. exists e. exists x. auto.\n  destruct a.\n  destruct a0.\n  destruct a.\n  destruct H.\n  subst. exists e. exists x0. auto.\n  simpl. congruence.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; simpl; intros.\n  + (*Case [x] is a key of [x] is a key of [x] *)\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence | ].\n    destruct (le_gt_dec x x0); [ congruence |Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; intros.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a e); simpl in *.\n  (* L *)\n  (* L *)\n  destruct (insert x a eQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  destruct a; simpl in *; subst.\n  destruct a; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst; auto.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst; auto.\n  destruct b; simpl in *; subst; auto.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst; auto.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; subst; auto.\n  destruct b; simpl in *; subst.\n  destruct b; simpl in *; substQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  destruct a; simpl; eauto.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  destruct (f a); simpl; eauto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\n  destruct a; simpl; eauto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst.\n  rewrite map_insert; reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst; apply map_insert; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct b; simpl; auto.\n  destruct bQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst. apply raw_insert_neq.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHx. auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite <- map_insert_eq; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  rewrite map_insert; reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; subst. apply map_insert.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; auto.\n  rewrite IHx; auto.\n  destruct (g a) eqn:Heq; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\n  apply map_insert_eq. auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destructQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros; subst.\n  rewrite map_insert_eq; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  rewrite IHm; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; try congruence.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros; subst.\n  assert (map f (fold_right f g (map g (fold_right f g (map g (g d)))).\n  apply map_insert.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n    try match goal with\n    | |- context [ map_insert?r?l?e?q] =>\n      injection h; clear h; intros h;\n      injection h; clear h; intros h;\n      injection h; clear h; intros h;\n      injection h; clear h; intros h;\n      injection h; clear h; intros h;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h; intros;\n      injection h; clear h;\n      injection h; intros;\n      injection h; clear h; intros;\n      injection h; clear h;\n      injection h; intros;\n      injection h; clear h; intros;\n      injection h; clear h;\n      injection h; intros;\n      injection h; clear h;\n      injection h; intros;\n      injection h; clear h; intros;\n      injection h;\n      injection h; intros; injection h; clear h;\n      injection h; intros;\n     Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto with map_upd.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with |-?f = _ => destruct o end; auto.\n  simpl in *.\n  match goal with |-?f = _ => destruct o end; f_equal; eauto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; destruct e; simpl in *; try discriminate;\n  try match goal with |- context [map _?a?b] =>\n    assert (a = b) by (eapply map_insert; eauto);\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eauto;\n    try match goal with |- context [map _?a?b] => eapply map_insert; eautoQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; destruct e; simpl; auto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\n  f_equal.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n    try match goal with\n         | H: Some _ |- _ => destruct o end; f_equal; eauto end.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with\n  | |- context[f1?g2] => destruct o end; f_equal; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 4 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _ _) ] => rewrite map_insert; auto\n  end.\n  do 3 match goal with\n  | |- context [map _ (insert _ _)Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?o =?o |- _ => destruct o end;\n  simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destruct o; simpl; eauto with set.\n  destructQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?e =?f?f?x => destruct o end;\n  simpl; eauto with set.\n  match goal with |-?e =?f?x => destruct o end;\n  simpl; eauto with set.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n    try match goal with\n    | |- context [ match?a with Some?a => _ end] => destruct a end;\n    simpl; eauto with set.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; destruct e; simpl; eauto with typeclass_instances.\n  simpl; eauto with typeclass_instances.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?A =?B => destruct o end;\n  simpl; eauto with set.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; destruct e; simpl; eauto.\n  destruct (map_insert_eq _ _ _ _ H) as (l & l & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl).\n  split; auto.\n  destruct (map_insert_eq _ _ _ Hl) as (l & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl & Hl).\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl & Hl & Hl & Hl).\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl & Hl & Hl & Hl').\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl & Hl & Hl & Hl).\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl & Hl & Hl).\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl').\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl').\n  split; auto.\n  destruct Hl as (Hl & Hl & Hl).\n  split; auto.\n  destruct Hl as (Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst.\n  rewrite map_insert; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction h; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction h; intros; simpl; auto.\n  rewrite IHx.\n  destruct a.\n  destruct a.\n  simpl.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst.\n  apply map_insert; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto with map.\n  induction e; intros; simpl; eauto.\n  rewrite IHx. reflexivity.\n  simpl; eauto with map.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst.\n  assert (forall a, f (h a) = h a).\n  { intros; eapply map_insert. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_neq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto. }\n  { intros; eapply map_insert_eq; eauto.Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHx; simpl.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with |- context [map _ (map _ _ (map _ _)) ] =>\n    destruct (map_insert_map f g); try reflexivity;\n    try match goal with |- context [map _ (map _ _ _)) ] =>\n      destruct (map_insert_map f g); try reflexivity;\n    try match goal with |- context [map _ (map _ _ _)) ] =>\n      destruct (map_insert_map f g); try reflexivity;\n    try match goal with |- context [map _ (map _ _ _)) ] =>\n      destruct (map_insert_map f g); try reflexivity;\n    end.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  apply map_map_ind.\n  intros.\n  destruct (g a) eqn:H; auto.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  intros.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  intros.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  intros.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  intros.\n  destruct (g a) eqn:H; auto.\n  simpl in H.\n  apply map_insert.\n  apply map_insert.\n  apply map_insert.\n  intros.\n  destruct (g a) eqn:Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_insert_map.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_insert_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  induction e; intros;\n    try match goal with |-?a =?a => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?a =?b => destruct a end; try reflexivity.\n  match goal with |-?b =?Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  eapply map_ext.\n  intros; eapply map_insert_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_insert_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  apply map_insert_map; auto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert_map_unmap_unmap.\n  rewrite map_insert_map_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap.\n  rewrite map_insert_map_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmap_map_unmap_unmap_unmap_unmap_unmap_unmap_unmap_unmapQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with |-?x =?y =>\n    match goal with _ :?x =?y |- _ => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with _ :?x =?y |- _ => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-?x =?y => destruct y end;\n    [ match goal with |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros; simpl; auto.\n  destruct l; simpl; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction l; simpl; intros; inv; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction params; intros; simpl; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction l; simpl; intros; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct eQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction l; simpl; auto.\n  intros.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct b; simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simpl in *.\n  destruct (f a); simplQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction l; intros; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction l; simpl; intros.\n  - auto.\n  - auto.\n  - auto.\n  - auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx.\n  rewrite IHx.\n  apply IHx.\n  apply IHx.\n  apply IHx.\n  apply IHx.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction xl; intros; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; intros; simpl; auto.\n  rewrite IHm; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; intros.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  induction e; intros; simpl; eauto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros; simpl; eauto with set.\n  - simpl.\n    destruct o; simpl; auto.\n  - destruct o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  induction e; simpl; eauto.\n  rewrite IHl; eauto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; intros.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; simpl; intros;\n    try match goal with |- context [?P] => destruct o end; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction l; simpl; auto; intros.\n  simpl.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n  intros.\n  rewrite fold_add.\n Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros;\n  try match goal with _ |- _ => destruct o end;\n  simpl; eauto with set.\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (intros; apply H; auto).\n  assert (forall e, P e) by (Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.\n  apply fold_invariant with (f := fun s e => forall e, P e nil) e.\n  intros.Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros.\n  - simpl.\n    destruct o; auto.\n    - simpl.\n      destruct o; auto.\n    - simpl.\n      destruct o; auto.\n    - destruct o; auto.\n    - simpl.\n      destruct o; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction e; intros.\n  - destruct a as [l IHl].\n    + auto.\n    + destruct a as [l IHl].\n      * destruct a as [l IHl].\n        + destruct a as [l IHl].\n        + destruct a as [l IHl].\n        + destruct a as [l IHl].\n          + destruct a as [l IHl].\n          + destruct a as [l IHl].\n          + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [l IHl].\n            + destruct a as [Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  assert (forall e, P e -> P e).\n  { intros.\n    eapply H; eauto. }\n  eapply fold_invariant; eauto.\n  intros.\n  eapply H; eauto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction e; intros.\n  - simpl.\n    destruct o.\n    + simpl.\n      destruct o.\n      * destruct o.\n        * simpl.\n        destruct o.\n        * simpl in *.\n        destruct o.\n          * simpl in *.\n          destruct o.\n          apply IHm.\n          * simpl in *.\n          destruct o.\n            simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n            destruct o.\n            * simpl in *.\n              destruct o.\n            * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.\n              destruct o.\n              * simpl in *.Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction e; intros;\n    try match goal with\n    | |- fold f nil _ => destruct o; try destruct o; try destruct o; try destruct o; try destruct o; simpl; eauto\n    end;\n    try match goal with\n    | |- fold f nil _ => destruct o; try destruct o; try destruct o; try destruct o; try destruct o; simpl; eauto\n    end;\n    try match goal with\n    | |- fold f nil _ => destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; simpl; auto\n    end;\n    try match goal with\n    | |- fold f nil _ => destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; simpl; try destruct o; try destruct o; try destruct o; try destruct o; simpl; auto\n    end;\n    try match goal with\n    | |- fold f nil _ => destruct o; try destructQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros; simpl; eauto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros; simpl; auto.\n  repeat rewrite IHl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2.\n  induction e; simpl.\n  - intros. apply H. auto.\n    apply IHl1. auto.\n    apply IHl2. auto.\n    apply IHl2. auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros.\n  inv H0; simpl.\n  rewrite IHl1.\n  rewrite IHl1.\n  simpl.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl2.\n  rewrite IHl1.\n  rewrite IHl1.\n  rewrite IHl1.Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2.\n  induction k1 as [|k1 k2]; simpl; intros; try discriminate.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros; auto.\n  destruct (k1 0); auto.\n  destruct (k2 0); auto.\n  destruct (k1 0); auto.\n  destruct (k2 0); auto.\n  destruct (k1 0); auto.\n  destruct (k1 0); auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros; try discriminate.\n  simpl; eauto with typeclass_instances.\n  intros.\n  simpl; eauto with typeclass_instances.\n  intros.\n  simpl; eauto with typeclass_instances.\n  intros.\n  simpl; eauto with typeclass_instances.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2; revert k1 k2; induction k1; intros;\n  try match goal with |-?a <=?b => pose proof (length_monotonic H a) as H end.\n  - destruct (length_monotonic H a) as [H | H];\n    [ match goal with H : _ |- _ => destruct a end;\n    [ match goal with H : _ |- _ => destruct a end;\n    [ match goal with H : _ |- _ => destruct a end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ => destruct H end;\n    [ match goal with H : _ |- _ =>Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2.\n  destruct (lt_dec k1 k2); [congruence | congruence ].\n  destruct (lt_dec k2 k2); [congruence | congruence ].\n  destruct (lt_dec k1 k2); [congruence | congruence ].\n  destruct (lt_dec k1 k2); [congruence | congruence ].\n  destruct (lt_dec k2 k2); [congruence | congruence ].\n  destruct (lt_dec k1 k2); [congruence | congruence ].\n  destruct (lt_dec k2 k1 k2); [congruence | congruence ].\n  destruct (lt_dec k2 k2 k2); [congruence | congruence ].\n  destruct (lt_dec k2 k2 k2 k2); [congruence | congruence ].\n  destruct (lt_dec k1 k2 k3); [congruence | congruence ].\n  destruct (lt_dec k2 k3 k3 k3); [congruence | congruence ].\n  destruct (lt_dec k3 k3 k3 k3); [congruence | congruence ].\n  destruct (lt_dec k3 k3 k3 k3); [congruence | congruence ].\n  destruct (lt_dec k3 k3 k3 k3Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2 H.\n  induction k1; intros.\n  - rewrite H. apply H. apply Nat.le_le_incl. apply Nat.le_le_incl.\n  - apply Nat.le_le_incl. apply Nat.le_le_incl. apply Nat.le_le_incl.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2; unfold length.\n  destruct (map f e) as (e, e0).\n  subst.\n  auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros;\n  try match goal with |-?x =?y => destruct y end; try (discriminate); subst; auto end.\n  + apply IHmap; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  eapply map_NoDup; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e x.\n  induction e; simpl; intros;\n    try match goal with\n        | |- context [nth _?x?y] => destruct (nth_error _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e x.\n  unfold lookup; simpl.\n  destruct (find x s).\n  + apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply find_beyond_length.\n    apply findQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  unfold lookup, lookup, lookup.\n  destruct (find x e) eqn:E;\n    try destruct (find x e) eqn:E; try discriminate.\n  - apply IHl. auto.\n  - apply IHl. auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  unfold lookup; simpl; auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  destruct (find_beyond_length e x); simpl in *; auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  generalize (find_beyond_length e x); intros.\n  case (index e); intros.\n  - destruct a.\n    + apply (find_beyond_length e); auto.\n    + apply (find_beyond_length e); auto.\n    + apply (find_beyond_length e); auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros A e x.\n  induction e; intros;\n    try solve [inversion H; subst; eauto].\n  + simpl in *.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.\n    destruct (find x e); auto.Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  revert e. induction e; simpl; intros; try discriminate.\n  - simpl.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2) eqn:H; try discriminate.\n    destruct (x == k2)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros A e x k a H.\n  induction e; simpl; intros.\n  inv H.\n  simpl.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruence.\n  destruct (find x e); try congruenceQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  - rewrite IHs.\n    destruct (find x k); auto.\n    apply IHs. omega.\n  - rewrite IHs.\n    destruct (find x k); auto.\n    apply IHs. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length e x).\n  pose proof (find_beyond_length eQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_beyond_length; eauto.\n  eapply H0; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct (eq_dec a x).\n  - subst.\n    apply IH; auto.\n    apply IH; auto.\n  - apply IH; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  - simpl. auto.\n  - intros.\n    apply IHn. omega.\n    apply IHn. omega.\n  - intros.\n    apply IHn. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct e; simpl in *.\n  { eapply lookup_beyond_length; eauto. }\n  destruct a as [k1 [k2 [??]]].\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyond_length; eauto. }\n  { eapply lookup_beyQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct (find_beyond_length _ _ _ H); auto.\n  destruct (find_beyond_length _ _ H); auto.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct (find_beyond_length _ _ _ H); auto.\n  destruct H1 as [k [ | k]].\n  rewrite H2 in H1; inv H1.\n  split; auto.\n  destruct H1 as [k [ | k]].\n  rewrite H2 in H1; inv H1.\n  split; auto.\n  destruct (find_beyond_length _ _ _ H1); auto.\n  destruct H1 as [k [ | k]].\n  rewrite H2 in H1; inv H1.\n  split; auto.\n  destruct (find_beyond_length _ _ H1); auto.\n  destruct (find_beyond_length _ _ H1); auto.\n  destruct (find_beyond_length _ _ H1); auto.\n  destruct (find_beyond_length _ _ _ H1); auto.\n  destruct (find_beyond_length _ _ _ H1Qed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_beyond_length; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  eapply H; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  (* In order to be able to use the previous one of the following predicate. *)\n  auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite length_empty.\n  destruct (index_empty A k) as [ | [ | ] eqn:?.\n  congruence.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  (* In order to [length l] holds, the same length. *)\n  rewrite length_empty.\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (length_empty l).\n  generalize (lengthQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_empty.\n  rewrite length_Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  unfold length.\n  intros.\n  destruct (le_gt_dec k x); auto.\n  (* E0 is the second case, we could be used to make the same\n   of [nth x e] for each variable [k] *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  eapply add_valid; eauto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  unfold length.\n  rewrite <- (fold_empty A).\n  apply fold_empty; auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  apply length_empty.\n  apply length_empty.\n  apply length_empty.\n  apply length_empty.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\napply max_l.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  assert (i < j). apply le_lt_trans with (2:=0) in H. omega. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec i j); [ omega | omega ].\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  apply max_l.\n  apply min_l.\n  apply max_l.\n  apply min_l.\n  apply max_r.\n  apply max_r.\n  apply min_r.\n  apply max_l.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply min_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_l.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_r.\n  apply max_Qed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  pose proof max_l; omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intro.\n  destruct (le_gt_dec i j); [ omega | omega ].\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax.\n  case (le_gt_dec i j); intro; try tauto.\n  case (le_gt_dec j i); intro.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (2 := j); auto.\n  apply le_lt_trans with (Qed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  pose proof max_l.\n  pose proof max_l.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_l.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_r.\n  pose proof max_Qed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  pose proof (min_l (S i) (S i)) as d.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof. \n  intros.\n  mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold mymax.\n  unfold mymax.\n  unfold mymax.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n  rewrite max_l.\n  rewrite max_r.\n  rewrite max_r.\n Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  unfold mymax; simpl.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  replace (S n) with (S n + 1)%nat by omega.\n  rewrite <- minus_n_Sm.\n  reflexivity.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  apply mymax_l.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_l.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (fun x => x)).\n  apply (raw_insert_general A (Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  rewrite (tree_add_correct _ _ _ _ _ _ H) in H.\n  destruct H as [x1 x2].\n  apply (IHn _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H0) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H0) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H0) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n  rewrite (tree_add_correct _ _ _ _ H) in H0.\n Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold mymax.\n  destruct (le_gt_dec m n); [ | omega | omega ].\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (1 + k) by omega.\n  replace (2 + k) with (1 + k) by omega.\n  replace (2 + k) with (1 + k) by omega.\n  replace (2 + k) with (2 + k) by omega.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (2 + k) by omega.\n  replace (2 + k) with (2 + k) by omega.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (2 + k) by omega.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (2 + k) by omega.\n  replace (2 + k) with (2 + k) by omega.\n  replace (2 + k) with (2 + k) by omega.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (2 + k) by omega.\n  rewrite <- minus_n_O.\n  replace (2 + k) with (2 + k) by omegaQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  case (le_gt_dec m n); intro.\n  rewrite <- plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_n.\n  rewrite plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite plus_n_Sm.\n  rewrite <- plus_n_Sm.\n  rewrite <-Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec (length e) (length e)); try omega.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  case (le_gt_dec m n); intro.\n  - subst.\n    apply (le_gt_dec m n); assumption.\n    apply le_lt_trans with n; assumption.\n    apply lt_trans with n; assumption.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  apply mymax.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  unfold mymax.\n  generalize (le_gt_dec k x); intro.\n  (* case *)\n  destruct (le_gt_dec k x); intro.\n  (* case *)\n  simpl in H; simpl in H; subst.\n  rewrite H; simpl.\n  intuition.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k Open Scope nat_scope.\n  pose proof (nth_insert_general l k e) as H.\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_insert_general l k e) as H.\n  apply (H k).\n  pose proof (nth_Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k LC.\n  destruct (le_gt_dec k x).\n  - constructor.\n    apply le_lt_trans with (1 := 0). omega.\n    apply le_lt_trans with (1 := 1). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (1 := H0). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (1 := H0). omega.\n    apply le_trans with (1 := H1). omega.\n    apply le_trans with (2 := 1). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (2 := 1). omega.\n    apply le_trans with (2 := H1). omega.\n    apply le_trans with (1 := 1). omega.\n    apply le_trans with (2 := 1). omega.\n    apply le_trans with (2 := 1). omega.\n    apply le_trans with (2 := 1). omega.\n    applyQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  destruct (le_gt_dec k x); [ | omega ].\n  intuition.\n  intuition.\n  intuition.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  destruct (le_gt_dec k x); [ | omega ].\n  intuition.\n  intuition.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_P in *.\n  unfold nat_of_PQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k hi LC H.\n  (* We can fail with the following proof. *)\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k)) by (apply H; auto).\n  assert (exists k, (raw_insert x o e = Some k)Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  mymax.\n  rewrite <- plus_assoc.\n  simpl.\n  mymax.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite (plus_comm (S (S (S (S n)))) (S (S (S n)))) at 1.\n  rewrite plus_assoc.\n  rewrite (plus_comm (S (S (S (S n)))) at 1.\n  rewrite plus_assoc.\n  rewrite (plus_comm (S (S (S (S (S n)))) at 1.\n  rewrite (plus_comm (S (S (S (S (S n)))) at 1.\n  rewrite plus_assoc.\n  rewrite (plus_comm (S (S (S (S n)))) at 1.\n  rewrite (plus_comm (S (S (S (S n)))) at 1.\n  rewrite (plus_comm (S (S (S (S (S (S (S n)))) at 1).\n  rewrite (plus_comm (S (S (S (S (S (S n))))Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k LC.\n  (* this is the same as long as long as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as well as wellQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros; subst; auto.\n  mymax. rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold mymax.\n  rewrite <- app_assoc.\n  unfold myQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  mymax.\n  unfold mymax.\n  simpl.\n  unfold mymax.\n  simpl.\n  unfold mymax.\n  fold mymax.\n  unfold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n  fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n  fold mymax. fold mymax.\n  fold mymax. fold mymax.\n  fold mymax. fold mymax.\n  fold mymax. fold mymax.\n  fold mymax. fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n  fold mymax.\n  fold mymax. fold mymax.\n Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec k x).\n  + split. eapply m_le_S; eauto.\n    unfold mymax.\n    eapply le_S; eauto.\n    unfold mymax.\n    eapply le_S; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros A e k x a; induction k; simpl; intros.\n  mymax. rewrite IHl.\n  simpl. unfold min. rewrite IHl.\n  rewrite IHl.\n  unfold min. rewrite IHl.\n  unfold min. rewrite IHl.\n  unfold min. rewrite IHl. unfold min. rewrite IHl.\n  unfold min. rewrite IHl.\n  unfold min. rewrite IHl. unfold min. rewrite IHl. unfold min. rewrite IHl. unfold min. rewrite IHl.\n  unfold min. rewrite IHl. unfold min. rewrite IHl. unfold min. rewrite IHl. unfold min. rewrite IHr. rewrite IHr. unfold min. rewrite IHl. rewrite IHl. unfold min. rewrite IHr. rewrite IHr. unfold min. rewrite IHr. rewrite IHr. unfold min. rewrite IHr. rewrite IHr. rewrite IHr. reflexivity.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros A x k [].\n  assert (length (raw_insert x a e) <= k) by omega.\n  eapply length_insert_general; eauto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold length.\n  unfold length.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x a e) as s.\n  remember (raw_insert x aQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.\n  unfold insert; simpl.\n  case (le_gt_dec k x); intro; try tauto.\n  rewrite <- (insert_comm x).\n  simpl.Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros A e k x a.\n  unfold insert.\n  remember (nth k x a) as l.\n  remember (nth k x a) as l.\n  remember (nth k x a) as l.\n  revert l.\n  remember (nth k x a) as l.\n  revert l.\n  induction l; intros.\n  inv H.\n  destruct a; simpl.\n  mymax.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. inv H.\n  rewrite IHx in H. invQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  rewrite <- insert_rev.\n  apply length_insert_general.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  assert (length (raw_insert x a e) = length (raw_insert x a e)).\n  apply length_insert_length.\n  apply length_insert_length.\n  simpl.\n  rewrite <- nat_of_P_le.\n  unfold nat_of_P.\n  unfold nat_of_P.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_of_P.\n  unfold nat_of_P.\n  rewrite nat_of_P_lt.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_of_P.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_of_P.\n  rewrite nat_of_P_lt.\n  unfold nat_of_P.\n  rewrite nat_of_P_lt.\n  unfold nat_of_P.\n  rewrite nat_of_P_le.\n  unfold nat_Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  apply length_insert_alt.\n  applyQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  unfold delete.\n  destruct (le_gt_dec k x); [left|right]; apply IHx; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  erewrite length_insert_general in * by reflexivity. mymax.\n  unfold mymax.\n  fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. fold mymax. foldQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  erewrite length_insert_general in * by reflexivity. mymax.\n  rewrite length_insert_general in * by reflexivity. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax.Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  erewrite length_insert_length; eauto.\n  unfold length.\n  rewrite <- app_nil_r.\n  assert (length (insert x a e) <= length (insert x a e) <= length e).\n  { induction e; simpl; intros.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.\n    replace (length (insert x a e) + 1) with (length (insert x a e) + 1) by reflexivity.\n    replace (length (insert x a e) + 1) with (length e) by reflexivity.Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  rewrite length_insert_general in * by omega.\n  rewrite length_insert_length.\n  rewrite length_insert_general in * by omega.\n  rewrite length_insert_length.\n  rewrite length_insert_general in * by omega.\n  rewrite length_insert_length.\n  rewrite length_insert_general in * by omega.\n  rewrite length_insert_length.\n  rewrite length_insert_general in * by omega.\n  rewrite length_insert_length.\n  rewrite length_insert_general.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  erewrite length_insert_general in * by reflexivity. mymax.\n  rewrite length_insert_length.\n  destruct e; simpl.\n  mymax. erewrite IHn by reflexivity. mymax.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  destruct (le_gt_dec k x); auto.\n  apply lt_le_trans with (length (insert x a e)); auto.\n  apply lt_le_trans with (length (insert x a e)); auto.\n  apply lt_le_trans with (length (insert x a e)); auto.\n  apply le_trans with (length (insert x a e)); auto.\n  apply lt_le_trans with (length (insert x a e)); auto.\n  apply le_trans with (length (insert x a e)); auto.\n  apply le_trans with (length (insert x a e); auto.\n  apply le_trans with (length (insert x a e e)); auto.\n  apply le_trans with (length (insert x a e)); auto.\n  apply le_trans with (length (insert x a e e)); auto.\n  apply le_trans with (length (insert x a e)); auto.\n  apply le_trans with (length (insert x a e e)); auto.\n  apply le_trans with (length (insert x a e e)); auto.\n  apply le_trans with (length (insert x a e e)); auto.Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite lengthQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_length; eauto.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x a e) <= k). eapply length_insert_alt; eauto.\n  assert (length (raw_insert x aQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  induction e; simpl; intros.\n  intuition.\n  intuition.\n  intuition.\n  intuition.\n  intuition.\n  intuition.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\n  rewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. rewrite length_insert_alt.\n  destruct (le_gt_dec k x); [left|right]; intuition.\n  rewrite H; clear H.\n  case (le_gt_dec k x); intro.\n  2: intro; subst; auto.\n  destruct a; simpl.\n  mymax. erewrite IHx by reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_alt by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_alt_1 by reflexivity. mymax.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. unfold length.\n  rewrite length_insert_general in * by reflexivity.\n  intro.\n  apply length_insert_general.\n  apply length_insert_comm.\n  apply length_insert_comm.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite length_insert_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewriteQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax.Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_insert_length; reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite lengthQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  unfold length.\n  rewrite length_insert_general.\n  rewrite length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_invariant_1.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_invariant.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_invariant.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_invariant.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_insert_general.\n  apply length_Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. myQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite length_insert_general.\n  apply length_insert_alt.\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (length_insert_comm l).\n  exact (lengthQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite length_insert_general in * by reflexivity. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax mymax. mymax mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax. mymax mymax. mymax.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite length_insert_general; reflexivity.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. eapply length_map; eauto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  erewrite length_map; eauto.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewriteQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  rewrite length_map.\n  reflexivity.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  erewrite length_insert_length in * by reflexivity. mymax.\n  do 2 rewrite length_insert_length.\n  rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insert_length.\n  do 2 rewrite length_insertQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  erewrite length_map in * by reflexivity. mymax.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite length_map.\n  apply length_map_general.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| [|] | ] using f_equal.\n  destruct e; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  induction e1 as [|a e1 IH]; intros; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl;Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> forall x, In x l -> forall x, In x l -> forall x, In x l -> forall x, In x l -> x = x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> forall x, In x l -> forall x, In x l -> x = x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> forall x, In x l -> forall x, In x l -> x <> x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> forall x, In x l -> x <> x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> x <> x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> x <> x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> x <> x).\n  intros.\n  assert (forall x, In x l -> forall x, In x l -> x <>Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  destruct (eq_dec a a).\n  - subst.\n    rewrite H.\n    tauto.\n  - subst.\n    rewrite H.\n    tauto.\n  - subst.\n    rewrite H.\n    tauto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  generalize (H a k).\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H1 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H1 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n  destruct (find_key_eq k k); auto.\n  rewrite <- H0 in H1.\n Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k x a k a.\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).\n  assert (x < k) by (apply repr_inj; auto).Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k x a k x a k.\n  rewrite <- (agree_below _ _ _ _ H).\n  apply agree_above.\n  apply agree_above.\n  apply agree_above.\n  apply agree_above.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k x a k.\n  induction k; simpl; intros; subst.\n  unfold update. rewrite H0; auto.\n  unfold update. rewrite H0; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k x a k H.\n  revert x a k H; induction k; intros; simpl.\n  mymax. rewrite <- (repr_map_map f).\n  auto.\n  intro. rewrite <- (repr_map_map f). auto.\n  intro. rewrite <- (repr_map_map f). auto.\n  intro. rewrite <- (repr_map f). auto.\n  intro. rewrite <- (repr_map f). auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  rewrite <- (agree_eqn (level a)).\n  rewrite <- (agree_eqn (level a)).\n  rewrite H0 in H.\n  apply H0.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  unfold agree in H.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. unfold agree.\n  destruct e as [x [H1 H2]]. destruct e; try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_nat_dec x k); try contradiction.\n  destruct (eq_Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros A e. apply agree_empty_left.\n  apply agree_empty_left.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n  apply agree_empty_right.\n Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct (K.eq_dec x k); auto.\n  rewrite <- (H x), <- (H x); auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. apply agree_empty_right. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct e as [x y]; destruct e as [x y]; simpl; auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite agree_empty_left. reflexivity.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  unfold agree in *.\n  destruct e as [| a e]; auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_dec a a); auto.\n  rewrite <- (repr_insert_alt H).\n  destruct (lt_gt_decQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros; apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct (level a); auto.\n  rewrite <- (repr_find x); auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  induction e as [|a e]; simpl; intros; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (1 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (1 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2 := x).\n  unfold agree. intros. apply agree_unique with (1 := M.empty _) (2Qed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2 k. unfold agree. intros. apply agree_unique with (P := fun x => x); auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct (zle 0 k).\n  + rewrite <- (agree_add k), <- (agree_add k), <- (agree_add k), <- (agree_add k), <- (agree_add k), <- (agree_add k), <- (agree_add k), <- (agree_add k), (agree_add k), <- (agree_add k), <- (agree_add k), (agree_add k), <- (agree_add k), (agree_add k), (agree_add k), (agree_add k), <- (agree_add k), (agree_add k), <- (agree_add k), (agree_add k,agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k), (agree_add k, (agree k), (agree_add k), (agree_add k,agree_add k), (agree_add k), (agree k, (agree_add kQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  unfold agree. intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun x => x); auto.\n  intros. apply agree_unique with (P := fun xQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. apply agree_unique with (level x); auto. apply agree_unique with (level x); auto. apply agree_unique with (level y); auto. apply agree_unique with (level y); auto. apply agree_unique with (level y); auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2 k.\n  unfold agree. intros.\n  apply agree_insert. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2 k.\n  unfold agree. intros. apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (p := p) (p := p).\n  apply agree_unique with (p := p).\n  apply agree_unique with (Qed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree. apply agree_empty.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2 k.\n  induction k as [| k]; simpl; intros.\n  destruct (peq x x).\n  + destruct (peq x x).\n    + destruct (peq x x).\n      * left; apply equal_1; apply equal_1; apply equal_2; auto.\n      * left; apply equal_1; apply equal_2; auto.\n      * left; apply equal_1; apply equal_1; auto.\n      * left; apply equal_1; apply equal_2; auto.\n      * left; apply equal_1; apply equal_2; auto.\n      * left; apply equal_1; auto.\n      * right; apply equal_2; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct (M.get x e1) eqn:E1; simpl in *; intuition.\n  destruct (M.get x e2) eqn:E2; simpl in *; intuition.\n  rewrite <- E1 in E1; intuition.\n  rewrite <- E1 in E2; intuition.\n  rewrite <- E2 in E1; intuition.\n  rewrite <- E2 in E1; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E1 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E1 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E2 in E1; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E1 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E3 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n  rewrite <- E2 in E2; intuition.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o?.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).\n    split; auto.\n    exists (p o).Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros.\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalize (sub_transitive H).\n    generalizeQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub, osub, osub, osub,le.\n    intros.\n    assert (ms := osub_Some o).\n    apply osub_Some with o; assumption.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o.\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o o H).\n    generalize (sub_transitive o oQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub in *. intros o.\n    apply sub_transitive with (o := o); auto.\n    exists (one_val (get o (get o (get o (get o (get o (get o (get o (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o))))) (get o (get o (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o)))) (get o (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o (get o))))) (get o (get o (get o (get o (get o (get o (get o))))) (get o (get o (get o (get o (get o (get o)))) (get o (get o (get o (get o (Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o?.\n    exists o.\n    split.\n    - apply sub_reflexive.\n    - intros a2. destruct o; inv H. apply sub_reflexive.\n    - intros a2. destruct o; inv H; apply sub_reflexive.\n    - intros a2. destruct o; inv H; apply sub_reflexive.\n    - intros a3. destruct o; inv H; apply sub_reflexive.\n    - intros a3. destruct o; inv H; apply sub_reflexive.\n    - intros a4. destruct o; inv H; apply sub_reflexive.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o. destruct o; simpl in *; try discriminate.\n    inversion H; subst; auto.\n    inversion H; subst; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o H.\n    elim (sub_transitive _ _ H).\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n    exists o; split; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o o o o H; induction o; intros;\n    try discriminate; try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n    try discriminate;\n   Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o; intros.\n    - exists a; auto.\n    - exists a1; auto.\n    - exists a2; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros o. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros o a1 a2.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros o.\n    exists a1; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [|] [|]; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros??? [k1 o2]. injection h; clear h; intro; subst; eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub.\n    congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros???. injection h; clear h; intro; subst; eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    generalize (h _ eq_refl). clear h. intros [a1 [??]]] [a2 [??]]] [a3 [??]]] | [a4 [??]]] | [a5 [??]]] | [a5 [??]]] | [a6 [??]]] ]; [left; auto; auto; auto; discriminate.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros? h a2 H; induction H; simpl; auto.\n    destruct (le_gt_dec x n); [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n); [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n); [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [ case (eq_nat_dec x n) | intros; auto].\n    destruct (le_gt_dec x n) as [Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros???????? H0? H1 H2.\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub.\n    intros.\n    generalize (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    generalize (h _ eq_refl). clear h. intros [a2 [??]]] H0.\n    generalize (h _ eq_refl). clear h. intros [a1 [??]]] H0.\n    generalize (h _ eq_refl). clear h. intros [a2 [? [? [? [? [??]]]].\n    exists a2; exists a2; exists a3; exists a3; exists a4; exists a5; exists a6;\n    repeat split; auto.\n    destruct H as [a3 [? [??]]]].\n    exists a3; exists a3; exists a4; exists a5; exists a6;\n    repeat split; auto.\n    destruct H as [a4 [? [? [??]]]].\n    exists a4; exists a4; exists a4; exists a5; exists a6;\n    repeat split; auto.\n    destruct H as [a4 [? [? [??]]]].\n    exists a4; exists a4; exists a5; exists a6; exists a6;\n    repeat split; auto.\n    destruct H as [a5 [? [??]]]].\n    exists a4; exists a5; exists a5; exists a6; exists a6;\n   Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros? h. injection h; intro. subst; eauto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    generalize ( osub_Some_inversion o1 a2). intros [ a2 [? [? [??]]]].\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a2 [??]]] ; try discriminate.\n    exists (a1, a2).\n    exists (a1, a2).\n    split. assumption.\n    split. assumption.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o o?.\n    exists (mk_funspec (fun s => s) (fun s => s)).\n    exists (mk_funspec (fun s => s) (fun s => s)).\n    exists (mk_funspec (fun s => s) (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s) (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    exists (mk_funspec (fun s => s)).\n    split; reflexivity.\n    apply osub_Some_inversion in H1; congruence.\n    apply osub_Some_inversion in H1; congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o o. apply (afub_Some_inversion o); auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o o.\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tsle_gt_dec o o o).\n    generalize (tsle_gt_dec o o).\n    generalize (tslt_lt_dec o o o).\n    generalize (tsle_gt_dec o o o).\n    generalize (tsle_gt_dec o o o).\n    generalizeQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. rewrite functional_extensionality; auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o.\n    generalize (step_eq_refl o).\n    clear - H.\n    induction o.\n      auto.\n      auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o.\n    destruct o.\n    discriminate.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros o. apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply os_ub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osubQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold ef. congruence.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume in *.\n    intros.\n    destruct e as [ a1 [ a2 [a3 [??]]]] | [a3 [? [??]]]] | [a4 [? [??]]]] | [a4 [? [??]]]] | [a5 [? [??]]]] | [a5 [? [??]]]] | [a6 [? [??]]]] | [a6 [? [??]]]] | [a7 [? [? [??]]]] | [a8 [? [??]]]] | [a9 [? [??]]]] | [a9 [? [? [??]]]] | [a10 [? [??]]]] | [a11 [? [??]]]] | [a11 [? [? [??]]]] | [a12 [? [??]]]] | [a12 [? [? [??]]]] | [a12 [? [? [??]]]] | [a12 [? [? [??]]]] | [a12 [? [? [??]]]] | [a21 [? [? [??]]]] | [a12 [? [? [??]]]] | [a22 [? [? [??]]]] | [a12 [? [? [??]]]] | [a12 [? [? [??]]]] | [a22 [? [? [??]]]] | [a12 [? [? [? [??]]]] | [a23 [? [? [??]]]] | [a22 [? [? [??]]]] | [a23 [? [? [??]]]] | [a22 [? [? [??]]]] |Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold ef.\n    intros.\n    unfold ef in *.\n    destruct (eq_nat_dec x n).\n    exists (x0,x0).\n    exists (x0,x1).\n    exists (x1,x2).\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    exists (x2,x2).\n    split; auto.\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x3).\n    split; auto.\n    exists (x1,x1).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,x2).\n    split; auto.\n    exists (x1,xQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold ef.\n    induction e; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros.\n    destruct o. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold ef.\n    intros.\n    destruct o; eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume in *. intros.\n    destruct (classify_fun x => x) as [[x?] | ] | ] | ]; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros o. apply osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume, e.\n    intros.\n    destruct o1. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros. destruct o. eauto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros o1 o2 o3 o3 o4 H.\n    generalize ( osub_Some_inversion o1 o3); intro H; subst; eauto using osub_Some_inversion.\n    generalize ( osub_Some_inversion o1 o3); intro H; subst; eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros o1 o2 o3 o3 o4 H.\n    generalize (tsle_gt_dec o1 o2); clear tslt_gt_dec o3 o4 o4 H.\n    generalize (tsle_gt_dec o1 o2); clear tslt_gt_dec o3 o4 o5 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o4 o4 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o5 o5 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o4 o5 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o4 o4 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o4 o5 H.\n    generalize (tsle_gt_dec o4 o4); clear tslt_gt_dec o4 o4 o5 H.\n    generalize (tsle_gtQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold ef. rewrite osub_Some_inversion.\n    auto using osub_Some_inversion.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. intros?? H.\n    generalize (h _ eq_refl). clear h. intros [a1 [a2 [a3 [b1 [c1 [c2 [c1 [c2 [c2 [c3 [c3c4 [c4 [c5 [c6 c6 c7]]]]]].\n    destruct o2. eauto using osub_transitive_inversion.\n    exists o1, o2, o1, o2, o3, o4, o4, o5, o5, o6, o6, o7, o7, o7, o7, o7, o7, o7, o7, o7, o8, o8, o8, o8, o9, o9, o9, o8, o9, o9, o9, o9, o9, o10, o9, o9, o8, o9, o9, o10, o10, o10, o8, o11, o8, o7, o7, o8, o9, o9, o10, o9, o9, o10, o10,Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold ef.\n    intros o1 o2 o3 o4 H.\n    generalize (h _ eq_refl). clear h. intros [ a1 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a2 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a3 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a3 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a3 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a3 [???]?].\n    generalize (h _ eq_refl). clear h. intros [ a3 [?Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub.\n    eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. intros o1 o2 o3 H.\n    generalize (h _ eq_refl). clear h. intros [ a1 [a2 [??]]] | [b1 [b2 [??]]] | [b2 [c [? [??]]] | [b3 [c [? [???]]] | [b3 [c [? [? [????]]] | [b3 [c [? [??? [??]]] | [b3 [c [? [???? [?? [??]]] | [b4 [c [?? [?? [??? [??]]] | [b3 [c [c [? [?? [????]]] | [b4 [c [d [?? [????? [??]]] | [b4 [c [?? [??? [???]]] | [b5 [c [?? [??? [?? [?? [??]]] | [b4 [c?c [? [??? [??]]] | [b0 [c [? [?? [????]]] | [b1 [c [d? [?? [?? [???]]] | [b2 [c [ d? [? [? [???]]]Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. intros.\n    generalize (h _ eq_refl). clear h. intros [ a1 [a2 [??]]] | [a2 [??]]] | [a3 [??]]] | [a3 [??]]] | [a4 [??]]] | [a5 [??]]] | [a6 [??]]] | [a5 [??]]] | [a6 [??]]] | [a6 [??]]] | [a7 [??]]] | [a6 [??]]] | [a7 [??]]] | [a8 [??]]] | [a8 [??]]] | [a8 [??]]] | [a8 [??]]] | [a9 [??]]] | [a9 [??]]] | [a9 [??]]] | [a10 [??]]] | [a10 [??]]] | [a10 [??]]] | [a11 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]] | [a12 [??]]]Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume; intros.\n    apply osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume in *.\n    intros.\n    destruct (get_function x e1) as [a2 [ h2??] | [ a2 h2]].\n    generalize (h _ eq_refl). clear h1. intros [ a2 [ h1?]].\n    generalize (h _ eq_refl). clear h2. intros [ a3 [ h3]] [ a3 h4]].\n    generalize (h _ eq_refl). clear h3. intros [ a3 [ h4] [ a4 h5]].\n    generalize (h _ eq_refl). clear h4. intros [ a4 [ h5]] [ a5 h6]].\n    generalize (h _ eq_refl). clear h5. intros [ a5 [ a6 [ h7]] a7 [ a8 h9]].\n    generalize (h _ eq_refl). clear h5. intros [ a5 [ a6 [ a7 [ h8]] b7 [ a8 h9]].\n    generalize (h _ eq_refl). clear h5. intros [ a6 [ a7 [ h8]] a8 [ h9]].\n    generalize (h _ eq_refl). clear h6. intros [ a7 [ aQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume.\n    eauto using osub_refl.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros e1 e2 e3 H.\n    generalize (elrererererere re) (sigrererererererere re) (sigrererererererererere re) (sigrererererererererererere re) (sigrererererererererererere) (rererererererererererererere)\n      (sigrererererererererererererererere) (rerererererererererererere)\n      (rererererererererererererererererere)\n      (rerererererererererererererererererere)\n      (rerererererererererererererererere)\n      (rerererererererererererererererere) (rererererererererererererere)\n      (rerererererererererererererererere) (rerereQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume.\n    eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    inversion h1; clear h1; intro.\n    generalize (hp1 _ _ H); intros [ a1 [ h2?]: exists a1, h1, h2.\n    case (le_gt_dec x n); [ case (lt_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n); \n            [ case (le_gt_dec x n); [ case (le_gt_dec x n); [ case (le_gt_dec x n)]; \n            [ case (le_gt_dec x n); [ case (le_gt_dec x n); \n            [ case (le_gt_dec x n); [ case (le_gt_dec x n)]; \n            [ case (le_gt_dec xQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume; intros.\n    destruct (t1 e2 e3) as [[ a2 a3] d].\n    generalize (hs1 _ _ _ _ eq_refl). clear h1. intros [ a2 h2].\n    generalize (hs2 _ h3); intros [ a3 h3].\n    generalize (hs1 _ _ _ _ eq_refl). clear h2. intros [ a3 h4].\n    generalize (hs2 _ _ _ _ eq_refl). clear h3. intros [ a4 h5].\n    generalize (hs3 _ _ _ _ eq_refl). clear h5. intros [ a4 h5].\n    generalize (hs3 _ _ _ _ eq_refl). clear h5. intros [ a5 h6].\n    generalize (hs3 _ _ _ eq_refl). clear h5. intros [ a6 h7].\n    generalize (hs3 _ _ _ _ eq_refl). clear h6. intros [ a7 h7].\n    generalize (hs3 _ _ _ eq_refl). clear h7. intros [ a8 h8].\n    generalize (hs3 _ _ _ _ eq_refl). clear h7. intros [ a8 hQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. intros.\n    destruct (ts1 _ h2); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts1 _ h4); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts2 _ h3); auto.\n    destruct (ts2 _ h4); auto.\n    destruct (ts2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e.\n    generalize (H e); intros [ a1 [ a2 [h1 [??]]]].\n    generalize (H0 e); intros [ a1 [ a2 [h2 [??]]]].\n    generalize (H0 e); intros [ a1 [ h2??.\n    generalize (H0 e); intros [ a2 [h1? [??]]]].\n    generalize (H0 e); intros [ a2 [h2 [? [??]]]].\n    generalize (H0 e); intros [ a1 [h3 [? [? [??]]]].\n    generalize (H0 e); intros [ a1 [h3 [? [??]]]].\n    generalize (H1 e); intros [ a3 [h4 [? [? [? [??]]]]].\n    generalize (H1 e); intros [ a3 [h4 [? [??]]]].\n    generalize (H1 e); intros [ a3 h5 [? [? [??]]]].\n    generalize (H0 e); intros [ a3 h5 [? [? [? [??]]]].\n    generalize (H1 e); intros [ a3 h5 [? [? [??]]]].\n    generalize (H1 e); intros [ a3 h5 [? [? [? [??]]]].\n    generalize (H1 e); intros [ a3 h5 [? [? [? [??]]]].\n    generalize (Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    generalize (ts1 _ h2); intros [ a2 [ a3 [h1 [? [? [??]]]]].\n    destruct (t_empty_right H0).\n    (* the \"is\" environment *)\n    generalize (ts1 _ h2); intros [ a1 [ a2 h1?]].\n    generalize (ts2 _ h1); intros [ a2 [ a3 h2]] | [ a3 h3 ] ].\n    (* The \"is\" environment *)\n    generalize (ts2 _ h2); intros [ a3 h3] | [ a4 h5] ].\n    (* The \"is\" environment *)\n    generalize (ts1 _ h3); intros [ a3 h5].\n    (* the \"is\" environment *)\n    generalize (ts2 _ h3); intros [ a3 h5].\n    (* The \"is\" environment *)\n    generalize (ts2 _ h3); intros [ a3 h5] | [ a4 h5] ].\n    (* the \"is\" environment *)\n    generalize (ts2 _ h4); intros [ a4 h5] | [ a5 h6] ].\n    (* The \"is\" environment *)\n    generalize (ts2 _ h5);Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume.\n    eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume.\n    auto using osub_refl.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. eauto using osub_refl.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume, app.\n    eauto using osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e.\n    destruct (tsle_dec o o1).\n    { apply osub_Some_inversion with o1. assumption. }\n    { apply osub_Some_inversion with o2. assumption. }\n    { apply osub_Some_inversion with o1. assumption. }\n    { apply osub_Some_inversion with o2. assumption. }\n    { apply osub_Some_inversion with o1. assumption. }\n    { apply osub_Some_inversion with o1. assumption. }\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e.\n    generalize (h _ eq_refl). clear h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [a2 [h1 [h2 [h3 [h4 h5]]]]].\n    exists a1, h1; exists a2, h2; split; eauto.\n    exists a1, h1; exists a2, h3; split; eauto.\n    exists a1, h2; exists a2, h4; split; eauto.\n    exists a1, h3; split; eauto.\n    exists a1, h4; split; eauto.\n    exists a2, h4; split; eauto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume.\n    eauto using osub_intro.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume in *.\n    intros e e1 e2.\n    generalize (H e1 e2); intros [ a2 [ a3 [ h1 [? [??]]]].\n    inversion H; subst; eauto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    generalize ( osub_Some_inversion H).\n    generalize ( osub_Some_inversion H).\n    destruct (raw_insert x o1 e2).\n    destruct (raw_insert x o1 e2).\n    destruct (raw_insert x o2 e2).\n    destruct (raw_insert x o2 e2).\n    destruct (raw_insert x o1 e2).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o2 e3).\n    destruct (raw_insert x o1 e3).\n    destruct (raw_insert x o1 e3).Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros. rewrite <- make_empty_None_None.\n    apply osub_Some_Some_inversion. assumption.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    generalize (tsle _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros.\n    destruct o1; auto.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros.\n    rewrite lookup_empty_None. apply osub_None_Some.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    destruct o1. eauto using osub_Some_inversion.\n    intro.\n    apply osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume.\n    intros. rewrite lookup_empty_None. apply osub_Some_inversion.\n    split; auto.\n    intro.\n    unfold make_insert.\n    destruct o1.\n    simpl.\n    rewrite <- find_empty_None_None_Some_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalize (f x); intros.\n    generalizeQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume in *. intros. rewrite lookup_empty_None. apply osub_Some_inversion.\n    destruct o1. auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume.\n    intros. rewrite lookup_empty_None_None_Some. apply osub_Some_Some_inversion.\n    repeat find_lookup_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros.\n    rewrite lookup_empty_None. apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_Some_inversion.\n    apply osub_SomeQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume in *.\n    intros.\n    destruct o1; try solve [inversion 1 | inversion 1 | inversion 1 | inversion 1 | inversion 1].\n    simpl.\n    case (le_gt_dec x n); [ case (eq_nat_dec x n); intro H; inversion H; clear H; intro H; subst; eauto.\n    (* A case *)\n    repeat lookup_lookup; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    generalize (t_equal _ _ _ H).\n    clear t.\n    induction e1; simpl; intros; eauto using osub_None_Some_Some.\n    (* In the case, [lookup_insert x o e1] appears in [x = n], [x = n], [x = n], [x <> n], [x <> n], [x <> n], [x <> n], [x <> n], [x <> n]. *)\n    assert (x <> n).\n    { apply (H0 _ _ _ _ _ H0).\n      apply (H0 _ _ _ _ _ H1).\n      apply (H0 _ _ _ _ _ _ H2).\n      apply (H0 _ _ _ _ _ _ H1).\n      apply (H0 _ _ _ _ H2).\n      apply (H0 _ _ _ H2).\n      apply (H0 _ _ _ _ _ _ H2).\n      apply (H0 _ _ _ _ _ _ H1).\n      apply (H0 _ _ _ H2).\n      apply (H _ _ _ _ H2).\n      apply (H0 _ _ _ H2).\n      apply (H0 _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume in *. intros.\n    apply (get_insert x o e1 e2).\n    rewrite <- (get_insert x o e1 e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e1 e2).\n    rewrite <- (get_insert x o e1).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e1).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e1).\n    rewrite <- (get_insert x o e1).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e1).\n    rewrite <- (get_insert x o e2).\n    rewrite <- (get_insert x o e2).\n   Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume.\n    intros. rewrite lookup_empty_None. apply osub_Some_inversion.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. do 6 intro.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o1.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o2.\n    simpl.\n    destruct o1.Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None_Some_Some_Some_Some_Some_Some_None_None.\n    apply osub_Some_Some_Some_None_Some_None_Some_None_None_None_None_None.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros. rewrite insert_append.\n    destruct (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In the case, [lookup_insert] is injective *)\n    repeat find_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume.\n    intros. rewrite lookup_empty_None. apply osub_None_Some.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 3 intro. rewrite lookup_empty_None_None_None_Some.\n    apply osub_intro.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 2 intro.\n    generalize (H (is_empty _). apply osub_intro. assumption.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros.\n    rewrite lookup_empty_None. apply osub_refl.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume.\n    intros.\n    repeat find_lookup_insert.\n    rewrite lookup_empty_None.\n    rewrite lookup_empty_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_None_Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume.\n    intros. rewrite lookup_empty_None_Some.\n    destruct o1. eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n    intro n. destruct (le_gt_dec x n) as [ | n].\n    eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_intro.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume in *. do 7 intro.\n    remember (get_insert x o1 e2) as o1.\n    generalize (node_is_empty_Some_inversion 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None_Some.\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n := n).\n    apply osub_intro with (n :=Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_intro.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros. unfold subsume in *.\n    simpl in *.\n    repeat find_insert; eauto using osub_reflexive.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f.\n    induction e1; simpl; intros.\n    (* E_eq *)\n    destruct (le_gt_dec e1 e2).\n    (* E_eq *)\n    simpl.\n    destruct (le_gt_dec e1 e2).\n    (* E_eq *)\n    assert (t = t).\n    { rewrite raw_insert_nil_inversion.\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      rewrite raw_insert_b_ingo in h by reflexivity.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)\n      destruct (f a); auto.\n      (* E_eq *)Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold super_unfold_unfold_lift.\n    destruct x.\n    simpl.\n    destruct (f a1); destruct (f a2); simpl.\n    rewrite raw_insert_value_None in H.\n    discriminate.\n    destruct a1.\n    simpl.\n    apply (f a1); auto.\n    eauto using AnnTyping_map.\n    auto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f e1 e2 H.\n    unfold subsume in H.\n    rewrite raw_insert_nil.\n    solve [ eauto using osub_Some].\n    solve [ eauto using osub_Some].\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    (* Existentials *)\n    simpl.\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (f a)).\n    (* Existentials *)\n    apply (H0 (fQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    eapply subsume_map_inversion; eauto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f e1 e2 H H0.\n    apply (f (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a) (fun a => f a)Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    generalize (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear h; intro h;\n    rewrite <- (fs_cons_inversion h); clear hQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    apply (f (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x) (fun x => f (f x))).\n    apply (f (fun x => f (f x) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x)) (fun x => f (f x))).\n    apply (f (fun x => f (fun x => f (f x)) (fun x => f (f x)) (fun x => f (fun x => f (f x)) (fun x => f (f x))).\n    apply (f (fun x => f (fun x => f (f x)) (fun x => f (f x) (fun xQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    inversion e1.\n    (* Base case *)\n    destruct x.\n    (* Base case *)\n    destruct x.\n    (* Base case *)\n    destruct x.\n    (* Base case *)\n    destruct x.\n    (* Base case *)\n    simpl.\n    (* Base case *)\n    destruct x.\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    destruct (f a).\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n    (* Base case *)\n   Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    (* Base. *)\n    apply (f_equal (fun a => sub a1) (f a)); simpl; auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inv_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversion h); auto.\n    (* Base. *)\n    repeat (rewrite raw_insert_inversionQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  rewrite <- (app_nil_r n).\n  reflexivity.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  induction n.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl. reflexivity.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  rewrite (IHn 0); simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros.\n  - auto.\n  - auto.\n  - simpl.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1) at 1.\n    rewrite (IH (n + 1) 1).\n    rewrite (IH (n + 1) 1) atQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  simpl; intros n.\n  simpl; auto.\n  simpl; intros n.\n  simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  apply omega_hint_1.\n  apply omega_hint_2.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  intros a; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros n.\n  induction n as [| n IHn].\n  - reflexivity.\n  - simpl.\n    simpl.\n    destruct (n <=? n); reflexivity.\n  - simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n    destruct (n <=? n); reflexivity.\n    simpl.\n   Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  intros.\n  - apply IHn.\n  - apply IHn.\n  - apply IHn.\n  - apply IHn.\n  - apply IHn.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  intros.\n  - simpl.\n    case_eq (n0 + 1); auto.\n    intros.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHmQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction e1; simpl in *; intros.\n  - auto.\n  - auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; intros; simpl; auto.\n  destruct e2; simpl; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros A e1 e2 n1 n2.\n  induction n1; intros; try solve [inversion H; subst; auto].\n  rewrite <- minus_n_Sm in H.\n  rewrite <- minus_n_O in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewrite plus_n_Sm in H.\n  rewriteQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  apply (length_concat (fun n => length e1) e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e1).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e1).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e1 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (app_length e2 e2).\n  rewrite <- (appQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros A e1 e2.\n  induction e1; simpl; intros.\n  - apply IHn; auto.\n  - apply IHn; auto.\n  - apply IHn; auto.\n  - apply IHn; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  apply app_nil_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; intros.\n  + simpl.\n    rewrite IHs. reflexivity.\n  + simpl.\n    rewrite IHs. reflexivity.\n  + simpl.\n    rewrite IHs. reflexivity.\n  + simpl.\n    rewrite IHs. reflexivity.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  induction e1; simpl; intros.\n  rewrite raw_insert_nil.\n  rewrite raw_insert_nil_inversion_clear H.\n  rewrite raw_insert_nil_inversion_clear H.\n  rewrite raw_insert_nil_inversion_clear H.\n  rewrite raw_insert_nil_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear H.\n  rewrite raw_insert_cons_inversion_clear HQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros. induction e1; simpl; intros.\n  - split; [ | split ].\n    - split; [ | split ].\n      * split; [ | split ].\n        * split; [ | split ].\n        * split; [ | split ].\n        * split; [ | split ].\n        * split; [ | split ].\n          * split; [ | split ].\n          * split.\n            * split; [ | split ].\n            * split; [ | split ].\n            * split; [ | split ].\n            * split; [ | split ].\n            * split.\n              * split; [ | split ].\n              * split; [ | split ].\n              * split.\n              * split.\n              * split; [ | split ].\n                * split.\n                * split.\n                * split.\n                * split.\n                * split.\n                * split.\n                  * split.\n                  * split.\n                  apply H5.\n                  split.\n                    * split.\n                  * split.\n                  * split.\n                  * split.\n                  * split.\n                  * apply H5.\n                    split.\n                    * split.\n                    * split; [ | split ].\n                    * split.\n                    * split.\n                    * apply H6.\n                    * split.\n                    * split.\n                    * splitQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2.\n  induction e2; simpl; intros.\n  - auto.\n    rewrite raw_insert_append_In in H.\n    destruct (List.map_none _ _ H).\n    auto.\n    destruct (List.map_none _ _ H).\n    auto.\n    destruct (List.map_none _ _ H).\n    auto.\n    auto.\n  - rewrite raw_insert_append_In in H.\n    destruct (List.map_none _ _ H).\n    auto.\n    destruct (List.map_none _ _ H).\n    auto.\n    auto.\n  - rewrite raw_insert_append_In in H.\n    destruct (List.map_none _ _ H).\n    auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  - rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite raw_insert_app.\n    rewrite rawQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  induction e1; simpl; intros.\n  + rewrite raw_insert_None. auto.\n  + rewrite raw_insert_None_inversion. auto.\n  + rewrite raw_insert_None_inversion. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2; induction k; simpl; intros.\n  - inversion H0.\n    auto.\n    rewrite IH1. auto.\n  - inversion H0.\n    rewrite IH1. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2.\n  induction e1; simpl; intros.\n  - auto.\n    + auto.\n    + auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 k n.\n  induction e1; simpl; intros.\n  - auto.\n  - auto.\n  - auto.\n  - auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 k n.\n  destruct e1; simpl; intros.\n  replace n with n by omega. assumption.\n  eauto using iter_concat with (n + 1) by omega.\n  eauto using iter_concat with (n + 1) by omega.\n  eauto using iter_concat with (n + 1) by omega.\n  eauto using iter_concat with (n + 1) by omega.\n  eauto using iter_concat with (n + 1) by omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros A n x nx e1 e2.\n  induction e1; simpl; intros.\n  - change (x = x) with (x = x); auto.\n    rewrite <- (H1 e2); auto.\n  - change (x = x) with (x = x); auto.\n    rewrite <- (H1 e2); auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  + auto.\n    apply IHn; auto.\n  + rewrite <- (insert_concat _ _ _ e1 e2); auto.\n  + rewrite <- (insert_concat _ _ _ e1 e2); auto.\n  + rewrite <- (insert_concat _ _ _ e1 e2); auto.\n  + rewrite <- (insert_concat _ _ _ _ e1 e2); auto.\n  + rewrite <- (insert_concat _ _ _ _ e2); auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  replace n with (n + 1) by omega.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  replace n with n by omega.\n  rewrite <- (emp_sepcon (P:= fun x => x) (snd (fst (snd (fst (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (fst (snd (snd (snd (fst (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (fst (snd (snd (snd (snd (snd (fst (snd (fst (snd (snd (snd (fst (snd (snd (fst (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (snd (fst (fst (snd (snd (snd (snd (fst (snd (fst (snd (snd (snd (snd (snd (snd (fst (snd (fst (snd (snd (fst (snd (snd (snd (fst (fst (snd (fst (fst (snd (snd (snd (fst (snd (snd (snd (snd (snd (snd (fst (snd (Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  destruct (eval_expr e1 e2); auto.\n  rewrite <- insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite <- insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite <- insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite <- insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insertQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  - exists x. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat.\n  rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat.\n  rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_concat.\n  rewrite <- insert_concat. rewrite <- insert_concat. rewrite <- insert_assoc. rewrite <- insert_assoc.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  - reflexivity.\n  - rewrite app_nil_r. reflexivity.\n  - rewrite app_nil_r. reflexivity.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  replace n with (n + 1) by omega.\n  rewrite <- (IHn e1 e2).\n  rewrite <- (IHn e2 e1).\n  rewrite <- (IHn e2 e1).\n  rewrite <- (IHn e2 e2 e2).\n  rewrite <- (IHn e2 e2).\n  rewrite <- (IHn e2 e2 e2).\n  rewrite <- (IHn e2 e2 e2 e2).\n  rewrite <- (IHn e2 e2 e2 e2).\n  rewrite <- (IHn e1 e2 e2 e3 e3).\n  rewrite <- (IHn e2 e2 e3 e4 e4 e4 e5 e6 e7 e7 e8 e9 e10 e11 e12 e13131313141414151515151515151616161616161617171717171718181819191919202020202021,\n        I16161817191818201921,\n        I32, I32, I32, I32, I32, I32, I32, I32, I32, I32, I32, I32, I32,Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  remember (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a) (split (fun a => a)Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros A n x nx e1 e2 e3.\n  destruct x, x0; simpl; intros.\n  rewrite <- (IHl x).\n  rewrite <- (IHl (p + x)).\n  rewrite <- (IHl x).\n  rewrite <- (IHl (p + x)).\n  rewrite <- (IHl x).\n  rewrite <- (IHl x).\n  rewrite <- (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite <- (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl x).\n  rewrite (IHl xQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite IHn.\n  reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  induction n; intros.\n  - simpl.\n    destruct a.\n    - simpl.\n      unfold nat_rect.\n      apply H.\n      rewrite app_nil_r.\n      auto.\n    - simpl.\n      destruct a.\n      rewrite app_nil_r.\n      simpl.\n      rewrite app_nil_r.\n      auto.\n      apply H.\n      apply H.\n      simpl.\n      unfold nat_rect.\n      apply H.\n      rewrite app_nil_r.\n      auto.\n      auto.\n      auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros; simpl.\n  destruct (ident_eq n a).\n  + subst; destruct a.\n    simpl in H.\n    + subst; auto.\n    + simpl in H.\n      inversion H.\n      simpl in H.\n      subst; auto.\n      + simpl in H.\n        inversion H.\n      + simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H.\n        simpl in H.\n        inversion H. simpl in H.\n        inversion H.\n        simplQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl; auto.\n  destruct a.\n  rewrite app_nil_r in H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in H.\n  destruct H.\n  rewrite app_nil_r in HQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  revert n.\n  induction n; intros; destruct a; try discriminate.\n  destruct a; try discriminate.\n  destruct (ident_eq i i); try discriminate.\n  destruct (ident_eq i i); try discriminate.\n  destruct (ident_eq i i).\n  + subst; simpl.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i i); try discriminate.\n    destruct (ident_eq i iQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; intros; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  induction n; intros; simpl in *.\n  - destruct a; simpl in *; try discriminate.\n    simpl in *.\n    destruct a; simpl in *; try discriminate.\n    destruct a; simpl in *; try discriminate.\n    destruct a; simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    destruct (a a); simpl in *; try discriminate.\n    simpl in *; try discriminate.\n    simplQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros.\n  + destruct (ident_eq n a).\n    + subst; auto.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHm.\n      apply IHmQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite IHn; auto.\n  rewrite IHn; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  destruct a.\n  + left.\n    - rewrite <- (rev_involutive (snd x)) in H by auto.\n    - destruct H0 as [a?].\n      + left.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        right.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        left.\n        rewrite <- (rev_involutive (snd x)) in H by auto.\n        left.\n        rewrite <-Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  destruct a; simpl in *.\n  + simpl in *.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  induction n; simpl; intros.\n  rewrite app_nil_r.\n  auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  destruct a; simpl.\n  + rewrite <- insert_concat_eq.\n    unfold insert_concat in H.\n    simpl in H.\n    destruct (ident_eq i i); auto.\n  + rewrite <- insert_concat_eq.\n    unfold insert_concat in H.\n    simpl in H.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.\n    destruct (ident_eq i i); auto.Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  rewrite <- insert_concat_tail.\n  apply pred_ext.\n  apply pred_ext; intros; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  unfold replicate.\n  induction n; simpl; intros.\n  + simpl. rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHm.\n    rewrite <- IHmQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + simpl in H.\n    destruct a; auto.\n    destruct a; auto.\n    destruct a; auto.\n    destruct a; auto.\n    destruct a; auto.\n    destruct a; auto.\n    destruct b; auto.\n    destruct a; auto.\n    destruct a; auto.\n    destruct b; auto.\n    destruct b; auto.\n    destruct H; auto.\n    destruct a; auto.\n    destruct b; auto.\n    destruct b; auto.\n    destruct H; auto.\n    destruct a; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct a; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct a; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; auto.\n    destruct H; autoQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  - simpl.\n    rewrite (IHn (m + x)) in H.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\n    apply IHm.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  destruct e1; simpl; auto.\n  rewrite H; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + simpl. rewrite <- (IHn (x, t)). auto.\n  + simpl. rewrite <- (IHn (x, t)). auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  apply fold_right_sepcon.\n  apply sepcon_derives; auto.\n  apply sepcon_derives; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  unfold concat.\n  simpl.\n  rewrite <- map_map.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewrite <- map_map.\n  apply map_ext.\n  rewriteQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite <- insert_concat_eq.\n  destruct (ident_eq i i).\n  + destruct (ident_eq i i).\n    + destruct (ident_eq i i).\n      + subst.\n        rewrite IHm.\n        reflexivity.\n        reflexivity.\n        + apply IHm.\n        reflexivity.\n        apply IHm.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n        reflexivity.\n       Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  unfold concat.\n  rewrite (sepcon_emp _ _ _ (pred_rect _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0 H1).\n  rewrite (sepcon_emp _ _ _ _ _ _ _ _ _ _ H1).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ _ _ _ H1).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ _ _ H1).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ _ H2).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ H1).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ _ H2).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ H1).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ H2).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ _ H2).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ H3).\n  rewrite <- (sepcon_emp _ _ _ _ _ _ _ _ H3).Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  simpl.\n  induction n; simpl; auto.\n  rewrite <- app_nil_r.\n  rewrite <- app_nil_r.\n  simpl.\n  f_equal. f_equal. f_equal. f_equal.\n  f_equal. f_equal.\n  f_equal. f_equal.\n  rewrite map_app.\n  apply in_map_iff.\n  apply in_map_iff.\n  apply in_map_iff.\n  apply in_map_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_iff.\n  apply in_map_iff.\n  apply in_iff.\n  apply in_iff.\n  apply in_iff.\n  apply in_map_iff.\n Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_spec.\n  rewrite concat_Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; intros.\n  rewrite IHm; auto.\n  rewrite IHm; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct a; simpl.\n  - rewrite <- (IH (A + n)) at 1.\n    auto.\n  - rewrite <- (IH (A + n)) at 1.\n    auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  unfold concat.\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_comm _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_assoc _ (A:=A)).\n  rewrite (sepcon_assocQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct a as [n?].\n  unfold default_val.\n  simpl.\n  rewrite <- app_assoc.\n  apply sepcon_derives; auto.\n  rewrite <- (emp_sepcon _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- sepcon_assoc.\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- sepcon_assoc.\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite (sepcon_assoc _ (eq _)).\n  rewrite <- (sepcon_assoc _ (eq _)).\n  rewrite (sepcon_assoc _ (Qed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> pf_r; case: s2 => [s1 pf1] /= H.\nhave [[a_safe1]] := (step_same s1) pf2; apply/eqP; rewrite -def_r => ->.\nrewrite /setS /= => H1 H2 H3; case: ifP => //.\nby rewrite -(getS _ pf_r) -(getS _ pf_r) -(getS _ pf_r) -(getS _ pf_r) -(getS _ pf_r).\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n1 pf; rewrite /getS; case: s1 r => // /eqP.\nhave: (getS s1 l) = getS s2 r n1 pf; first by move/eqP.\nrewrite /getS; case: (getS n1 l) => // /eqP.\nrewrite /getS; case: (getS n2 l) => /= /eqP.\nrewrite /getS; case: (getS n2 l) => /= /eqP.\nby case: (getS n2 l) => /= /eqP ->.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> pf s1 s2 r1 r2 /andP[/eqP pf s2 r2 r3 r4 r5] s.\nby case: s1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r12 r13 r14.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>pf; exists (get (get (S (n + n)) (get (S (n + n)))) (get (S (n + n)))) (get (S (n + n)))) (get (S n)).\nby rewrite!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=!getS_juice /=.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof. by move=> pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pf; exists pfQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> pf_a; apply/andP; split.\n- by move=> s1 r1 r2 r1 r2 r2 r1 r2 r3 r4; apply/andP; split.\n- by move=> s2 r3 r4 r4 r5 r6 r7 r8 r8 r9 r10 r11 r12 r13 r13.\nby move=> s3 r4 r5 r6 r7 r8 r9 r12 r13.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> pf s1 s2 r n; rewrite /getS.\nhave: {subset s1 s2 r} by apply: subset_leq_trans pf s1.\nhave: {subset s2 r} by apply: subset_leq_trans pf s1.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s1.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {subset s2 r} by apply: subset_leq_trans pf s2.\nhave: {Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r n; move=> IH; have [s2 r] := (IH s1 r); pose (pf : a_safe a s1) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getS a_res pf)) in IH; pose (pf : a_safe a s2) := (getS (getSQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof. by move=> s1 s2 r; rewrite /getS. Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> a_step pf s1 r2; rewrite /getS; case: ifP => // x.\nby case: ifP => //= _; rewrite?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?getS?S?getS?getS?getS?getS?S?getS?getS?S?getS?S?getS?getS?S?getS?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?getS?S?S?getS?S?getS?S?S?getS?S?S?getQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s1 s2; split=> //.\nby move=> H1 H2; rewrite /getS /set1.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H s H1 H2 H3; have H4: H4 \\subset H4 by rewrite H5.\nby case: (H4 s); [left | right].\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s1 s2; apply/allP=> x; rewrite /= /mkP => /allP.\nby rewrite /mkP => /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [] /allP [].\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> p; case: (p (p p)); auto.\ncase: (p (p (p (fst p))); auto.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> f; have H := IH f; have H := IH f; have H := H; move/(_ H).\nrewrite /findP; case: ifP => //; apply: IH.\nby case: ifP => // _; apply: IH.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s1 s2; case: s2 => // [s3 s4] [|s4 s5] //.\n  by case: s5 => // [s6 [s6 [s7 [s7 [s7 [s7 [s8 [s9 [s10 [H11 [H12 [H12 [H13 H13 H14]]]]]]]].\nby exists s4; exists s6; split=> //.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> p f.\nhave := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); have := (size_size p); rewrite size_size.\nhave /size_size_size p: size p = size p by rewrite size_size_poly1.\nhave s_p: size p <= size p.\n  apply/size_size_size => /size_size_gt0; have := size_size p; have := size_size p; have := (size_size p); have := size_size_gt0.\n  have: size p <= size p by rewrite size_size_poly1.\n  have: size p <= size p by rewrite size_poly_gt0; have := size_size_gt0.\n  have: size p <= size p by rewrite size_size_poly1 size_gt0 size_gt0.\n Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> p1 p2 p3; apply/eqP.\nmove=> p3; rewrite /getS; case: p2 => // p3 p4 p4 p5 p5 p6.\nby rewrite /getS; case: p3 => // p4 p5 p6 p6.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s; case/andP=> H; case/andP=> H1 H2.\nby rewrite /findP?H1?H2?H3?H4?H5.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> p S; case: s => //= H; move/S; rewrite -leqNgt => /andP[H1] /andP[H2] /andP[H3] /andP[H4] /andP[H4] /andP[H4] /andP[H4] /andP[H5] /andP[H5] /andP[H5] /andP[H5] /andP[H5] /andP[H5] /andP[H6] /andP[H6] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H7] /andP[H8] /andP[H8] H8] /andP[H8] /andP[H8] /andP[H8] /andP[H8] /andP[H8] /andP[H9] /andP[H9] /andP[H10] /andP[H11] /andP[H9] /andP[H10] /andP[H11] /Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: s; try case/andP. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: s. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>H; case/andP=>H1 H2; exists x.\nmove/orP; case/andP=>H2; exists x.\nmove/orP; case/andP=>H3; case/andP=>H4; case/andP=>H4; case/andP=>H5; case/andP=>H5;\nby case/andP=>H4; case/andP=>H5; case/andP=>H5; case/andP=>H5; case/andP;\nby case/andP; case/andP; case/andP=>H5; case/andP; case/andP; case/andP;\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>N S; apply: (step_step_total _ _ _ S); first by move/H.\nmove=>N S; apply: (step_step_total _ _ _ S); first by move/H.\nmove=>N S; apply: (step_step_total _ _ _ S); first by move/H.\nby move/H=>N; apply: (step_step_total _ _ S); first by move/H.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>H.\ncase: s => [x s'] r; first by exists r'; rewrite H; apply: H.\nby case: s' => [x s'] r; first by exists r'; rewrite H; apply: H.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by rewrite -pf=> ->. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby case: s => [[s'] r'] r' H; case: s' r' H' H'; case: s' H' H' H' H' H' H' H' H'' H'' H' H' H' H' H'' H' H' H' H'' H' H' H' H' H' H' H' H'' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H' H'' H' H' H' H' H'' H' H' H' H' H' H' H'' H' H' H' H' H' H'' H' H'' H' H'' H' H'' H' H' H' H' H'' H' H'' H'' H' H' H' H'' H'' H' H' H' H'' H' H'' H'' H'' H'Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: s; case: s. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=>H1 H2; case: s' r' r'; move/H2=>H3 H4. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>S; case: (step_step_total s1 s2)=>H.\n- by rewrite -pf=>x; case: (step_step_total s2 s2)=>H1.\n- by rewrite -pf=>x; case: (step_step_total s1 s2)=>H2.\n- by rewrite -pf=>x; case: (step_step_total s1 s2)=>H2.\n- by rewrite -pf=>x; case: (step_step_total s1 s2)=>H2.\n- by rewrite -pf=>x; case: (step_step_total s2 s2)=>H2.\n- by rewrite -pf=>x; case: (step_total s2 s2)=>H2.\n- by rewrite -pf=>x; case: (step_total s1 s2)=>H2.\n- by rewrite -pf=>x; case: (step_total s1 s2)=>H2.\n- by rewrite -pf=>x; case: (step_total s2)=>H3.\n- by rewrite -pf=>x; case: (step_total s1 sQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>D; apply: start_step_step_total; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>S; exists s1, (f (safe_local S)). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>S; exists s1; apply: start_step_step_step_step_step_step_step; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>S; apply: s1; apply: s2; apply: s2; apply: s2; apply: s1; apply: s2; apply: s3; apply: s3; apply: s3; apply: s3; apply: s3; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s5; apply: s5; apply: s4; apply: s5; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: s4; apply: sQed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H1 H2; rewrite /s; apply: IH; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H; apply: (step_step_total s); auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>S; exists s1; split; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>S; exists s1; exists s2; split; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by rewrite -h=> /(safe_all_safe_valid s1) (c l); exists s'. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by rewrite -pf=> /(coh_s l). Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>S; exists s1, (f (safe_local S)). Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by rewrite -pf=> /(prefix_safe_valid S); apply: start_step_step_refl. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by rewrite -s; apply: start_step_step_step_step; assumption. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nintros.\napply: (step_step_state_state_state_state_state _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; rewrite H in H; inversion H; subst. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nintros.\nassert (H := safe_local s s1 r H).\nassert (H := safe_local s s2 r H).\nassert (H := safe_local s s2 r H).\nassert (H := safe_local s s2 r H).\nassert (H := safe_local s s2 r H).\nassert (H := safe_local s s2 r H).\ndestruct H as [s1 [s2 [H1 H2]]].\nassert (H1 := safe_local s1 s2 r H).\nassert (H2 := safe_local s1 s2 r H0).\ndestruct H as [s2 [s3 [H4 H5]]].\nassert (H2 := safe_local s1 s2 r H0).\ndestruct H as [s3 [s4 [H5 H6]]].\nassert (H3 := safe_local s2 s3 H0).\ndestruct H as [s4 [s5 [H5 H6]]].\nassert (H5 := safe_local s3 s4 r H0).\ndestruct H as [s4 [H5 H6]]].\nassert (H6 :=Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: step_corestep_preserve; auto. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>S; exists s1; apply: start_step_step_refl. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>S; apply: (step_step_step_step_step _ _ _ _ _ S). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nintros s; split; intros.\n- rewrite /step_valid /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h.\nby rewrite h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h /h].\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (H _ _ (fun x => x)).\nby apply: (H _ (fun x => x)).\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (H (h (h (h (h (h (h (h (h (h (h (h (h (h (h (h h)))) (h (h (h (h (h (h (h)))) (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h)))) (h (h (h (h (h (h (h)))) (h (h (h (h)))) (h (h (h (h (h (h (h (h)))) (h (h (h (h (h (h (h)))) (h (h (Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (s \\In Coh W); apply: (s \\In Coh W); apply: (s \\InCoh W); apply: (s \\In Coh W); apply: (s \\InCoh W);\n  by rewrite /at!getSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh.\nby rewrite!getSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh /atSh.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=> s; move: (h t); rewrite /h; case: s => //= /H.\nby case: s=> //= /H.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H.\ncase: s => [[x s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y s] [y sQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: s; apply: s; apply: s. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (H s); apply: (H s); apply: (H s); apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by case=>l t m [] [] l m [] l; case m. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros; split; intro.\n- apply H0.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H1.\n- apply H2.\n- apply H.\n- apply H1.\n- apply H2.\n- apply H2.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros.\nassert (HH:= H0).\napply (H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros s t; induction t; simpl; auto.\nintros e0; induction t; simpl; auto.\nintros e0; induction t; simpl; auto.\nintros e1; induction t; simpl; auto.\nintros e1; induction t; simpl; auto.\nintros e1; induction t; simpl; auto.\nintros e2; induction t; simpl; auto.\nintros e2; induction t; simpl; auto.\nintros e1; induction t; simpl; auto.\nintros e2; induction t; simpl; auto.\nintros e3; induction t; simpl; auto.\nintros e3; induction t; simpl; auto.\nintros e4; induction t; simpl; auto.\nintros e4; induction t; simpl; auto.\nintros e5; induction t; simpl; auto.\nintros e4; induction t; simpl; auto.\nintros e5; induction t; simpl; auto.\nintros; induction t; simpl; auto.\nintros; induction t; simpl; auto.\nintros; induction t; simpl; auto.\nintros; induction t; simpl; auto.\nintros e5; induction t; simplQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> H.\nelim: s t m t m t m => [|t m t] t m t0; first by rewrite /t /t /t /t /t /t /t /t0 /t0 /t0 /t1 /t0 /t0 /t0 /t0 /t1 /t1 /t0 /t1/t1 /t2 /t1.\nmove=> H; case: (H t m t0) m t0 => [|t0] m t1 t2 m1 t2 m2 t3; first by rewrite /t /t0 /t0 /t1 /t0 /t0 /t0.\nhave H: s' \\In (t_rcv t0) (t_rcv t0) by apply: (H t0); rewrite /t /t0 /t0 /t0 /t0 /t0 /t0 /t0 /t0.\nhave H: s' \\In (t_rcv t0) (t_rcv t0) by apply: (H t0); rewrite /t /t0 /t0 /t0Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros.\neapply tryrecv_act_step_total; eauto.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros.\ndestruct s as [s1 s2].\nexists (fun x => x).\nsplit.\nintros x.\nsplit.\nintros.\nrewrite <- H0 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H0 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H1 in H0; apply H0.\nrewrite <- H0 in H; apply H0.\nrewrite <- H0 in H; apply H0.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros H; apply H.\nintros l m tms.\ngeneralize (H0 l m tms); generalize (H0 l m tms); generalize (H0 l m tms); generalize (H0 l m tms); generalize (H0 l m tms); clear H0 m tms);\n intros H1; apply H1.\nintros l m tms.\ngeneralize (H0 l m tms); generalize (H1 l m tms); generalize (H0 l m tms); clear H0 m tms;\n intros H2; apply H2.\nintros l m tms.\ngeneralize (H0 l m tms); generalize (H0 l m tms); generalize (H0 l m tms); clear H1 m tms);\n intros H3; apply H3.\nintros l m tms.\ngeneralize (H0 l m tms).\ngeneralize (H0 l m tms).\ngeneralize (H1 l m tms); generalize (H0 l m tms); clear H1 m tms.\nintros H3; apply H3.\nintros l m tms.\ngeneralize (H0 lQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros s t.\ndestruct t; simpl; intros.\n- destruct t; simpl; intros.\n  apply (H t); auto.\n- destruct t; simpl; intros.\n  apply (H t); auto.\n- destruct t; simpl; intros.\n  apply (H t); auto.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=> t s' r.\nmove=> t s' r; move=> t s' r.\nelim: t s' r t' r.\nby case: t' r.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros; apply prop_ext; intro.\nintros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /tryrecv_act_step; move/andP=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H=>H; move/H; move/H=>H=>H; move/H=>H; move/H=>H=>H; move/H; move/H=>H=>H; move/H; move/H=>H=>H; move/H=>H=>H; move/H=>H;\nby rewrite H; move/H=>H=>H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H=>H; move/H=>H; move/H=>H=>H; move/H=>H=>H; move/H=>H;\nby rewrite H; move/H=>H=>H; move/H=>H=>H; move/H=>H; move/H=>H; move/H=>H; move/H=>H=>H; move/Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms: state, exv_act_step s2 r m tms) => [-> | ne_c].\n  + by move=>H; exists l, m, tms; left; split=> //.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n  + by move=>H; exists l; rewrite H; case: ifP.\n- by move=>H; exists l; rewrite H; case: ifP.\n- by move=>H; exists l; rewrite H; case: ifP.\n- by move=>H; exists l; rewrite H; caseQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms: t_R, e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_R e_RQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step /tryrecv_act_step /tryrecv_act_step /try_case /try_v_act_step /try_vact_step /try_case /try_vact_step /try_v_step /try_v_step /try_case/v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /vstep /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /v_step /vQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms, m = 0) then (t_rcv rt,T) else T.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms, m = 0) => [-> | ne_t] //.\n- by rewrite /t_rcv rt; case: (classic (exists l m tms, m = 0) => [-> | ne_t] //=.\n- move=>H; exists (t_rcv rt,T).\n  by move=>H; exists (t_rcv rt,T).\n- move=>H; exists (t_rcv rt,T).\n  by exists (t_rcv rt,T).\n- move=>H; exists (t_rcv rt,T).\n- move=>H; exists (t_rcv rt,T).\n  by move=>H; exists (t_rcv rt,T).\n- move=>H; exists (t_rcv rt,T).\n- move=>H; exists (t_rcvQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists r, r = s0 /\\ r = s0)) => [-> | | ]; last by move/eqP.\n- move=>H; exists r; exists r; split=> // r r H1 H2 H3.\n  by apply: (IHr _ H1 H2).\n- move=>H; exists r; split=> // r H1 H2; split=> //.\n  by apply: (IHr _ H2).\n- move=>H; exists r; split=> //; split=> //.\n  by apply: (IHr _ H1 H2).\n- move=>H; exists r; split=> //; apply: (IHr _ H1).\n- move=>H; exists r; split=> // r H1 H2 H3; split=> //.\n  by apply: (IHr _ H1 H2).\n- move=>H; exists r; split=> //; apply: (IHr _ H1).\n- move=>H; exists r; split=> //; apply: (IHr _ H2).\n- move=>H; exists r; split=> //.Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step /tryrecv_act_step /tryrecv_act_step /tryrecv_act_step /try_op /try_casev_step /try_case_v_step /try_case_v_step /try_case_v_step /try_v_step /try_case /try_case_v_step /try_if_step /try_c_step /try_case_v_step /try_step /try_case_v_step /try_step /try_c_step /try_step /try_case_v_step /try_case_v_c_step /try_c_step /try_c_step /try_step /try_c_step /try_c_step /try_step /try_c_step /try_step /try_c_step /try_step /try_c_step /try_c_step /try_step /try_c_step /try_c_step /try_step /try_step /try_c_step /try_stepQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l, m @ l) (cup (getS s l))); last first.\n- move=>H; exists i; rewrite?H?H //; split=>H.\n  by rewrite H; apply: H; apply: H.\n- move=>H; exists i; rewrite?H //; split=>H; apply: H.\n  by apply: H; apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H; apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H; apply: H.\n- move=>H; exists i; rewrite?H //; split=>H.\n  by apply: H.\n- move=>Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /tryrecv_act_step.\nby case: (classic (exists r, m, r)) => [-> | | ] /andP[H].\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /tryrecv_act_step.\ncase: (classic (exists l, m, mapv_act_step s1 s2 r)).\n- move=>H; exists l; split=>l m tms; split=>//; move/H.\n- move=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H=>H; exists l; split=>r m tms; split=>//; move/H.\n- move/H=>H; exists l; split=>r m tms; split=>//; move/H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_act_step /tryrecv_act_step /try_bindv_act_step /try_v_act_step /try_v_act_step /try_v_c.\nby exists (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcv_trans (getP l)) (t_rcQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; rewrite /tryrecv_act_step.\ncase: (classic (exists l : nat, netypes l = 0)) => [|l IHl].\n  - by case: l => [|l IHl]; exists l; left; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; left; apply: H.\n  - by case: l => [|l IHl]; exists l; right; apply: H.\n  - by case: l => [|l IHl]; exists l; left; apply: H.\n  - by case: l => [|l IHl]; exists l; left; apply: H.\n  - by case: l => [|l IHl]; exists l;Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>H; move: (H _ _ H) => H; move: H=>H.\nmove: (H _ _ _ _ H) => H; move: H=>H.\nrewrite H; move: (H _ _ H) => H.\nmove: (H _ _ _ H) => H; move: H=>H.\nrewrite H; move: (H _ _ H) => H.\nmove: (H _ _ H) => H.\nby rewrite H; move: (H _ _ H) => H.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; case: (classic (exists l m tms from rt (fun x => x))).\n- by move=>H; case: (classic (exists l m tms from rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms from rt (fun x => x)));\n- by move=>H; case: (classic (exists r m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>H; case: (classic (exists l m tms to rt (fun x => x)));\n- by move=>Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms to rt (lev_act_step s1 s2)) => [-> | ne_x].\n  by exists r; rewrite?e1?e2?e3?e4.\nby exists r; rewrite?e3?e4?e5.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>C; apply: (do_recP (fun e => e.2 == (l, t_snd st)) h) s).\n- by apply: (do_recP (fun e => e.2 == (l, t_snd st)) h) s).\n- by apply: (do_recP (fun e => e.2 == (r, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (l, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (l, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (r, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (r, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (r, t_snd st)) h).\n- by apply: (do_recP (fun e => e.2 == (r, t_Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s t; case: s => [|t s]; constructor; try by constructor.\ncase=>H s'; constructor; try by constructor; by apply: H.\ncase=>H s' H; constructor; try by constructor; by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H s' H; constructor; try by apply: H.\ncase=>H sQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>D H1 D1 D2; case/andP: D1 D2.\n- by case/andP: D2 D3.\n- by case/andP: D3.\n- by case/andP: D3.\n- by case/andP: D3.\n- by case/andP: D4.\n- by case/andP: D3.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D6.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D5.\n- by case/andP: D6.\n- by case/andP: D6.\n- by case/andP: D5.\n- by case/andP: D6.\n- by case/andP: D5.\n- by case/andP: D6.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s; case: s => //= s s IHs; move/IH=>H.\n- (* The problem is the use the same *)\n- (* no need to use the proof *)\n- (* no need to prove *)\n- (* no need to show that *)\n- (* no need to use the proof. *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* no need to show that *)\n- (* noQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s; apply: send_act_safe_step_step.\ncase=>C; apply: send_act_safe_step.\ncase=>C; apply: send_act_safe_step.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe_step.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C; apply: send_act_safe.\ncase=>C;Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>D s1 D s2 r H1 H2; apply: send.\nhave D s: send_act_safe s :=\n  [set (h := mk_st_step _ D s) s (t_fst st) s (t_fst st) s].\nhave D s: send_act_safe s :=\n  [set (h := mk_st_step _ D s) s (t_fst st) s (t_snd st)).\nhave D s: send_act_safe s :=\n  [set (h := mk_st_step _ D s) s (t_fst st) s (t_fst st) s)].\nhave D s: send_act_safe s :=\n  [set (h := mk_st_step _ D s) s (t_fst st) s (t_fst st) s].\nhave D s: send_act_safe s :=\n  [set (h := mk_st_step _ D s) s (t_fst st) s].\nhave D s: send_act_safe s :=\n  [set (h := mk_stQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s; apply: send.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s; case=>C; rewrite /send_act_safe /s_eq /s_eq /s_eq /s_eq /s_eq /s_eq /s_eq /s_eq /s_s.\nby rewrite!send_act_safe /s_eq /s_eq /s_s /s_eq /s_eq /s_eq /s_s_eq /s_eq /s_s_eq_s /s_eq /s_eq_s_s.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=> s; case=>D; apply: (IH _ _ D); apply: (IH _ D); apply: (IH _ D).\nmove=>D; apply: (IH _ D); apply (IH _ D).\nmove=>D; apply: (IH _ D); apply (IH _ D).\nmove=>D; apply (IH _ D); apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D); apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D); apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D).\nmove=>D; apply (IH _ D).\nby move=>D; apply (IH _ D).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H s; apply: send_act_safe_valid.\nby exists s; rewrite?H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 H2; case:H1; case:H2.\n- by case:H1.\n- by case:H2.\n- by case:H1.\n- by case:H1.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H1.\n- by case:H1.\n- by case:H2.\n- by case:H2.\n- by case:H1.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H1.\n- by case:H2.\n- by case:H1.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H2.\n- by case:H1.\n- by case:H2.\n- by case:H1.\n- byQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case: s; first by case=>H1 H2; case: (H1 H2); move: (H2 H2); move: (H3 H3); move: (H4); move: (H4 H4); move: (H4 H4); move: (H5 H4); move: (H5 H5); move: (H5 H6); move: (H5 H6); move: (H6); move: (H6); move: (H6 H6); move: (H6); move: (H7); move: (H7); move: (H6); move: (H8); move: (H6); move: (H7); move: (H8); move: (H8); move: (H8); move: (H9); move: (H8); move: (H9); move: (H8); move: (H9); move: (H8); move: (H9); move: (H9); move: (H9); move: (H9); move: (H9); move: (H9); move: (H9); move:Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>S [s0 [s1 [t0 [t0 [t0 [t1 [t0 [t1 [t2 [t2 [t3 [t3 [t4 [t4 [t4 [t5 [t5 [t5 [t6 [t6 [t7 [t7 [t7 [t7 [t8 [t8 [t8 [t9 [t10 [t10 [t10 [t11 [t12 [t13 [t13 [t14 [t14 [t14 [t15 [t15 [t15 [t14 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t16 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15 [t15Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=>H.\napply: send; apply: send; apply: send; apply: send; apply: send; apply: s.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case: s => // [[s l] s] s //=; apply: send. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=>H; case: s => //= H; case: s => //= H; case: s => //= H; case: s => //= H.\n- by case: s => //= H; case: s => //= H.\n- by case: s => //= H; case: s => //= H.\n- by case: s => //= H; case: s => //= H; case: s H=> //= H; case: (H s)=> //= H.\n- by case: s => //= H; case: (H s)=> //= H; case: (H s)=> //= H.\n- by case: s=> //= H; case: (H s)=> //= H; case: (H s)=> //= H.\n- by case: s=> //= H; case: (H s)=> //= H.\n- by case: s => //= H; case: (H s)=> //= H; case: (H s)=> //= H.\n- by case: (H s)=> //= H; case: (H s)=> //= H.\n- by case: (H s)=> // H; case: (H s)=> //= H.\n- by case: (HQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>C; case C; rewrite /send_act_safe_state; case: C; rewrite C;\ncase: C; rewrite /send_act_safe_state; case: C; rewrite C;\ncase C; rewrite C; first by move/C: C; rewrite C; move/C; rewrite C; move/C; rewrite C; move/C=> <-; move/C=> ->.\nby move=> C; rewrite /send_act_safe_state; case: C; rewrite C; move/C=> ->; move/C=> ->; move/C=> ->; move/C.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=> s; case: s; case: s; case: s; case=>s s' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r' r'' r'' r'' r' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r''.\n\n(* We define the first step. *)\nVariable tr : state.\n\nDefinition map := map s.\n\n(* This is used to define an additional function. *)\nVariable s : state.\nVariable s' : state.\n\n(* The following example, we define a set of s *)\nVariable s1 : state.\n\nDefinition map := map s s1.\n\nVariable sQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=> s1 s2 r; case: s1 => //= s2 r s2 r; case: s2 => //= s2 r s2 r; case: s3 => //= s3 r; case: s4 => //= s4 r; case: s4 => //= s4 r; case: s5.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- by exists r; rewrite?eqxx?orbT.\n- byQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase: s => [[s] s'] s' Hs; exists s'.\n- exists (mk l s').\n  split; auto.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in Hs.\n  rewrite IHs' in HsQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>C; exists s'; exists (fun e => e).\n- exists (fun e => e.2 == (l, t_snd st)) (RState s1 s2); exists s'; split; first by split.\n- by exists (fun e => e.2 == (l, t_snd st)) (RState s1 s2); exists s'; split; first by split.\n- by exists (fun e => e.2 == (r, t_snd st)); split.\n- by exists (fun e => (r, t_snd st)) (RState s1 s2); split.\n- by exists (fun e => (r, t_snd st)) (RState s1 s2); split.\n- by exists (fun e => (r, t_snd st)) (RState s1 s2); split.\n- by exists (fun e => (r, t_snd st)); split.\n- by exists (fun e => (r, t_snd st)) (RState s1 s2); split.\n- by exists (fun e => (r, t_fst st)) (RState s2Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>C D s2 r; case=>C D s2 r; case=>D s2 r; case=>D s3 r; case=>D s4 r; case=>D s4 r; case=>D s5 r5 r6.\n- by rewrite E s2 D s4 D s4 D s5 s6 s6.\n- by rewrite E s4 D s4 D s6.\n- by rewrite E s4 D s5 s6.\n- by rewrite E s5 s6.\n- by rewrite E s4 D s6.\n- by rewrite E s4 D s6.\n- by rewrite E s4 D s6.\n- by rewrite E s5 (t_fst st3) s6.\n- by rewrite E s4 D s6.\n- by rewrite E s4 D s6.\n- by rewrite E s4 D s6.\n- by rewrite E s4 (t_fst st3) s6.\n- by rewrite E s6.\n- by rewrite E s5 (t_fst st3) s6.\n- by rewrite E s4.\n- by rewrite E s5Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase: s => [s t s'] /= H; case: s' => [s' r'] /= H; exists s'.\n- by move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- by move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H t s') H; exists s'.\n- move: (H tQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>S; case=>S; case:S; case=>S; case=>S; case=>S; case:S=>S; case=>S; case=>S.\n- by case:S=>S; case=>S; case=>S; case=>S; case:S; case=>S; case=>S.\n- by case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S;\n by case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S;\nby case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S;\n[case=>S; case=>S; case=>S; case=>S; case=>S; case=>S; case=>S;Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S; elim: n => //= n IHn in le_n_S; first by rewrite big_nil.\ncase: (S n) => //= n IHn in le_n_S; case: (S n) => //= n IHn in le_n_S; case: (S n) => //= n IHn in le_n_S.\nby rewrite big_conscons IHn // big_cons IHn // => i _; apply: IHn.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>S D s' r; case: (R s); case: (R s); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (R s'); case: (RQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> m n; case: m n => // m n; case: m => // m IHm; case: m.\n- move=> m IHm; rewrite /l1 /= /r2 /= /l1 /= /l2 /= /l2 /= /l2 /= /l2 /= /l2 /= /l2 /= /l2 /= /l3 /= /l2 /= /l3 /= /l3 /= /l4 /= /l4 /=!l3.\n- by move=> m n; rewrite /l2 /= /l2 /= /r2 /= /r3 /= /l3 /= /l2 /= /l4 /= /l5 /= /l5 /= /l6 /= /l7 /= /l7 /= /l8 /= /l8.\n- move=> m n; rewrite /l2 /= /l3 /= /l3 /= /l3 /= /l4 /= /l4 /= /l5 /= /l6 /= /l8 /= /l9 /= /l4 /= /l6 /= /l8 /= /l8 /=!l9.\nby move=> m n; rewrite /l2 /= /l3 /= /Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> n; case: d => //= d ->.\nhave /andP [/andP[/andP[/andP[/andP [/andP [/andP[/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/negP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/eqP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/eqP [/andP [/andP [/andP [P [_ [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [/andP [P [/andP [_ [/Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by move=> d /andP[]. Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> n; elim: n=> [|n IHn]; first by rewrite?size_map.\ncase: ifP => //= n IHn; rewrite?size_map // => -> {1}n IHn; exists (1.+1.+1.+1.+1); rewrite?size_map?size_map.\nby rewrite!size_map /=!size_map /=!size_map -size_map.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d _ /= [|n]; first by case: d => //= d; case: d.\nby case: d => //= d; case: d => //= d ->.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> dst; apply: (valid_valid dst).\nhave: forall d, d!= 0 -> size d!= 0 -> d!= 0.\n  move=> dst; apply: (valid_valid dst).\n  by rewrite /hst; move=> /andP[].\nhave: forall d, d!= 0 -> d!= 0 -> d!= 0 -> d!= 0.\n  move=> dst; apply: (valid_valid dst).\n  by rewrite /dst; move=> /andP[].\nhave: forall d, d!= 0 -> d!= 0 -> d!= 0 -> d!= 0.\n  move=> dst; apply: (valid_valid dst).\n  by rewrite /dst; move=> /andP[].\nhave: forall d, d!= 0 -> d!= 0 -> d!= 0.\n  move=> dst; apply: (valid_valid dst).\n  by move=> /andP[].\nhave: forall d, d!= 0 -> d!= 0 -> d!= 0.\n  move=> dst; apply: (valid_valid dst).\n  by move=> /andP[].\nhave: forall d, d!= 0 -> d!= 0 ->Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> dstep; case: dstep.\n- by case: dstep.\n- by case=> /= dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> /= dstep; exists dstep.\n- by case=> // dstep; exists dstep; exists dstep.\n- by case=> /= dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> // dstep; exists dstep.\n- by case=> //= dstep; exists dstep; exists dstep; exists dstep; exists dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> //= dstep; exists dstep; exists dstep; exists dstep; exists dstep; exists dstep; exists dstep; exists dstep; exists dstep.\n- by case=> //= dstep; exists dstep.\n- by case=> //= dstep; exists dstep; exists dstep;Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> n d; case: n d => // n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d; case: d => //= n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d; case: d => //= n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d; case: d => //= n d; case: d => //= n d; case: d.\ncase: d => //= n d; case: d => //= n d; case: d.\ncase: d => //= n d; case: d => //= n d; case: d => //= n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d; case: d => //= n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d.\ncase: d => //= n d; case: d => //= n d; case: d => //= nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d_lt_n; apply/andP.\nrewrite /l1 d_lt_n; case: ifP => // ->.\nby rewrite /l1 d_lt_n; case: ifP => // ->.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> dst; rewrite /l1 dst.\nhave [-> | dst] := eqVneq dst; first by rewrite dst.\nhave [-> | dst] := eqVneq dst; first by rewrite dst.\nhave [-> | dst] := eqVneq dst; first by rewrite dst.\nby rewrite dst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d => // d; rewrite /l2 /l2 /l2 /l2 /l2 /l2 /l2 /l2 /l3 /l3/l4/l5/l6. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nmove=> /mapP[m_lt_mn_mn_def].\nby apply/allP=> _ /mapP[n /(nth_error_valid d)(k, j); rewrite?nth_default.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d => //= d; rewrite /l2 d; case: d => //= d; rewrite /l2 d. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d; case: d => //= d ->. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d => // d; rewrite /l2 /l3 /l3 /l4 /l4/l4/l5/l6/l7/l8/l8/l8/l9/l9/l9/l10/l10/l10/l11/l11/l12/l12/l11/l13/l14/l14/l14/l14/l14/l14/l14/l15/r14/r14/r14/l14/r14/r14/r14/r14/r14/r14/r14/r15/r14/r15/r14/r14/r14/r14/r14/r15/r14/r14/r15/r14/r14/r14/r14/r15/r14/r14/r14/r14/r14/r14/r14/r14/r14/r15r14/r14/r14/r14/r14/r14/r14/r14/r14/r14/r14/rQed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> // d ->; rewrite /l2 /dinter /=!andbT /dinter /=!andbT /dinter /=!andbT /dinter /=!andbT /dinter /=!andbT. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d => // ->. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case/perm_coh0=> <-; apply: perm_coh0. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d => // d; exists d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case=>x y; rewrite /=!inE /=!inE /=!inE /=!inE /=!inE /=!inE /=!inE /=!inE. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n; case: n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => [|n] [|n] [|m]; exists m; exists d. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => // m; apply: lcoh n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n; case: n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case=> // m lcoh. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ /(_ n H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ /(_ n H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ /(_ _ H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ /(_ n H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: m => // m [] m [] [] m [] []. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ /(_ _ H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> H; case: C => _ _ /(_ _ (erefl _)).\nby case: C => _ /(_ _ (erefl _)).\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ /(_ n H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ /(_ n H). Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ /(_ n H). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (n \\in_nodes); rewrite /=!inE. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H; case: (m \\in all_node_nodes) => //= H.\ncase: (m \\in all_node_nodes) => //= H; rewrite findPt.\nby rewrite findPt; case: eqP H => // H _; rewrite findPt.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: (n <= m); rewrite findPt. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (m _ _ _ H). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H; case: (m \\in_nodes); last first.\n  by rewrite findPt /=; case=>m /IH; case: (m \\in_nodes); last first.\n  by rewrite findPt.\nby rewrite findPt /=; case: (m \\in_nodes); last first.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\ncase: m=> [|m IHm] [|m IHm] [|m IHm] [|m IHm] //= m IHm] //= m.\n- by rewrite nth_nil.\nby rewrite nth_nil.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: n. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=> H; case: n=>n; rewrite nth_nil => H; case: (IH _ H).\nby rewrite nth_nil => H; case: (IH _ H); rewrite nth_nil => H; case: H.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: m => // _ /(_ n H). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (m _ _ H)=>m; rewrite findPtUn. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: C => _ ->. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; case: (valid _ _ _ _ _ _ _ _ _ _ H) => H.\nby apply: (H m); rewrite findPtUn.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; case: C => _ /(_ n H)/eqP.\nby move: (H n H)=>m; rewrite /n /n /n /n /n /m /n /m /n /m /n /m /n /m /n /n /n /m /m /n /n /n /n /m /n /n/m /n /m /m /n /m /n/n/n /m.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> H; case: C=> _ /(_ _ (fun _ => _)).\nby case: C=> _ /(_ _ (fun _ => _)).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (tmp H)=>m; rewrite /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index /index/index /index /index/index /index /index /index /index.\nby move=> H; apply: (H n); rewrite?index_index?index_index //?index_index_index?index_index_index?index_index_index.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: C => _ _ /(_ _ H). Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; case: C => _ /(_ _ _ _ H) /= _ H.\nby case: (H m) => // H.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: C => _ _ /(_ n H)=>m [H]. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; case: (stup d) => /= H; case/orP=>H.\nby case: (m \\in_pf (size d)) => // H; rewrite H.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: (H m); rewrite -E=>H. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case: m => //= m IHm. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: m => // m; rewrite!inE. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /index; case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case: H=> -> _ /(_ n H)/eqP. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case: C => _ /H /H. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case: m => // m IHm; rewrite H. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=> H; case: m => // _ /(_ n H) _; case: m => // _ /(_ n H) _; case: m => //= ->.\nby move: (H n H)=>m; rewrite H.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case=> /andP[/eqP H]. Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\ndestruct (AR_S x) as [N [H1 H2]]; exists N.\nintros.\nexists (N.succ N).\nintros.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in |- *.\nassert (forall y z : S, G y -> G y z -> G y z).\nintros.\napply H; auto with algebra.\napply Trans with (G y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  apply (H _ H).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros x y z; unfold is_group in *.\n  rewrite H.\n  apply H.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nintros; apply H.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply sym_eq.\napply eq_sym.\napply eq_sym.\napply eq_sym.\napply H0.\napply eq_sym.\napply H.\napply eq_sym.\napply H.\napply eq_sym.\napply H.\napply H.\napply eq_sym.\napply H.\napply H0.\napply eq_sym.\napply H.\napply H.\napply H.\napply H.\napply eq_sym.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z; elim x; intro H; elim H; intro H0; elim H0; intro H1; elim H1;\n intro H1; elim H1; intros H2; elim H2; intros H3; elim H3; intros H4; elim H4; intros H5; elim H6; intros H6; elim H7;\n intros H8; elim H8; intros H9; elim H9; intros H10; elim H9;\n intros H10 H11; elim H10; intros H11 H12; elim H12; intros H12 H12; elim H12;\n intros H11 H12; elim H12; intros H12 H12; elim H12; intros H12 H12; elim H12; intros H12 H13;\n elim H13; intros H13 H13 H14; elim H13; intros H14 H14; elim H13;\n intros H15 H16; elim H13; intros H17 H18; elim H17; intros H18 H19; elim H18;\n intros H18 H20; elim H18; intros H19 H20 H20; elim H20Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in H.\ndestruct H.\nauto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in |- *.\nintros.\napply H0.\nintros x H.\napply H1.\nintros x H.\napply H1.\nintros x H.\napply H1.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\napply H.\nintros x H.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros H y z H1 H2.\napply H1.\napply H2.\napply H1.\napply H2.\napply H3.\napply H1.\napply H3.\napply H2.\napply H3.\napply H3.\napply H3.\napply H4.\napply H1.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H3 y1); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\napply (add_add_assoc S (Add x1 y1) x1 y1 y2); auto.\napply add_add_assoc; auto.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n clear H5 H6 H7 H8 H9.\n(* use of the same result *)\nelim (H9 x H9); intros; elim H9; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H5 y H0); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H10; intros; elim H10; intros; elim H9Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H2 y H0); intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n clear H4 H8 H9.\n(* use of the opposite *)\nelim (H9 x H2); intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n clear H4 H8.\n(* use of the opposite *)\nelim (H9 x H2); intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H8.\n(* use of the opposite *)\nelim (H9 x H2); intros; elim H8; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the opposite *)\nelim (H9 x H2); intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n clear H9.\n(* use of the opposite *)\nelim (H9 x HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim (H1 x H2); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x1); intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x H1); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H1 x H2); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H0 x H1); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H4 H5 H6 H7 H8.\n(* use of the sign *)\nelim (H6 (conj x) x y); intros; elim H6; intros; elim H7; intros; elim H7;\n clear H6 H7 H8.\n(* use of the opposite *)\nelim (H7 x H1); intros; elim H6; intros; elim H7; intros; elim H7;\n clear H8 H9.\n(* use of the same side of the same side of the same side of the side *)\nelim (H7 x H2); intros; elim H7; intros; elim H7; intros; elim H8;\n clear H8.\n(* use of the same side of the same side of the side of the side of the side of the side of the side of the side of the side of the side ofQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (Add x y)); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (Add x1 y)); intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6;\n introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply (conj_com _ _ (conj_com _ _ _ H)).\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; apply (add_add (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => x) (fun x => xQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (conj (Add x1 y) x1); elim (H0 x2); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (conj H (conj H (conj H (conj H (conj H (conj H (conj H (conj H (conj H))))) x).\nelim (H (conj H (conj H (conj H (conj H (conj H (conj H)))) x)).\nrewrite (ass x1 y); elim (H (conj H (conj H (conj H (conj H)))) x).\nrewrite (ass (Add x1 y) x2 y); elim (H (conj H (conj H (conj H (conj H (conj H)))) x).\nrewrite (ass x1 y); elim (H (conj H (conj H (conj H (conj H (conj H (conj H)))) x)).\nrewrite (ass (Add x1 y) x2 y); elim (H (conj H (conj H (conj H (conj H)))) x).\nrewrite (ass (Add x1 y) x2 y); elim (H (conj H (conj H (conj H (conj H)))) x).\nrewrite (ass (Add x1 y) x2 y); elim (H (conj H (conj H (conj H)))) x).\nrewrite (ass (Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm y x H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm y x H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).\nrewrite (mult_comm x y H).Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (Add_add x y); elim (ax x y); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H H H0 H1.\n(* use of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the *)\n\nLemma set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_setQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x); elim (H x); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H0 x H1); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H0 x H1); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_group in |- *.\nelim (H x H0); intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Fopp x)).\nrewrite <- (Ropp_involutive (Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp (-x)).\nrewrite <- (opp_opp_opp (- x)).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (opp_opp_opp (-x).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (opp_opp_opp (-x).\nrewrite <- (opp_opp_opp (-x)).\nrewrite <- (Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H11; intros; elim H11;\n intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_opp_opp_opp x).\nrewrite (opp_opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (opp_opp x).\nrewrite (oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold not in |- *.\nintro H.\nrewrite (minus_0_l (F:=F)).\nrewrite (opp_opp x).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (opp_opp y).\nrewrite (Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H (Opp x) x y); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_midpoint in |- *; split.\nelim (H0 (Opp x) x); intros; elim H0; intros; elim H0; intros.\n(* [x+y] *)\nelim (H4 x H0); intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_subspace in |- *; split.\nelim H; intros; elim H; intros; elim H2; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elimQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_Fzero in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H9Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim (H x H0); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n clear H2 H2 H3 H4 H5.\n(* [x+y=0] *)\nelim (H0 x H1); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n clear H2 H2 H3 H5.\n(* [x+y=0] *)\nelim (H1 x H2); intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H2 H2 H3 H4.\n(* [x+y=0] *)\nelim (H1 x H2); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n clear H2 H3 H4.\n(* [x+y<>0] *)\nelim (H1 x H2); intros; elimQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_empty in |- *; split.\nelim H; intros; elim H0; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) x y).\nunfold not in |- *; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H2; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_subspace in |- *.\nunfold is_subspace in |- *.\nunfold not in |- *; intro H.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elimQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intro.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero _))) _))) _)) _)))).\nunfold is_the_group.\napply (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero _))) (- (-x))) (-x)) (-x)) (-x)) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) (-x) x) (-x) (-x) (-x) (-x) x) (-x) x) (-x) x) H) H6 H8).\nunfold is_the_group.\napply (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero (opp_zero _))) (-x) (-x) (-x) (-x) x) (-Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_opp.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim (opp_unicity H (O+x)) H0).\n(* [x+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [x+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H1).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H1).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H1).\n(* [y+y] *)\nelim (opp_unicity H (O+x)) H0).\n(* [y+yQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nunfold not in |- *; intro; elim H; intros; elim H; intros.\nrewrite H; apply opp_opp; auto with *.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_unicity H (O/O)).\nrewrite <- opp_zero.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite oppQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_opp.\nrewrite opp_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_opp; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof fun A B f g => forall x y : A, R x y -> x = y :>A.\nintros A P.\nunfold pi1 in |- *.\napply\n (Build_Map (Ap:=fun x : A => f x = g y :>A).\nexact (Build_Map (Ap:=fun x : A => f x = g y :>A).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof fun x y => forall x y : A, R x y -> P (pi1 x y) (pi2 x y).\n\nLemma pi2 : forall (A : Set) (R : A -> A -> A -> Prop),\n  pi2 -> forall (x y : A), R x y -> P (pi1 x y).\nProof fun x y => forall x y : A, R x y -> P (pi2 x y).\n\nintros A R H0 H1 H2; apply (pi2 x y H1).\napply (pi2 x y H1).\napply (pi2 x y H1).\napply (pi2 x y H2).\napply (pi2 x y H2).\napply (pi2 x y H2).\napply (pi2 x y H1).\napply (pi2 y H2).\napply (pi2 x y H2).\napply (pi2 y H2).\napply (pi2 y H2).\napply (pi2 y H2).\napply (pi2 y H2).\napply (pi2 y H2).\napply (pi2 y H2).\napply (pi2Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P.\nexact (fun x => True).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\nelim (H x); intros.\nred in |- *; intros.\nelim (H x); intros.\napply H.\nelim H0; intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (H x); intros.\nexact (Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\napply\n (Build_Map (A:=Set)).\nexact (Build_Map (A:=Set)).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P x y H; elim H; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintro A.\napply (Build_Map (Ap:=fun a : A => P a a) (Build_Map (Ap:=fun a : A => P a) a (Build_Map A)).\nred in |- *.\nintros A x y H'0.\napply (Build_Map (Ap:=fun a : A => P a) (Ap:=fun a : A => P a) a (Build_Map A) a (Ap:=fun a : A => P a) a (Build_Map A) a (Ap:=fun a : A => P a) a (Build_Map A) a) a)\n    (Ap:=fun a : A => P a (Build_Map A) a (Ap:=fun a : A => P a) a (Build_Map A) a)\n    (Ap:=fun a : A => P a (Build_Map A) a (Ap:=fun a : A => P a) a (Build_Map A) a)\n    (Ap:=fun a : A => P a (Build_Map A) a (Ap:=fun a : A => P a) a (Build_Map A) a)\n    (Ap:=fun a :Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P x y H; case H; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintro A.\nintro x.\nintro x.\nintro x.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H0.\nintro.\napply H0.\nintro.\napply H.\nintro.\napply H0.\nintro.\napply H0.\nintro.\napply H0.\nintro.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\napply (Build_Map (Ap:=fun x : A => P x) x).\napply (Build_Map (Ap:=fun x : A => P x) x).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nintros.\nauto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros A P p; elim p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros.\napply\n (Build_subtype (fun (A : Set) (P : A -> Prop) (p : {x : A | P x})\n    (p : {x : A | P x})\n    (p : {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x}.\nintros.\napply\n (Build_subtype (fun (A : Set) (P : A -> Prop) (p : {x : A | P x})\n    (p : {x : A | P x} -> {x : A | P x} -> {x : A | P x}.\nintros.\napply\n (Build_subtype (fun (A : Set) (P : A -> Prop) (p : {x : A | P x})\n    (p : {x : A | P x})\n    (p : {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x}.\nintros.\napply\n (Build_subtypeQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nintros A P p; apply pi2.\napply pi2.\napply pi2.\napply pi2.\napply pi2.\napply pi2.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi1.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi1.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\napply pi3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; simpl in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply inv_refl.\n intros.\n simpl in |- *.\n apply invQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\napply inv_sym; auto.\napply inv_sym; auto.\napply inv_sym; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nunfold inversible in |- *.\nelim H1; intros.\nunfold inversible in |- *.\nelim H1; intros.\nunfold inversible in |- *.\nelim H2; intros.\nunfold inversible in |- *.\nelim H2; intros.\nunfold inversible in |- *.\nelim H2; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible in |- *.\nelim H3; intros.\nunfold inversible inQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (S 0) with (S 0).\nchange (SQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros.\nelim H1; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H2; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.\nelim H3; intros.\nrewrite plus_comm; apply le_S_n; assumption.Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\n simpl in |- *.\n simpl in |- *.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros.\ndestruct x; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\nunfold Z.abs.\nrewrite <- Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_r.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_r.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <- Z_mult_distr_l.\nrewrite <-Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  unfold Z.abs, Z.abs.  unfold Z.abs.  simpl in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.  simpl in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  simpl in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |- *.  simpl in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  simpl in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  simpl in |- *.\n  unfold eval_lu in |- *.  unfold eval_lu in |- *.  unfold eval_lu in |- *.\n  unfold eval_lu in |-Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold IdZ.\nunfold Z.abs.\nrewrite Z_mult_distr_l.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  reflexivity.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n now destruct x.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  compute in |- *; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  now apply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\napply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  unfold Z.abs.\n  apply Z.mul_0_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nintros.\nreplace 0%Z with (-1)%Z.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_l.\nrewrite Zmult_1_l.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1_r.\nrewrite Zmult_1_r.\nrewrite Zmult_1_l.\nrewrite Zmult_1Qed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintro; elim (Z_lt_irrefl 0); intros.\nrepeat rewrite Z_mult_distr_l; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; red in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nintros; apply Z_unitary_commutative_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nsplit.\nred in |- *; auto with zarith.\nunfold not in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Z.abs in |- *; trivial.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Zunit_0, Zunit.\nintros; apply Z_unitary_commutative_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integverif_sign.\nrepeat split.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ WITHOUT ANY WARRANTY; simpl; intros; ring.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ }+{ in |- *.\nunfold integ ; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ in |- *; simpl in |- *.\nunfold VarZ inQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integelve in |- *.\nsplit.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexact Z_one_pos.\nexactQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros; unfold Integ DECLARE in |- *.\nunfold Integ DECLARE in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in |- *.\nunfold Integ in H.\nunfold Integ in H.\nunfold Integ in H.\nunfold Integ in H.\nunfold IntegQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integignon in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_mult_distr_l.\nred in |- *; auto with zarith.\nsplit.\nexact Z_mult_distr_r.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nunfold integ discrR.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integ,*)  in |- *.\nintros; unfold integ in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integignon in |- *.\nsplit.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_r.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_r.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexact Z_mult_simpl_l.\nexactQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintro x; case x; simpl in |- *; auto with zarith.\nsplit.\nrewrite <- (Z_opp_r x); auto with zarith.\nunfold IdZ in |- *; trivial.\nintros; apply Z_to_eq_bool.\napply (Z_to_eq_bool 0); auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; apply inversibleZ; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize (Z_div_mod_eq_full x); intro; subst; trivialQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim x; auto with zarith.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right; reflexivity.\n(* neg n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; left; trivial.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim a.\n(* abs n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold integuePOST, invs, invs, invs, invs, invs, invs, invs, invs.\nintros; left; assumption.\n(* neg n *)\nintros; left; apply H.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim a.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; elim a.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)\nintros; right; trivial.\n(* abs n *)\nintros; left.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* abs n *)Qed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun A B : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f : Ens => (fun f : Ens => (fun f : Ens => f))) B)\n   (fun f :Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E.\napply Extensionality_Ensembles.\nunfold In in |- *; auto.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E.\nelim (classic (is_a_vide = f) (is_a_vide = f)).\nintros; auto with *.\nintros; auto with *.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nDefinition E := fun v : E => v = v.\n\nTheorem E_fun_iff_empty : forall E : Ens, ~ In E Vide.\nProof\n  fun E : Ens => fun v : E => v = v.\n\nTheorem E_fun_Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros.\napply H.\napply H.\napply H.\napply H0.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumptionQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun (E : Ens) (M : Ens) (y : IN E M) =>\n  fun (y : IN E M) =>\n  fun (y : IN (PR (PR y))) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  fun (y : IN (PR y)) =>\n  funQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun (E : Ens) (f : E) (g : E) =>\n  forall (x : E) (g : E),\n  IN (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton _)))))))))))\n                             (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton _)))))))))))\n                      (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton _))))))) (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton _)))))))\n                      (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton _))))))\n                      (Singleton (SingletonQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun x y : Ens =>\n   match x return (IN E x) with\n   | left _ => x\n   | right _ => y\n   end.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide -> ~ In E Vide.\nProof\n  fun x y : Ens =>\n   match y return (IN E x) with\n   | left _ => x\n   | right _ => y\n   end.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide -> ~ In E Vide.\nProof\n  fun x y : Ens =>\n   match y return (IN E x) with\n   | left _ => x\n   | right _ => y\n   end.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide -> ~ In E Vide.\nProof\n  fun x y : Ens =>\n   match y return (IN E x) with\n   | left _ => x\n   | right _ => x\n   end.\n\nTheorem Vide_is_empty : forall E : Ens, ~ In E Vide -> ~ In E Vide.\nProof\n  fun x y : Ens =>\n   match y return (IN E x) with\n   | left _ =>Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun E : Ens =>\n    fun y : Ens =>\n    fun y : Ens =>\n    fun y : Ens =>\n      fun y : Ens =>\n      fun y : Ens =>\n      fun y : Ens =>\n      fun y : Ens =>\n      fun y : Ens =>\n        fun y : Ens =>\n          fun y : Ens =>\n          fun y : Ens =>\n            fun y : Ens =>\n                fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                    fun y : Ens =>\n                  fun y : Ens =>\n                  fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                  fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                      fun y : Ens =>\n                    fun y : Ens =>\n                      fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                    fun y : Ens =>\n                      funQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun (A : Ens) (x : E) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (x : (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (x : (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sg A x)) =>\n  fun (A : Ens) (v : G (sgQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros; elim H; intros E H; elim H; intros E H; elim H;\n [ intro H1; elim H1; intros E' H2; elim E; intros E' H3; elim E;\n intros E' H4; elim E; intros E' H5; elim E; intros E' H6;\n elim E; intros E' H6; elim E; intros E' H'7; elim E;\n intros E' H'7; elim E; intros E' H'8; elim E; intros E' H'8; elim E;\n intros E' H'8; elim E; intros E' H'8; elim E; intros E' H'8; elim E;\n intros E' H'8; elim E; intros E' H'8; elim E; intros E' H'8; elim E;\n intros E' H'9; elim E; intros E' H'8; elim E; intros E' H'9; elim E;\n intros E' H'9; elim E; intros E' H'8; elim E; intros E' H'9; elim E;\n intros E' HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros H1; elim H1;\n [ intros H2 H3; exists x; split; assumption | idtac ];\n auto with set.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros H0 H1; elim H; intros H1;\n [ right; reflexivity | idtac ].\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; cut (In E (fun x => E' x)).\nintro E; elim E; intros x0 H1; elim E; intros H2; elim H2;\n intros H3; elim H4; intros H5; elim H5; intros H6;\n elim H5; intros H6; elim H6; intros H7; elim H7;\n intros H8; elim H8; intros H9; elim H9; intros H10;\n elim H9; intros H10; elim H10; intros H11; elim H10;\n intros H10; elim H12; intros H11; elim H10; intros H12;\n elim H12; intros H12; elim H12; intros H13;\n elim H12; intros H13 H13; elim H13; intros H13 H14; elim H13; intros H15 H15;\n elim H13; intros H15 H16; elim H15; intros H16 H17; elim H15;\n intros H17 H18; elim H17; intros H18; elim H18;\n intros H18 H18; elim HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros E H0; elim E; intros E H1; elim E;\n intros H1 H2; elim E; intros H3; elim E; intros H4 H5;\n elim E; intros H5 H5; elim E; intros H5 H6; elim E; intros H6 H6;\n elim E; intros H6 H7; elim E; intros H7 H8;\n elim E; intros H8 H9; elim E; intros H10 H10; elim E; intros H10 H10;\n elim E; intros H11 H11 H12; elim E; intros H12 H12;\n elim E; intros H12 H12; elim E; intros H12 H13; elim E;\n intros H12 H13; elim E; intros H13 H13; elim E; intros H13 H13 H13;\n elim H13; intros H13 H14; elim E; intros H13 H14 H14;\n elim E; intros H15 H15; elim E; intros H15 H16 H16; elim E;\n intros H17 H17 H18;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros x H0;\n elim H; intros x H1; elim H0; intros x H1;\n elim H0; intros x H1; elim H1; intros H2;\n elim H0; intros H2; elim H2; intros H3;\n elim H3; intros H4; elim H4; intros H5;\n elim H5; intros H6; elim H6; intros H7;\n elim H6; intros H8; elim H7; intros H8;\n elim H8; intros H9; elim H9; intros H9; elim H9; intros H10;\n elim H9; intros H11 H12; elim H10; intros H12; elim H12; intros H12;\n elim H10; intros H12 H12; elim H12; intros H13;\n elim H12; intros H13 H14; elim H13; intros H14 H14;\n elim H14; intros H15 H16; elim H15; intros H16 H16; elim H15; intros H16 H16;\n elim H16; intros HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred in |- *; simpl in |- *; intros E H; elim H; intros.\nred inQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros H1; elim H1;\n intros H2; elim H1; intros H3; elim H3;\n intros H4; elim H3; intros H4; elim H4;\n intros H5; elim H5; intros H6; elim H6;\n intros H7; elim H6; intros H7; elim H7;\n intros H8; elim H8; intros H9; elim H9; intros H10; elim H9;\n intros H10; elim H10; intros H10 H11; elim H10;\n intros H10 H11; elim H12; intros H12; elim H13; intros H10 H11;\n elim H12; intros H12 H12; elim H13; intros H13 H14;\n elim H13; intros H13 H14; elim H14; intros H13 H15;\n elim H14; intros H15 H16; elim H15; intros H16 H16; elim H16;\n intros H17 H17; elim H16; intros H17 H17; elim H17;\n intros H17 H18Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold Vide in |- *; simpl in |- *; intros E H; elim H; auto.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros E; elim (classic (exists x : Ens, In x Vide /\\ ~ In x Vide /\\ ~ In x Vide)).\nintros E; elim (classic (exists x : Ens, In x Vide /\\ ~ In x Vide /\\ ~ In x Vide)).\nintros E; elim H; intros x H0; elim H0; intros H1; elim H0;\n [ intros x H1; elim H1; intros H2; elim H2; intros H3; elim H3; intros H4; elim H4;\n [ intros H5; elim H6; intros H6; elim H6; intros H7; elim H7; intros H8; elim H8;\n [ intros H9; elim H9; intros H10; elim H10; intros H10; elim H9; intros H11; elim H10;\n [ intros H11 H11; elim H11; intros H12; elim H12; intros H12; elim H10;\n [ intros H11 H12; elim H12; intros H12; elim H12; intros H12; elim H12;\n [ intros H13 H13; elim H13; intros H13 H14; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\nProof fun E : Ens => fun x : Ens => E' (fun y : Ens => x = y /\\ E' (fun y : Ens => y = y)) E.\n\nTheorem single_th1 :\n forall (F : Ens) (a : Ens) (i : IN (PR1 X)), IN (PR2 X)).\nProof fun E : Ens => fun x : Ens => E' (fun y : Ens => x = y /\\ E' (fun y : Ens => x = y)) E.\n\nTheorem single_th2 :\n forall (F : Ens) (a : Ens) (i : IN (PR1 X)), IN (PR2 X)).\nProof fun E : Ens => fun x : Ens => E' (fun y : Ens => x = y /\\ E' (fun y : Ens => x = y)) E.\n\nTheorem single_th3 :\n forall (F : Ens) (a : Ens) (i : IN (PR1 X)), IN (PR2 X)).\nProof fun E : Ens => fun x : Ens => E'.\n\nTheorem single_th4 :\n forall (F : Ens) (a : Ens) (i :Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'0 H'1 H'2; split; [ auto with zfc | idtac ].\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'0; elim E; intros x; elim E; intros x; elim E; intros x; elim E; intros x; elim E; intros x; elim E;\n intros x; elim E; intros x; elim E; intros x; elim E; intros x; elim E;\n intros x; elim E; intros x; elim E; intros x; elim E;\n intros x; elim E; intros x; elim E; intros x; elim E; intros x; elim E;\n intros x0; elim E; intros x0; elim E; intros x1; elim E;\n intros x0; elim E; intros x1; elim E; intros x1; elim E;\n intros x1; elim E; intros x1; elim E; intros x2; elim E; intros x2; elim E;\n intros x1; elim E; intros x2; elim E; intros x3; elim E;\n intros x1; elim E; intros x2; elim E; intros x3; elim E; intros x4;\n elim E; intros x4; elim E; intros x5; elim E; intros x6; elim EDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'.\nelim H'; intros E H'; elim H'.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintro E.\napply (Build_Map (Ap:=fun x => x)).\nauto with algebra.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'; elim H; intros E H'; elim H'; intros H'0 H'1;\n  elim H'; intros H'2 H'3; exists x; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E F E H' H'0; elim (H' H'); auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E F' E' H'0 H'1 H'2.\nelim H'; intros E'0 H'2.\nelim H'; intros H'3.\nelim (H'0 (e x)); auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'; elim E; intros E' H'0; elim E'0; intros E'0; elim E'0; intros E'1 E'2;\n  elim E'0; intros E'0; elim E'0; intros E'1 E'0; elim E'0; intros E'1 E'1;\n    elim E'0; intros E'0 E'0; elim E'0; intros E'1 E'2;\n      elim E'0; intros E'0 E'1 E'1; elim E'0; intros E'0 E'1; elim E'0; intros E'0 E'1;\n        elim E'0; intros E'1 E'1 E'1; elim E'1; intros E'0 E'2;\n          elim E'0; intros E'0 E'1 E'1; elim E'0; intros E'0 E'1 E2;\n          elim E'0; intros E'1 E'1 E'2; elim E'0; intros E'1 E'1 E'2;\n          elim E'0; intros E'1 E'2 EDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'0 H'1.\nelim (classic (Equal E' A) (Equal E' A))\n    (Equal (Equal (inter E' A)) (inter (inter E' A)) (inter (inter E' A)) (inter (inter E' A))\n    (inter (inter (inter E' A)) (inter (inter (inter E' A)) (inter (inter (inter E' A)) (inter (inter (inter (inter E' A)) (inter (inter (inter (inter (inter E' A)) (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (inter (interDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction 1.\nintros; elim (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction 1.\nexact E.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros; apply (inf_and_elim A B').\nexact E'.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfoldbit, merged in |- *; simpl in |- *; intros A e H H0; elim H0; clear H0; intros A e H0;\n  split; intro H1; elim H1; intro H2; elim H2; intro H3;\n  elim H1; intro H2; elim H2; intro H3; elim H3; intro H4;\n  elim H3; intro H5; elim H6; intro H5; elim H5; intro H5;\n  elim H6; intro H7; elim H7; intro H8; elim H8; intro H9;\n  elim H9; intro H9; elim H9; intro H10; elim H9; intro H11;\n  elim H10; intro H9; elim H9; intro H10; elim H10; intro H11;\n  elim H9; intro H10; elim H10; intro H11; elim H11; intro H12;\n  elim H10; intro H11; elim H11; intro H11; elim H12; intro H12; elim H11; intro H12;\n  elim H11; intro H11; elim H11; intro H12;Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction 1.\nexact E.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Incident in |- *; simpl in |- *; intros A e H; elim H;\n clear H; intros A' H'; elim H'; intros A' H'0; clear H'0.\nexact (H' A x); clear H'; intros A' H'; elim H'; intros A' H'0; clear H'0.\nexact (H' A x); clear H'; intros A' H'0.\nexact (H' A x); clear H'; intros A' H'0; elim H'; intros A' H'1; clear H'0.\nexact (H' A x); clear H'; intros A' H'0; elim H'; intros A' H'1; clear H'0.\nexact (H' A x); clear H'; intros A' H'1; elim H'; intros A' H'1; clear H'1.\nexact (H' A' x); clear H'; intros A' H'0; elim H'; intros A' H'1; clear H'1.\nexact (H' A x); clear H'; intros A' H'1; elim H'; intros A' H'1; clear H'1Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; red in |- *; intro A'.\nelim A'; simpl in |- *; intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *; intros A' e H1; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *; intros A' e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl in |- *;\n intros A e H0; elim A'; simpl inQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *; red in |- *; red in |- *; intro H; elim H; intros A' B H0.\nunfold Paire in |- *; red in |- *; intro H; elim H; intros A' B' H1.\nelim H; intros A' H2.\nunfold Paire in |- *; red in |- *; intro H; elim H; intros A' B' H3.\nelim H; intros A' H4; elim H4; intros A' B' H5.\nelim H5; intros A' H5.\nelim H5; intros A' H6.\nelim H6; intros A' H7.\nelim H6; intros A' H8; elim H9; intros A' H10.\nelim H7; intros A' H10.\nelim H9; intros A' H10.\nelim H10; intros A' H11.\nelim H11; intros A' H12.\nelim H12; intros A' H12.\nelim H12; intros A' H13.\nelim H13; intros A' H13.\nelim H13; intros A' H13.\nelim H13Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction E; simpl in |- *; intros A e H0;\n  split; [ apply (H1 H0).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction a.\nintros A B a H; elim H; intros x; elim H; intros; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros.\nelim H; intros x0; elim x0.\nintros; elim x0.\nintros; elim x0.\nintros; elim x1.\nintros; elim x1.\nintros; elim x1.\nintros; elim x2.\nintros; elim x2.\nintros; elim x3.\nintros; elim x3.\nintros; elim x4.\nintros; elim x5.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x7.\nintros; elim x7.\nintros; elim xQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction 1.\nelim H; intros x; elim H; intros H0 H1; elim H1; intros H2; elim H2;\n intros H3 H4; elim H2; intros H4 H5; elim H5;\n intros H5 H6; elim H6; intros H7 H8; elim H7; intros H8 H9;\n elim H7; intros H8 H9; elim H8; intros H9 H10; elim H10;\n intros H10 H10 H11; elim H10; intros H11 H12; elim H12; intros H12 H12;\n elim H13; intros H12 H12 H13 H13 H14 H14 H14 H14 H16.\nunfold inv_head in H14.\nelim H14; intros H14 H15; elim H15; intros H16 H16 H17 H17 H18;\n elim H17; intros H18 H18 H19; elim H18;\n intros H18 H18 H19; elim H18; intros H18 H20; elim H18;\n intros HQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *.\nintros; split.\nintros; elim H; intros x0; elim x0.\nintros; elim x0; intros; elim x1.\nintros; elim x1.\nintros; elim x1.\nintros; elim x1.\nintros; elim x2.\nintros; elim x2.\nintros; elim x3.\nintros; elim x3.\nintros; elim x4.\nintros; elim x4.\nintros; elim x4.\nintros; elim x4.\nintros; elim x5.\nintros; elim x5.\nintros; elim x5.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x7.\nintros; elim x7.\nintros; elim x8.\nintros;Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold a; unfold a; unfold a; unfold a; unfold a; unfold b;\n unfold a; unfold a; unfold b; unfold b;\n unfold a; unfold b; unfold b;\n unfold b; unfold b; unfold b; unfold b;\n unfold b; unfold b; unfold c; unfold c;\n unfold c; unfold c; unfold c; unfold c; unfold c;\n unfold c; unfold c; unfold c; unfold c; unfold c;\n unfold c; unfold c; unfold d; unfold c;\n unfold d; unfold d; unfold c; unfold c; unfold d;\n unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfold d; unfold d;\n unfold d; unfold d; unfold d; unfoldQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction 1.\nelim H; intros x0; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elimQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim H; intros x; elim x; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim H; intros x0; elim H; intros x0; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim HQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros;Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nauto with zfc.\n\nintros; elim H; intros x H; elim x; intros H0 H1; elim H0; intros H1 H2; elim H1;\n intros H1 H2; elim H1; intros H2 H3; elim H1;\n intros H3 H4; elim H1; intros H4 H5; elim H1; intros H5 H6;\n elim H1; intros H1 H2; elim H2; intros H2 H3; elim H2;\n intros H4 H5 H6; elim H2; intros H6 H7 H8; elim H2; intros H7 H8 H8;\n elim H2; intros H8 H9 H9; elim H2; intros H9 H10 H10; elim H10;\n intros H10 H11 H11; elim H2; intros H10 H11 H12; elim H2; intros H11 H12; elim H2;\n intros H11 H12 H13; elim H2; intros H13 H13 H14; elim H2; intros H15 H15Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction 1.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x; auto with zfc.\nsimple induction x; auto with zfc.\n\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x2.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x1.\nsimple induction x2.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x1.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nintros.\nrewrite H3.\nelim H3.\nelim (H0 (e x2)); auto with zfc.\n\nelim (H1 (e x2)); auto with zfc.\n\nintros.\nelim (H1 (e x2)); auto with zfcQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros; elim (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *.\nunfold Paire in |- *.\nsimpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *.\nintros; split.\nunfold inv in |- *.\nintros; elim H; intros x; elim x.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction 1.\nexists false; auto with zfc.\n\nintros; elim H; intros x0; elim x0.\nexists x0; auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction 1.\n\nelim H0; intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros;Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; elim (H0 (e x)); auto with zfc.\nintros; elim (H0 (e x)); auto with zfc.\n\nintros; elim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire, Vide in |- *; simpl in |- *; intros; elim H; intros; elim H; clear H; intros;\n elim H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros;Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros.\nelim (H1 (a::nil)); intros.\nauto with zfc.\nexists a; auto with zfc.\n\nintros.\nelim (H0 (a::nil)); intros.\nauto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nunfold a; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros.\napply H; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *.\nintros; elim (H0 (a a)); auto with zfc.\nintros; elim H0; intros x0; elim x0; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists a; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists a; split;\n [ auto with zfc | idtac ].\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; unfold not in |- *;\n auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nintros; elim H; intros x0 H1; elim H1; intros x1 H2; elim H2; intros x2 H3;\n elim H3; intros x3 H4; elim H4; intros x5 H6;\n elim H6; intros x6 H7; elim H8; intros x6 H7;\n elim H7; intros x7 H8; elim H8; intros x8 H9; elim H9;\n intros x8 H10; elim H9; intros x9 H10; elim H10; intros x11 H10 H11;\n elim H10; intros x10 H11; elim H11; intros x12 H11 H11; elim H12;\n intros x12 H13; elim H13; intros H13 H13 H14;\n elim H14; intros x15 H14 H14; elim H14; intros H14 H14 H15;\n elim H14; intros x1 H15; elim H15; intros H16 H16 H16 H17;\n elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold a, a, a, b in |- *; simpl in |- *; intros; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H; intros A e H; elim H;\n clear H; intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A e H; elim H; clear H; intros A e H; elim H; clear H;\n intros A eQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold not in |- *; simpl in |- *; intros; split;\n [ unfold a; case (a a); intros; auto with zfc | auto with zfc ].\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nintros; split.\nintros; elim H; intros x H1; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H4; intros; elim H6; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elimQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Deire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Canc in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *.\nunfold Disj in |- *; simpl in |- *; intros.\nunfold Disj in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros E H; elim E; intros H; elim H;\n intros H H; elim H; intros H0; elim H; intros H1; elim H1;\n intros H1; elim H1; intros H2; elim H2; intros H3; elim H3;\n intros H4; elim H4; intros H5; elim H3; intros H6; elim H6; intros H6;\n elim H7; intros H7; elim H7; intros H8; elim H8;\n intros H9; elim H8; intros H9; elim H9; intros H10; elim H9;\n intros H10 H11; elim H9; intros H11; elim H10; intros H11 H11; elim H11;\n intros H11 H11; elim H12; intros H12; elim H12; intros H13 H13;\n elim H13; intros H13 H14; elim H13; intros H13 H14; elim H13;\n intros H13 H14; elim H14; intros H14 H14; elim H14; intros H14Qed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Canc in |- *; simpl in |- *.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim HQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *.\nunfold Disj in |- *.\nunfold Canc in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in |- *.\nunfold Disj in H.\nunfold Disj in |- *.\nunfold Disj in H.\nunfold Disj in |- *.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in |- *.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj in H.\nunfold Disj inQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Same, in |- *; simpl in |- *; intros;\n elim H; intros H0; elim H0; intros H1; elim H1;\n intros H2; elim H2; intros H3; elim H3;\n intros H4; elim H3; intros H4; elim H4;\n intros H5; elim H5; intros H5; elim H6; intros H6 H6;\n elim H5; intros H6 H6; elim H6; intros H7; elim H7;\n intros H8 H9; elim H9; intros H8; elim H10;\n intros H9 H10; elim H9; intros H10 H11; elim H9; intros H12; elim H10;\n intros H10 H10 H11; elim H10; intros H10 H12; elim H10;\n intros H11 H11 H12; elim H11; intros H12 H12; elim H12; intros H12 H13;\n elim H12; intros H12 H13; elim H13; intros H13 H13; elim H13;\n intros H13 H14; elim H14; intros H13 H14; elimQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; intros E H; elim H; intros H0;\n elim H; intros H1; elim H2; intros H2; elim H3; intros H4;\n elim H1; intros H5; elim H6; intros H6;\n elim H1; intros H8; elim H6; intros H8; elim H6; intros H8;\n elim H8; intros H9; elim H8; intros H10; elim H10; intros H11;\n elim H9; intros H10; elim H12; intros H11; elim H12; intros H11 H12;\n elim H12; intros H12; elim H12; intros H12; elim H12; intros H13;\n elim H12; intros H12 H13; elim H13; intros H13 H13; elim H14;\n intros H13 H14; elim H14; intros H14 H14; elim H14; intros H15 H14;\n elim H14; intros H15 H15; elim H16; intros H16 H18; elim H14; intros H15;\n elim H17; intros H18 H16 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; simpl in |- *; intros; split;\n [ elim (H0 H1); intros H2; elim H2; clear H2; intros H3;\n elim (H1 H2); intros H4; elim H4; clear H4; intros H4;\n elim (H2 H3); intros H5 H5; elim H5; clear H6; intros H6;\n elim (H2 H3); intros H5 H6; elim H6; clear H6; intros H7 H7;\n elim (H2 H3); intros H6 H7; elim H7; clear H7; intros H8;\n elim (H8 H5 H6); intros H6 H7; elim H7; clear H7; intros H8;\n elim (H2 H3 H); intros H7 H8; elim H8; clear H8; intros H8 H8;\n elim (H8 H9 H10); intros H8 H9; elim H8; clear H8; intros H9;\n elim (H2 H5 H8); intros H9 H10; elim H8; clear H8; intros H10 HQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; simpl in |- *.\nintros; apply Extensionality_Ensembles; apply Extensionality_Ensembles; apply Extensionality_Ensembles; apply Extensionality_Ensembles; assumption.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; unfold lin_comb in |- *; simpl in |- *.\nintros; split;\n [ intros; auto with zfc | intros; auto with zfc ].\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; simpl in |- *; intros E H; elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\n intros H; elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H; intros H; elim H; clear H; intros;\n elim H; clear H; intros H; elim H; clear H; intros H;\n elim H; clear H;Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; simpl in |- *; intros; split; [ idtac | idtac ].\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; simpl in |- *; intros E H; elim H; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros E A A' H; elim (eqA_not_eq A A'); auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold Disj in |- *; unfold Disj in |- *;\n unfold Disj in |- *; unfold DisjQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Canc in |- *; intros A A' H; elim H; clear H; intros A' H0; elim H; clear H; intros A' H1;\n elim H; clear H; intros A' H1; elim H1; clear H1; intros A' H2;\n elim H; clear H1; intros A' H2; elim H2; clear H1; intros A' H2;\n elim H; clear H; intros A' H3; elim H3; clear H3; intros A' H4;\n elim H; clear H; intros A' H3 H4; elim H4; clear H4; intros A' H4;\n elim H; clear H; intros A' H5; elim H4; clear H5; intros A' H5;\n elim H; clear H; intros A' H5; elim H; clear H; intros A' H6;\n elim H; clear H; intros A' H5; elim H; clear H; intros A' H6;\n elim H; clear H; intros A' H5; elim H; clear H; intros A' H6;\n elim H; clear H;Qed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros A A' H; elim (classic (exists B : Ens, IN B A).\nintros A A' H; elim (classic (exists B : Ens, IN B A').\nintros B A' H; elim (classic (exists B : Ens, IN B A').\nintros B A' H; elim (classic (exists B : Ens, IN B A').\nintros B A' H; elim (classic (exists B : Ens, IN B A').\nintros B A' H; elim (classic (exists B : Ens, IN B A').\nintros B A' H; elim H; intros B' H'0; exists B; exists B'; split.\nintros B A' H; elim H'; intros B' H'1; exists B'; split.\nintros B' H'; elim (classic (exists B : Ens, IN B' A').\nintros B A' H'; elim (classic (exists B : Ens, IN B A').\nintros B A' H'; elim (classic (exists B : Ens, IN B' A').\nintros B A' H'; elim (classic (exists B : Ens, IN B A').\nintros BQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros A A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim A'0; intros A' H'1; elim A'0; intros A' H'2; elim A'1;\n intros A' H'1; elim A'1; intros A'1 H'2; elim A'1;\n intros A' H'1; elim A'1; intros A' H'2; elim A'1; intros A'1 H'2; elim A'1;\n intros A' H'2; elim A'1; intros A' H'3; elim A'1; intros A'1 H'2; elim A'1;\n intros A' H'2; elim A'1; intros A'1 H'2; elim A'1;\n intros A' H'2; elim A'1; intros A'1 H'2; elim A'1; intros A'1 H'2; elim A'1;\n intros A'1 H'2; elim A'1; intros A'2 H'2; elim A'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (Paire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (classic (X = X)).\nauto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros E1 E2; elim (Paire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros E1 E2; elim ( COMire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (Paire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (conire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (conire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (ClockwiseNotCollinear E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros E1 E2; elim (Paire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Canc in |- *; intros E1 E2; elim (paire_IN E1 E2);\n auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nunfold Comp in |- *.\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => P x)).\nintros.\nelim (A_ind (fun x : A => x = x :>A) (fun x : A => PDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Comp_prop _ _ _ (fun x => P)).\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nunfold Comp in |- *; auto with algebra.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\napply (Build_Map (Ap:=fun x : A => x) (fun x : A => P (f x)) (fun x : A => P (f x))).\nexact (Build_Map (Ap:=fun x : A => P (f x)) (fun x : A => P (f x))).\nexact (Build_Map (Ap:=fun x : A => P (f x))).\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* This is the following definition of the same as a given set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set *)\n(* M is a given set of the set of the set of the set of the set of the set of the set of the set set of *)\n(* M is the set of set of the set set of the set set of the set of the set set of the set set of the set *)\n(* set of set of set of set set set set of set set *)\n\nDefinition set_set (A B : Ens) := Equal A B /\\ Equal B A.\n\nDefinition set_set_set (A : Ens) (P : A -> Prop) := Equal A P.\n\nLemma set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_setDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* We define the composition of the composition of the identity *)\n\nDefinition Comp : Ens -> Prop := forall x : Ens, P x.\n\nDefinition Comp_proj (A B : Ens) (P : A -> Prop) (g : Comp_proj A B) : Prop :=\n  forall x : Ens, Comp_proj A P x.\n\nDefinition Comp_proj (A B : Ens) (P : A -> Prop) : Prop :=\n  forall x : Ens, Comp_proj A P x.\n\nDefinition Comp_proj (A B : Ens) (P : A -> Prop) (g : Comp_proj A B) :=\n  forall x : Ens, Comp_proj A P g x -> Comp_proj A P g x.\n\nDefinition Comp_proj (A B : Ens) (P : A -> Prop) (g : Comp_proj A B) : Prop :=\n  forall x : Ens, Comp_proj A P g x -> Comp_proj A P g x.\n\nDefinition Comp_proj (A B : Ens) (P : A -> Prop) :=\n  forall x : Ens, Comp_proj A P g x -> Comp_proj A P g x.Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* The \"un ensemble\" and set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set of the set\n  set of set of the set set of the set set of the set of the set of the set of the set of the set\n  set set of set set set of the set of the set set of the set of the set set of the set of the set\n  set set of set set of the set set of the set of the set of the set set of the set set\n  set set of set set of the set set of the set of the set set set of the set\n  set of set of set of set set of the set set of the set of the set of the set set.\n*)\n\nDefinition set_set_set (A : Type) (P : A -> Prop) (a : A) :=\n  forallDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P.\nelim (classic (exists e : A, P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e))\n  with (P := fun x : A => ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ P e /\\ ~ PDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; elim H; intros x H; elim H; intros H; elim H; intros H0 H1; elim H0; intros H1 H2; elim H1;\n intros H2 H3; elim H3; intros H4; elim H4; intros H5 H5 H5;\n elim H4; intros H5 H5 H6; elim H6; intros H6 H7; elim H7;\n intros H8 H8 H9; elim H8; intros H10 H10; elim H8;\n intros H9 H10 H11; elim H9; intros H10 H11 H12; elim H12; intros H11 H11 H12;\n elim H10; intros H11 H12 H12; elim H12; intros H12 H12 H13;\n elim H12; intros H12 H13 H13 H14; elim H14; intros H13 H14 H15;\n elim H15; intros H15 H15 H16 H16 H16 H17;\n elim H17; intros H17 H18 H20; elim H17; intros H19 H20; elim H18;\n intros H18 H20; elim HDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintro x.\nintro x.\nelim x; intros.\nred in |- *; intro; subst; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.\nred in |- *; intro; apply H; assumption.Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; simpl in |- *; unfold inv in |- *; intros A f fr P.\nelim (H (f x)); auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E F P.\nelim (g (fun x => P (f x))).\nintros x p; exact (f x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; unfold Comp in |- *; simpl in |- *; intros; elim A f; intros x p; exact (f x p).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; simpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp, Comp, Comp, Comp in |- *; simpl in |- *; intros; apply Comp_INC with (f:=f) (g:=f) (g:=g) (g:=f) (h:=g) (h:=g) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h)Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfoldComp in |- *; intros E; elim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E P); intros A f fr P.\nelim (Comp_INC E PQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E F H; elim (H E F); intros A f fr P.\nexact (f x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; simpl in |- *; intros; elim A f fr P.\nintros x p H; exact (f x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Comp,Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A B' H'0; elim H'0; intros H'1; elim H'1; intros H'2; clear H'1;\n elim H'0; intros H'2; elim H'0; intros H'3; elim H'2; intros H'4; clear H'0;\n elim H'0; intros H'4; elim H'0; intros H'5; elim H'0; intros H'6; \n clear H'0; elim H'0; intros H'7; elim H'8; intros H'8; clear H'0;\n elim H'0; intros H'8; elim H'8; intros H'9; clear H'0;\n elim H'0; intros H'8; elim H'9; intros H'9; elim H'9; intros H'9; clear H'0;\n elim H'9; intros H'10 H'10; elim H'9; intros H'10; elim H'10; intros H'11; \n clear H'0; elim H'10; intros H'10; elim H'10; intros H'11; \nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A B B' H'0.\napply Trans with (b := b); auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A B B' H'0; case (Rtotal_order A B').\nintros A' B' H'1; case (Rtotal_order A' B').\nintros A' B' H'2; case (Rtotal_order A' B').\nintros A' B' H'3; case (Rtotal_order A B').\nintros A' B' H'4; case (Rtotal_order A' B').\nintros A' B' H'5; case (Rtotal_order A' B').\nintros A' B' H'5; case (Rtotal_order A' B').\nintros A' B' H'6; case (Rtotal_order A B').\nintros A' B' H'7; case (Rtotal_order A B').\nintros A' B' H'8; case (Rtotal_order A' B').\nintros A' B' H'8; case (Rtotal_order A B').\nintros A' B' H'8; case (Rtotal_order A B').\nintros A' B' H'8; case (Rtotal_order A' B').\nintros A' B' H'8; case (Rtotal_orderQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B' H'0; try assumption.\nelim (Couple_not_empty A B A' B' H'0); intros H'1 H'2.\nelim (Couple_not_empty B B' B' H'0); intros H'2.\nelim (Couple_not_empty B' A' B' H'2); intros H'3.\nelim (Couple_not_empty B' B' B' H'3); intros H'5.\nelim (Couple_not_empty B' B' A' H'0); intros H'6.\nelim H'7; intros H'6.\nelim (Couple_not_empty B' B' B' H'0); intros H'7.\nelim H'8; intros H'8 H'9; elim H'8; intros H'10 H'11.\nelim H'8; intros H'11 H'12.\nelim (Couple_not_empty B' B' B' H'0); intros H'8.\nelim H'8; intros H'8 H'9; elim H'8; intros H'9 H'9;Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B' H'0; apply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'; auto.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'; auto.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles; exists A'; auto.\napply Extensionality_Ensembles; exists A'.\napply Extensionality_Ensembles;Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B' H'0; elim H'0; intros H'1 H'2;\n [ apply H'2; exists B; split; [ idtac | apply H'1; exists B; split; auto ].\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A B' H'; elim H'.\nintros A B' H'0; elim H'.\nintros A B' H'1; elim H'.\nintros A B' H'2; elim H'.\nintros A B' H'3; elim H'3; intros A'4 H'5; exists A'; split; auto.\nintros A B' H'5; elim H'5; intros A'6 H'7; exists A'; split; auto.\nintros A B' H'6; elim H'6; intros A'7 H'8; exists A'; split; auto.\nintros A B' H'7; elim H'7; intros A'7 H'8; exists A'; split; auto.\nintros A' B' H'7; elim H'7; intros A'7 H'8; exists A'; split; auto.\nintros A' B' H'8; elim H'8; intros A'8 H'9; exists A'; split; auto.\nintros A B' H'8; elim H'9; intros A'9 H'10; exists A'; split; auto.\nintros A'Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof fun A B' B' : Ens =>\n (_, <- (Couple A B) (Couple B B') (Couple B B') -> EQ A B').\n\nTheorem Couple_inj_left : forall A B A' B' : Ens, EQ A B' -> EQ A' B' -> EQ A B'.\nProof fun A B A' B' : Ens =>\n (_, (Couple A B) (Couple B A') (Couple B B') -> EQ A B').\n\nTheorem Couple_inj_left : forall A B A' B' : Ens, EQ A B' -> EQ B A'.\nProof fun A B A' B' : Ens =>\n (_, (Couple A B) (Couple A B B') -> EQ A B').\n\nTheorem Couple_inj : forall A B A' B' : Ens, EQ A A' B' -> EQ A B'.\nProof fun A B A' B' : Ens =>\n (_, (Couple A B) (Couple B A') (Couple B B') -> EQ A' B').\n\nTheorem Couple_inj_left : forall A B A' B' : Ens, EQ A B' -> EQ A A' B'.\nProof funQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A B A' B' H'0; case (NoEq_a _ H'0).\nexact (Couple_of_Couple_neg A B B'); auto.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof\n  fun (E E' : Ens) (E' : Ens) (E' : Ens) (E' : Ens) (E' : Ens) (E'' : Ens) =>\n  Build_EQ A A' B' -> EQ B' E'' -> EQ A B'' E''.\nProof\n  fun (E E' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) =>\n  Build_EQ A A B' E'' -> EQ A B'' E'' -> EQ A B''.\nProof\n  fun (E E' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) =>\n  Build_EQ A B E'' E'' -> EQ A B'' E''.\nProof\n  fun (E E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) (E'' : Ens) =>\n  Build_EQ A B E'' E'' -> EQ A B'' E'' -> EQ A B''.\nProof\n  fun (E E'' : Ens)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *.\nintros A A' B' H'0; elim H'0; intros H'1 H'2;\n elim H'0; intros H'3 H'4; elim H'3; intros H'5 H'7;\n elim H'4; intros H'7 H'7; elim H'7; intros H'8 H'8 H'9;\n elim H'8; intros H'9 H'10; elim H'9; intros H'9 H'10;\n elim H'9; intros H'9 H'10; elim H'10; intros H'11 H'12;\n elim H'9; intros H'11 H'12; elim H'9; intros H'12 H'13;\n elim H'10; intros H'11 H'12; elim H'12; intros H'12 H'13; elim H'12; intros H'13 H'13;\n elim H'14; intros H'13 H'14; elim H'14; intros H'14 H'15;\n elim H'14; intros H'14 H'14; elim H'15; intros HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Setminus in |- *; simpl in |- *; intros A A' B' H'0; elim H'0;\n intros H'1 H'2; elim H'0; intros H'3 H'4;\n elim H'0; intros H'5 H'6 H'7;\n elim H'0; intros H'6 H'7; elim H'0; intros H'7 H'8;\n elim H'0; intros H'8 H'9; elim H'8; intros H'9 H'9;\n elim H'9; intros H'9 H'10; elim H'9; intros H'9 H'10;\n elim H'9; intros H'9 H'10; elim H'9; intros H'10 H'11;\n elim H'9; intros H'10 H'10; elim H'9; intros H'11 H'12;\n elim H'9; intros H'11 H'12; elim H'9; intros H'11 H'12;\n elim H'9; intros H'11 H'13; elim H'9; intros H'12 H'13;\n elim HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros A' B' H0; elim H0; simpl in |- *; intros H1 H2;\n elim H1; simpl in |- *; intros H1 H2; elim H2;\n simpl in |- *; intros H2 H2; elim H2; simpl in |- *; intros H2 H3;\n elim H2; simpl in |- *; intros H3 H4; elim H3;\n simpl in |- *; intros H4 H5; elim H2; simpl in |- *; intros H5 H6;\n elim H2; simpl in |- *; intros H6 H6; elim H2; simpl in |- *;\n intros H6 H7; elim H7; simpl in |- *; intros H8 H8; elim H8; simpl in |- *;\n intros H8 H9; elim H9; simpl in |- *; intros H9 H9; elim H9;\n simpl in |- *; intros H10 H10; elim H9; simpl in |- *;\n intros H11 H11 H12; elim H12; simpl in |- *; intros H13 H13;\n elim H12; simpl in |- *; intros HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros A' B' B' H'0; elim H'0; intros H'1 H'2;\n elim H'0; intros H'3 H'4; elim H'0; intros H'4 H'5;\n elim H'0; intros H'5 H'6; elim H'6; intros H'6 H'7;\n elim H'0; intros H'7 H'8; elim H'8; intros H'9 H'9 H'9;\n elim H'9; intros H'8 H'9; elim H'9; intros H'9 H'10; elim H'9;\n intros H'10 H'11 H'12; elim H'9; intros H'11 H'12; elim H'9; intros H'11 H'12;\n elim H'9; intros H'11 H'12; elim H'9; intros H'13 H'13;\n elim H'13; intros H'13 H'14; elim H'14; intros H'15 H'14;\n elim H'14; intros HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros.\nabsurd (EQ (Couple A B') (Couple B B') (Couple B B') -> EQ A B').\nsimpl in |- *.\nsimple induction 1.\nintros.\nabsurd (EQ A B') in |- *.\nintros.\ncut (EQ A B') B' \\/ EQ A' B').\nsimpl in |- *.\nsimple induction 1.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ A B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ A' B') in |- *.\nintros.\nabsurd (EQ A B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B') in |- *.\nintros.\nabsurd (EQ B' B')Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros A B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\nintros A' H'; elim H'; auto with zfc.\nintros A' B' H'; elim H'; auto with zfc.\n\nintros A' H'; elim H'; auto with zfc.\n\nintros A' H'; elim H'; auto with zfc.\nintros A' H'; elim H'; auto with zfc.\n\nintros A' H'; elim H'; auto with zfc.\nintros A' H'; elim H'; auto withQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros A A' B' H; elim (H A' B); simpl in |- *; intros H0;\n elim (H0 A' B'); simpl in |- *; intros H1;\n elim (H0 A' B'); simpl in |- *; intros H1;\n elim H1; intros H2; elim H2; intros H3;\n elim H3; intros H4; elim H4; intros H5 H6;\n elim H5; intros H5 H6; elim H6; intros H6 H7;\n elim H7; intros H8 H8; elim H9; intros H10 H11; elim H8;\n intros H10 H11 H12; elim H10; intros H11 H12; elim H12; intros H12 H13;\n elim H11; intros H12 H13; elim H12; intros H13 H14;\n elim H14; intros H13 H13 H14; elim H14; intros H15 H14 H14 H15;\n elim H14; intros H15 H16 H17; elim H16; intros H15 H16 H18Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros x0; elim x0; simpl in |- *; simple induction 1; intros H3 H4;\n elim H4; simpl in |- *; intros H4 H5; elim H5; intros H6;\n elim H5; intros H6 H7; elim H7; intros H8 H9 H10;\n elim H7; intros H8 H9 H10; elim H8; intros H9 H10 H11;\n elim H8; intros H10 H11 H11; elim H8; intros H11 H12; elim H8;\n intros H12 H13 H13 H14 H14 H14 H14 H14 H14 H15 H16 H17 H18 H18 H19 H20 H20 H20 H20 H21 H21 H22 H22 H23 H23 H22 H25 H23 H24 H24 H25 H25 H25 H25 H25 H26 H25 H27 H26 H26 H26 H27 H26 H26 H29 H28 H26 H29 H29 H29 H30 H29 H30 H30 H31 H31 H31 HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros B' H'; elim (H' x); simpl in |- *.\nintros x0 H'0; elim H'0; simpl in |- *.\nsimple induction x0.\nsimple induction x0.\nintros.\nrewrite H'0.\nunfold In in |- *.\nsimple induction x0.\napply EQ_reflexive.\nintros; elim H'0; simpl in |- *.\nsimple induction x0.\nintros.\ncut (EQ (singleton A') (singleton B) (singleton B')) -> EQ A' B').\nsimpl in |- *.\nsimple induction x0.\nintros.\nelim H'0; simpl in |- *.\nintros.\ncut (EQ A' (singleton B) (singleton B') (singleton B'))).\nsimpl in |- *.\nsimple induction x0.\nauto with zfc.\n\nintros.\ncut (EQ A' (singleton B') (singleton B') (singleton B')).\nsimpl in |- *.\nsimple induction x0.\nauto with zfc.\n\nintros; elim H'0; simpl in |- *.\nsimple induction x0.\nauto with zfc.\n\nintrosQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros A A' B' H H0; elim H0; intros H1 H2; elim H2; intros H2 H3;\n elim H1; intros H3 H4; elim H3; intros H5 H5 H6;\n elim H4; intros H5 H6 H7; elim H6; intros H7 H7 H8;\n elim H8; intros H9 H10; elim H8; intros H10 H11 H10;\n elim H9; intros H10 H11; elim H10; intros H11 H12 H12; elim H10;\n intros H11 H12 H12; elim H12; intros H12 H13 H13 H14 H14 H14 H15 H16 H17 H17 H18 H18 H19 H19 H19 H20 H21 H21 H22 H22 H21 H22 H22 H21 H22 H22 H22 H22 H23 H22 H23 H24 H24 H25 H25 H26 H26 H27 H27 H27 H27 H29 H29 H29 H29 H30 H29 H31 H31Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A B H.\napply (H (H (H (H (H (H (H (H (H (H H)))) (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H H)))) (H (H (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H H)))) (H (H (H (H (H (H H)))) (H (H (H (H (H (H (H H)))) (H (H (H (H (HQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold inter in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros a0 b0 H2.\napply H1.\napply H2.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H3.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H4.\napply H5.\napply H.\napply H4.\napply H4.\napply H.\napply H4.\napply H.\napply H4.\napply H4.\napply H.\napply H4.\napply H5.\napply H4.\napply H.\napply H4.\napply H.Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ,Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold not in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2; elim H2.\nintros a' H3; elim H3; intros H4; elim H4;\n intros H5; elim H5; intros H6; elim H6;\n intros H6 H7; elim H7; intros H7; elim H7; intros H8; elim H7;\n intros H7 H8; elim H7; intros H9; elim H9;\n intros H8 H9; elim H9; intros H10 H10; elim H10;\n intros H10 H11; elim H11; intros H10 H11; elim H12; intros H12 H13;\n elim H11; intros H12 H12; elim H12; intros H12 H13; elim H13;\n intros H13 H14; elim H14; intros H14 H15; elim H15; intros H15 H17;\n elim H18; intros H16 H18; elim H18; intros H17 H18;\n elim H18; intros H18 H18; elim H18; intros H18 H18;\n elim H18; intros HQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nunfold Add in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\napply H with x0; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *.\nsimple induction 1.\napply (H (Couple A B') (Couple A' B') (Couple A' B') (Couple A' B') B')\n with (Couple A B' (Couple A' B') (Couple A' B') (Couple B' B') (Couple A' B')\n end.\n\nHint Resolve Couple_sound_right: zfc.\n\n\nTheorem Couple_inv : forall A B A' B' : Ens, EQ A A' -> EQ A A' B'.\nunfold EQ in |- *.\nsimple induction 1.\napply (H (Couple A' B') (Couple A' B' B') (Couple A' B' B')\n with (Couple A' B' (Couple B' B' B') (Couple A' B')\n (Couple B B' A') (Couple A' B') (Couple A' B')\n end.\n\nHint Resolve Couple_inv_right: zfc.\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n(****************************************************************************)\n\n(****************************************************************************)\n(*                                                                          *)\n(*              Formal Language Theory                                      *)\n(*                                                                          *)\n(*              Judicael Courant - Jean-Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2; elim H2;\n intros H3; elim H3; clear H3.\napply H3; assumption.\napply H1; assumption.\napply H1; assumption.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim H2; intros H3.\napply H3; apply EQ_trans with (a := b); auto with zfc.\n\napply EQ_trans with (a := b); auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros b H1; elim (H2 false).\nintros b H2; elim (H2 false).\nintros b H2; elim (H1 false).\nintros b H3; elim (H4 false).\nintros b H4; elim (H4 false).\nintros b H5; elim (H2 false).\nintros b H4; elim (H4 false).\nintros b H5; elim (H5 false).\nintros b H6; elim (H5 false).\nintros b H6; elim (H6 false).\nintros b H7; elim (H7 false).\nintros b H8; elim (H7 false).\nintros b H8; elim (H7 false).\nintros b H9; elim (H8 false).\nintros b H8; elim (H8 false).\nintros b H9; elim (H9 false).\nintros b H8; elim (H8 false).\nintros b H9; elim (H8 false).\nintros b H9; elim (H9 false).Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold EQ in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\napply EQ_trans with A'; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Add in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r2; simple induction E2; intros A2 f2 r3.\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e0; simpl in |- *.\nelim (IN_EXType (sup A2 f3) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A2 f3) E2').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A2 f3) E1').\nintros x e0; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x e0; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e; simpl in |- *.\nelim (IN_EXType (Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A2 f1 r2; simple induction E2; intros A3 f3 r3.\nintros E1 f2 r3; elim E1; intros A3 f4 r5; apply A4;\n clear E1 E2 E3 E3 F4.\nelim E1; intros A4 f5 r6; simpl in |- *.\nexists (pair_t _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nsplit.\nsimple induction x3.\n\nsimple induction x2; simpl in |- *.\nexists (pair_t _ x2).\napply A4.\napply A4.\napply A4.\napply A4.\napply A4.\nassumption.\n\napply A5.\nassumption.\napply A4.\nassumption.\n\napply A4.\nassumption.\nassumption.\napply A4.\nassumption.\nassumption.\napply A4.\nassumption.\nassumption.\napply A4.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1'; intros A1 f1 r2; simple induction E2; intros A2 f2 r2;\n [ idtac | exists x; auto with zfc ].\nelim (IN_EXType (sup A1 f2) E1').\nintros x0 e0; simpl in |- *.\nelim (IN_EXType (sup A2 f1) E2').\nintros x0 e0; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E1).\nintros x0 e1; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E1).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E1).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E2).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A2 f) E1).\nintros x1 e; simpl in |- *.Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1'; intros A1 f1 f2; simple induction E2; intros A3 f3;\n [ intros A3 f4 f5; intros A4 f5; intros A5 f5;\n elim A5; intros A6 f6; intros A7 A8;\n elim A7; intros A7 A8; elim A8; intros A8; elim A8; intros A8; elim A8;\n intros A9; elim A9; intros A8; elim A9; intros A9; elim A9;\n intros A9; elim A9; intros A9; elim A9; intros A10; elim A9;\n intros A9; elim A9; intros A9; elim A9; intros A9; elim A9;\n intros A10; elim A9; intros A9; elim A9; intros A10; elim A9;\n intros A10; elim A10; intros A10; elim A10; intros A10; elim A10;\n intros A10; elim A10; intros A10; elim A10; intros A10; elim A10;\n intros A10; elim A10; intros AQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A2 f1 r2; simple induction E2; intros A3 f2 r3.\nintros E1 E2' i1.\nelim (IN_EXType (sup A1 f2) E1').\nintros x0 e0; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e; simpl in |- *.\napply IN_sound_left with (Couple (pi2 (sup A1 f2) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\n\napply EQ_Assn with (Couple (pi2 (sup A1 f2) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\n\napply EQ_sym.\n\napply EQ_sym.\napply EQ_sym.\napply EQ_sym.\nassumption.\napply EQ_sym.\napply EQ_sym.\nassumption.\napply EQ_sym.\nassumption.\napply EQ_sym.\nassumption.\nassumption.\nassumption.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1 E2' E1'2' i1.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e; simpl in |- *.\nsplit.\nsimple induction x0.\nintros y0 y0; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x0 e0; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup AQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r2; simple induction E2;\n intros A2 f2 r1 r2; simple induction E2; simpl in |- *; intros;\n auto with zfc.\n\nintros E1 E2' E2' i1.\nelim (IN_EXType (sup A2 f2) E2').\nintros x e; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists (Prod E1' x2); simpl in |- *.\nsplit.\nauto with zfc.\n\nsimple induction x1; simpl in |- *.\nexists (Prod E1' x1); simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e; simpl in |- *.\nexists x1; simpl in |- *.\nsplit.\nsimple induction x2.\n\nexists (Prod E1' x2); simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nauto with zfc.\n\nelim (IN_EXType (sup A2 f2) E1').\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 f2; simple induction E2;\n intros A2 f1 f2; simple induction E3; simpl in |- *;\n intros A2 f2 f3; simple induction E4; simpl in |- *;\n intros A3 f4 v0 H1; simpl in |- *; apply EQ_trans with (App f1 f2) (App f1 f2) (App f2 f3) x0);\n auto with zfc.\n\nelim\n (axs_comprehension\n    (fun c : E =>\n      match c with\n      | couple (App f1 f2) (App f2 f3) (App f2 f3) (App f3 f4) (App f2 f4) x0)); \n auto with zfc.\n\nelim\n (axs_comprehension\n    (fun c : E =>\n     match c with\n      | couple (App f1 f2) (App f2 f3) (App f3 f4) (App f3 f4) (App f4 f4) x0)); \n auto with zfc.\n\nelim\n (axs_comprehension\n    (fun c : E =>\n     match c with\n      | coupleQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r2; simple induction E2; intros A2 f2 r3.\nintros x0 e1; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1').\nintros x0 e0; simpl in |- *.\nelim (IN_EXType (sup A2 f1) E1').\nintros x1 e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E1).\nintros x1 e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2).\nintros x0 e; simpl in |- *.\nelim (IN_EXType (sup A1 f2) E2).\nintros x1 e; simpl in |- *.\nelim (IN_EXType (sup A2 f2) E2).\nintros x1 e; simpl in |- *.\nelimQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;\n simple induction E2; simpl in |- *.\nexists (union E1 E2') (union E2 E3').\nunfold union in |- *; simpl in |- *.\nexists (union E1 E2') (union E2 E3').\nexists (union E2 E3').\nsimpl in |- *.\nsplit.\nsimple induction x1.\nauto with zfc.\n\nsimple induction x1.\nauto with zfc.\n\nsimple induction x1.\n\nsimple induction x1; simpl in |- *.\nexists true; auto with zfc.\n\nintros x1 e2; simpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nintros.\nexists (union E2 E3').\nauto with zfc.\n\n\nsplit.\nsimple induction x2.\nauto with zfc.\n\n\nsimple induction x2; simpl in |- *.\nexists (union E2 E3').\nauto with zfc.\n\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E'' H'0; elim H'0; clear H'0.\nintros E'' H'1 H'2; elim H'0; clear H'0.\nintros E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E''.\nelim H'0; clear H'0; intros E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E''.\nelim H'0; clear H'0.\nintros E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E''.\nelim H'0; clear H'0.\nintros E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' E'' EQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E'' E'' F'' H'0.\nelim (IN_EXType (Prod E' E'' F''); intros A1 A2 E2.\nelim (IN_EXType (Prod E' E'' F''); intros A2 E2.\nelim (IN_EXType (Prod E'' F''); intros A2 E3.\nelim (IN_EXType (Prod E' E'' F''); intros A3 E3.\nelim (IN_EXType (Prod E'' F''); intros A3 E4.\nelim (IN_EXType (Prod E'' E'' F''); intros A3 E5.\nelim (IN_EXType (Prod E'' F''); intros A3 E4 E4.\nelim (IN_EXType (Prod E'' F''); intros A4 E5 E6.\nelim (IN_EXType (Prod E'' F''); intros A4 E6.\nelim (IN_EXType (Prod E'' F''); intros A6 E5.\nelim (IN_EXType (Prod E'' F''); intros A5 E6.\nelim (IN_EXType (Prod E'' F''); intros A6 E6.Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E' H'0 H'1.\nelim (IN_EXType (E' : Ens) (fun x : Ens => EXType _ (fun B : Ens => IN (Couple A B) E''))\n    (fun (x : Ens) (y : (A * B)) =>\n     exists y : (A * B) (fun B : Ens => IN (Couple A B) (fun B : Ens => IN (Couple A B) (fun B : Ens => IN (Couple A B) B)))\n    (fun x : Ens =>\n     exists y : (A * B) (fun B : Ens => IN (Couple A B) (fun B : Ens => IN (Couple B A) B) (fun B : Ens => IN (Couple A B) B)))\n    (fun x : Ens =>\n     exists y : (A * B) (fun B : Ens => IN (Couple A B) (fun B : Ens => IN (Couple A B) (fun B : Ens => IN (Couple B) B)))\n    (fun x : Ens =>\n     exists y : (A * B) (fun B : Ens => IN (Couple A B) (fun B : Ens =>Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E' H'0; unfold IN in |- *; apply Singleton_is_empty; auto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E' H'0; elim H'0; intros A B E E E'0;\n elim H'0; intros A E E E E'0; elim H'0; clear H'0; intros A E E0 E0;\n elim H'0; intros A E E E E0 E0; elim E0; clear E0; intros A E0 E1 E1 E1;\n elim E0; intros A E E0 E1 E1 E2; elim E0; clear E0; intros A E1 E2 E2 E2;\n elim E0; intros A E E0 E1 E1 E2; elim E0; clear E0; intros A E1 E2 E3;\n elim E0; intros A E E0 E2 E3; elim E0; clear E0; intros A E1 E3 E4;\n elim E0; intros A E0 E1 E2 E2; elim E0; clear E0; intros A E1 E2 E3 E4;\n elim E0; intros A E E1 E3 E3 E4; elim E0; clear E0; intros AQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E'' E'' H0; generalize (IN_EXType (fun A : Ens => exists B : Ens, EQ (Couple A B) E'')).\nintros E E'' E'' H1 H2; generalize (IN_EXType (Singleton A) E'' H2);\n intros G0 H2; generalize (IN_EXType (Singleton A) E'' H3);\n intros G1 H3; generalize (IN_EXType (Singleton A) E'' H3);\n intros G1 H4; generalize (IN_EXType (Singleton A) E'' H4);\n intros G2 H5; generalize (IN_EXType (Singleton A) E'' H6);\n intros G2 H5; generalize (IN_EXType (Singleton A) E'' H6);\n intros G2 H6; generalize (IN_EXType (Singleton A) E'' H7);\n intros G2 H6; generalize (IN_EXType (Singleton A) E'' H7);\n intros G2 H7; generalize (IN_Type (Singleton A) E'' H8);\n intros G2 H8; generalize (IN_EXType (Singleton A) EQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E'' E'' H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'0.\napply Extensionality_Ensembles.\nsplit.\napply H'.\napply Extensionality_Ensembles.\nsplit.\napply H'.\napply Extensionality_Ensembles.\napply HQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E' E'' E'' F' H'0 H'1 H'2; try assumption.\napply Singleton_is_empty.\nexact (Singleton_is_empty E''); auto with zfc.\n\nsimpl in |- *.\napply Singleton_is_empty.\nexact (Singleton_is_empty E''); auto with zfc.\n\nsimpl in |- *.\nunfold Empty in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nelim (IN_EXType (sup A) (sup A) (sup A) (sup A)); intros a1 a2 e.\nelim H'0; intros a2 e1.\nrewrite <- H'1.\napply Singleton_is_empty.\nexact (Singleton_is_empty E''); auto with zfc.\n\nsimpl in |- *.\nelim (IN_EXType (sup A) (sup A) (sup A))); intros a1 e2 e2.\nelim H'0; intros a2 e3.\nrewrite <- H'1.\napply Singleton_is_empty.\nexact (Singleton_is_empty E''); auto with zfc.\n\n\nsimpl in |- *.\nelim (INQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E'' E'' F' H'0 H'1 H'2 H'3 H'4 H'5.\nelim H'0; clear H'0; intros A E' H'0 H'1 H'2; elim H'2; clear H'1;\n intros A E'0 H'1 H'2; elim H'1; clear H'1; intros A E'0 H'2 H'3;\n elim H'1; clear H'1; intros A E'0 H'1; elim H'1; clear H'1; intros A E'0 H'2;\n elim H'2; clear H'2; intros A E'1 H'2; elim H'2; clear H'1; intros A E'0 H'2 H'3;\n elim H'2; clear H'2; intros A E' E0 H'2; elim H'2; clear H'2; intros A E'0 H'1;\n elim E'0; clear H'2; intros A E' E0 H'2; elim H'2; clear H'1; intros A E0 HQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E E E' H'0 H'1; clear H'0 H'1; intros A0 H'1; clear H'0;\n intros A0 H'1 H'2; clear A1 H'1; intros A2 H'2 H'3; clear A1 H'1;\n intros A0 H'1 H'2; clear A1 H'2; clear A1 H'1;\n intros A0 H'1 H'2; clear A0 H'2; intros A0 H'1; clear A1 H'1;\n clear A0 H'1; intros A1 H'2 H'2; clear A0 H'1;\n intros A1 H'1 H'2; clear A0 H'1; intros A2 H'2; clear A1 H'2;\n clear A0 H'1; intros A1 H'1; clear A1 H'1;\n elim (IN_EXType (sup A0 f1) (sup A0 f1) (sup A1 f2) (sup A1 f2));\n auto with zfc.\n\napply Singleton_is_empty_right with (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\nProof fun A B C D : Ens =>\n  forall x : Ens, B x -> Equal (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (EQC x) (Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof\n  fun (A B : Ens) (f : A -> B) =>\n  forall (x : A), f (f x) = f x.\n\nTheorem EQC : forall (A B : Ens) (f : A -> B), EQC A B -> EQC A B.\nProof\n  fun (A B : Ens) (f : A -> B) =>\n  forall (x : A), f (f x) = f x.\n\nTheorem EQC : forall (A B : Ens) (f : A -> B), EQC A B.\nProof\n  fun (A B : Ens) (f : A -> B) =>\n  forall (x : A) (y : A), f (f x) = f x.\n\nTheorem EQC : forall (A B : Ens) (f : A -> B), EQ_C A B.\nProof\n  fun (A B : Ens) (f : A -> B) =>\n  forall (x : A) (y : B), EQ_C A B f -> EQ_C A B f.\n\nTheorem EQC : forall (A B : Ens) (f : A -> B), EQ_C ADefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof.\n\nDefinition EQC : Ens -> Ens -> Prop :=\n  forall x y : Ens, x = y -> EQC x y.\n\nDefinition EQC : Ens -> Ens -> Prop :=\n  forall x y : Ens, EQC x y -> EQC x y.\n\nRecord EQC (D : Ens -> Prop) :=\n  EQC : Ens -> Ens -> Prop;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQC D;\n  EQC : EQDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof\n  fun (A : Ens) (B : Ens) (c : EQ (C := A)) =>\n  fun (A : Ens) (c : EQ A B) =>\n  fun (c : EQ (C := A)) (c : EQ (C := A)) (c : EQ C) =>\n  fun (c : EQ (C := A)) (c : EQ C) =>\n  fun (c : EQ (C := A)) (c : EQ C) =>\n  fun (c : EQ (C := A)) (c : EQ C) =>\n  fun (c : EQ (C := C) (c : EQ (C := B)) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ (C := c)) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ C) =>\n  fun (c : EQ C) (c : EQ C) =>\n  fun (c : EQ C) (cDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof Build_Extensionality.\n\nSection SUBC.\n\nVariable C : Ens.\nVariable A B C : Ens.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\nHypothesis B : C.\n\nLet step1 : SUB C B.\nProof EQ_symm C B.\n\nLet step2 : SUB C B.\nProof EQ_symm C B.\n\nLet step3 : SUB C B.\nProof EQ_symm C B.\n\nLet step4 : SUB C B.\nProof EQ_symm C B.\n\nLet step5 : SUB C B.\nProof EQ_symm C B.\n\nLet step5 : SUB C B.\nProof SUB_trans C B.\n\nLet step5 : SUB C B.\nProof EQ_symm C B.\n\nLet step6 : SUB C B.\nProof EQ_symm C B.\n\nLet step6 : SUB C B.\nProof EQ_trans C B.\n\nLet step6 : SUB C B.\nProof EQ_symm C B.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof Build_middle (C :=\n  Build_middle (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Type :=\n  Build_middle (C := Set).\n\nDefinition EQC : Ens -> Ens -> Type :=\n  Build_middle (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Ens -> Ens :=\n  Build_middle (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Ens -> Ens :=\n  Build_middle (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Ens -> Prop :=\n  Build_middle (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Ens -> Prop :=\n  Build_middle (C := Set) (C := Set) (C := Set).\n\nDefinition EQC : Ens -> Ens -> Ens :=\n  Build_middle (C := Set) (C := Set).\n\nRecord EQC : Ens -> Ens -> Ens -> Prop :=\n  Build_EQC : Ens -> Prop;\n  Build_EQC : Ens -> Prop;\n  Build_EQC : Ens -> Prop;\n  Build_EQD : Ens -> Prop;Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof\n  fun (X : Ens) (P : Ens -> Prop) (u : P X) =>\n  (forall X : Ens, P X -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop) ->\n  (forall Y : Ens, P Y -> Prop)Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof\n  fun (A : Ens) (x y : A) =>\n  forall (y : B) (y : B),\n  Equal A y -> Equal B y -> Equal y y.\n\nRecord group_set : Ens -> Type :=\n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_set_is_a_relation : Ens -> Type := \n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_is_a_relation : Ens -> Type := \n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_is_a_relation : Ens -> Type := \n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_is_a_relation : Ens -> Type := \n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_is_a_relation : Ens -> Type := \n  { group_set :> Type; group_set :> group_set}.\n\nRecord group_set_is_a_relation : Ens -> Type := \n  { group_Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition eq_refl : Prop := eq_refl_equal_eq_refl.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_sym_Out : Prop := eq_refl_Out.\n\nDefinition eq_sym_Out : Prop := eq_trans_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_refl_Out : Prop := eq_refl_Out.\n\nDefinition eq_trans_Out : Prop := eq_trans_Out.\n\nDefinition eq_trans_Out : Prop := eq_refl_OutDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintros.\nunfold EQC.\nexact (eq_sym (EQC H)).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B f eq1 f eq2.\nsimple induction 1; intros A f eq1.\nexact (fun x : A => eq1 x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nintros B f eq1 f2.\nintro eq2.\napply eq1.\nexact (fun x : A => f1 x = f2 x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B h eq1.\nexact (proj1 A).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros A f eq1.\nexact (forall x : A, f (g y) = f x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A B f eq1.\nexact (forall x : A, B x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq1.\nexact (forall x : A, f x = f x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros; induction 1; intros A f eq1.\nexact (forall x : A, f x = f x) A.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintro F.\nsimple induction F.\nexact (fun A B f => (fun x : A => f x (g y)))).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintro F.\nelim F.\nexact (fun x : A => x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintro F.\nintros F.\napply (Build_Setoid (A:=B)).\nexact (Build_Setoid (A:=B)).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nexact (depprod _ (fun y : A => eq1 x (g y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\napply (Build_Setoid (Ap:=C)); assumption.\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros A B f eq1.\nsimple induction 1; intros A B f eq1.\nexact (fun x : A => f (f x)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ _ (fun y : A => EQC X (e y)))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (depprod _ (fun y : A => EQC X y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintro A.\napply (Build_Map (Ap:=CIN CIN A)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2.\nred in |- *.\nintros y H0 H1.\nelim H1; intros H2; [ intro H3; elim H4; intros H5; elim H5; intros H6; elim H6; intros H7; elim H7;\n intros H8; elim H8; intros H9; elim H8; intros H9; elim H9;\n intros H9; elim H10; intros H10; elim H10; intros H10 H11;\n elim H10; intros H11 H11; elim H11; intros H11 H12; elim H12;\n intros H12 H12; elim H12; intros H12 H13; elim H13; intros H13 H14;\n elim H12; intros H13 H14; elim H14; intros H14 H14 H14;\n elim H14; intros H13 H14 H14; elim H14; intros H14 H15;\n elim H14; intros H14 H14 H14; elim H14; intros H15 H16; elim H14; intros H14 H16;\n elim H14; intros H15 HDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E; case E; intros E; case E; intros E; case E; case E; trivial.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E F.\napply (fun E F => EQC_refl E F).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nexact (fun E : Ens => EQC E (e x)).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E F E F.\napply (fun E F => (fun x : Ens => EQC F (e x))).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E F E1 E2.\nexact (fun E F F F).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E H.\nexact (EQC_refl E).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E F.\nexact (fun E F F G H).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E.\napply (X Y); assumption.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E; elim (eq_refl_equal E).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E F G H0.\napply (CIN E).\napply (CIN E).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3; elim H; intros; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nunfold EQC in |- *.\nelim (eq_sym_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eqQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nred in |- *.\nsplit; intros.\napply H1.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H4.\napply H5.\napply H4.\napply H3.\napply H5.\napply H3.\napply H4.\napply H4.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H5.\napply H5.\napply H5.\napply H4.\napply H4.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H4.\napply H5.\napply H5.\napply H4.\napply H5.\napply H4.\napply H4.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napplyQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nunfold EQC in |- *.\nelim (INC_irrefl E1); intros A f H3.\nelim H3; intros A f H4.\nexists f; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nsimpl in |- *.\nsplit; intros.\nunfold EQC in |- *.\nintuition.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nsimpl in |- *.\nsplit; intros.\nelim H; intros.\nelim (H3 H1); intros.\nelim (H3 H3); intros.\nelim (H4 H5); intros.\nelim (H5 H6); intros.\nelim (H7 H7); intros.\nelim (H8 H9); intros.\nelim (H9 H9); intros.\nelim (H9 H10); intros.\nelim (H8 H9); intros.\nelim (H9 H10); intros.\nelim (H10 H10); intros.\nelim (H10 H10); intros.\nelim (H10 H11); intros.\nelim (H11 H11); intros.\nelim (H11 H12 H13); intros.\nelim (H12 H14); intros.\nelim (H12 H10 H11); intros.\nelim (H11 H12 H14); intros.\nelim (H12 H14); intros.\nelim (H13 H14 H14); intros.\nelim (H14 H14); intros.\nelim (H14 H15); intros.\nelim (Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction 1; intros A f HR.\nsimpl in |- *.\nsplit; intros; apply H0; assumption.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\nunfold EQC in |- *.\nelim\n (classic (exists e0 : Ens, (e0 = e1 /\\ e0 = e1 /\\ e1 = e2 /\\ e0 = e1)).\nintros E1 E2 E3.\nelim (classic (exists e1 : Ens, (e0 = e1 /\\ e1 = e2 /\\ e1 = e2)).\nintros e1 E3.\nelim (classic (exists e2 : Ens, (e = e1 /\\ e1 = e2 /\\ e2 = e3)).\nintros e2 E3.\nelim (classic (exists e3 : Ens, (e = e2 /\\ e3 = e4 /\\ e1 = e3)).\nintros e3 E4.\nelim (classic (exists e3 : Ens, (e = e3 /\\ e1 = e2 /\\ e2 = e3)).\nintros e4 E4.\nelim (classic (exists e4 : Ens, (e = e3 /\\ e4 = e4 /\\ e5 = e4)).\nintros e4 E5.\nelim (classic (exists e5 : Ens, (eQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction 1; intros; apply EQC_trans with E1; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a1 x); intros.\nelim (b0 x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a1 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (a2 x); intros.\nelim (b0 x); intros.\nelim (a1 x); intros.\nelim (a2 x); intros.\nelim (a1 x); intros.\nelim (a1 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b1 x); intros.\nelim (b1 x); intros.\nelim (Qed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; intros.\nelim X2; intros.\nelim (X3 y); intros.\nexists x1.\napply X3 with (e0 x0); auto with zfc.\nelim (b0 x); intros.\nexists x1.\napply X3 with (e0 x0); auto with zfc.\nelim (b0 x); intros.\nexists x1.\napply X3 with (e0 x0); auto with zfc.\nelim (b0 x); intros.\nelim (X4 y); intros.\nexists x1.\napply X3 with (e0 x); auto with zfc.\n\nelim (X4 y0); intros.\nelim (X4 y); intros.\nexists x1.\napply X4 with (e0 x); auto with zfc.\nelim (X4 y); intros.\nelim (X4 y); intros.\nexists x1.\napply X4 with (e0 x); auto with zfc.\n\nelim (X5 y); intros.\nelim (X5 y); intros.\nelimQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros; elim X3; intros.\nelim (b0 x); intros.\nelim (a0 x0); intros.\nelim (a1 x); intros.\nelim (a1 x0); intros.\nelim (b0 x); intros.\nelim (a2 x); intros.\nelim (a1 x0); intros.\nelim (b1 x); intros.\nelim (a2 x0); intros.\nelim (a2 x); intros.\nelim (b0 x); intros.\nelim (b1 x0); intros.\nelim (b1 x); intros.\nelim (b2 x); intros.\nelim (b1 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b1 x); intros.\nelim (b2 x0); intros.\nelim (b2 x); intros.\nelim (b1 x); intros.\nelim (b2 x); intros.\nelim (b1 x0); intros.\nelim (b1 x); intros.\nelim (bQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nelim X2; intros.\nelim (a0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b1 x); intros.\nelim (b1 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nexact (EQC_trans E1 E2); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\napply X with (e0 x0); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X1; intros; elim X2; intros.\nelim (a0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (a0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b1 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nelim (b0 x); intros.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; intros.\napply X with (e1 x0); auto with zfc.\napply X with (e0 x0); auto with zfc.\napply X with (e0 x0); auto with zfc.\napply X with (e0 x0); auto with zfc.\napply X with (e0 x0); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros E1 E2 E3.\napply EQC_sym.\nred in |- *; intro; elim X2; intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nexists x0.\napply X with (e1 x0); auto with zfc.\nelim (b x0); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (c x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (c x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (c x); intros.\nelim (b x); introsQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'; simple induction E'; simpl in |- *; intros.\nelim X1; intros; elim X2; intros; elim X3; intros.\nelim X2; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E E' H'0; unfold EQC in |- *; apply EQC_INC.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E2; simple induction E3; simpl in |- *;\n intros; elim X1; intros.\nelim (a0 x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (Qed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E E' H'0; apply EQC_INC with E E; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'; simple induction E; simpl in |- *;\n intros.\nsplit; intros.\napply X with (e0 x); auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'; simple induction E2; simpl in |- *; intros.\nsplit; intros.\nelim (b x); intros.\nexists x; auto with zfc.\n\nintros.\nelim (b x); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E3; simple induction E4; simpl in |- *;\n intros.\nsplit; intros.\nelim X1; intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\n\nelim X1; intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros.\nsplit; intros.\nelim (a x); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'; simple induction E3; simpl in |- *; intros.\nelim X1; intros; elim X2; intros; elim X3; intros; elim X3; intros; elim X4;\n intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6;Qed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E3; simpl in |- *; intros.\nelim X1; intros; elim X3; intros; elim X4; intros.\nelim X3; intros; elim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' H'; intros; elim H'; intros.\nelim (CINC_EQC E E); intros.\nelim (CINC_EQC E E'); intros.\nelim (CINC_EQC E E'); intros.\nelim (CINC_EQC E E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQC E' E'); intros.\nelim (CINC_EQCQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' H'0 H'1 H'2.\nexact (CINC_EQC E E' H'0).\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction 1; intros E E F H0; elim H0; intros F H0; elim H1; intros F H1;\n elim H1; intros F H1; elim H1; intros F H1; elim H2; intros F H2;\n elim H1; intros F H2; elim H2; intros F H1; elim H2; intros F H2;\n elim H1; intros F H2; elim H2; intros F H2; elim H2; intros F H3;\n elim H2; intros F H2; elim H2; intros F H3; elim H3; intros F H4;\n elim H3; intros F H4; elim H2; intros F H5; elim H3; intros F H6;\n elim H2; intros F H5 H6; elim H2; intros F H2; elim H2; intros F H2;\n elim H3; intros F H4; elim H4; intros F H6;\n elim H2; intros F H2; elim H2; intros F H2; elim H2; intros F H2;\n elim H2; intros F H2Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E; simpl in |- *; intros.\n(* EINC: sALLEARTUTRDETUTRROSUTRROSRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETRETREQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' E'' F' H'0; elim H'0; intros.\nsplit; intros.\nexact (H0 E); auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' H'.\nunfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim (b x); intros.\nelim (a x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E; intros;\n [ | idtac ].\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.\nelim (c x); intros.Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros.\nelim X2; intros.\nelim (a x0); intros.\nelim (a x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (a x0); intros.\nelim (a x0); intros.\nexists x1.\napply X with (e0 x); auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' H'0.\napply EQC_INC_EQC.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E E' H'.\napply CINC_EQC.\nunfold CINC in |- *.\nelim X; intros.\nelim X2; intros.\nexists x; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simple induction E''; simple induction E''; unfold CINC in |- *;\n intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X4; intros.\nelim X5; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simple induction E''; simple induction E''; simple induction E'';\n intros.\n(* x = y *)\nelim X2; intros; elim X3; intros.\nelim X4; intros.\nexists x0; auto with zfc.\n\nelim X4; intros.\nelim X4; intros.\nexists x1; auto with zfc.\n\nelim X4; intros.\nexists x0; auto with zfc.\n\nelim X4; intros.\nexists x1; auto with zfc.\n\nelim X4; intros.\nexists x0; auto with zfc.\n\nelim X4; intros.\nelim X5; intros.\nexists x1; auto with zfc.\n\n\nelim X4; intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction 1; simple induction 1; intros;\n [ intros; exists x; auto with zfc | intros ].\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E E'' E'' H'0 H'1.\nunfold CIN in |- *; simpl in |- *.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelimQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction 1; simple induction 1; intros x p; exists x; auto with zfc.\n\nelim X2; intros.\nelim (b x); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E E'' H'0.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in H.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CIN in H0.\nunfold CQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply H0; assumption.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction 1; simple induction 1; intros x p; exists x; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction 1; simple induction 1; intros;\n [ idtac\n | exists x; auto with zfc ].\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simple induction 1; intros x p; exists p; auto with zfc.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nexists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X2; intros.\nelim X2; intros.\nexists y; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; intros E'' E'' E'' F'';\n intros E'' E'' F'' F'' F'' F'' F'' F'' E'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F''.\nintros.\nelim E''; intros E'' E'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F''.\nintros.\nelim E''; intros E'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F''.\nintros.\nelim E''; intros E'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F''.\nintros.\nelim E''; intros F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F'' F''.\nintros.\nelim E''; introsQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simple induction 1; simple induction 1; intros.\napply X1.\nexists x; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X2; intros; elim X3; intros.\nexists x0; auto with zfc.\nelim X3; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X1; intros.\nelim X1; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros; elim X2; intros.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y0 p; exists y0.\napply EQC_EtaC with E E'' E'' E''; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simple induction 1; intros;\n [ intros y0 z; exists y0; auto with zfc ].\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros; elim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X5; intros.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim Y1; intros.\nelim Y2; intros.\nelim Y2; intros.\nelim Y1; intros.\nelim Y2; intros.\nelim Y2; intros.\nelim Y1; intros.\nelim Y2; intros.\nelim Y2; intros.\nelim Y3; intros.\nelim Y2; intros.\nelim Y3; intros.\nelim Y3; intros.\nelim Y3; intros.\nelim Y4; intros.\nelim Y3; intros.\nelim Y3; intros.\nelim Y3; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y4; intros.\nelim Y5; intros.\nelim Y5; intros.\nelim Y4; intros.\nelim Y4; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; intros; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y0 p; elim X2; intros y0 p0;\n exists y0; apply EQC_Assn with (e y0); auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_Assn with (e0 y); auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E''; simpl in |- *; intros.\nelim X1; intros; elim X2; intros y0 p; elim X2; intros y0 p; elim X3;\n intros y1 p; exists y0; apply EQC_EtaC with (e0 y); auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim XQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; intros.\nelim Xl; introsQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E''; simpl in |- *; intros.\nelim X1; intros; apply Xl0; elim X2; intros y1 p0; elim X2; intros y2 p0;\n exists y0; apply EQC_Assn with (e y); auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros x p; exists y.\napply EQC_forwards with (e0 y); auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction 1; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros; elim X2; intros y0 p; elim ( Version 2);\n intros; elim X3; intros; elim X3; intros; elim X3; intros; elim X3;\n intros; elim X4; intros; elim X4; intros; elim X4; intros; elim X4;\n intros; elim X4; intros; elim X4; intros; elim X5; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X; intros; elim X1; intros y0 p; elim X2; intros y1 p0; elim X3;\n intros y1 p0; elim X3; intros y2 p0; elim X3; intros y3 p0; elim X4;\n intros y3 p0; elim X4; intros y4 p0; elim X4; intros y5 p0;\n intros y4 p0; elim X4; intros y5 p1; elim X5; intros y5 p6;\n intros y5 p8; elim X5; intros y6 p8; elim X6;\n intros y8; elim X6; intros y8 p9; elim X6; intros y8;\n elim X6; intros y8; elim X7; intros y8; elim X8;\n intros y9; elim X8; intros y9; elim X6; intros y8;\n elim X6; intros y9; elim X9; intros y10; elim X8;\n intros y10; elim X6; intros y11 p10; elim X8Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\nelim X1; intros.\napply Xl; elim X2; intros y0 p; elim X2; intros y0 p0; elim (NotClockwiseBAC y0 p0);\n intros y0 p0; elim X3; intros y1 p1; elim X3; intros y2 p1;\n elim X3; intros y1 p2; elim X3; intros y3 p3; elim X4; intros y4 p1;\n elim X3; intros y1 p1; elim X3; intros y2 p2; elim X3; intros y3 p3;\n elim X3; intros y3 p4; elim X4; intros y4 p5; elim X3; intros y3 p4;\n elim X4; intros y5 p5; elim X4; intros y4 p6; elim X5; intros y5 p6;\n intros y5 p6; elim X5; intros y5 p6; elim X6; intros y6 p7;\n intros y8 p8; elim X5; intros yQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E; intros; elim X1; intros E2.\napply X1.\napply X2.\napply X3.\napply X3.\nassumption.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; intros.\nexact CINC_sym; assumption.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros; elim X2; intros; elim X3; intros; elim X3; intros;\n elim X3; intros; elim X4; intros; elim X5; intros; elim X6;\n intros; elim X5; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros; elim X6;\n intros; elim X6; intros; elim X6; intros;Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros; elim X1; intros y0 p; elim ( Behavior \"LInc?])); intros y1.\nexists y; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros; elim X2; intros.\nelim X2; intros; elim X2; intros; elim X3; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *;\n intros; split; intros.\nelim X1; intros y0 p; exists y0; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simple induction E''; simple induction E''; intros.\nintros y z t; exists y.\napply EQC_ Subst with E'' E''; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simple induction E''; unfold CINC in |- *;\n intros; split; intros.\nelim H; intros.\napply X1.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y0 p; exists y0; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' H'0; unfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simple induction E''; simpl in |- *; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nunfold CINC in |- *.\nelim X1; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X2; intros.\nunfold CINC in |- *; simpl in |- *.\nelim X2; intros.\nunfold CINC in |- *.\nsimpl in |- *.\nelim X1; intros.\nunfold CINC in |- *.\nunfold CINC in |- *.\nelim X2; intros.\nunfold CINC in |- *.\nunfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nunfold CINC in |- *.\nunfold CINC in |- *.\nunfold CINC in |- *.\nelim X1; intros.\nunfold CINC in |- *.\nelim XQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' H'0; elim X2; intros E'' H'1; elim H'0; intros E'' H'2;\n elim H'0; intros E'' H'2; elim H'0; intros E'' H'3; elim H'3; intros E'' H'4;\n elim H'0; intros E'' H'4; elim H'0; intros E'' H'5; elim H'0; intros E'' H'5;\n elim H'0; intros E'' H'5; elim H'0; intros E'' H'6; elim H'0; intros E'' H'7;\n elim H'0; intros E'' H'8; elim H'4; intros E'' H'6; elim H'7; intros E'' H'7;\n elim H'0; intros E'' H'8; elim E''; intros E'' H'7; elim H'8; intros E'' H'8;\n elim E''; intros E'' H'8; elim E''; intros E'' H'8; elim E''; intros E'' H'8;\n elim E''Qed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim X; intros y0 p; exists y0; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros; elim X2; intros y1 p0; elim X2; intros z0 p0; elim X2;\n intros z0; elim X2; intros z1 p0; elim X2; intros z1 p1; elim X3;\n intros z1 p1; elim X3; intros z2 p2; elim X3; intros z3 p4; elim X4;\n intros z3 p4; elim X5; intros z4 p5; elim X5; intros z5 p6;\n intros z5 p6; elim X6; intros z6; elim X7; intros z6;\n intros z6; elim X6; intros z8; elim X6; intros z6;\n intros z7; elim X7; intros z8; elim X7; intros z8; elim X8;\n intros z8; elim X8; intros z8; elim X8; intros z8; elim X8;\n intros z9; elim X8; intros z9; elim X9; intros z9; elim X9;\n introsQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; intros A f X E E'' H; elim X; intros x p; elim p;\n intros y p; exists y.\nelim p; intros y p; exists x; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros; elim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.\nelim X4; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X5; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; intros.\nelim X6; introsQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f X0 E0; elim X0; intros A0 B0 X0; elim X1; intros A1 B1; elim X1;\n intros A1 B1 X2; elim X1; intros A2 B2; elim X2; intros A3 B3; elim X4;\n intros A4 A5 B4; elim X1; intros A4 B5; elim X1;\n intros A5 B1 X4; elim X1; intros A5 A6; elim X1; intros A6 B6;\n intros A6 B2 X4; elim X1; intros A6 B6; elim X2; intros A6;\n clear X1 A6 A6 A6 A6 A7; elim X2; intros A6 A6;\n intros A6 B1 X4; elim X1; intros A6 A7; elim X1; intros A8 A8 A8 A9;\n elim X1; intros A8 A9 A9; elim X1; intros A9 A10; elim A10;\n intros A9 A10; elim AQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros E E E' E'' H'0; elim X; intros x0 p; elim p; elim p;\n intros x0 p; elim p; intros x0 p0; elim p0;\n intros x1 p0; elim p; intros x1 p0; elim p0; intros x1 p1;\n elim p0; intros x1 p1; elim p0; intros x1 p1; elim p0;\n intros x2 p0; elim p0; intros x1 p1; elim p0; intros x2 p2;\n elim p0; intros x3 p1; elim p0; intros x3 p2; elim p0; intros x4 p1;\n elim p0; intros x4 p2; elim p0; intros x4 p1; elim p0;\n intros x5 p1; elim p0; intros x5 p1; elim p0; intros x1 p2;\n elim p0; intros x4 p0; elim p0; intros x5 p0;\n intros x5 p0; elim p0; intros x5 p1; elim p0; intros x6 p2;\n elimQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros E0; elim E0; intros E1 E2; elim E0; intros E2 E3 E4;\n elim E0; intros E3 E4 E5; elim E2; intros E5 E6;\n elim E3; intros E5 E6; elim E3; intros E5 E6; elim E3;\n intros E6 E7; elim E3; intros E6 E6; elim E3; intros E6 E7;\n elim E6; intros E7 E7; elim E7; intros E7 E7; elim E7;\n intros E7 E7; elim E7; intros E7 E8; elim E7;\n intros E8 E7; elim E7; intros E8 E7; elim E7; intros E7 E7;\n elim E7; intros E7 E7; elim E7; intros E7 E8; elim E7;\n intros E8 E7; elim E7; intros E8; elim E7;\n intros E7 E7; elim E7; intros E8 E7Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *;\n intros; elim X; intros Xl Xl Xr; elim Xl; intros Xl Xr; elim Xl; intros Xl Xl;\n elim Xl; intros Xl Xr; elim Xr; intros Xl; elim Xr; intros Xl;\n elim Xl; intros Xl Xr; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl;\n intros Xl; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl; intros Xl;\n elim Xl; intros Xl; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl;\n intros Xl; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl;\n intros Xl; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl; intros Xl;\n elim Xl; intros Xl; elim Xl; intros Xl; elim Xl; intros Xl; elim Xl;\n intros Xl; elim XlQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; unfold CINC in |- *; simpl in |- *; intros.\nelim X; intros y z; exists y; apply EQC_Assn; assumption.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros Xl Xl; elim Xl; intros Yl; elim Xl; intros Yl;\n exists l; split; [ assumption | split; [ assumption | split; [ assumption | split; assumption ].\nelim Xl; intros Xl; elim Xl; intros Yl; elim Yl; intros Yl;\n exists l; split; [ assumption | split; [ assumption | split; assumption ].\nelim Xl; intros Yl; elim Yl; intros Yl; elim Yl; intros Yl;\n exists l; split; [ assumption | split; [ assumption | assumption ].\nelim Xl; intros Yl; elim Yl; intros Yl; elim Yl; intros Yl;\n exists l; split; [ assumption | split; [ assumption | split; assumption ].\nelim Yl; intros Yl; elim Yl; intros Yl; elim Yl; intros Yl;\n exists l; split; [ assumption | split; [ assumption | assumption ].\nelim Yl; intros Yl; elim Yl; intros Yl; elim Yl;Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X1; intros y p; elim (PR2 y p); intros p0;\n elim (PR3 y p0); intros p1; elim (PR3 y p0); intros p2;\n elim (PR3 y p1); intros p3; elim (PR3 y p0); intros p3;\n elim (PR3 y p0); intros p4; elim (PR3 y p0); intros p5;\n exists p1; apply EQC_Assn with (e x); auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E); intros y0 p; elim p; intros y0 p; elim p; intros y1 p;\n [ apply EQC_EtaC with (e y0); auto with zfc | idtac ].\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *;\n intros A f X0 E0 i; elim X0; intros X1 E0; elim X2; intros X3 E1;\n elim X1; intros X3 E3; elim X3; intros X4 E5;\n elim X1; intros X4 E5; elim X4; intros X5 E6;\n elim X5; intros X6 E6; elim X6; intros X6 E7;\n elim X7; intros X8 E6; elim E7; intros X8 E8; elim E8; intros X8 E8;\n elim X8; intros X9 E8; elim E9; intros X9 E9; elim E9; intros X9 E9;\n elim X8; intros X9 E9; elim E9; intros X9 E9; elim E9; intros X9 E9;\n elim E9; intros X9 E9; elim E9; intros X9 E9; elim E9; intros X9 E9;\n elim E9; intros X10 E9; elim E9; intros X9 E9; elim E9Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros A f X0 B0 X0 B1 X2 X4; elim X3; intros X1 X2;\n elim X1; intros X3 X4; elim X3; intros X4;\n elim X1; intros X4 X5; elim X2; intros X5 X6;\n intros X6 X7; elim X7; intros X8; elim X8; intros X8; elim X8;\n intros X8; elim X8; intros X9; elim X9; intros X8; elim X8;\n intros X8; elim X9; intros X9; elim X8; intros X9; elim X8;\n intros X9; elim X9; intros X9; elim X9; intros X9; elim X9;\n intros X9; elim X9; intros X10; elim X10; intros X9; elim X10;\n intros X10; elim X9; intros X9; elim X10; intros X9; elim X8;\n intros X9; elim X9; intros X10; elim X9; introsQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simpl in |- *;\n intros; apply E; unfold CINC in |- *; simplQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros; elim X1; intros x0 p; elim p; intros y p; elim p; intros y0 p;\n intros y0 p; elim p; intros y0 p0; elim p0; intros y1 p0;\n elim p0; intros y1 p0; elim p0; intros y2 p0; elim p0; intros y1 p1;\n elim p0; intros y1 p1; elim p0; intros y2 p1; elim p0; intros y2 p2;\n elim p0; intros y3 p3; elim p0; intros y4 p4; elim p0; intros y1 p2;\n elim p0; intros y4 p1; elim p0; intros y1 p1; elim p0; intros y2 p2;\n elim p0; intros y3 p4; elim p0; intros y1 p4;\n elim p0; intros y1 p4; elim p0; intros y1 p1; elim p0; intros y1 p2;\n elim p0; intros y1 pQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; unfold CINC in |- *; simpl in |- *; intros.\nelim X; intros y z; elim (Y1 y); intros z0 z1; elim z1; intros z1 z2;\n exists z0; apply EQC_Assn with (e y); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; unfold CINC in |- *; simpl in |- *; intros A e X H0; elim H0; clear H0; intros A' e0 H1;\n elim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; simple induction 1; intros; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; simple induction 1; simple induction 1; intros A' H;\n [ left; apply EQC_EtaC with (e x); auto with zfc | apply EQ_C_EtaC with (e x); auto with zfc ].\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; simple induction 1; simple induction 1; intros; discriminate.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; simple induction E; unfold CINC in |- *; simpl in |- *;\n intros A f X H; elim X; intros; elim H; intros; elim H; clear H;\n intros; elim H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n introsQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; intros.\nelim H; intros A' B' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' B' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' B' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' B' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' B' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H;\n elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' B' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim A; clear H; intros A' HQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; simple induction 1; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim (H0 E0); intros.\nexists x; split; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; unfold CINC in |- *; simpl in |- *; intros A e0;\n  split; intros.\nelim (H (e0 x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction 1; simple induction 1; intros; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction B; simple induction F; simpl in |- *; intros A e;\n  split; intros; elim (H (e x)); intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n    intros; elim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfoldbit in |- *.\nintros; split.\nunfold a, a, b, a, b, b, c, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d, d).\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nunfold Ps in |- *; red in |- *; simpl in |- *; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nsimple induction x.\nexists true; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *.\nsimpl in |- *.\nintros.\nelim (X1 X2); intros; exists x; auto with zfc.\n\nexists y; auto with zfc.\n\nintros; exists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfoldbit in |- *.\nunfold inc in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nsimple induction y.\nexists true; auto with zfc.\n\nsimple induction x.\nexists false; auto with zfc.\n\nintros; elim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold FSC in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction a.\nexists true; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nexists false; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold FSC in |- *; unfold Ar2 in |- *; unfold Ar2 in |- *; unfold Ar2 in |- *;\n intros A' B' B' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; introsQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Incident in |- *.\nsimpl in |- *.\nintros; split.\nintros; elim (H (e x)); auto with zfc.\n\nexists x; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold FSC in |- *.\nintros; split; red in |- *; intros A' B A'; elim (H (a' x)); intros A' B' H0;\n elim (H (a' x)); intros A' B' H1;\n elim (H (a' x)); intros A' B' H0; elim (H0 A' B' H1); intros A' H1;\n elim (H0 A' B' H0); intros A' B' H2; elim (H0 A' H2); intros A' H2;\n elim (H0 A' B' H2); intros A' H2; elim (H0 A' B' H2); intros A' H3;\n elim (H0 A' B' H2); intros A' H3; elim (H0 A' B' H3); intros A' H4;\n elim (H0 A' B' H3); intros A' H4; elim (H0 A' B' H4); intros A'4 H5;\n elim (H0 A' B' H0); intros A'5 H6; elim (H1 A' B'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CEQ, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CEQ, CEQQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nintro; elim (H (e x)); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nsimple induction x; auto with zfc.\nexists false; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\nexists false; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nintros; apply CIN_associative with (e x); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nsimple induction x; exists y; auto with zfc.\nexists false; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; elim A; intros A e Xl; elim A; intros A e; elim A;\n intros A e Xl; elim A; intros A e Xl; elim A; intros A e0; elim A;\n intros A e0 A e0; elim A; intros A e1 Xl; elim A; intros A e0; elim A;\n intros A e0 A0 e1; elim A; intros A e1 Xl; elim A; intros A e1; elim A;\n intros A e1 Xl; elim A; intros A e1 Xl; elim A; intros A e2 Xl; elim A;\n intros A e1 Xl; elim A; intros A e0; elim A; intros A e1 Xl; elim A;\n intros A e1 Xl; elim A; intros A e1 Xl; elim A; intros A0 l1; elim A;\n intros A e1 Xl; elim A; intros A0 e1 Xl; elim A; intros A0 l2; elim A;\n intros A0 e1 Xl; elim A; intros A0Qed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists false; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nintros.\nunfold CIN in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nintros.\nunfold CIN in |- *; simpl in |- *; intros; elim (H (e x)); auto with zfc.\n\nintros.\nunfold CIN in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nunfold CIN in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nintros.\nunfold CIN in |- *; simpl in |- *; intros; elim (H (e x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; exists true; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nunfold CIN in |- *; simpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nunfold CIN in |- *; simpl in |- *.\nintros; split; auto with zfc.\nexists true; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ auto with zfc | auto with zfc ].\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CEQ, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CINQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ apply CIN_con; assumption | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | apply CIN_con; assumption ]\n | applyQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *.\nintros; elim (CIN_con_prop_left C); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists false; auto with zfc.\nexists true; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *.\nintros.\nelim (classic (B:=C)); intro H1.\nexists (b:=C); split; assumption.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Prod, CIN in |- *; simpl in |- *; intros A B E;\n elim (H0 A); intros; elim (H1 A); intros; elim (H2 A); intros; elim (H4 A); intros; elim H4;\n intros; elim (H4 A); intros; elim (H5 A); intros; elim H5;\n intros; elim (H5 A); intros; elim (H5 A); intros; elim H5;\n intros; elim (H5 A); intros; elim (H6 A); intros; elim (H6 A);\n intros; elim (H6 A); intros; elim (H6 A); intros; elim (H6 A);\n intros; elim (H6 A); intros; elim H5; intros; elim H6;\n intros; elim (H6 A); intros; elim (H6 A); intros; elim (H6 A);\n intros; elim (H6 A); intros; elim (H6 A); intros; elim (H6 A);\n intros; elim (H6 A); intros; elim (H6 A); intros; elim (H6 A); intros; elim (H6 A);\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *; simpl in |- *; intros A B C H; elim H; clear H; intros A B C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A B C H; elim H; clear H; intros A B C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A B C H; elim H; clear H; intros A C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A B C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A B C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A C H; elim H; clear H; intros A C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A C H; elim H; clear H;\n intros A B C H; elim H; clear H; intros A C H; elim H; clear H; intros A C H; elim H; clear H;\n intros A B CQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *; simpl in |- *; intros A B E H; elim H; clear H;\n intros; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H; clear H; intros A' H; elim H; clear H;\n intros A' H; elim A; clear H; intros A' H; elim H; clear H;\n intros A' H; elim H;Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *; exists C; unfold CIN in |- *;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN, CIN in |- *; simpl in |- *; intros A e A e0 H0.\nelim (H0 (A:=A) (B:=A) (B:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold C in |- *; simpl in |- *; intros; split.\nintros; elim (H (CIN_C A (A:=B)); auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nunfold E' in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold diff_t in |- *; unfold diff_t in |- *; unfold diff_t in |- *.\nintros; unfold diff_t in |- *.\nelim (CIN_con_prop_right C A); intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_prop C A);\n intros; elim (CIN_con_prop C A); intros; elim (CIN_con_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *.\nintros; elim (CIN_fail_right C); intros; elim b;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *.\nintros; split.\nintros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros;\n elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear HQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C H; elim (CIN_Apart C H);\n intros A B C HQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *.\nintros; elim (CIN_con_prop E); intros; elim b;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; unfold CIN in |- *;\n unfold CIN in |- *; simpl in |- *; intros A e0 e1 e2 e3.\nelim (CIN_con_prop _ _ _ e1 e2 e3 e3 e4 e4 e5 e6 e7 e7 e8 e9 e10 e11 e11 e12 e12 e13 e13 e13 e14 e14 e15 e15 e15 e16 e16 e17 e18 e18 e19 e19 e20 e21 e22 e14.\n\n(*\nLemma CIN_disj :\n forall E F : Ens, CIN E F -> CIN E F -> CIN E F.\nunfold CIN in |- *; simpl in |- *; unfold CIN in |- *;\n simpl in |- *; unfold CIN in |- *;\n unfold CIN in |- *;\n simpl in |- *; unfold CIN in |- *;\n intros A e0 e1 e2 e3.\nelim (CIN_con_prop _ _ _ e1 e2 e3 e4 e5 e6 e7 e8 e9 e11 e12 e12 e13 e14 e14Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; intros;\n elim (CIN_begin E); intros; elim b;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in |- *.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CIN in H.\nunfold CINQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; exists false;\n auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; intros; elim b;\n simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CINQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Disj in |- *; simpl in |- *; intros; split; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; simpl in |- *; intros.\nelim (X1 E'); intros.\nexists x; exists y; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold not in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; simpl in |- *; intros; split.\nauto with zfc.\n\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold is_a, CIN in |- *; simpl in |- *; intros;\n split.\nintros; elim H; clear H; intros H0 H1; elim H; clear H; intros H1 H2; elim H; clear H;\n intros H1 H2; elim H2; clear H2; intros H3 H4; elim H3; clear H3;\n intros H4 H5; elim H4; clear H4; intros H5 H6; elim H5; clear H5;\n intros H6 H7; elim H7; clear H5; intros H7 H8; elim H7; clear H8;\n intros H8 H9; elim H; clear H; intros H9 H10; elim H9; clear H10;\n intros H10 H10; elim H; clear H; intros H10 H11; elim H; clear H;\n intros H12 H12; elim H; clear H; intros H12 H12; elim H; clear H;\n intros H12 H13; elim H; clear H; intros H13 H13; elim H13; clear H13;\n intros H13 H13; elim H; clear HQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; simpl in |- *; exists false; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold is_inter in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold not in |- *; red in |- *; intro; elim (X1 E); intros.\nexists (singleton E); auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; split;\n [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *; intros; splitQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\nauto.\nDefined.",
                    "Definition Nat : nat -> Ens.\nintros E H' H'0 H'1.\ngeneralize (H' E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\nclear H'0.\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\nclear H'0.\ngeneralize (H'0 E').\ngeneralize (H'0 E').\ngeneralize (H'0 E').\nDefined.",
                    "Definition Nat : nat -> Ens.\nexact (Le E E) (Le E E').\n\nHint Resolve O : sets.\n\nLemma N_eq_dec : forall a : Z, a = a :>Z.\nexact (Le E E) (Le E E').\nDefined.",
                    "Definition Nat : nat -> Ens.\nexact (Le_trans (A:=O)).\n\nDefinition Empty_empty : Ens := \n  (exists y : (Ord Vide y) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (Ord (fun _ => x) (OrdDefined.",
                    "Definition Nat : nat -> Ens.\nauto.\nDefined.",
                    "Definition Nat : nat -> Ens.\nauto with sets.\nDefined.",
                    "Definition Nat : nat -> Ens.\nauto.\nDefined.",
                    "Definition Nat : nat -> Ens.\nauto with *.\nDefined.",
                    "Definition Nat : nat -> Ens.\nintros E H0.\ngeneralize (H0 E).\ngeneralize (H0 E).\ngeneralize (H1 E).\ngeneralize (H0 E).\ngeneralize (H1 E).\ngeneralize (H1 E).\ngeneralize (H1 E).\ngeneralize (H2 E).\ngeneralize (H0 E).\ngeneralize (H2 E).\ngeneralize (H0 E).\ngeneralize (H1 E).\ngeneralize (H2 E).\ngeneralize (H1 E).\ngeneralize (H0 E).\ngeneralize (H2 E).\nintros.\ngeneralize (H1 E).\ngeneralize (H2 E).\ngeneralize (H3 E).\ngeneralize (H2 E).\ngeneralize (H3 E).\nintros.\ngeneralize (H2 E).\ngeneralize (H3 E).\ngeneralize (H1 E).\nintros.\ngeneralize (H3 E).\ngeneralize (H1 E).\ngeneralize (H3 E).\nintros.\ngeneralize (H2 E).\ngeneralize (H0 E).\nintros.\ngeneralize (H3 E).\ngeneralize (H1 E).\nintros.\ngeneralize (H3 E).\ngeneralize (H1 E).\nDefined.",
                    "Definition Nat : nat -> Ens.\nProof Build_Setoid (A:=A) (B:=A).\n\nDefinition Def (E : Ens) :=\n  forall x : E, E x -> E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E E (Comp E (Comp E)))) x))) x)\n      (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E E)))) x))).\n\nDefinition Def (E : Ens) :=\n  forall x y : E, E x -> E y -> E y.\n\nDefinition Def : Ens -> Prop :=\n  forall x y : E,\n  E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E E)))) x))).\n\nDefinition Def : Ens :=\n  forall x y : E,\n  (Comp E (Comp E (Comp (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Comp E (Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof\n  fun F : Ens =>\n  fun x : Ens =>\n  fun x : Ens =>\n  fun x : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun x : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun x y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun x y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun x y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : EnsQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E : Ens.\nintro E.\nelim E.\nauto.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; Auto with sets.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E.\napply sup_empty.\napply sup_empty.\nred in |- *; intros H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.\nelim H'.Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E.\nred in |- *.\nauto with sets.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof\n  fun A B : Ens =>\n  fun x y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun x : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>\n  fun y : Ens =>Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E H H'.\nelim (H' H'0); auto with sets.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E.\nred in |- *; red in |- *; intros; try assumption.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E H; Auto with sets.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E H H'0; Auto with *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Same in |- *; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; simpl;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; simpl;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; unfold R;\n unfold R; unfold R; unfold R; unfold R; unfold R;\n unfold R; unfold R; unfold R; unfold R; unfold R; unfold R; simpl;\n unfold R; unfold R; unfoldQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold inc in |- *; unfold eqmap in |- *;\n apply IN_Union with (A:=A) (B:=A) (B:=A) (B:=C) (B:=A) (B:=C) (A:=B) (B:=C) (B:=C) (B:=A) (A:=B) (B:=C) (A:=A) (B:=C) (B:=A) (B:=C) (A:=A) (B:=A) (B:=A) (B:=B) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=B) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold R in |- *; unfold PR in |- *;\n apply IN_Union with (A := A); auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Included in |- *; simpl in |- *; intros;\n apply Extensionality_Ensembles; split; intros;\n [ idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtacQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold R in |- *; unfold not in |- *; intros H H0; elim H0; intro H1; elim H1; intro H2;\n elim H1; intro H2; elim H2; intro H3;\n elim H3; intro H4; elim H4; intro H5; elim H5; intro H6;\n elim H5; intro H5; elim H5; intro H6; elim H5; intro H6;\n elim H5; intro H6; elim H6; intro H7; elim H8; intro H7;\n elim H6; intro H7; elim H8; intro H8; elim H9; intro H8;\n elim H9; intro H9; elim H9; intro H9; elim H9; intro H9;\n elim H9; intro H9; elim H9; intro H9; elim H9; intro H9;\n elim H10; intro H10; elim H9; intro H10; elim H9; intro H10;\n elim H10; intro H9; elim H10; intro H9; elim H10; intro H9;\n elim H10Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Same in |- *; intros E; inversion E; inversion E; clear E; inversion H.\n\n(*\nTheorem Finite_th1 : forall E : Ens, Finite E (Class_succ E).\nintros E; unfold Same in |- *; intros E; inversion E; clear E; inversion E; clear E; inversion H.\n\n(*\nTheorem Finite_th2 : forall E : Ens, Finite E (Class_succ E).\nintros E; unfold Same in |- *; intros E; inversion E; clear E; inversion E; inversion E; clear E.\n\n(*\nTheorem Finite_th2 : forall E : Ens, Finite E (Class_succ E).\nintros E; unfold Same in |- *; intros E; inversion E; clear E; inversion E; clear E; inversion E; clear E; inversion E; clear E.\n\nTheorem Finite_th3 : forall E : Ens, Finite E (Class_succ E).\nintros E; unfold Same in |- *; intros E; inversion E; clear E; inversion E; clear E.\n\n(*\nTheorem Finite_th4 : forall E : Ens, Finite E (Class_succ E).\nintros E; unfoldQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Symmetric in |- *; auto with *.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold incl in |- *; simpl in |- *; intros.\nexact H.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold incl in |- *; unfold PR in |- *; unfold PR in |- *; intros; elim H; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold IN in |- *; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfold PR in |- *; unfold PR in |- *;\n intros; unfoldQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold SUB in |- *;\n [ intros H'; elim H'; clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'; elim H'; clear H'; intros H'0;\n clear H'; intros H'; elim H'; clear H'; intros H';\n clear H'; intros H'0; elim H'; clear H'; intros H';\n elim H'; clear H'; intros H'0; elim H'; clear H'; intros H'0;\n clear H'; intros H'0; elim H'; clear H'; intros H'0;\n clear H'0; intros H'; elim H'; clear H'; introsQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof\n  fun E : Ens => fun H : Ens => forall H : Ens, EQ E H -> EQ (Add E E) H.\n\nTheorem Extensionality_symm : forall E E' : Ens, SUB E E' -> EQ E E' -> EQ E A.\nProof\n  fun E F H0 : Ens => forall H1 : Ens, EQ (Add E E) H1.\n\nTheorem Extensionality_symm : forall E E' : Ens, SUB E E' -> EQ (Add E E) (Add E E) (Add E E) (Add E E).\nProof\n  fun E F H1 : Ens => forall H2 : Ens, EQ E F H2 -> EQ (Add E E) H2.\n\nTheorem Extensionality_symm : forall E F : Ens, SUB E F -> EQ (Add E F) (Add E F).\nProof\n  fun E F H1 : Ens => forall H2 : Ens, EQ (Add E F) H2.\n\nTheorem Extensionality_symm : forall E F : Ens, SUB (Add E F) (Add E F) (Add E F).\nProof\n  fun E F H1 : Ens => forall H2 : Ens,Qed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold PR in |- *; unfold PR in |- *; unfold PR in |- *;\n auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E; unfold Is_empty in |- *; unfold Is_empty in |- *; unfold Is_empty in |- *;\n unfold Is_empty in |- *; unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;\n unfold Is_empty in |- *;Qed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold PR in |- *; apply IN_Union with (E:=E); auto with sets.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E; unfold Same in |- *; split; [ auto with zfc | idtac ].\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold PR in |- *; unfold PR in |- *; unfold PR in |- *;\n apply IN_Union with (E:=E) (E:=E); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold PR in |- *; unfold PR in |- *; intuition.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E; unfold PR in |- *; unfold PR in |- *; unfold PR in |- *;\n intros.\napply IN_Union with E; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E H; unfold not in |- *; intro H; apply H; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E F H'; unfold IN in |- *; unfold IN in |- *; unfold IN in |- *;\n apply IN_Union with (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C:=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=E') (C':=E) (C':=E) (C':=E') (C':=E) (C':=E) (C':=E) (C':=E) (C':=E') (C':=E') (C':=E') (C':=E) (C':=E) (C':=E) (C':=E) (C':=E) (C':=Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold Subset in |- *; unfold not in |- *; intros H; try assumption.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E; unfold IN in |- *; intro H; elim H; intros i1 i2.\nelim (Paire_IN E (spaces i1) E1 i2).\nintros; right; apply IN_sound_right with E; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold PR in |- *; unfold PR in |- *; unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PR in |- *;\n unfold PRQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold Add in |- *; unfold IN in |- *; unfold not in |- *; intros;\n apply IN_Add_E; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold IN in |- *; apply IN_Union with E; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold PR in |- *; unfold PR in |- *; intros H0.\napply IN_empty; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E H'; unfold IN in |- *; intuition.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E E; unfold IN in |- *; unfold PR in |- *; unfold PR in |- *;\n intros; elim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interior_E F); intros.\nelim (alternate_interiorQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; apply (IN_EXType (sup A f) (sup A f) i); auto with algebra.\napply (IN_EXType (sup A f) (sup A f) i); auto with algebra.\napply (IN_EXType (sup A f) (sup A f)); auto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; unfold Nat.succ in |- *; elim (proj1_sig_IN_M n).\nintros; left; apply IN_sound_right with (sup A f); auto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; apply Nat_IN_Omega.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nelim (IN_EXType (sup A f) (sup A f)).\nintros a e.\nsimpl in |- *.\nchange (EQ (sup A f) (f a)) in e.\nelim e.\nauto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; unfold not in |- *; intro H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (sup A f) (sup A f) (sup A f)) in |- *.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nreplace (EQ (sup A f) (sup A f)) with e.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nreplace (EQ (sup A f)) with e.\napply EQ_empty_r.\napply EQ_empty_r.\napply EQ_empty_r.\napply EQ_empty_r.\napply EQ_empty_r.\napply EQ_empty_r.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nunfold Finite in |- *.\nelim (H (empty A)).\nintros; right; apply IN_sound_right with (sup A f); auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\nrewrite H.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim n; simpl in |- *.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in |- *.\napply IN_sound_right with (sup A f); auto with zfc.\napply IN_sound_right with (sup A f); auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; unfold not in |- *; intro n.\nchange (EQ (S n) (comp (lift (S n))) (lift (S n))) in |- *.\nelim (IN_EXType (sup A f) i).\nintros a e.\nsimpl in |- *.\nchange (EQ (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nelim (IN_EXType (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nintros a e.\nsimpl in |- *.\nchange (EQ (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nelim (IN_EXType (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nintros a e.\nsimpl in |- *.\nchange (EQ (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nelim (IN_EXType (sup A f) (comp (lift (S n))) (lift (S n))) in |- *.\nintros a e.\nsimpl in |- *.Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nunfold nat_S in |- *.\nelim (Union_IN A f) n.\nintros n0.\nelim (Union_IN A f) n0.\nintros a e.\napply IN_sound_right with (sup A f); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; simpl in |- *.\nauto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; apply Extensionality_Ensembles.\nunfold not in |- *; intro; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H;Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; simpl in |- *; exists (S n); auto with algebra.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *; exists A; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold IN in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; simpl in |- *; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; simpl in |- *; exists (S n); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold Finite in |- *; intros; apply IN_empty_imp_Finite; auto with algebra.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *; unfold Add in |- *; unfold Add in |- *;\n unfold Add in |- *;\n unfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX.\napply IN_Nat_EX_Type.\napply IN_Nat_EX.\napply IN_Nat_EXQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E; unfold Extensionality in |- *; simpl in |- *.\nintros.\napply IN_Nat_S; auto with algebra.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; simple induction 1.\nintros n e.\nexists e.\nauto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; simple induction 1.\nintros n e.\nexists (Nat n); auto with zfc.\nintros n e.\nelim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim e.\nintros; elim eQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E; simpl in |- *; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; simple induction 1.\nintros n0 e.\nexists (S n0).\nunfold n0 in |- *; auto with zfc.\nintros; apply EQ_Nat_S; auto with zfc.\nintros; apply EQ_Nat_S; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros E n E H.\nred in |- *; intros.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nauto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; red in |- *; intro H1.\napply H1; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintros; apply H; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros; exists n0.\nauto with zfc.\n\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; intros.\napply H; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; red in |- *; simpl in |- *.\nintros; elim (H E); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; red in |- *; intros.\nelim (H E); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold incl in |- *.\nunfold incl in |- *.\nunfold incl in |- *.\nunfold incl in |- *.\nunfold incl in |- *.\nunfold incl in |- *.\nintros.\napply H.\nelim (H E); auto with zfc.\n\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintros; exists 0; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nsimpl in |- *.\nsimple induction 1; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4;\n intros; elim H3; intros; elim H4; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elimQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nunfold not in |- *; simple induction 1.\nintros; elim H; auto with zfc.\nintros; elim H; auto with zfc.\nintros; elim H; auto with zfc.\nintros; elim H; auto with zfc.\nQed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. apply H. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H. apply H. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. transitivity (eq_sym x); auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; discriminate. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y; unfold eq, eq, eq; intuition. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y.\n  unfold eq; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. eapply eq_trans; eauto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; apply H. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. destruct (eq_dec x y); auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. unfold eq. destruct x, y; simpl; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. eapply lt_trans; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply lt_trans with y; assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with y; eauto. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. transitivity (y + z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply lt_trans with (y := z).\n    apply ltQed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros; eapply lt_trans; eauto. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with y; assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply H. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. rewrite (eq_sym x); reflexivity. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. transitivity (S.compare x y); eauto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. eapply lt_not_eq; eauto. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. transitivity (x = y); eassumption. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply lt_not_eq. apply lt_not_eq. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply StrictOrder_Irreflexive. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. transitivity (y?= x); eauto. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply eq_sym. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive x). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. transitivity (y?= x); eauto. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. transitivity (y == y); eauto. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. unfold lt; case_eq (compare x y); intro H. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros Hx Hy. rewrite <- Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nintro.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intro.\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewrite (mult_comm 1).\n rewriteQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (multZ_eq_1 _ _ H).\n apply (mult_Z_eq_1 _ _ H).\n apply (mult_Z_eq_1 _ _ H).\n apply (mult_Z_eq_1 _ _ H).\n apply (mult_Z_eq_1 _ _ H).\n apply (mult_Z_eq_1 _ _ H).\n apply (mult_Z_eq_1 _Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; apply multZ_eq_1; assumption.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  induction n.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_nat n) 0); intros.\n  simpl in |- *.\n  elim (multZ_eq_dec (Z_of_natQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_assoc.\n  rewrite <- (mult_comm (m - 1)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (m - 1Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; apply multZ_eq; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n rewrite (mult_comm (multZ_of_nat (S n))) at 2.\n rewrite (mult_comm (multZ_of_nat (S n))) at 2.\n rewrite <- (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (S n)))))).\n rewrite (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (S n)))))).\n rewrite (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (S n)))))).\n rewrite (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (mult_comm (S n)))))).\n rewrite (mult_comm (mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto with arith.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros n; pattern n; rewrite mult_comm; rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewrite <- mult_assoc;\n rewrite <- mult_assoc; rewriteQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros.\n rewrite (multZ_eq2 n).\n rewrite (multZ_eq_2 n).\n rewrite (mult_comm n).\n rewrite (mult_comm n).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (mult_comm (pos n)).\n rewrite (Qed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto with *.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply plus_pos_pos_pos.\n assumption.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_plus_neg_l.\n\nLemma mult_neg_pos_pos : forall x y : Z, x = y -> x = y.\nProof multZ_eq_plus_neg_l.\n\nLemma mult_neg_neg_pos : forall x y : Z, x = y -> x = y.\nProof multZ_eq_plus_neg_l.\n\nLemma mult_neg_pos_pos : forall x y : Z, x = y -> x = y.\nProof multZ_eq_plus_neg_r.\n\nLemma mult_neg_pos_pos : forall x y : Z, x = y -> x = y.\nProof multZ_eq_plus_neg_l.\n\nLemma mult_neg_pos : forall x y : Z, x <> y -> x = y.\nProof multZ_eq_minus_neg_l.\n\nLemma mult_neg_pos : forall x y : Z, y <> 0 -> x = y.\nProof multZ_eq_minus_neg_l.\n\nLemma mult_neg_pos : forall x y : Z, x <> y ->Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros; elim (mult_neg_Z x y); trivial.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x).\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewrite (mult_comm y).\n rewriteQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_3.\n\n(*******************)\n\nLemma mult_pos_pos : forall x y : Z, x = 0 -> x = 0.\nProof multZ_eq_0_r.\n\nDefinition oppZ (x : Z) := x.\n\nLemma mult_pos_pos : forall x y : Z, x = 0 -> x = 0.\nProof mult_neg_neg_Z.\n\nLemma mult_neg_neg_pos : forall x y : Z, x = 0 -> x = 0.\nProof mult_neg_neg_pos.\n\nLemma mult_neg_neg_pos : forall x y : Z, x = 0 -> y = 0.\nProof mult_neg_neg_neg_pos.\n\nLemma mult_neg_neg_pos : forall x y : Z, y <> 0 -> x = 0.\nProof mult_neg_neg_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z, x <> 0 -> y = 0.\nProof mult_neg_neg_neg_neg.\n\nLemma mult_neg_neg_neg : forall x y : Z,Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y H; elim H; intros.\n simpl in |- *; auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y; apply mult_pos_l.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof mult_pos_Z.\n\nLemma mult_pos_pos_eq :\n forall (x y : Z) (y : Z), multZ (pos x) y = double (multZ x y) (oppZ y).\nProof mult_pos_eq_1.\n\nLemma mult_neg_neg_eq :\n forall (x y : Z) (y : Z), multZ (neg x) y = double (multZ x y) (oppZ x).\nProof mult_neg_eq_1.\n\nLemma mult_neg_neg_eq :\n forall (x y : Z), multZ (pos x) y = double (multZ x y) (oppZ x).\nProof mult_neg_eq_1.\n\nLemma mult_neg_eq :\n forall (x y : Z) (y : Z), multZ (neg x) y = double (multZ x y) (oppZ x).\nProof mult_neg_eq_1.\n\nLemma mult_neg_eq :\n forall (x y : Z), multZ (neg x) y = double (multZ x y) (oppZ x).\nProofQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_neg_l.\n\nLemma mult_pos_neg_r :\n forall (x y : Z), multZ (pos x) y = oppZ x + - y.\nProof multZ_eq_neg_l.\n\nLemma mult_neg_neg_r :\n forall (x y : Z), multZ (pos x) y = oppZ x + - y.\nProof multZ_eq_neg_r.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = oppZ x + - y.\nProof multZ_eq_neg_l.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = oppZ x + - y.\nProof multZ_eq_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = oppZ x + - y.\nProof multZ_eq_neg_r.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = oppZ x + - y.\nProofQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; unfold pred in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_sym x y); intros; elim H0; intros.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (>>)% (x0 = x1).\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nintros; unfold pred in |- *; rewrite (tech_mult_negZ n0 y).\nelim (inlist y I); intros.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nintros; unfold pred in |- *; rewrite (tech_mult_negZ n0 y).\nelim (inlist y I); intros.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nintros; unfold pred in |- *; rewrite (tech_mult_negZ n0 y).\nelim (inlist y I); intros.\n(*Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Babs x y.\nProof mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (neg x) y = Babs x y.\nProof mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = Babs x y.\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = Babs x y.\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = Babs x y.\nProof mult_neg_l.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = Babs x y.\nProof mult_neg_l.\n\nLemma mult_neg_l : forall x y : Z, multZ x y = Babs x y.\nProof mult_neg_r.\n\nLemma mult_neg_l : forall x y : Z,Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Negz x.\nProof multZ_eq_0.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Negz x.\nProof multZ_eq_1.\n\nLemma mult_pos_r : forall x y : Z, multZ (pos x) y = Negz x.\nProof multZ_eq_1.\n\nLemma mult_pos_r : forall x y : Z, multZ (pos x) y = Negz x.\nProof multZ_eq_1.\n\nLemma mult_pos_r : forall x y : Z, multZ (pos x) y = Qden x.\nProof multZ_eq_1.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Qden x.\nProof multZ_eq_1.\n\nLemma mult_pos_r : forall x y : Z, multZ (pos x) y = Qden x.\nProof multZ_eq_1.\n\nLemmaQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = sinh x (multZ x y).\nProof multZ_eq_mult_pos_l.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = exp x (multZ x y).\nProof multZ_eq_mult_neg_r.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp y (multZ x y).\nProof multZ_eq_mult_pos_l.\n\nLemma mult_pos_l : forall x y : Z, multZ x y = exp x (multZ x y).\nProof multZ_eq_mult_neg_l.\n\nLemma mult_neg_r : forall x y : Z, multZ x y = exp y (multZ x y).\nProof multZ_eq_mult_pos_l.\n\nLemma mult_neg_r : forall x y : Z, multZ x y = exp x (multZ x y).\nProof mult_Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_pos_r.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Qden (multZ x y) (multZ x y).\nProof mult_pos_r.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = Qden (multZ x y) (multZ x y).\nProof mult_pos_r.\n\nLemma mult_neg_r : forall x y : Z, multZ (pos x) y = Qden (multZ x y) (multZ x y).\nProof mult_neg_r.\n\nLemma mult_pos_l : forall x y : Z, multZ (pos x) y = Qden (multZ x y) (multZ x y).\nProof mult_neg_r.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = Qden (multZ x y) (multZ x y).\nProof mult_neg_r.\n\nLemma mult_neg_l : forall x y : Z, multZ (pos x) y = Qden x (multZQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simplQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma plus_assoc : forall (x y : Z) (y : Z), multZ x y =VV (multZ x y) (oppZ y).\nProof mult_pos_l.\n\nLemma mult_comm : forall (x y : Z) (y : Z), multZ (pos x) y =VV (multZ x y) (oppZ y).\nProof mult_comm.\n\nLemma mult_comm : forall (x y z : Z), multZ (pos x) y =VV (multZ x y) (multZ x y).\nProof mult_comm.\n\nLemma mult_assoc : forall (x y z : Z), multZ (pos x) y =VV (multZ x y) (multZ x y).\nProof mult_comm.\n\nLemma mult_assoc : forall (x y z : Z) (z : Z), multZ (pos x) y = z.\nProof mult_comm.\n\nLemma mult_assoc : forall (x y z : Z), multZ x y = z.\nProof mult_assoc.\n\nLemma mult_assoc : forall (x yQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* neg n *)\nintros; unfold multZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim ( np n0); intros.\n (* neg n *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim ( np n0); intros.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim ( np n0); intros.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim ( np n); intros.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim ( np n); intros.\n (* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite (tech_mult_neg_Z n0 y).\nelim ( np n); intros.\n (* neg n *)\nintros; simpl in |- *; reflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; apply False_ind.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_neq y I); intros. elim H0; intros; elim H1; intros; exact H2.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply False_ind.\n(* neg n *)\nintros; unfold predZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y) I); intros. elim H1; intros; elim H2; intros; exact H3.\n(* neg n *)\nintros; unfold predZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (Pmult_nat n0 y) I); intros. elim H1; intros; elim H2; intros; exact H3.\n(* neg n *)\nintros; unfold predZ in |- *; rewrite (tech_mult_Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nsimple induction x.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n(* abs n *)\nintros;Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; apply plus_pos_pos_pos; assumption.\n(* pos n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_pos_l x y).\nelim (tech_mult_neg_pos_l x y).\nelim (tech_mult_neg_r x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_r x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_r x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_mult_neg_l x y).\nelim (tech_multQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n0) y).\nelim (archimed (pos n) y).\nelim (archimed (pos n0) y).\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ x (pos n)).\nelim (Ana_reg_l x y); intros.\napply (opp_involutive (pos (pos n0) y)); reflexivity.\n(* pos n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ x (pos n)).\nelim (addZ_irreflexive (multZ x y)).\nelim ( (**********************************)\n\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ x (pos n)).\nelim (Bijection _ _ _ _ _ _ _ H H0); intros.\napply (opp_involutive (pos n0) y); reflexivity.\n(* pos n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ x (pos n)).\nelim (Ana_reg_l x y); intros.\napply (opp_involutive (pos n)).\nelim (RList_abs (mult x y)).\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nsimple induction x.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0 *)\nintros; simpl in |- *; reflexivity.\n(* 0Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (tech_mult_negZ n0 y); intros.\n (* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; apply plus_pos_pos_pos.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm x y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm x y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm x y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (mult_comm x y); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm x y); rewrite (multQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg x *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; rewrite (add_comm (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.S N))))) y)).\nelim (succ_tech_posZ y (succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (Z.succ (ZQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; unfold neg in |- *; rewrite (mult_comm Z); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* abs n *)simple induction n.\n(* neg n *)simple induction n.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.\n(* neg n *)\nsimpl in |- *; rewrite (mult_comm x); reflexivity.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (mult_comm Z).\nrewrite <- (Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; rewrite (mult_comm (Z.neg y)). \nrewrite (mult_comm (Z.neg y)). \nrewrite (mult_comm (Z.neg y)).  rewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite H; elim (mult_comm (Z.neg y)).\nrewrite HQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\napply False_ind; apply (mult_pos_pos x); assumption.\n(* neg n *)\nsimple induction n.\n(* neg n *)\napply False_ind; apply (mult_pos_neg x); assumption.\n(* neg n *)\nsimple induction n.\n(* neg n *)\napply False_ind; apply (mult_neg_pos x); assumption.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; apply mult_pos_r.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite (add_comm Z).\nelim (mult_neg_pos_r (neg y) x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutiveQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x.\nunfold multZ in |- *.\nreplace (pos 0) with (pos 0) by ring.\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_neg_Z n0).\nrewrite (tech_mult_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; apply mult_pos_pos.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros x; case x.\n(* neg 0 *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction x.\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z x) in |- *.\nelim (mult_neg_pos x).\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z x) in |- *.\nelim (mult_neg_neg_Z x).\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z x) in |- *.\nelim (mult_neg_neg_Z x).\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z x) in |- *.\nelim (mult_neg_Z x).\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z x) in |- *.\nelim (mult_neg_Z x).\n(* neg n *)\nsimpl in |- *.\nintros; unfold multZ in |- *; rewrite (tech_mult_neg_Z xQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction x.\n(* pos n *)\nsimpl in |- *; rewrite (tech_mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Z x).\nelim (mult_neg_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimpleQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; apply False_ind; apply (mult_pos_l 0).\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *.\napply False_ind; apply (mult_pos_l 0).\n(* neg n *)\nintros n0 H; rewrite (tech_mult_negZ n0).\nelim (mult_neg_l 0) n0.\n(* neg n *)\nintros n0 H; rewrite (tech_mult_neg_Z n0).\nelim (mult_neg_l 0 n0).\n(* neg n *)\nintros n0 H; rewrite (tech_mult_neg_Z n0).\nelim (mult_neg_l 0 n0).\n(* neg n *)\nintros n0 H; rewrite (tech_mult_neg_Z n0).\nelim (mult_neg_l 0 n0).\n(* neg n *)\nintros n1 H; rewrite (tech_mult_neg_Z n0).\nelim (mult_neg_l 0 n).\n(* neg n *)\nintros n H; rewrite (tech_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; apply mult_pos_l.\nexact (add_mIZ_predZ x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos (S y) *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* pos (S y) *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)simple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)\nsimple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\n(* neg x *)simple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; rewrite (tech_mult_negZ y); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; case x; simpl in |- *; trivial.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x.\nunfold multZ; rewrite (tech_mult_negZ x) in H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(*Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)simple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* neg n *)\nsimple induction x.\n(* negQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* negQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(*Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n    intro H; elim H; intro H; elimQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x.\n  unfold unique in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold lt in |- *.\n  unfold ltQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intro x; elim x; simpl in |- *; intros; assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absZ.\n  apply zero_absQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro.\n  apply (zero_pos_pos x).\n  apply neg_pos_pos.\n  apply neg_pos_pos.\n  apply neg_pos_pos.\n  apply neg_pos_pos.\n  apply pos_pos_pos.\n  apply neg_pos_pos.\n  apply neg_pos.\n  apply neg_pos_pos.\n  apply neg_pos_neg.\n  apply neg_pos_pos.\n  apply neg_neg_neg.\n  apply neg_neg_pos.\n  apply neg_pos_neg.\n  apply neg_pos_pos.\n  apply neg_pos_neg.\n  apply neg_pos_neg.\n  apply neg_neg_neg.\n  apply neg_pos_neg.\n  apply neg_neg.\n  apply neg_neg.\n  apply neg_neg_neg.\n  apply neg_pos_neg.\n  apply neg_neg.\n  apply neg_pos_neg.\n  apply neg_neg_neg.\n  apply neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg.\n  apply neg_neg_neg.\n  apply neg_neg_Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x; case x; trivial.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x.\n  case x.\n  intro y.\n  case y.\n  intro.\n  absurd (x = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = y); auto.\n  intro.\n  absurd (y = yQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absZ.\n apply zero_absQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold)*) in |- *.\n  unfold cut (exists x : Z, (exists y : Z, x = y /\\ x = y)).\n  intro H.\n  elim H.\n  intros.\n  cut (exists x0 : Z, x = y).\n  intro H0.\n  cut (exists y : Z, x = y).\n  intro H0.\n  elim H0.\n  intros.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro H1.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).\n  intro.\n  cut (exists y : Z, x = y /\\ y = y).Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x; elim x; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro; elim H; intro H; elim H; intros; elim H; intro H; elim H; intro H; elim H; elim H; intro; elim H; intro H; elim H; intro; elim H; elim H; intro; elim H; intro; elim H; elim H; intro; elim H; intro; elim H; intro; elim H; elim H; intro; elim H; intro; elim H; elim H; intro; elim H;\n    intro H H; elim H; introQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nreflexivity.\nsimpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *; intro; auto with zarith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *; auto with *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros; elim H; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x H; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold ren in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold pco in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold rr in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold noZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact (fun x : Z => plus_comm x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim x.\n(* (pos n) *)\nintros; elim x.\n(* (pos n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.\n(* (neg n) *)\nintros; elim x.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *.\nauto with zarith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *.\nelim x; simpl in |- *.\nelim (le_lt_eq_dec 0 0); intros; elim H1; simpl in |- *;\n assumption.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim HQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x. \n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; intro H; elim H; intro H; elim H; intro H; elim H;\n intro H0; elim H0; intro H0; elim H0; intro H1; elim H0;\n intro H1; elim H0; intro H1; elim H1; intro H2; elim H1;\n intro H2; elim H2; intro H3; elim H3; intro H4; elim H4;\n intro H4; elim H4; intro H4; elim H5; intro H5; elim H5;\n intro H5; elim H5; intro H6; elim H5; intro H6; elim H6;\n intro H7; elim H7; intro H8; elim H7; intro H8; elim H8;\n intro H8; elim H9; intro H9; elim H10; intro H9; elim H10;\n intro H9; elim H9; intro H10; elim H10; intro H11; elim H9;\n intro H9; elim H10; intro H10; elim H10; intro H11; elim H10;\n intro HQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (neg n) *)\nintros n0 H1; elim H1; intros H2.\n(* (neg n) *)\nintros n0 H1; elim H2; intros H3.\n(* (neg n) *)\nintros; elim H3; intros H4.\n(* (neg n) *)\nintros n0 H1; elim H3; intros H4.\n(* (neg n) *)\nintros n0 H2; elim H3; intros H4.\n(* (neg n) *)\nintros n0 H3; elim H3; intros H5.\n(* (neg n) *)\nintros n0 H2; elim H3; intros H6.\n(* (neg n) *)\nintros; elim H3; intros H6.\n(* (neg n) *)\nintros; elim H3; intros H6.\n(* (neg n) *)\nintros; elim H3; intros H7.\n(* (neg n) *)\nintros; elim H4; intros H8.\n(* (neg n) *)\nintros; elim H4; intros H8.\n(* (neg n)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; auto with arith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x. \nunfold lt in |- *; intros; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in H; elim H; intro H; elim H; intro H;\n rewrite H0 in H; elim H; intro H;\n rewrite H0 in HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivity.\n(* succ *)\n(* succ *)\nreflexivityQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n (* neg n *)\nreflexivity.\n(* neg n *)\nunfold gt in |- *; unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\n(*Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* negative n *)\nreflexivity.\n(* pos n *)\nunfold gt_absZ in |- *; unfold gt_absZ in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(*... *)\nreflexivity.\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*... *)\n(*...Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n (* abs n *)\nintros.\nelim H; auto.\n(* abs n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfoldQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nunfold lt_absZ in |- *; unfold lt in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n (* neg n *)\nreflexivity.\n(* pos n *)\nunfold lt in |- *; unfold lt_absZ in |- *; unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold lt in |- *; unfold lt_absZ in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold gt inQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros; elim (sumbool_of_bool (Neqb y x1)); intro H.\n rewrite H; apply sym_eq.\n assumption.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply (H 0).\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold!; case (y?= y); intro; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H;\n\t[ intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim HQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  destruct y.\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n unfold Zne.\n destruct y.\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_reg_l (y - y)).\n reflexivity.\n simpl in |- *.\n apply (mult_regQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  elim (lt_irrefl _ H).\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (sgn_eq1 (abs_neg y) (abs_neg y)).\n rewrite (Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intro y.\n  case (eq_dec y x); intro H.\n  case (eq_dec y x); intro H.\n  case (eq_dec y x); intro H.\n  case (eq_dec y x); intro H.\n  case (eq_dec y x); intro H0.\n  case (eq_dec y x); intro H0.\n  case (eq_dec y x); intro H0.\n  case (eq_dec y x); intro H1.\n  case (eq_dec y x); intro H1.\n  case (eq_dec y x); intro H1.\n  case (eq_dec y x); intro H1.\n  case (eq_dec y x); intro H2.\n  case (eq_dec y x); intro H2.\n  case (eq_dec x y); intro H3.\n  case (eq_dec x y); intro H4.\n  case (eq_dec y x); intro H4.\n  case (eq_dec x y); intro H5.\n  case (eq_dec x y); intro H5.\n  case (eq_dec x y); intro H5.\n  case (eq_decQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  elim H; intro.\n  apply H0; assumption.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply andb_true_iff_1.\n  apply andb_true_iff_2.\n  apply andb_true_iff_2.\n  apply andb_true_iff_2.\n  apply andb_true_iff_2.\n  apply andb_false_iff_2.\n  apply andb_true_iff_2.\n  apply orb_true_iff_2.\n  apply andb_true_iff.\n  apply andb_false_iff_2.\n  apply orb_true_iff.\n  apply orb_true_iff_2.\n  apply orb_false_iff.\n  apply orb_true_iff.\n  apply andb_true_iff_2.\n  apply orb_true_iff.\n  apply orb_true_iff.\n  apply orb_false_iff.\n  apply orb_true_iff.\n  apply orb_true_iff.\n  apply orb_true_iff.\n  apply orb_true_iff.\n  apply orb_false_iff.\n  apply orb_false_iff.\n  apply orb_false_iff.\n  apply orb_true_iff.\n  apply andb_true_iff.\n  apply orb_true_iff.\n  apply andb_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros.\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_nat_plus_one y).\nrewrite <- (succZ.abs_natQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros.\napply plus_le_compat_r with (n := pos n1).\napply plus_le_compat_r.\napply le_n_S.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_SnQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros x y H; elim H; auto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ x). \n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintro H; elim H.\n(* neg n *)\nintroQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simpleQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(*Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* pos n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ x).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros x y; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\n(* neg n *)\nintros; symmetry  in |- *; exact (succ_predZ x).\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_ Public).\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct n.\n(* neg n *)simple destruct nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofnest_eq4.\n\n(**********************)\n\nLemma succ_addZ_r : forall x y : Z, succZ (succZ x) = succZ (addZ x y).\nProofnest_eq4.\n\n(**********************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = succZ (planar x).\nProofnest_eq4.\n\n(**********************)\n\nLemma succ_predZ : forall x : Z, succZ (sgn x) = succZ ( Public Public Public License, Z, Z, Z, Z, Z).\nProofnest_eq4.\n\n(***************)\n\nLemma succ_pred_pos : forall x : Z, succZ (pred x) = succZ ( Public License, Z).\nProof.\n(*QF*)\n\nLemma pred_succ_pred_pos : forall x : Z, succZ (pred x) = succZ (pred x).\nProof.\nintros x.\nelim (pred_pos (pred x)).\n(* succ_pred_pos. *)\nintros; rewrite succ_pred_pos.\nrewrite pred_pos.\nrewrite pred_pos.\nrewrite pred_pos.\nrewrite predQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Substitute.\n\nLemma succ_antisymmetric : forall x y : Z,]]| (sgn x) = succZ (addZ x y).\nProof Substitute.\n\nLemma succ_antisymmetric : forall x y : Z, ~!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof]]|\n intro; elim x.\n(* add_neg_pos_neg *)\nunfold succ, oppZ, pred in |- *.\nsimpl in |- *.\nrewrite pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ Implicits pred_ ImplicitsQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof)^(eq_4.\n\nLemma succ_addZ_r : forall x y : Z,DomRng (pos x) y = succZ ( Ideal x) y.\nProofUniv_eq5.\n\n(***************)\nLemma succ_succZ : forall x y : Z,DomRng (pos x) y = succZ (SORsetoid x).\nProof))%:R.\n\n(***************)\nLemma pred_ind_compat :\n forall (x y : Z),DomRng (pos x) y = succZ (SORsetoid x) (SORsetoid y).\nProof.\nsimple induction x.\n (* abs *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* pred *)\nreflexivity.\n(* pred *)\n(* predQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof]]|\n intros; elim x.\n (* neg n *)\nreflexivity.\n(* pos n *)\nrewrite pred_succZ; trivial.\n(* pos n *)\nrewrite pred_succZ; trivial.\n(* pos n *)\nrewrite pred_succZ; trivial.\n(* pos n *)\nrewrite pred_pos_predZ; trivial.\n(* pos n *)\nrewrite pred_succZ; trivial.\n(* pos n *)\nrewrite pred_pos_predZ; trivial.\n(* pos n *)\nrewrite pred_pos_succZ; trivial.\n(* pos n *)\nrewrite pred_pos_predZ; trivial.\n(* pos n *)\nrewrite pred_pos_predZ; trivial.\n(* pos n *)\nrewrite pred_pos_))))))),\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.\n(* pos n *)\nrewrite pred_pos_absolu; trivial.Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq4.\n\n(**************)\nLemma succ_aapp :\n forall x y : Z,]]]]]; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq5.\n\n(***************)\nLemma tech_add_pos_neg :\n forall (x y : Z) (y : Z),\nnmono (pos (S x)) y = succZ (addZ x y).\nProof ptc_eq_2.\n\nLemma tech_add_neg :\n forall (x y : Z) (y : Z),\nnmono (pos x)) y = succZ (Pmult_nat (S x)) y.\nProof ptc_eq_2.\n\n(***************)\nLemma tech_add_neg :\n forall (x y : Z) (y : Z),\nnmono (pos (S x)) y = succZ (Pmult_nat (S x)) y.\nProof ptc_eq_2.\n\n(**************)\n\n(* 0 *)\nsimple destruct n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (addZ x y).\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (Twol x) y.\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (Seg x) y.\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (Twol x) y.\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (Twol x) y.\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} x y = succZ (Seg x) y.\nProof._Z.\n\nLemma tech_opp_neg_neg : forall x y : Z, {-} (neg x) y = succZ (Twol x) y.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq3.\n\n(***************)\nLemma tech_add_neg_neg_neg :\n forall (x y : Z),      \n      (neg x) y = succZ (addZ x y).\nProof Melquiond\nintros x y.\nelim x.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nreflexivity.\n(* neg x *)\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq3.\n\n(**************)\nLemma pred_ evl_l : forall x y : Z, succZ x (predZ x) = succZ x ( Acknowledgments: This is actually compared).\nProof Substitute.\n(**************)\n\nLemma pred_ind_l :\n forall (x y : Z) (y : Z), predZ x y = predZ y.\nProof Substitute.\n\nLemma pred_ind_l :\n forall (x y : Z) (y : Z), predZ x y = predZ x ( Acknowledgments: This is done with this is just an explicit substitution. \nProof Substitute.\n\nLemma pred_ind_r :\n forall (x y : Z) (y : Z), predZ x y = predZ y x ( Acknowledgments: This is done with this should be used in\n (In this) in the same assumption) *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction x.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple induction n.\nreflexivity.\n(* pos n *)simple inductionQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction n.\n(* neg n *)\nsimpl in |- *; rewrite pred_stepr.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(*Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* negQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nintros; rewrite (tech_add_neg_neg_pos_neg_neg_neg n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros.\nunfold succ in |- *; rewrite pred_succ_predn.\nelim (le_irrefl 0).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(*Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction x.\n(* neg x *)\nsimple induction x.\nreflexivity.\n(* neg x *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg x *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg x *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg x *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)\nsimple induction x.\nreflexivity.\n(* neg y *)simple induction x.\nreflexivity.\n(* neg y *)simple induction x.\nreflexivity.\n(* neg y *)simple induction x.\nreflexivity.\n(* neg yQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg y0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* neg n *)simple induction n.\n(* negQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpleQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof ML Module \"x < y\" := (le_refl x).\n\nLemma add_neg_pos_pos : forall x : Z,:{0 < x} + {~ x <> 0}.\nProof ML Module \"x < y\" := (le_refl x).\n\n(* no test *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* negQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof Subst induction x.\n (* neg n *)\nreflexivity.\n (* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* negQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof._Z.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivityQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof ML_pos_pos.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof Irreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\nassumption.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nassumption.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* neg n *)\n(* neg n *)\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof ptc_eq_sym; assumption.\n(* neg 0 *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* succ n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof]]| tauto.\n(* neg n *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (neg O) *)simple induction n.\n(* (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_pos_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simpleQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.\n(* neg n *)simple induction x.\nreflexivity.Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_involutive; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nreflexivity.\n(* neg n *)simple induction n.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)\nsimple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.\nreflexivity.\n(* 0 *)simple induction x.Qed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. apply (@orp_stable L _ _ _ Gamma corable_truep_stable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@imp_p_stable L _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@orp_stable L _ _ _ Gamma corable_truep_stable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_stable L _ _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@imp_imp_adjoint A _ _ _ _ Gamma corable_spec); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_stable L _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@orp_stable L _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_imp_refl L _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_stable L _ _ Gamma corable_truep); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@impp_stable L _ _ Gamma corable_truep); auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_andp_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@orp_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@derives_trans_trans_derives _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@orp_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@imp_transitive_sepcon2 L _ _ _ Gamma corable_sepcon1). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@ext_sepcon_stable L _ _ _ Gamma corable_p_stable); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ Gamma corable_andp_sepcon1). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon2); auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@andp_comm_sepcon1 L _ _ Gamma corable_andp1); auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@sepcon_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon1); auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon1); auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@orp_stable L _ _ _ Gamma corable_sepcon1). Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@orp_stable L _ _ _ Gamma corable_sepcon1). Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@andp_stable L _ _ _ Gamma corable_sepcon1). Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@derives_trans_sepcon1 L _ _ Gamma corable_p_stable); auto. Qed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n destruct (H _ H) as [H1 H2].\n destruct (H _ H2) as [H3 H4].\n destruct (H _ H3) as [H5 H6].\n destruct (H _ H5) as [H7 H8].\n destruct (H _ H8) as [H8 H9].\n destruct (H _ H8) as [H8 H9].\n destruct (H _ _ H10) as [H10 H10].\n destruct (H _ _ H11) as [H11 H12].\n destruct (H _ _ H12) as [H12 H13].\n destruct (H _ _ H13) as [H13 H13].\n destruct (H _ _ H13) as [H13 H14].\n destruct (H _ _ H15) as [H14 H15].\n destruct (H _ _ H15) as [H14 H15].\n destruct (H _ _ _ H15) as [H15 H15].\n destruct (H _ _ _ H15) as [H15 H15].\n destruct (H _ _ H15) as [Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n destruct (Z.eq_dec a 0); [left|right]; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\nunfold Zis_gcd, Zis_gcd, Zis_gcd.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec a b); auto.\ndestruct (Z.gcd_dec b a); auto.\ndestruct (Z.gcd_dec b b); auto.\ndestruct (Z.gcd_dec b a);Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n destruct (Z.ltb_spec a b).\n intro.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros; apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_sym.\n  apply ZisQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; generalize (Zgcd_div a d H); intro H.\ndestruct (Z.compare a b); trivial.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.\n intros b d H.\n apply Zis_gcd.Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; induction H; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [right|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compare a b); [right|right]; trivial.\ndestruct (Z.compare a b); [right|right]; trivial.\ndestruct (Z.compare a b); [right|right]; trivial.\ndestruct (Z.compare a b); [right|right]; trivial.\ndestruct (Z.compare a b); [left|right]; trivial.\ndestruct (Z.compareQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  case (Z.div_eucl a b d); intros H.\n  exists (S b) ; exists H.\n  apply Z.div_eucl; auto.\n  rewrite <- H0.\n  apply Z.div_eucl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  replace (x mod y) with (y-x)%Z by auto with zarith.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case Zneq_bool; intros H; constructor; intuition.\n  replace x with (y - x)%Z by omega.\n  replace x with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (y - x)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace x with (x - y)%Z by omega.\n  replace y with (y - x)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace y with (x - y)%Z by omega.\n  replace yQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; apply Zneq_bool_true.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; subst; auto with zarith.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  replace (x+(y-a)+b) with (x-a)+b by auto with zarith.\n  replace (x+(y-a)+b) with (x-a)+b by auto with zarith.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Zneq_bool x y); auto.\n  rewrite H; auto with zarith.\n  rewrite <- H; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; apply Zneq_bool_true.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_false.\n  rewrite Zneq_bool_true.\n  rewrite Zneq_boolQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition; (auto with zarith).\n  replace x with (Z.pred x) by (rewrite Z.add_comm; auto with zarith).\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  replace (x - y) with (x - y)%Z by omega.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y); auto;\n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto;\n try (intros; discriminate); auto;\n try (intros; discriminate); auto;\n try (intros; discriminate); auto;\n try (intros; discriminate); auto;\ntry (intros; discriminate); auto;\ntry (intros; discriminate);\ntry (intros; discriminate); auto;\ntry (intros; discriminate);\n try (intros; discriminate);\ntry (intros; discriminate); auto;\ntry (intros; discriminate);\ntry (intros; discriminate); auto;\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y); intros; discriminate. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold wp; intros.\n  apply hoare_while.\n  intros x p post H.\n  apply hoare_while.\n  intros x p post H.\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun x => x).\n  apply hoare_while with (Q := fun xQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ => True).\n  apply hoare_pre with (fun _ =>Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros x0 y0 y1 z2 z3.\n  destruct (H x0) as [[n Pn] | n Pn].\n  intros n Pn.\n  inversion Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply Pn.\n  apply PnQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp. intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp. intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp. intros i'.\n  apply hoare_wp.\n  intros i'.\n  apply hoare_wp.\n  intros iQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros until post.\n  induction (A 0); intros.\n  apply hoare_wp.\n  intro x.\n  destruct x.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wpQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros.\n  destruct (H (p, post) as (q, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) & (p, post) (p, post) & (p,Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n  intros; apply hoare_wp.\n Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold post; intros.\n  apply hoare_wp.\n  intros (e0, e1); auto.\n  apply hoare_wp.\n  intros (e0, e2); auto.\n  apply hoare_wp.\n  intros (e0, e2); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (e0, e3); auto.\n  apply hoare_wp.\n  intros (Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare.\n  intros.\n  destruct (ex_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_or_or_and_and_and_or_and_or_and_and_and_and_or_or_or_and_and_and_or_and_and_and_and_or_and_or_and_and_and_or_or_and_and_and_or_and_or_and_and_or_or_or_or_and_or_and_or_or_or_and_or_and_and_or_and_or_or_and_or_and_or_and_or_or_or_or_and_and_and_or_or_or_or_or_or_and_and_or_and_or_or_or_and_or_or_and_and_or_or_and_or_or_or_andQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim (lt_irrefl n).\nintros m H1.\nelim H1; intros m H2.\nelim H2; intros m H3.\nelim H1; intros m H3.\nelim H3; intros m H4.\nelim H4; intros m H5.\nelim H5; intros m H6.\nelim H5; intros m H6.\nelim H6; intros m H7.\nelim H7; intros m H8.\nelim H8; intros m H8.\nelim H9; intros m H9.\nelim H8; intros m H9.\nelim H9; intros m H9.\nelim H9; intros m H9.\nelim H10; intros m H9.\nelim H10; intros m H10.\nelim H9; intros m H10.\nelim H10; intros m H10.\nelim H11; intros m H10.\nelim H11; intros m H11.\nelim H11; intros m H11.\nelim H10; intros m H11.\nelim H12; intros m H11.\nelim H12Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\napply (lt_O_eq _ _ (lt_O_eq _ _ _ H)).\napply lt_O_eq; trivial.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim H; intros n H; elim H; intros H0; elim H0; intros H1; elim H0; intros H1; elim H0; intros H1; elim H0; intros H1; elim H1; intros H1; elim H1; intros H2; elim H2; intros H2; elim H2;\n intros H3; elim H4; intros H4; elim H5; intros H5; elim H6; intros H6;\n elim H5; intros H6 H6 H7; elim H7; intros H8; elim H7; intros H8; elim H8;\n intros H8 H9; elim H9; intros H9; elim H8; intros H9 H10; elim H9;\n intros H10 H10; elim H10; intros H11 H12; elim H12; intros H12 H13;\n elim H10; intros H10 H11 H12; elim H12; intros H12 H13;\n elim H12; intros H12 H13 H14; elim H13; intros H13 H13 H14;\n elim H14; intros HQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n H.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.\n  apply lt_minus_O.Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\nunfold le in |- *.\napply le_O_n.\napply le_O_n.\napply le_trans with m; [ assumption | apply le_O_n ].\napply le_n_S.\napply le_n_n.\napply le_n_S.\napply le_n_Sn.\napply le_n_n.\napply le_n_S.\napply le_n_n.\napply le_n_n.\napply le_n_Sn.\napply le_n_n.\napply le_n_S.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napply le_n_n.\napplyQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros.\n  elim H; intro; elim H0; intro; elim H0; intro; elim H0; intro; elim H0; intro; elim H0; intro; elim H0; intro; elim H0; intro; elim H0;\n clear H0; intros.\n  apply le_lt_trans with n; [ auto with arith | simpl in |- *; auto with arith ].\n  rewrite <- H0 in H1.\n  apply le_lt_trans with (m := S n); auto with arith.\n  rewrite <- H1; auto with arith.\n  rewrite <- H0 in H1.\n  apply le_lt_trans with n; [ auto with arith | simpl in |- *; auto with arith ].\n  rewrite <- H1; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (lt_irrefl _ H).\nrewrite (ltQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m; elim n; intros m H.\nelim (le_lt_or_eq _ _ H).\nintros m H1.\nelim (lt_not_eq _ _ H).\nintros m H1; exists m; auto.\napply le_lt_trans with (m := S m); auto.\napply lt_lt_trans with (m := S m); auto.\napply lt_n_Sn.\napply le_trans with (m := S m); auto.\napply lt_lt_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_lt_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.\napply lt_le_trans with (m := S m); auto.Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\nunfold n in |- *.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\napply le_trans with (m - n); auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\nunfold lt in |- *.\napply (lt_n_O _ H).\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_O_n.\napply lt_O_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros; elim n; simpl in |- *; auto.\nintros m H1; absurd (m < n - m); auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m1 H1; apply le_minus_O; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros m H1; apply le_antisym; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto with arith.\nintros m1 Rec m1 Rec m1 Rec m1 Rec m2 Rec m1 Rec m2 Rec m2 Rec m1 Rec m2 Rec m1Rec m2 Rec m2 Rec m2 Rec m1 m2 Rec m2.\n  apply le_minus_O; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; apply Rec; apply lt_S_n; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros; elim n; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_n_S; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m1 Rec m1 Rec m1 Rec m1 Rec m1 Rec m2 Rec m2 Rec m2 Rec m2 Rec m1 Rec m2 Rec m1 m2 Rec m2 Rec m2 Rec m1 m2 Rec m2 Rec m2.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; apply le_minus_O.\nintros m1 Rec m1 Rec m1 Rec m1 Rec m1 Rec m2 Rec m2 Rec m2 Rec m2 Rec m2 Rec m2 Rec m1 Rec m2 Rec m2 Rec m1 m2 Rec m2 Rec m1 m2 Rec m2 Rec m2 m3 Rec m3 Rec m3 Rec m1 m3Rec m3 Rec m1 m3Rec m3Rec m4\n    Rec m1 m2 Rec m1 m3 Rec m3 Rec m3 Rec m3 Rec m1 m2 m4Rec m5 m6 m7 m7 m8.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros n m; elim n; simpl in |- *; auto.\nintros m1 Rec m1; case m; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m3 Rec m3 Rec m3; case m1; simpl in |- *; auto.\nintros m3 Rec m3; case m2; simpl in |- *; auto.\nintros m3 Rec m3; case m3; simpl in |- *; auto.\nintros m3 Rec m3; case m3; simpl in |- *; auto.\nintros m4 Rec m3; case m3; simpl in |- *; auto.\nintros m4 Rec m3; case m3; simpl in |- *; auto.\nintros m4 Rec m3; case m3; simpl in |- *; auto.\nintros m4 Rec m3; case m3; simpl in |- *; auto.\nintrosQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a b; elim n; simpl in |- *; auto.\nintros m H1; apply le_minus_O; auto with arith.\nintros m1 H1; apply le_minus_O; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; case b; simpl in |- *; auto.\nintros m1 H1; apply Rle_antisym; apply lt_O_n; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; elim H; simpl in |- *; auto.\nintros m H1; apply Rec; apply lt_minus_O; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; elim a; simpl in |- *; auto.\nintros n0 Rec m; case m; simpl in |- *; auto.\nintros m1 Rec m1; case m; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 RecQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c; elim b; simpl in |- *; auto.\nintros n0 Rec m n0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m0 Rec m1 Rec m1 Rec m1 m1 Rec m1 m2.\n  simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0; apply lt_plus_O; auto with arith.\nintros n1 Rec m1 n2 Rec m1 Rec m1 Rec m1 Rec m1 Rec m2 Rec m1 Rec m1 Rec m1 Rec m2 Rec m2 Rec m2 Rec m2 Rec m2 Rec m1 m2 Rec m2 Rec m1 m2 Rec m2 Rec m2 m2.\n  elim Rec; apply le_S_n; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; case b; simpl in |- *; auto.\nintros m1 H1; apply (Nat.inj_le 0); auto.\nintros m1 H1; apply (Nat.inj_le 0); auto.\nintros m1 H1; apply (Nat.inj_le 0); auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; elim a; simpl in |- *; auto.\nintros n0 Rec m H.\napply le_trans with (m := m); auto.\napply le_minus_O; auto.\nintros n1 Rec m H.\napply le_minus_O; auto.\nintros n1 Rec m H.\napply le_trans with (m := n0); auto.\napply le_minus_O; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; elim H; simpl in |- *; auto.\nintros m H1; elim H; simpl in |- *; auto.\nintros m1 H1; elim H1; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c; elim b; simpl in |- *; auto.\nintros n H1; case b; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1 n1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1 n1 Rec m1 n1 Rec m1; case m1; simpl in |- *;Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H; elim b; simpl in |- *; auto.\nintros m H1; apply le_trans with (m := m).\napply le_plus_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napply le_minus.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl_l.\nreplace a with (a - b).\nrewrite <- (plus_comm b c).\nrewrite <- (plus_comm b c).\nrepeat rewrite mult_assoc.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_comm.\nrepeat rewrite mult_comm.\nrepeat rewrite mult_assoc.\nrepeat rewrite mult_assoc.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite (fun x => plus_comm x a).Qed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite <- le_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse.\nrepeat rewrite plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl_l.\nrewrite (plus_comm a).\nrepeat rewrite plus_comm.\nrewrite <- le_plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l; auto with arith.\nrepeat rewrite plus_comm.\nrewrite (plus_comm b c).\nrepeat rewrite plus_comm.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_comm.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite mult_minus_simpl_l.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_comm.\nrewrite <- plus_plus_distr_r.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_comm.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_comm.\nrepeat rewrite plus_comm.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_assoc.\nrepeat rewrite (fun x => plus_comm x a).\nrepeat rewrite plus_assoc.\nrewrite (Qed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H0.\napply plus_minus; auto with arith.\nrewrite plus_plus_distr_r; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_le_compat_l with (p := a).\nrepeat rewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm; rewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_comm.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_comm; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eq_bool_dec a b); auto.\n  case (eqDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof.\n    intros a b H.\n    case (eq_dec a b); case (eq_dec a b); intro H; auto.\n    apply H in H0; auto.\n    apply H in H0; auto.\n  Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b.\n  case (eq_bool_dec a b); auto; intros H0; case H; auto.\n  case (eq_bool_dec b c); auto; intros H1; case H; auto.\n  case (eq_bool_dec b c); auto; intros H2; case H2; auto.\n  case (eq_bool_dec b c); auto; intros H3; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H4; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H5; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H3; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H3; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H4; case H3; auto.\n  case (eq_bool_dec b c); auto; intros H4; case H4; auto.\n  case (eq_bool_dec b c); auto; intros H5; case H5; auto.Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b H.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\n  destruct H; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b; case b; simpl in |- *; auto.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  intros H; discriminate.\n  introsDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b H.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_false_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_true_iff.\n  apply eq_false_iff.\n  apply eq_true_iff.\n  apply eq_false_iff.\n  apply eq_true_iff.\n  apply eq_false_iff.\n  apply eq_true_iff.\n  apply eq_false_iff.\n  apply eq_true_iff.\n  applyDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b H.\n  destruct (eq_dec a b); [left|right]; auto.\n  right; auto.\n  right; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b H.\n  destruct (eq_bool_dec a b) as [H1|H1]; destruct (eq_bool_dec a b) as [H2|H2]; trivial.\n  left; exists b; auto.\n  right; exists b; auto.\n  right; exists b; auto.\n  right; exists b; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; unfold eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nrewrite eq_bool_dec.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros. case (eq_bool_dec a b); intro H.\n  case (eq_bool_dec a b); intro H.\n  case (eq_bool_dec a b); intro H.\n  case (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  case (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  case (eq_bool_dec b b); intro H.\n  case (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  case (eq_bool_dec b b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  case (eq_bool_dec b b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  case (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  rewrite (eq_bool_dec a b); intro H.\n  caseDefined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros; injection H; intros; injection H; intros; injection H; intros; injection H; intros; injection H;\n intros; injection H; intros; injection H;\n intros; injection H; intros; injection H;\n intros; injection H; injection H; intros; injection H;\n injection H; intros; injection H;\n intros; injection H; injection H;\n intros; injection H; injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; intros; injection H;\n injection H; introsQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.\nintros m H; case n; simpl in |- *; auto.Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case a; simpl in |- *; auto.\nintros a b H1.\ncase (le_bool_dec a b); intros H2.\nrewrite H2; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; simpl in |- *; auto.\nintros n H; apply le_lt_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_lt_trans with (1 := H).\napply le_trans with (1 := H).\napply le_n_S.\napply le_trans with (1 := H).\napply le_trans with (Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case a; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintrosQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case a; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros H; inversion H.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H; apply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n0 H0; apply le_S_n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H0 H1; case b; simpl in |- *; auto.\nintros n1 H0; case b; simpl in |- *; auto.\nintros n1 H0; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H0; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H0; case b; simpl in |- *; auto.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl inQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H; apply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H; case b; simpl in |- *; auto.\nintros n1 H; caseQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; apply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n1 H; case b; simpl in |- *; auto.\nintros n1 H; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n2 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H; apply le_lt_trans with (1 := H); auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n2 H b; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H; elim H; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1 H b; case b; simpl in |- *; auto.\nintros n1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; simpl; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; generalize l1; elim l1; clear l1; simpl in |- *; auto.\nintros a1 l2; generalize (length_app l1 l2); elim l2; clear l1; simpl in |- *; auto.\nintros a2 l3; generalize (length_app l1 l3); elim l3; clear l3; simpl in |- *; auto.\nintros a1 l3; generalize (length_app l1 l3); elim l3; clear l3; simpl in |- *; auto.\nintros a3 l3; generalize (length_app l2 l3); elim l3; clear l3; simpl in |- *; auto.\nintros a3 l4; generalize (length_app l3 l4); elim l3; clear l3; simpl in |- *; auto.\nintros a3 l4; generalize (length_app l1 l3); elim l4; clear l3; simpl in |- *; auto.\nintros a4 l4; generalize (length_app l3 l4); elim l4; clear l3; simpl in |- *; auto.\nintros a3 l4; generalize (lengthQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros a1 l1 l2 H0; case l2; simpl in |- *; auto.\nintros a2 l1 l2 H0; case (H0 a1); simpl in |- *; auto.\nintros a2 l1 l2 H0; case (H1 a2); simpl in |- *; auto.\nintros a3 l4; case (H1 a3); simpl in |- *; auto.\nintros a4 l5 l6 H0; case (H1 a3); simpl in |- *; auto.\nintros a4 l5 l6 H0; case (H1 a3); simpl in |- *; auto.\nintros a4 l6 H0; case (H1 a3); simpl in |- *; auto.\nintros a4 l6 H0; case (H1 a4); simpl in |- *; auto.\nintros a4 l6 H0; case (H1 a3); simpl in |- *; auto.\nintros a4 l6 H0; case (H1 a4); simpl in |- *; auto.\nintros a5 l6 H0; caseQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros a1 l1 l2 H H0; elim H; clear H; intros; auto.\nintros a2 l1 l2 H H1; elim H; clear H; intros; auto.\nintros a2 l1 l2 H H2; elim H; clear H; intros; auto.\nintros a2 l1 l2 H1; elim H1; clear H1; intros; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros a1 l2; rewrite <- H; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros l1 l2; elim (length_app l1 l2); clear l2; simpl in |- *; auto.\nintros H; case H; auto.\nintros a1 l2 H; elim (length_app l2 l2); clear l2; simpl in |- *; auto.\nintros a2 l1 H1 H2 H3; elim (length_app l1 l2); clear l1; simpl in |- *; auto.\nintros a2 l3 H; elim (length_app l1 l3); clear l3; simpl in |- *; auto.\nintros a1 l2 H1 H2; elim (length_app l3 l3); clear l3; simpl in |- *; auto.\nintros a3 l4 H1 H2; elim (length_app l1 l3); clear l3; simpl in |- *; auto.\nintros a3 l4 H1; elim (length_app l1 l2); clear l3; simpl in |- *; auto.\nintros a3 l4 H1; elim (length_app lQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; exists (a1 :: l1); simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; generalize l1; elim l2; clear l1; simpl in |- *; auto.\nintros a l1 l2 Hl1; generalize l2; elim l2; clear l1; simpl in |- *; auto.\nintros a1 l2 Hl2; generalize l2; elim l1; clear l2; simpl in |- *; auto.\nintros a2 l1 Hl1; generalize l2; elim l2; clear l1; simpl in |- *; auto.\nintros a1 l2 Hl2; generalize l2; elim l2; clear l2; simpl in |- *; auto.\nintros a2 l3 Hl1; generalize l2; elim l3; clear l3; simpl in |- *; auto.\nintros a1 l2 Hl2; generalize l3; elim l3; clear l3; simpl in |- *; auto.\nintros a2 l3 Hl2; generalize l3; elim l3; clear l3; simpl in |- *; auto.\nintros a3 l3 Hl2; generalize l3; elim l3; clear l3; simpl in |- *; auto.\nintros a3 l4 Hl3; generalizeQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; revert l1 l2; induction l1 as [| a l1 IH]; intros; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l; rewrite length_app.\napply length_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3; elim l3; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2 H1 H2; case H.\nintros a2 l3; rewrite <- H1; auto.\nintros a1 l3 H1 H2; case H.\nintros a3 l4; rewrite <- H1; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3; elim l2; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros.\ndestruct (le_lt_dec n 0).\ncontradict H0.\nomega.\nomega.\nomega.\nomega.\nomega.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros nln; revert l t; induction n; intros; auto; intros.\n  case (le_lt_dec (S n) (S n)); intro.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); autoQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros.\n  induction n; intros.\n  simpl in |- *.\n  case (le_lt_dec n 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 0); intros.\n  simpl in |- *.\n  case (le_lt_dec (S n) 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 1); intros.\n  simpl in |- *.\n  case (le_lt_dec (S n) 0); intros.\n  simpl in |- *.\n  case (le_lt_dec (S n) 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 1); intros.\n  simpl in |- *.\n  case (le_lt_dec (S n) 0); intros.\n  simpl in |- *.\n  case (le_lt_dec (S n) 0); intros.\n  simpl in |- *.\n  case (le_lt_dec n 0); intros.\n  simpl in |- *.\n  case (le_lt_decQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n; destruct (le_dec (S n) 0).\n (* n = 0 *)\n replace (S n) with (S (S n)).\n rewrite S_INR.\n rewrite S_INR.\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S n) with (S (S n)).\n rewrite S_INR.\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S (S n)) with (S (S n)).\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S n) with (S (S n)).\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S (S n)) with (S (S (S n))).\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S n) with (S (S n)).\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S (S n)) with (S (S n)).\n rewrite S_INR.\n reflexivity.\n (* n = 0 *)\n replace (S (S n)) with (Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  rewrite <- minus_n_O.\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  rewrite <- minus_n_O.\n  rewrite <- minus_n_O.\n  apply le_lt_trans with (S n); [ assumption | apply le_O_Sn ].\n  rewriteQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros nln.\nreplace (n + 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n + 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_O.\nreplace (n - 1) with (n - 1) by omega.\nrewrite <- minus_n_Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros; induction n; simpl; intros.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  simpl; auto with arith.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nintros.\nintros.\ndestruct t as [| n]; simpl in |- *; try discriminate.\nrewrite H0 in H0.\nrewrite H1 in H0.\nrewrite H1 in H0.\nrewrite H1 in H0.\nrewrite H1 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H1 in H0.\nrewrite H0 in H0.\nrewrite H1 in H0.\nrewrite H0 in H0.\nrewrite H1 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in HQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  simple induction n.\n  intros.\n  simpl in H.\n  apply (IHn (S n) (S n)).\n  rewrite H0.\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_trans with (S n).\n  apply le_lt_trans with (S n).\n  apply le_transQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n as [| n IH]; simpl; auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\ndestruct (le_lt_dec n (ln l)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n.\nelim ln; auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n; rewrite H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n Hnt; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros nln l t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n.\nunfold replace_zero with (1:=0); auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros nln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros nln.\ninduction n; simpl in |- *; auto.\nintros n.\nassert (S n = S n).\napply lt_n_S.\napply lt_le_n_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_S.\napply lt_le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0ln1 ln2 t1 t2 l1 l2 H1 H2 H3.\ncase (lt_eq_dec n0 n); intros; auto.\nintros; discriminate.\nintros; discriminate.\nintros n0ln1 ln2 t1 t2 l1 l2 H H1 H2 H3.\ncase (lt_eq_dec n0 n); intros; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l; elim H; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l1 H1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln1 t2 l2 l1 H1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln1 t2 l1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l2 H1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l1 H1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t2 l1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l2 H1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l1 H2; elim H1; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l1 H1 H2; elim H1; simpl in |- *; auto.\nintros nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln t l H; elim H; simpl in |- *; auto.\nintros n0ln1 ln2 t2 l1 l2 H1; elim H1; simpl in |- *; auto.\nintros n0ln2 t1 t2 l1 l2 H2; elim H1; simpl in |- *; auto.\nintros n0ln2 t1 l1 l2 H2; elim H2; simpl in |- *; auto.\nintros n0ln2 t1 l1 l2 H1; elim H2; simpl in |- *; auto.\nintros n0ln2 t1 l1 l2 H2; elim H2; simpl in |- *; auto.\nintros n0ln2 t2 l1 l2 H H2; elim H2; simpl in |- *; auto.\nintros n0ln2 t2 l1 l2 H H2; elim H2; simpl in |- *; auto.\nintros n0ln2 t1 l1 l2 H1; elim H2; simpl in |- *; auto.\nintros n0ln2 t2 l2 H1 H2; elim H2; simpl in |- *; auto.\nintros n0Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln l t l H; elim H; simpl in |- *; auto.\nintros n0 ln2 t l1 l2 H1; elim H1; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln2 t l1 l2 H2; elim H1; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 H3; elim H1; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 H3; elim H2; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 H4; elim H3; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 H4; elim H4; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 l3 H4; elim H4; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 l3 H4; elim H4; simpl in |- *; auto.\nintros n0 ln3 t l1 l2 H4; elim H4; simpl in |- *; auto.\nintros n0 ln3 t l1Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros n0 ln1 t2 l1 l2 H1; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln l t H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln2 t1 t2 l H0; apply H; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln; case (le_lt_dec n 0); intro.\nrewrite ln1_abs; ring.\nintros; discriminate.\nintros n0 ln2 t1 t2 l; case ln2; simpl in |- *; auto.\nintros n0 ln1 t2 l1 l2 H0; case ln2; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln2 t1 t2 l1 l2 H0; case ln2; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln2 t1 t2 l2 H0; case ln2; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln2 t1 t2 l1 l2 H0; case ln2; simpl in |- *; auto.\nintros n0 ln2 t2 l2 l2 H0; case ln2; simpl in |- *; auto.\nintros n0 ln2 t1 t2 l1 l2 H0; case ln2; simpl in |- *; auto.\nintros n0 ln3 t3 l1 l2 H1; case ln2; simpl in |- *; auto.\nintros nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nln; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l t H; elim H; simpl in |- *; auto.\nintros n0 ln1 t2 l1 l2 H; elim H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H.\nunfold b in |- *.\nunfold b in |- *.\napply (H a b).\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'; case H'; auto with sets.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H.\nelim H.\nintros H1; elim H1; intros H2; elim H2; intros H3; elim H3;\n intros H4; elim H4; intros H5; elim H5; intros H6;\n elim H7; intros H8; elim H8; intros H9; elim H9;\n intros H10; elim H10; intros H11; elim H12; intros H12;\n elim H11; intros H11; elim H12; intros H12;\n elim H12; intros H13; elim H12; intros H13 H14;\n elim H14; intros H14 H14; elim H14; intros H15;\n elim H14; intros H15; elim H14; intros H14 H15;\n elim H14; intros H14 H15; elim H15; intros H15 H16;\n elim H15; intros H15 H17; elim H14; intros H16 H17;\n elim H17; intros H17 H18; elim H17; intros H18 H19;\n elim H18; intros H18 H19; elim H18; intros H18Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\n  intros a b H; case (Z_lt_dec a b); auto.\n  apply Z.lt_trans with b; auto.\n  apply Z.lt_trans with (b := b); auto.\n  apply Z.lt_trans with (b := b); auto.\n  apply Z.lt_trans with (b := c); auto.\n  apply Z.lt_trans with (b := c); auto.\n  apply Z.lt_trans with (b := c); auto.\n  apply Z.lt_trans with (b := c); auto.\n  apply Z.lt_trans with (b := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c); auto.\n  apply Z.lt_trans with (c := c);Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H; case (classic (b \\/ ~ a)).\nintro H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ b); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ b); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H; absurd (b \\/ ~ a); auto.\nintros H;Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H H0; apply (H a); auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto.\nintros a b H0; elim H; auto.\nintros b H0; elim H; auto.\nintros a b H0; elim H; auto.\nintros a b H0; elim H; auto.\nintros b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros a b H0; elim H0; auto.\nintros b H0; elim H0; auto.\nintros b H0; elim H0; auto.Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H'0.\nelim H'0; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H; case (classic (b -> ~ a)).\nauto with *.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; intros H1; elim H1; intros H2; elim H2; intros H3; elim H3; intros H4; elim H4;\n intros H5 H6; elim H7; intros H8; elim H8; intros H9;\n elim H9; intros H10 H10; elim H10; intros H11 H11; elim H11; intros H12;\n elim H10; intros H11 H12; elim H12; intros H13 H14;\n elim H12; intros H14 H15; elim H13; intros H14 H15;\n elim H14; intros H15 H15; elim H15; intros H15 H15; elim H15; intros H15 H16;\n elim H15; intros H15 H16; elim H15; intros H16 H16;\n elim H16; intros H16 H18; elim H17; intros H17 H18;\n elim H17; intros H18 H18 H20; elim H17; intros H18 H20 H19;\n elim H18; intros H18 H20 H19; elim H18; intros H20 H20 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case n; simpl; try (intros; discriminate).\nintros n1 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n2 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n3 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n4 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n4 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n4 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n4 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n4 H1; case (le_or_lt n1 n2); simpl; try (intros; discriminate).\nintros n5 H1; case (le_or_lt n1 n2); simpl; try (Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; simpl; auto with arith.\nintros H1; case H1; auto.\nintros n0; case n0; simpl; auto with arith.\nintros n1 H1; case n0; simpl; auto with arith.\nintros n1 H1; case n1; simpl; auto with arith.\nintros n2 H1; case n1; simpl; auto with arith.\nintros n0 H1; case n1; simpl; auto with arith.\nintros n0 H1; case n0; simpl; auto with arith.\nintros n2 H1; case n1; simpl; auto with arith.\nintros n3 H1; case n2; simpl; auto with arith.\nintros n4 H1; case n0; simpl; auto with arith.\nintros n4 H1; case n1; simpl; auto with arith.\nintros n5 H1; case n1; simpl; auto with arith.\nintros n4 H1; case n2; simpl; auto with arith.\nintros n4 H1; case n2; simpl; auto with arith.\nintros n4 H1; case n2; simplQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case n; unfold N.lt; simpl; auto with arith.\nintros n1 H1; case n1; unfold N.lt; simpl; auto with arith.\nintros n2 H1; case n1; unfold N.lt; simpl; auto with arith.\nintros n1 H1; case n2; unfold N.lt; simpl; auto with arith.\nintros n1 H1; case n1; unfold N.lt; simpl; auto with arith.\nintros n2 H1; case n2; unfold N.lt; simpl; auto with arith.\nintros n1 H1; case n2; unfold N.lt; simpl; auto with arith.\nintros n2 H1; case n1; unfold N.lt; simpl; auto with arith.\nintros n2 H1; case n1; unfold N.lt; simpl; auto with arith.\nintros n3 H1; case n2; unfold N.lt; simpl; auto with arith.\nintros n3 H2; case n3; unfold N.lt; simpl; auto with arith.\nintros n4 H1; case n2; unfold N.lt;Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; auto.\nintros n m H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H; case n; auto.\nintros p H;Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; simpl; try (intros; discriminate).\nintros m H; case n; simpl; try (intros; discriminate).\nintros m H; case m; simpl; try (intros; discriminate).\nintros; discriminate.\nintros m H; case m; simpl; try (intros; discriminate).\nintros; discriminate.\nintros m H; case m; simpl; try (intros; discriminate).\nintros n1 m1 H; case m; simpl; try (intros; discriminate).\nintros n2 m2 H; case m; simpl; try (intros; discriminate).\nintros m1 H; case m; simpl; try (intros; discriminate).\nintros m2 H; case m; simpl; try (intros; discriminate).\nintros m2 H; case m; simpl; try (intros; discriminate).\nintros m3 H; case m; simpl; try (intros; discriminate).\nintros m4 H; case m; simpl; try (intros; discriminate).\nintros m5 H; case m; simpl; try (intros; discriminate).\nintros m4 H; case m; simpl; try (intros; discriminate).\nintros n1 H; case m;Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H.\napply N.le_lt_trans with (m + n)%nat; auto.\napply N.le_le_trans with (m + n)%nat; auto.\napply N.le_lt_trans with (m + n)%nat; auto.\napply N.le_lt_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.le_trans with (m + n)%nat; auto.\napply N.Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case n; simpl; auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros; case (le_or_lt n m); auto with arith.\nintros;Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case n; unfold N.le; simpl; auto with arith.\nintros n0 H; case H; auto.\nintros n1 H1; case H; auto.\nintros n2 H2; case H; auto.\nintros n0 H1; case H; auto.\nintros n1 H1; case H; auto.\nintros n1 H2; case H1; auto.\nintros n1 H1; case H; auto.\nintros n2 H1; case H1; auto.\nintros n2 H2; case H; auto.\nintros n3 H1; case H1; auto.\nintros n3 H1; case H1; auto.\nintros n4 H1; case H1; auto.\nintros n4 H1; case H1; auto.\nintros n4 H1; case H1; auto.\nintros n5 H1; case H1; auto.\nintros n5 H1; case H1; auto.\nintros n4 H1; case H1; auto.\nintros n5 H1; case H1; auto.\nintros n5 H1; case H1Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case n; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1; case p; simpl; auto with arith.\nintros p H1Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; unfold N.gt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R.\napply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; apply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; pattern p at 2; rewrite <- (IZR_INZ p);\n rewrite <- (IZR_INZ p); auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite <- (IZR_INZ; rewrite Z2R_correct).\napply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (Z_lt_dec p); auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros; apply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; red; intro; apply Z2R_correct.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R in |- *; simpl in |- *; apply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (Rle_dec p p); auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p.\napply (Rlt_le_trans _ _ H).\nnow apply Z2R_correct; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct (eq_dec x y); [now apply Z.mul_1_nonneg|].\n rewrite <- (pow2_pos x); [|now apply Z.mul_1_nonneg].\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H.\napply (pow_pos x); apply pow_pos.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H; case (Rlt_irrefl x); auto.\nintros H; rewrite H; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H; unfold pols_test2, pols_test1, pols_test1.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].\n(*. *)\nintros x y H; unfold pols_test2.\ndestruct (pow_eucl_aux x y H) as [ | v l].Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros x y Hx Hy.\n destruct (Rle_or_lt y 0) as [Hx|Hx].\n apply Rle_trans with (y + y); try now apply Rlt_le.\n now rewrite Hy, Rplus_0_l, Rabs_R0; [|now apply Rlt_le].\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H; unfold x, y; simpl.\nnow rewrite <-!pow_1_r,!pow_1_r,!pow_1_r.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\nunfold pols_test.\ndestruct x, y; simpl.\nrewrite Pos.compare_spec; trivial.\nrewrite Pos.compare_spec; trivial.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros x y Hx Hy.\n destruct (lt_trichotomy x y) as [H|H].\n apply (lt_trichotomy x y).\n rewrite <- (Ropp_involutive x). apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_lt_contravar.\n apply Ropp_gt_contravar.\n apply Ropp_lt_Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros x y H.\n apply (pow_add_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros x y H.\n rewrite H.\n rewrite H.\n apply (pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- pols_test2.\napply Rle_trans with (1 := H).\napply pols_test1.\nrewrite <- pols_test2.\napply Rle_trans with (1 := H).\napply pols_test1.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test1.\napply Rle_trans with (1 := H).\napply pols_test1.\napply Rle_trans with (1 := H).\napply pols_test1.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (1 := H).\napply pols_test2.\napply Rle_trans with (Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite RoppQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\n generalize (pols_test2 x y H0); intro.\n apply (pow2 2 1 2).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply pols_test2.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pow_pos x y).\nrewrite <- (pow_pos x y).\napply pow_pos.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_correct 2).\napply (pow_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add x y) at 1; auto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add _ _ H).\nrewrite <- (pow_add _ _ H).\nrewrite <- (pow_add _ _ H).\nrewrite <- (pow_add _ _ H).\nrewrite <- (pow_add _ _ H).\napply pow_add; auto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add_pow2 1 x y).\nrewrite <- (pow_add_pow2 1 y).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewrite <- (pow_add_pow2 1 y).\napply mult_lt_compat_r with (1 := H).\nrewriteQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\n apply (pols_test2 (x + y - x)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ngeneralize (nat_of_P p).\ninduction p as [p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p IHp|p|p IHp|p IHp|p|p IHp|p IHp|p|p IHp|p|p|p|p IHp|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|p|pQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nunfold pols_test4.\nrewrite <- (pow2_th _ _ (pow2_th _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\napply Ropp_le_contravar.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_l.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (1 := H).\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_l.\nrewrite Ropp_Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite (pow_add_r_eq _ _ H).\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite pow_add_r_eq_1.\nrewrite powQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_add_pow2_pow2 _ _ _ (pow_add_pow2 _ _ _ _ _)).\napply (pow_add_pow2_pow2 _ _ _ _ (pow_add_pow2 _ _ _ _ _)).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_powQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nrewrite <- (pow_add_r x y H1).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pols_test4.\napply pols_test4.\napply pols_test4.\napply pols_test4.\napply pols_test5.\napply pols_test4.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nunfold pols.\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- Ropp_minus_distr_l_reverse.\nrewrite <- Ropp_minus_distr_l_reverse.\nrewrite <- Ropp_minus_distr_l_reverse.\nrewrite <- Ropp_minus_distr_l_reverse.\napply Ropp_minus_distr_l.\napply Ropp_minus_distr_l_reverse.\napply Ropp_minus_distr_l_reverse.\napply Ropp_minus_distr_r_reverse.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pols_test4.\napply pols_test4.\napply pols_test5.\napply pols_test4.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test6.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_test5.\napply pols_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nunfold pols.\nrewrite <- (fst_spec2 x).\napply (fst_spec2 y).\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pow2_r (y + z)).\nrewrite <- pow_add; auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncut ((x + y) * (y + z) < 2 * (x + y * z)).\nintros.\nrewrite <- (mult_assoc x y).\napply (mult_assoc x y).\napply (mult_assoc (x + y) z).\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply mult_assoc.\napply multQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\n rewrite <- (pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_powQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive z).\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive z).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive z).\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <-Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nunfold pols.\napply (pow2 2 2 3).\nrewrite <- (pow2 2 3).\nrewrite <- (pow2 2 3).\napply mult_le_compat_l.\napply pow_lt_compat_r.\nrewrite <- (pow2 2 3).\napply mult_le_compat_l.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napplyQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pow_pow2 _ x y).\napply (pow_pow2 _ x).\napply (pow_pow2 _ x).\napply (pow_pow2 _ y).\napply (pow_pow2 _ x).\napply (pow_pow2 _ x).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\napply (pow_pow2 _ y).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nsimpl.\nrewrite (pow_comm 1 2).\napply (pow_comm 1 2).\napply (pow_comm 1 2).\napply (pow_comm 1 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (pow_comm 2 2).\napply (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite (pow_is_exp x y).\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncut (x * x < y * (y + x * y)).\nintros.\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1; rewrite <- mult_1_l.\napply mult_reg_l with (2:=1).\nreplace (2 * (x + y) * (y + z)) with (2 * x + z).\napply mult_reg_l with (2:=1).\nrewrite mult_1_l.\napply mult_reg_l with (2:=1).\nrewrite mult_1_r.\nreplace (2 * (x + y) * (y + z)) with (2 * (x + y * z)).\napply mult_reg_l with (2:=1).\nrewrite mult_1_l.\napply mult_reg_l with (2:=1).\nrewrite mult_1_l.\nrewrite mult_1_r.\nrewrite mult_1_r.\nrewrite mult_1_r.\nrewrite mult_1_r.\nrewrite mult_1_r.\napply mult_reg_l with (2:=1).\nrewrite mult_1_r.\nrewrite mult_1_l.\napply mult_reg_r with (2:=1).\nrewrite mult_1_r.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 ; replace y with (1 * y + x * y + x * y * y).\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncut (0 < x * y * (x + y) * x).\nintros.\ncut (0 < x * y * x).\nintros.\napply H.\napply H.\napply H.\napply H1.\napply H0.\napply H.\napply H1.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply polf_test1.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply pols_test5.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nunfold pols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros x y H.\npattern (x * y) at 1 in |- *; replace (x * y) with (1 * (x * y)).\nrewrite <- (pow_plus 2).\nrewrite <- pow_add.\napply pow_add_pow_pow_pow_pow_pow.\napply pow_add_pow_pow_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_pow_pow_pow.\napply pow_add_pow_pow_pow.\napply pow_add_pow_powQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros x y.\n apply polf_test1.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napplypols_test1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (polf_test1 x y z H0).\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (Ropp_involutive z).\ngeneralize (Ropp_involutive z).\nunfold pols.\nintros.\nunfold pols.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napplyQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (pow2_spec y z).\nintros ;\napply polr_test1.\napply polr_test2.\napply polr_test2.\napply polr_test1.\napply polr_test1.\napply polr_test1.\napply polr_test2.\napply polr_test2.\napply polr_test1.\napply polr_test1.\napply polr_test2.\napply polr_test1.\napply polr_test1.\napply polr_test2.\napply polr_test1.\napply polr_test2.\napply polr_test2.\napply polr_test1.\napply polr_test1.\napply polr_test2.\napply polr_test1.\napply polr_test1.\napply polr_test2.\napply polr_test1.\napply polr_test2.\napply polr_test2.\napply polr_test1.\napply polr_test2.\napply poll_test2.\napply polr_test2.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (monr_test1 x y z H).\ninduction x;intros;subst;trivial.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply polr_test1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\n generalize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test1 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_test2 x z H).\ngeneralize (pols_test2 x y z H).\ngeneralize (pols_testQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (formula2P_test1 x y z H1).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pols.\nintros.\napply (pow_add_1 _ _ H1).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2))))))))) x)) x).\nintros.\ngeneralize (ar2 (ar2Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pols.\nunfold pols.\nunfold pols.\nunfold pols.\nunfold pols.\nunfold pols.\nrewrite <- mult_0_r.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_compat.\napply mult_0_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p; induction m; simpl; intros.\n - now rewrite mult_0_r.\n - now rewrite mult_0_r.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\nrewrite <- mult_comm.\napply mult_le_compat_l.\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_r p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_r p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_l p).\nnow apply (plus_lt_compat_r p).\nnow apply (plus_lt_compat_r p).\nnow apply (plus_lt_compat_l pQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H.\napply mult_le_compat_l.\napply mult_lt_compat_r.\napply mult_lt_compat_l.\napply mult_lt_compat_r.\napply mult_lt_compat_r.\napply mult_lt_compat_r.\napply mult_le_compat_l.\napply mult_lt_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros n m p; induction m; simpl; auto with arith.\n  simpl in H; rewrite plus_0_r; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p.\n apply (mult_lt_compat_r n m p); trivial.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros n m p.\n  destruct (le_gt_dec n m) as [p|p].\n  - now rewrite <- mult_assoc, <- mult_assoc.\n    now rewrite mult_comm, <- mult_assoc.\n  - now rewrite <- mult_assoc, mult_assoc, <- mult_assoc.\n  - now rewrite mult_assoc, <- mult_assoc, <- mult_assoc.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  unfold mult_lt.\n  rewrite mult_comm.\n  unfold p.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply le_trans with (p * p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).\n  apply le_trans with (p * n).Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p; destruct n; simpl; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H; case (mult_lt_dec n m) as [H|H].\nnow rewrite (plus_comm _ H).\nnow rewrite (plus_comm _ H).\nnow rewrite (plus_comm _ H).\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  generalize (plus_lt_compat_l m p).\n  generalize (plus_lt_compat_l p m).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (plus_lt_compat_r m p).\n  generalize (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1 H2; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_gt_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H2; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_gt_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_gt_compat_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H0; elim (mult_gt_compat_l p n); auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; introsQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; elim (mult_gt_compat_l n m p H).\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; elim H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H0; elim H; intros; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; elim H1; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; elim H; clear H; intros H1.\napply mult_lt_compat_l.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; elim H1; intros H2 H3; elim H2; intros H3 H4; elim H3; intros H4 H5;\n elim H5; intros H5 H6; elim H6; intros H6 H7; elim H7; intros H8 H9;\n elim H7; intros H10 H11; elim H7; intros H11 H12; elim H12; intros H12 H12;\n elim H7; intros H13 H14; elim H7; intros H12 H13 H14;\n elim H7; intros H12 H13 H14; elim H8; intros H13 H15;\n elim H8; intros H13 H15; elim H8; intros H15 H15; elim H16; intros H15 H16 H16;\n elim H17; intros H15 H16 H16 H17; elim H16; intros H16 H17 H17 H17 H18;\n elim H17; intros H18 H17 H18; elim H17; intros H18 H19 H19 H20 H20 H20 H20 H21 H22 H22 H24 H25 H24 H24Qed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; elim (mult_lt_compat_l p n m); intros; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case (mult_lt_compat_l n m p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case n; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H1; elim H1; intros.\napply (mult_lt_compat_l p n m); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H0; red; apply mult_lt_compat_rev_l2.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; elim H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H1; case H1; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; red; apply mult_lt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n > 0); auto with arith.\napply le_not_lt; apply mult_lt_compat_rev_l1; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * m = 0); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; elim H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; apply plus_lt_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case n; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case n; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; elim (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H H0; red; apply mult_gt_compat_rev_l2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nintros H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * n); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; elim (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0 H1; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_le; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nintros H2; absurd (p * n = m * n); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_le; apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n < p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt b a); auto with arith; intros H1.\nabsurd (p * 0 < b); auto with arith.\napply le_not_le; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt b a); auto with arith; intros H1.\nabsurd (p * a <= b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n <= m); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H1; case (le_or_lt m n); auto with arith; intros H2.\nabsurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H; case (le_or_lt 0 (S b)); auto with arith; intros H0.\nabsurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H; case (le_or_lt b n); auto with arith; intros H1.\nabsurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0 H1; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n > 0); auto with arith.\nunfold ge; apply lt_not_le; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt b 0); auto with arith; intros H1.\napply lt_mult_reg_l with b; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0 H1; case (le_or_lt 0 a); auto with arith; intros H2; absurd (p * n <= a); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt b a); auto with arith.\nintros n H1 H2; absurd (n > 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt 0 n); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt n m); auto with arith.\nintros n H1 H2; absurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt 0 a); auto with arith.\nintros n H0 H1; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1; case (le_or_lt a b); auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0 H1; case (le_or_lt n m); auto with arith; intros H3; absurd (p * n > 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt 0 a); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H H1; red; apply lt_mult_0_l.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; case (le_or_lt a b); auto with arith; intros H2; absurd (p * a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; case H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; case H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H; case (le_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; apply lt_mult_rev_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H1; case (le_or_lt 0 a); auto with arith.\nintros n H1 H2; absurd (n = 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H; red; apply lt_mult_0_l.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; red; apply lt_mult_reg_l with b; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H H0; red; apply lt_mult_reg_l with (a * b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case (le_or_lt b 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case (le_or_lt 0 b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case b; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H1 H2; red; apply lt_mult_reg_l with b; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case (le_or_lt n m); auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H0 H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H; case H; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H0; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case (le_or_lt a 0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H1; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H0; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H0; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H H0; case H; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; case (le_or_lt n n); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; case n; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H H0; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H0; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; case n; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e0 H1 H2 H3 H4 H5 H6 H7; subst.\nclear H1 H2 H3 H4 H5 H6 H7 H8 H9; subst.\nclear H H3 H4 H5 H6 H7 H8 H9 H10; subst.\nclear H3 H4 H4 H5 H6 H7 H8 H10; subst.\nclear H3 H4 H5 H7 H8 H9 H10; subst.\nclear H4 H5 H5 H7 H8 H9; subst.\nclear H4 H5 H8 H9 H10; subst.\nclear H4 H5 H8 H9; subst.\nclear H4 H5 H7 H8 H9; subst.\nclear H4 H5 H9; subst.\nclear H5 H5 H8; subst.\nclear H5 H8; subst.\nclear H5 H; subst.\nclear H5 H6 H8; subst.\nclear H5 H8; subst.\nclear H; subst.\nclear H5; subst.\nclear H; subst.\nclear H; substQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n intros a b c d e H0 H1 H2 H3; clear H1 H2 H3;\n clear H1;\n match goal with\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clear H\n  | H:?A |- _ => apply H; clearQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\n  intros a b c d e He H H0 H1 H2 H3 H4;\n  [ intros H5 H6; elim H6; clear H6; intros H7;\n  [ intros H7 H8; elim H8; clear H8; intros H8;\n  [ intros H8; elim H8; clear H8; intros H8;\n  [ intros H9; elim H8; clear H8; intros H9;\n  [ intros H10; elim H9; clear H9; intros H10;\n  [ intros H10; elim H10; clear H10; intros H10;\n  [ intros H10; elim H10; clear H10; intros H10;\n  [ intros H10; elim H11; clear H11; intros H10;\n  [ intros H10; elim H10; clear H10; intros H11;\n  [ intros H10; elim H10; clear H10; intros H11;\n  [ intros H10; elim H10; clear H10; intros H10;\n  [ intros H11; elim H11; clear H11; intros H11;\n  [ intros H11 H11; elim H12; clearQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H0 H1 H2 H3 H4 H5 H6 H7 H8; intros H1 H1 H2 H3 H4 H5;\n intros H1 H1 H2 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H2 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H1 H2 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H2 H3 H4 H5 H8 H9;\n intros H1 H2 H3 H4 H5 H7 H8 H9;\n intros H1 H2 H4 H5 H8 H9;\n intros H1 H1 H2 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H2 H3 H5 H8 H9;\n intros H1 H2 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H2 H1 H3 H4 H5 H6 H7 H8 H9;\n intros H1 H2 H2 H5 H8 HQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e f g h Hh Hh.\nassert (H : a * b <= a * c * c) by\n  (rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewrite h; rewrite h; rewrite h; rewrite h; rewrite h;\n   rewriteQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H.\nrewrite H; ring.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Ha Hb Hc.\nassert (H := (refl_equal e Ha Hc Hc Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd HdQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e f g h Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd HdQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros.\napply (fun t => match t with | 0 => 0 end).\nintro.\napply (fun t => match t with | 0 => 0 end).\nintro.\napply (fun t => match t with | 0 => 0 end).\nintro.\napply (fun t => match t with | 0 => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | 0 => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | 0 => 0 | S n => 0 | S n => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | S n => 0 | S n => 0 | S n => 0 | S n => 0 | S n => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | S n => 0 | S n => 0 | S n => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | S n => 0 | S n => 0 end).\nintro.\napply (fun t => match t with 0 => 0 | S n => 0 | S n => 0 | S n => 0 |Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e; pattern a, b in |- *; pattern b in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n pattern c in |- *;\n patternQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H0 H1 H2 H3 H4 H5 H6.\n(* Prove that it is not to show that it is not in a=0 *)\n\nLemma test_test1 : forall a b c d e, a >= 0 -> a < b -> a < b -> a * c >= 0 -> a * b < c * d -> 0 < e * d -> d = 0 -> c = 0.\nintros a b c d e H H H0 H1 H2 H3 H4 H5 H6 H7.\n(* Prove that it is not in a=0 *)\n\nLemma test_test2 : forall a b c d e, b > 0 -> a > 0 -> b > 0 -> d * d * d <= e * d -> a < b * d -> a < b * d -> a < b * d.\nintros a b c d e H H0 H1 H2 H3 H4 H5 H6 H7.\n(* Prove that it is not in a=0 *)\n\nLemma test_test2 : forall a b c d e, b > 0 -> a > 0 -> b > 0 -> a * c >Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\nelim H1; intros H1 H2; rewrite H2; rewrite H3; rewrite H3;\n clear H1 H2 H3 H4 H5.\n(* Prove that the following definitions are not in a simple\n   same as the left side of the left side of the right side of the right side of the right side of the right side of the right side of the right side of the right side of the right side of the right side of the right side *)\n\nLtac h_hyps :=\n match goal with\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] => idtac\n |  |- context [False] =>Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\napply H1.\napply H2.\napply H3.\napply H4.\napply H5.\napply H4.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H5.\napply H6.\napply H6.\napply H6.\napply H6.\napply H5.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napply H6.\napplyQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H5 H6 H7.\n(* a in a = b *)\n\nLemma hyp_test2 : forall a b c d e, a >= 0 -> a >= 0 -> b < c -> a * b > c -> d <= e * c -> d + e * e <= 0.\nintros a b c d e H H H H1 H2 H3 H4 H6 H7 H8 H9.\n(* a > 0 *)\n\nLemma hyp_test3 : forall a b c d e, a >= 0 -> b > 0 -> b <= c -> a * b > c -> d > e * c -> a * d <= b * e * c -> a <= b * c.\nintros a b c d e H H H1 H2 H3 H4 H5 H6 H7 H8 H9.\n(* a > 0 *)\n\nintros.\n\n(* a > 0 *)\n\nassert (H7 := H3 H0).\nclear H1.\n(* a > 0 *)\n\nassert (H7 := H3 H1).\nclear H H2 H3 H4 H5 HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2.\nassert (H3 := H4 H5).\nclear H1 H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H0.\nclear H2.\nclear H0.\nclear H0.\nclear H H3.\nclear H3.\nclear H2.\nclear H3.\nclear H2.\nclear H3.\nclear H3.\nclear H0.\nclear H3.\nclear H3.\nclear H2.\nclear H3.\nclear H3.\nclear.\nclear H3.\nclear H1.\nclear H3.\nclear H3.\nclear H2.\nclear H1.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H3.\nclear H.\nclear H3.\nclear H3.\nclear H.\nclear H0.\nclear.\nclear H3.\nclear H3.\nclear H3.Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\nelim H3; intros H4 H5.\nelim H4; intros H5.\nelim H5; intros H6.\nelim H6; intros H7.\nelim H6; intros H7.\nelim H7; intros H7.\nelim H8; intros H9.\nelim H9; intros H10.\nelim H8; intros H10.\nelim H9; intros H10.\nelim H10; intros H11.\nelim H11; intros H10.\nelim H10; intros H11.\nelim H11; intros H11.\nelim H11; intros H12.\nelim H12; intros H11 H13.\nelim H12; intros H13.\nelim H11; intros H13.\nelim H12; intros H13 H14.\nelim H13; intros H13 H14.\nelim H14; intros H14 H14.\nelim H14; intros H14 H14.\nelim H14; intros H14 H14; elim H14; intros H14 H14.\nelim H14; introsQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\napply H2.\nexact H3.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\nelim (H2 a); auto with arith.\n(* H3 unchanged *)\nhyp_nsign_tac H5.\n(* Prove it *)\n\nRequire Import ZArith.\n\n(* Test *)\n\nDefinition Z_of_nat (a b c: Z) := b * c * a.\n\nDefinition Z_of_nat (a b c: Z) := b * c * a + c.\n\nDefinition Z_of_nat (a b c: Z) := b * c * a + c.\n\nDefinition Z_of_nat (a b c: Z) := b * c * b + c.\n\nDefinition Z_of_nat (a b c: Z) := b * c + c * a.\n\nDefinition Z_of_nat (a b c: Z) := b * c + c.\n\nDefinition Z_of_nat (a b c: Z) := b * c * b + c.\n\nDefinition Z_of_nat (a b c: Z) := b * c + c.\n\nDefinition Z_of_Z (aQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3 H4 H5 H6 H7.\n(* Check that the hypothesis is not found *)\n\nLemma test_test_2 : forall a b c d e, b >= 0 -> a * c < b * c -> a = 0 -> 0 <= e * c -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* Check that the hypothesis is not found *)\nhyp_nsign_tac H3.\n(* Check that the hypothesis is not enough *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not used *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not in the hypothesis *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not used *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not be proved *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not fail *)\nhyp_nsign_tac H5.\n(* Check that the hypothesis is not *)\nhyp_nsign_tac H6.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* Prove it *)\n\nLemma hyp_test2 : forall a b c d e, a >= 0 -> a > 0 -> a > 0 -> a > 0 -> d > 0 -> d > 0 -> d > 0 -> e < 0.\nintros a b c d e H1 H2 H3 H4 H5.\ngeneralize (H3 H3 H4); clear H1 H2 H3 H5.\ngeneralize (H3 H3 H4); clear H3 H2 H3 H4 H5.\ngeneralize (H1 H2 H3); clear H3 H3 H5.\ngeneralize (H1 H2 H3); clear H3 H2 H3 H3 H4 H5.\ngeneralize (H5 H2); clear H3 H2 H5.\ngeneralize (H3 H2 H3 H4); clear H2 H3 H3 H4 H5.\ngeneralize (H1 H3 H4); clear H2 H5 H2 H5.\ngeneralize (H5 H3 H4); clear H5 H2 H3 H5.\ngeneralize (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros H1; case H1; auto.\nintros n1 H2; case (le_or_lt m1 m2); auto with arith.\nintros H1; case H1; auto.\nintros n1 H1; case (le_or_lt n1 m2); auto with arith.\nintros n1 H1; case (le_or_lt n1 m2); auto with arith.\nintros n2 H1; case (le_or_lt n1 m2); auto with arith.\nintros n3 H2; case (le_or_lt n1 m2); auto with arith.\nintros n4 H2; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p H1 H2; case H1; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m H1; case (le_or_lt n1 m); auto with arith.\nintros n1 H2; case (le_or_lt n1 m1); auto with arith.\nintros m1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 H2; case (le_or_lt n1 m2); auto with arith.\nintros m1 H2; case (le_or_lt n1 m2); auto with arith.\nintros m2 H3; case (le_or_lt n1 m1); auto with arith.\nintros m3 H4; case (le_or_lt n1 m2); auto with arith.\nintros m3 H4; case (le_or_lt n1 m2); auto with arith.\nintros m4 H5; case (le_or_lt n1 m2); auto with arith.\nintros m4 H5; case (le_or_lt n1 m2); auto with arith.\nintros m4 H5; case (le_or_ltQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m H; case n; simpl; auto with arith.\nintros m H; case H; auto with arith.\nintros m1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 H2; absurd (nat_of_P p2 > nat_of_P p2)%nat; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m H; elim H; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; simpl; auto with arith.\nintros n1 H1; case H1; auto with arith.\nintros n2 H2; case H2; auto with arith.\nintros n1 H2; case H1; auto.\nintros n1 H2; case H2; auto.\nintros n1 H2; case H2; auto.\nintros n2 H3; case H2; auto.\nintros n1 H3; case H3; auto.\nintros n1 H3 H4; case H3; auto.\nintros n2 H4; case H3; auto.\nintros n1 H3 H4; case H3; auto.\nintros n2 H4; case H4; auto.\nintros n2 H4; case H4; auto.\nintros n2 H4 H5; case H4; auto.\nintros n2 H4 H5; case H4; auto.\nintros n1 H4 H6; case H5; auto.\nintros n1 H6 H6 H7; case H5; auto.\nintros n1 H7 H8; case H6;Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n2 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nintros n1 H1;Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros n2 H2; case (le_or_lt n1 m1); auto with arith.\nintros m2 H3; case (le_or_lt n1 m2); auto with arith.\nintros m3 H4; case (le_or_lt n1 m2); auto with arith.\nintros m3 H4; case (le_or_lt n1 m3); auto with arith.\nintros n4 m5 H5 H6; case (le_or_lt n1 m3); auto with arith.\nintros m4 H6; case (le_or_lt n1 m3); auto with arith.\nintros m4 H6; case (le_or_lt n1 m4); auto with arith.\nintros m5 H6; case (le_or_lt n1 m3); auto with arith.\nintros m4 H6; case (le_or_lt n1 m2); auto with arith.\nintros m4 H6; case (le_or_lt n1 m3Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl in |- *; auto with arith.\nintros n1 H1; case H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros m H; case H; auto with arith.\nintros m1 H1; case H; auto with arith.\nintros m2 H1; case H; auto with arith.\nintros m1 H2; case H1; auto with arith.\nintros m2 H2; case H2; auto with arith.\nintros m2 H1 H2; case H2; auto with arith.\nintros m3 H1 H2; case H2; auto with arith.\nintros m3 H1 H2; case H2; auto with arith.\nintros m3 H2; case H1; auto with arith.\nintros m3 H2; case H2; auto with arith.\nintros m3 H2; case H2; auto with arith.\nintros m3 H2; case H2; auto with arith.\nintros m4 H2; case H2; auto with arith.\nintros m4 H2 H2; case H2; auto with arith.\nintros m4 H1 H2; case H2; auto with arith.\nintros m3 H2 H3; case H2Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros n0 H; elim H; auto.\nintros m n1 H; elim H; auto.\nintros m1 n2 H0; elim H; auto.\nintros m2 n3 H1; elim H; auto.\nintros m3 n4 H1 H2; elim H1; auto.\nintros m3 n4 H1 H2; elim H1; auto.\nintros m3 n4 H1 H2; elim H2; auto.\nintros m4 n4 H1 H2; elim H2; auto.\nintros m4 n5 H1 H2; elim H2; auto.\nintros m4 n5 H1; elim H1; auto.\nintros m4 n5 H1 H2; elim H2; auto.\nintros m4 n5 H2 H2; elim H2; auto.\nintros m4 n5 H1; elim H2; auto.\nintros m4 n5 H1 H2; elim H2; auto.\nintros m4 n5 H1 H2; elim H2; auto.\nintros m4 n5 H1Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; auto.\nintros n1 H1; case (le_or_lt n1 m1); auto.\nintros m1 n2 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros H2; case (le_or_lt n1 m); auto with arith.\nintros H2; case H2; auto with arith.\nintros n2 H3; case (le_or_lt n1 m1); auto with arith.\nintros H3; case H3; auto with arith.\nintros H4; case H4; auto with arith.\nintros H4; case H5; auto with arith.\nintros H4; case H5; auto with arith.\nintros H5; case H5; auto with arith.\nintros H5; case H5; auto with arith.\nintros H2 H5; case H5; auto with arith.\nintros H5 H6; case H5; auto with arith.\nintros H6 H6; case H6; auto with arith.\nintros H6 H6 H7; case H6; auto with arith.\nintros H7 H8; case H6; auto with arith.\nintros H8 H9; case HQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1 H1;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply lt_le_trans with (m := n); auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros n2; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1; auto.\nintros n1; case H1;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros n2 H1; case (le_or_lt n1 m1); auto with arith.\nintros n2 H2; case (le_or_lt n1 m2); auto with arith.\nintros n3 H3; case (le_or_lt n1 m2); auto with arith.\nintros n4 H5; case (le_or_lt n2 m1); auto with arith.\nintros n4 H5; case (le_or_lt n2 m1); auto with arith.\nintros n5 H5; case (le_or_lt n1 m2); auto with arith.\nintros n5 H6; case (le_or_lt n1 m2); auto with arith.\nintros n4 H6; case (le_or_lt n1 m2); auto with arith.\nintros n5 H6; case (le_or_lt n1 m2); auto with arith.\nintros n5 H6; case (le_or_lt n1 m2); auto with arithQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros n2 H1; case (le_or_lt n1 m1); auto with arith.\nintros n1 H2; case (le_or_lt n1 m2); auto with arith.\nintros n1 H2; case (le_or_lt n1 m2); auto with arith.\nintros n1 H2; case (le_or_lt n1 m1); auto with arith.\nintros n1 H2; case (le_or_lt n1 m2); auto with arith.\nintros n2 H2; case (le_or_lt n1 m2); auto with arith.\nintros n1 H2; case (le_or_lt n1 m2); auto with arith.\nintros n2 H2; case (le_or_lt n1 m2); auto with arith.\nintros n1 H2; case (le_or_lt n1 m2); auto with arith.\nintros n2 H2; case (le_or_lt n1 mQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply le_trans with (m := N.to_nat m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate);\n auto with arith.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; simpl; auto.\nintros n0 H1; case n; simpl; auto.\nintros n1 H1; case n; simpl; auto.\nintros n2 H2; case n; simpl; auto.\nintros n3 H1; case n; simpl; auto.\nintros n4 H1; case n; simpl; auto.\nintros n5 H1; case n; simpl; auto.\nintros n5 H1; case n; simpl; auto.\nintros n6 H1; case n; simpl; auto.\nintros n6 H1; case n; simpl; auto.\nintros n7 H1; case n; simpl; auto.\nintros n6 H1; case n; simpl; auto.\nintros n6 H1; case n; simpl; auto.\nintros n7 H1; case n; simpl; auto.\nintros n8 H1; case n; simpl; auto.\nintros n10 H1; case n; simpl; auto.\nintros n8 H1; case n; simpl; auto.\nintros n9 H1; case n; simpl; auto.\nintros n10 H1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros n1 H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m H; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros H; inversion H1.\nintros p H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate);\n auto.\nintros p H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; simpl; auto with arith.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_morphism; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m H1; case m; simpl; auto with arith.\nintros m1 n1 H1; case m; simpl; auto with arith.\nintros m2 n2 H1.\nrewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (S n2)); auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros n0 H1; case (le_or_lt n0 m); auto with arith.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros n2 H1; case (le_or_lt n1 m1); auto with arith.\nintros n3 H2; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m1); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n4 H1; case (le_or_lt n1 m1); auto with arith.\nintros n4 H1; case (le_or_lt n1 m2); auto with arith.\nintros n5 H1; case (le_or_lt n1 m2); auto with arith.\nintros n5 H1; case (Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m1));\n rewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m1));\n rewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (S m1));\n rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (S m2)); rewrite <- (Nat2N.id m2);\n rewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id m2);\n rewrite <- (Nat2N.id (S m2));\n rewrite <- (Nat2N.id (Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate); auto.\nintros n1 n2 H H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S n1)); auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; auto with arith.\nintros m1 n1 H1; case m; unfold N.lt; simpl; try (intros; discriminate).\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m H; case n; unfold N.lt; simpl; auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1));\n rewrite <- (Nat2N.id (S n1)); auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); intros; try discriminate; auto.\nintros m2 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n1 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m2 n2 H1; case (le_or_lt n1 m2); intros; try discriminate; auto.\nintros m1 n2 H1; case (le_orQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros m2 n2 H1; case (le_or_lt n1 m2); auto with arith.\nintros m1 n2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\nintros m2 n1 H1; case (le_or_lt n1 m2); auto with arith.\nintros m3 n3 H1 H2; absurd (nat_of_P p2 > nat_of_P p2)%nat; auto with arith.\nintros m3 n1 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\nintros m3 n3 H1 H2; absurd (nat_of_P p2 > nat_of_P p2)%nat; auto with arith.\nintros m3 n4 H1 H2; absurd (nat_of_P p2 > nat_of_P p2)%Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate); auto.\nintros n0 H1; inversion H1.\nintros n1 H1; inversion H1.\nintros n2 H1; inversion H1.\nintros n2 H1; inversion H1.\nintros n3 H1; inversion H1.\nintros n3 H2; inversion H1.\nintros n3 H2; inversion H1.\nintros n3 H2; inversion H1.\nintros n4 H3; inversion H1.\nintros n4 H2; inversion H2.\nintros n4 H3 H4; inversion H2.\nintros n4 H4; inversion H1.\nintros n4 H4; inversion H1.\nintros n4 H5; inversion H2.\nintros n4 H5; inversion H1.\nintros n4 H5; inversion H2.\nintros n4 H5; inversion H2.\nintros n4 H6; inversion H2.\nintros n4 H5; inversion H2.\nintros n4 H6; inversion H2.\nintros n4 H5; inversion H2.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n apply (pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow; trivial.\n apply pow_pos_pow_pow_pow_pow_pow_pow_pow_pow; trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\napply (pow_pos_pos x y).\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n apply (pow_pos 2 x).\n now rewrite <- pow_add.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct (zeq_nat x y) as [Hy|Hy].\n rewrite Hy.\n rewrite <- Hx.\n rewrite <- Hx.\n rewrite <- Hy.\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hy.\n rewrite <- Hx.\n rewrite <- Hy.\n rewrite <- Hy.\n rewrite <- Hy.\n rewrite <- Hy.\n rewrite <- Hy.\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n rewrite <- Hx.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hy.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n apply (pow_pos_pos x).\n rewrite <- Hx.\n apply (pow_pos_pos x).\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y.\n destruct (Pos.compare_spec x y) as [H|H]; [ | right]; rewrite H; trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y H.\n apply (pow_pos x y H).\n apply pow_pos.\n rewrite <- pow_add.\n apply pow_pos.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y Hx Hy.\n destruct (eq_dec x y) as [H|H].\n now rewrite <- H.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n apply Pos.add_le_compat.\n apply Pos.sub_le_compat.\n apply Pos.mul_sub_distr_r.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y H; case (Rle_bool_dec x y); intro H.\n apply H.\n rewrite <- H; apply Ropp_0_lt_contravar.\n apply (comp_wd x).\n rewrite <- H; apply Ropp_0_lt_contravar.\n apply Rle_lt_trans with (x + y).\n apply Rle_lt_trans with (y + y).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + x).\n apply Rlt_le_trans with (y + xQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n now rewrite <- (morph_com x y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add_pow2 _ _ (pow_add_pow2 _ _ x y)).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (pow_add_pow2 _ _ x y).\nrewrite <- (Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_correct radix2 x y H0).\napply (pow_correct radix2 x y H).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ncut (x - y < 0).\nauto.\nintro.\napply (pow2_pos x y).\napply (pow2_pos y).\nrewrite <- pow2_pos.\nrewrite pow2_pos.\napply (pow2_pos y).\nrewrite <- pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_pos.\napply pow2_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add_l _ _ _ H).\nrewrite <- (pow_add_r _ _ H).\nrewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_l.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_l.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _ _ H).\napply mult_lt_compat_r.\nnow rewrite <- (pow_add_r _Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pow_pos x y); auto with zarith.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nunfold pols.\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2_pos y).\napply (pow2Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_pos x y).\napply (pow_pos x y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nunfold pols.\nunfold pols.\nunfold pols.\nrewrite (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (arQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\n rewrite <- (pow_pos x).\napply pols_test1.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow_add x y H).\nrewrite pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite <- pow_add.\nrewrite pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nunfold pols.\nauto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_add 2 x y).\napply pow_add.\napply pow_lt.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nchange (x + y * (x + y)) with (1 * (x + y)).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- (pow_add 2).\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- (pow_add 2).\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_add.\nrewrite <- pow_addQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ncut (x < 0).\nintros ; apply Rle_trans with (1:=x).\napply Rle_trans with (1:=x).\napply Rle_trans with (1:=x).\napply Rlt_minus.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_lt_0_compat.\nnow apply Rinv_0_lt_compat.\nnow apply Rinv_0_lt_compat.\nnow apply Rinv_0_lt_compat.\nnow apply Rinv_0_lt_compat.\nnow apply Rinv_0_lt_compat.\nnow apply Rinv_0_lt_compat.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_add 2 (x * y)) at 1; auto.\napply pow_add_r; auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1; rewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\napply Ropp_involutive.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ngeneralize (nat_div_eucl x y).\nauto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (Ropp_Ropp_opp y).\napply Ropp_0_le_contravar.\napply Rle_lt_trans with (1 := H).\napply Rle_trans with (1 := H0).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nrewrite <- (pow_mul_r x y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ngeneralize (pow_correct x y z H).\ngeneralize (pow_correct x y z H).\nrewrite pow_pow_correct; auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pow2_correct x).\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nunfold pols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 1 3; rewrite <- (Ropp_involutive z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Rle_lt_trans with (2 * x * y + z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Ropp_0_lt_contravar.\napply Rlt_le_trans with (2 * x * y + z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Rle_lt_trans with (2 * x * y + z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Rle_lt_trans with (2 * x * y + z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Ropp_0_lt_contravar.\napply Rlt_le_trans with (2 * y + z).\nrewrite <- (Ropp_involutive z).\napply Ropp_0_lt_contravar.\napply Rle_lt_trans with (2 * x).\nrewrite <- (Ropp_involutive zQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (Ropp_involutive z).\napply Rmult_le_compat_r.\nrewrite <- (Ropp_involutive z).\napply Ropp_le_contravar.\nrewrite <- (Ropp_involutive z).\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_lt_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_lt_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncut (x * y < 0).\nintros ; apply (pow_pos x y); auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nreplace (x + y * z) with ((x * y) * (x + z) * (x + y * z)).\nrewrite <- (pow_1_r 2); auto.\nrewrite <- (pow_1_r 2); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\n apply pols_test1.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern (x * y)%R at 2 in |- *.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (multQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncut (y <= 0).\nintros.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply HQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncut (0 <= x * y * x * y).\nintros.\n apply H.\napply Rle_trans with (1 * y * x * y * x).\napply Rle_trans with (1 * y * x * y * y).\napply Rplus_le_compat_l.\napply Rle_trans with (1 * y * x * y * x).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napplyQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\n rewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncut (0 < x * y * x).\nintros.\napply H1.\napply Rle_lt_trans with (1 := H).\napply H0.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H1.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H4.\napply H4.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nunfold pols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply polf_test1.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nring.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply Rle_trans with (1:=0) ; try apply (pow2_ok).\nrewrite (pow2_ok 0).\napply (pow2_ok 0).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 1).\napply (pow2_ok 2).\napply (powQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nunfold pols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply (fun x => 0) 0%nat%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0) 0%nat.\napply (fun x => 0Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncut (0 <= x).\nintros.\ncontradict H.\napply (fun x => H).\napply H0.\napply (fun x => H).\napply H.\napply (fun x => H).\napply H0.\napply H.\napply (fun x => H).\napply H0.\napply (fun x => H).\napply H0.\napply H0.\napply (fun x => H).\napply (fun x => H).\napply H0.\napply H0.\napply (fun x => H).\napply H0.\napply (fun x => H).\napply H0.\napply (fun x => H).\napply (fun x => H).\napply (fun x => H).\napply H0.\napply (fun x => H).\napply (fun x => H).\napply H0.\napply H0.\napply (fun x => H).\napply H0.\napply (fun x => H).\napply (fun x => H).\napply (fun x => H).\napply (fun x => H).\napply (fun x => H).\napply H0.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\napply (pow_add_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npolf.\nrewrite <- (pow_add 1 1 2).\nrewrite <- (pow_add 1 2).\napply pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros x y z H H0.\napply (pow2_correct x y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (pow2_correct y z H).\napply (powQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pols.\napply (pow_pos x y).\napply (pow_pos x y).\nrewrite <- mult_assoc.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test1.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test1.\napply pols_test2.\napply pols_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (nat_eq_dec z).\napply H0.\napply nat_eq_refl.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (pol_spec x y z H0).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x * y < 2 * z * x).\nintros.\napply (pow_pos 2 (x * y)); auto.\nrewrite <- H1.\napply pow_pos_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H2.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.\nrewrite H1.\napply pow_pos.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (monf_test1 x y z).\nintros.\ngeneralize (monf_test1 x y z).\nintros.\ngeneralize (monf_test1 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nintros.\ngeneralize (monf_test2 x y z).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (nat_of_P_eq_1 x).\nintros.\napply Rle_lt_trans with (2*x+y).\nnow apply H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H2.\napply H2.\napply H2.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (exprf_test1 x y z H).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2_ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2))))%rat))))))\n       (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2 (ar2_correct (ar2 (ar2 (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_O_n; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply lt_O_n; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_trans with n; assumption.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_trans with n; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply Nat.inj_lt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply le_trans with (p * n); auto with arith.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_trans with n; auto.\napply Nlt_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (m * n) by omega.\napply Nlt_trans with (mQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans with (m := n); try assumption.\napply Nlt_trans withQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_r; apply lt_O_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_r; apply gt_O_r.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_ge_compat_l; apply lt_n_S; repeat rewrite N2Nat.inj_mul.\napply plus_ge_compat_l; apply lt_n_S; repeat rewrite N2Nat.inj_mul.\napply plus_ge_compat_l; apply le_n_S; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_Sn.\napply (mult_ge_compat_r n m p); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply le_trans with p; auto.\napply (mult_ge_compat_l p n); rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply le_trans with p; auto.\napply (mult_ge_compat_l p n); rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_le_weak; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply le_trans with n; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_r; apply le_trans with n; auto.\nrewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_n_S; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_INR.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_trans with n; try rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply lt_N_lt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply le_trans with (n * m); trivial.\napply lt_n_Sn.\napply lt_O_Sn.\napply le_trans with (m * n); trivial.\napply le_trans with (m * n); trivial.\napply lt_n_Sn.\napply lt_n_Sn.\napply lt_n_Sn.\napply le_trans with (m * n); trivial.\napply lt_n_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_Sn_n.\napply lt_Sn.\napply lt_O_Sn.\napply lt_Sn_n.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_n_Sn.\napply lt_Sn.\napply lt_n_Sn.\napply lt_O_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_n_Sn.\napply lt_Sn.\napply lt_nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_n_Sm.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_n_Sm.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Sn_O.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_trans with (m * n); try rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_O_n.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_ge_compat_l; apply gt_n_Sm.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_trans with (nat_of_N n) (nat_of_N m).\nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_O_n; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_trans with (nat_of_N n) (nat_of_N m).\nrepeat rewrite N2Nat.inj_mul; apply le_n_O.\nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply gt_O_nat; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_n_Sm; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nge_mult_rev_0_r with (nat_of_N b). \nrewrite <- NQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H0; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_le_trans with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply gt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_le_trans with (nat_of_N b). \nrewrite <- N2Nat.Qed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_l with (nat_of_N b).\nrepeat rewrite N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H1; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <-Qed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r with (nat_of_N b). \nrepeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply gt_multQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_r with (nat_of_N b).\nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply Nlt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Qed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H1; apply Nlt_le; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_1_r with (nat_of_N b).\nrewrite <- N2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nlt_gt; apply gt_mult_0_eq_0; apply gt_mult_0_eq_0;\n  apply Nle_0_eq_0; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; rewrite <- Nle_0_eq_0; apply Nle_0_eq_0.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nle_gt; apply Nle_gt; apply Nle_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nle_0_eq_0.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_0.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_0.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_0.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply Nle_0_eq_1.\nrewrite <- N2Nat.inj_mul; apply N2Nat.id.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Ngt_0_eq; apply Ngt_gt; apply Ngt_gt; apply Ngt_0_eq; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nle_0_eq_0.\nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_l with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_l with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_l with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_mult_rev_0_r with (Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nle_lt; apply Nle_0_eq_0.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n.\napply Ngt_gt; apply Ngt_0_eq_0; apply Nle_0_eq_0; apply Nle_0_eq_0.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Ngt_0_eq_0; apply Nle_0_eq_0; apply Nle_0_eq_0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.inj_mul; apply N.gt_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.inj_mul; apply N2Nat.id.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.id.\nrewrite <- N2Nat.id.\nrewrite <- N2Nat.id.\nrewrite <- N2Nat.id.\nrewrite <- N2Nat.id.\nrewrite <- N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewrite N2Nat.id.\nrewriteQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- N2Nat.inj_mul; apply N.le_0_eq_0_l.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite N2Nat.inj_mul; apply le_0_eq_0_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (- p * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n + p)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (-(p * n))%R; auto with real; try ring.\nreplace (- p * n)%R with (- p + (p * n))%R; auto with real; try ring.\nreplace (- p * n)%R with (- p + (p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (- p + (p * n))%R; auto with real; try ring.\nreplace (- p * n)%R with (- p * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; replace (p * m)%R with (- p * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with ((-p * n)%R); auto with real; try ring.\nreplace (p * n)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (- p * n)%R; auto with real; try ring.\nrewrite H1; ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; replace (p * n)%R with (- (p * n))%R; auto with real.\nrewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; replace (p * m)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (- p)%R; auto with real; try ring.\nrewrite (Rmult_comm (p * n))%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (-(p * m))%R; auto with real; try ring.\nreplace (p * n + p)%R with (-(p * n))%R; auto with real; try ring.\nreplace (p * n)%R with (-(p * m))%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; pattern n at 2; replace (p * m)%R with (p * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (- p * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; replace (p * n)%R with ((p * n)%R); auto with real; try ring.\nreplace (p * n)%R with (-(p * n))%R; auto with real; try ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n > 0)%R; auto with real.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n < 0)%R; auto with real; try ring.\napply Rle_trans with (1 := H2).\napply Rmult_le_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n <= p * n)%R; auto with real.\nrewrite <- (Rmult_comm n); auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rmult_le_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto.\nintros H1 H2; case (Rle_or_lt n m); auto.\nintros H3; case (Rle_or_lt n m); auto.\nintros H4; case (Rle_or_lt n m); auto.\nintros H4; case (Rle_or_lt n m); auto.\nintros H5; case (Rle_or_lt n m); auto.\nintros H6; case (Rle_or_lt n m); auto.\nintros H6; case (Rle_or_lt n m); auto.\nintros H6; case (Rle_or_lt n m); auto.\nintros H7; case (Rle_or_lt n m); auto.\nintros H7; case (Rle_or_lt n m); auto.\nintros H8; case (Rle_or_lt n m); auto.\nintros H8; case (Rle_or_lt n m); auto.\nintros H8; case (Rle_or_lt n m); auto.\nintros H9; case (Rle_orQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Zle_or_lt n m); auto; intros H2.\nabsurd (p * n <= 0)%R; auto with real.\nrewrite <- Rmult_assoc; rewrite <- Rmult_assoc; rewrite <- Rmult_1_l; auto with real.\nrewrite <- (Rmult_comm (INR n)); auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < n)%R; auto with real; try ring.\nrewrite H2; ring.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rmult_lt_reg_l with (- (p * m))%R; auto with real.\nrewrite <- H2; ring.\napply Rlt_not_le; apply Rmult_lt_reg_l with (- (p * m))%R; auto with real.\nrewrite <- H1; ring.\napply Rle_trans with (2 := H3); auto.\napply Rlt_not_le; apply Rmult_lt_reg_l with (- (p * m))%R; auto with real.\nrewrite <- H1; ring.\napply Rmult_le_pos_compat_l.\napply (H3 n).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (- (p * m))%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_regQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with n; auto with real.\nreplace (p * m)%R with (-(p * n))%R; auto with real; try ring.\napply Rmult_lt_reg_l with n; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with n; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with n; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= m)%R; auto with real; try ring.\nreplace (p * m)%R with (- p * n)%R; auto with real; try ring.\napply Rle_lt_trans with (m * n)%R; auto with real; try ring.\napply Rmult_le_compat_l.\napply Rmult_le_reg_l with (n * m)%R; auto with real; try ring.\napply Rlt_not_le; apply Rmult_lt_reg_l with (n * m)%R; auto with real; try ring.\nreplace (p * m)%R with (- p * n)%R; auto with real; try ring.\nrewrite <- Rmult_assoc; rewrite Rmult_comm; rewrite Rmult_1_l;\n apply Rmult_le_compat_l; auto.\napply Rinv_0_lt_compat; apply Rmult_lt_reg_l with (n * m)%R; auto with real; try ring.\nrewrite <- Rmult_assoc; rewrite Rmult_1_l;\n apply RmultQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n = p * n)%R; auto with real; try ring.\nrewrite (Rmult_comm n), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m).\napply Rmult_lt_compat_l; auto.\nrewrite (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m).\napply Rmult_le_compat_l; auto.\nrewrite (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_comm m), (Rmult_assoc m), (Rmult_assoc m), (Rmult_assoc m), (Rmult_comm m), (Rmult_assoc m).\nrewrite (Rmult_comm m), (Rmult_comm m), (Rmult_assoc m), (Rmult_assoc m), (Rmult_comm m), (Rmult_assoc m), (Rmult_assoc m).\napply Rmult_le_compat_l; auto.\napply Rmult_Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real; try ring.\nabsurd (p * n > 0)%R; auto with real; try ring.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r := p); auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * n)%R; auto with real.\napply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n = 0%R); auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rmult_lt_reg_r with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_r with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (1 := H3).\napply Rinv_0_lt_compat; auto.\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (1 := HQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < 0)%R; auto with real.\napply Rle_trans with (p * n)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_l with (n * m)%R; auto with real.\napply Rmult_lt_reg_Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Zle_or_lt n m); auto; intros H2.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (n * m)%R.\napply Rmult_lt_reg_l with (n * m)%R.\napply Rmult_lt_reg_l with (n * m)%R.\napply Rinv_0_lt_compat; apply Rmult_lt_compat_l; auto.\napply Rinv_0_lt_compat; apply Rmult_lt_reg_l with (n * m)%R.\napply Rinv_0_lt_compat; apply Rmult_lt_reg_l with (n * m)%R.\napply Rinv_0_lt_compat; apply Rmult_lt_reg_l with (n * m)%R.\napply Rmult_lt_reg_l with (n * m)%R.\napply Rinv_0_lt_compat; apply Rmult_lt_reg_l with (n * m)%R.\napply Rinv_0_lt_compat; apply Rmult_lt_regQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; pattern (p * n)%R at 1; rewrite <- Rmult_assoc.\nrewrite Rmult_comm.\napply Rmult_lt_compat_l_rev.\napply Rmult_lt_reg_l with (n * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_pos_pos; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Zle_or_lt n m); auto; intros H1.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rle_trans with (2 * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n = 0%R); auto with real.\napply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\napply Rlt_notQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_trans with (p * n)%R; auto with real.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rinv_0_lt_compat; auto.\napply Rinv_lt_compat; auto.\napply Rinv_lt_compat; auto.\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rinv_0_lt_compat; auto.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt m n); auto; intros H3.\nabsurd (p * n > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nrewrite Rmult_comm; rewrite <- (Rmult_comm m); rewrite <- Rmult_assoc;\n rewrite <- (Rmult_comm m); rewrite <- Rmult_assoc;\n rewrite <- Rmult_assoc; rewrite <- Rinv_l_sym;\n rewrite Rmult_1_l; rewrite Rmult_1_l; rewrite <- Rinv_r_sym;\n rewrite Rmult_1_l; rewrite <- Rmult_1_l;\n rewrite <- (Rmult_comm m); rewrite Rmult_assoc; rewrite <- Rinv_l_sym;\n rewrite <- Rmult_1_l; rewrite <- Rinv_l_sym;\n rewrite Rmult_1_l; rewrite <- Rmult_assoc;\n rewrite <- Rinv_l_sym;\n rewrite Rmult_1_r; rewrite <- Rinv_sym;\n rewrite Rmult_1_r; rewrite <- Rinv_r_sym;\n rewrite Rmult_l; rewrite <- Rinv_l_Qed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto.\nintros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l withQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * m < 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_pos_pos; auto.\napply Rle_trans with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_pos; auto.\napply Rlt_not_le; apply Rmult_lt_pos_pos; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_pos; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_le_pos_pos; auto.\napply Rle_not_lt; apply (Rabs_pos_pos_lt n m); auto with real.\napply Rlt_not_le; apply (Rabs_pos_lt n m); auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < 0)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_lt; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_lt; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos; auto.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rinv_0_lt_compat; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R.\napply Rmult_lt_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rmult_ge_reg_l with (r * n)%R.\napply Rinv_0_Qed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_not_le; apply Rmult_le_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < m)%R; auto with real.\napply Rle_lt_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rle_Qed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * m < 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto with real.\napply Rle_trans with (p * n)%R; auto with real.\napply Rlt_not_lt; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rinv_0_lt_compat; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_reg_l with (p * n)%R; auto with real.\nreplace (p * n)%R with (- (p * n))%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\napply Rmult_ge_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H0 H1; rewrite <- H1; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Zle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rmult_ge_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; apply Rmult_ge_pos_l; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_ge_pos_pos.\napply Rinv_0_lt_compat_l.\napply Rmult_ge_pos_pos.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rmult_lt_pos.\napply Rmult_ge_pos.\napply Rmult_ge_pos.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.\napply Rmult_ge_pos.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rmult_ge_pos.\napply Rinv_0_lt_compat.Qed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_pos; auto.\nrewrite <- (Rmult_comm (INR (S n))) at 1.\nrewrite <- Rmult_assoc; rewrite <- Rinv_l_sym.\nrewrite Rmult_1_l; rewrite Rmult_1_l.\nrewrite Rmult_comm; rewrite <- Rinv_r_sym.\nrewrite Rmult_1_l; rewrite Rmult_1_l; auto with real.\nrewrite Rmult_assoc.\napply Rmult_ge_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1 H2; apply Rmult_lt_compat_l_rev with p; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1 H2;\n apply Rmult_ge_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_ge_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n apply Rlt_not_le; apply Rmult_le_pos_pos_pos.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H;\n apply Rle_ge; apply Rmult_gt_compat_l; auto.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_lt_reg_l with p; auto with real.\nreplace (p * n)%R with (- p * n)%R; auto with real.\napply Rle_ge; apply Rmult_lt_reg_l with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n apply Rmult_gt_compat_l_rev with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1 H2;\n apply Rle_ge; apply Rmult_le_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; apply Rmult_gt_compat_l_rev.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1 H2;\n apply Rle_ge; apply Rmult_le_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; pattern (p * n)%R at 1 in |- *;\n apply Rmult_gt_reg_l with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; pattern m at 1 in |- *;\n apply Rle_ge; apply Rmult_ge_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Zle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_ge; apply Rmult_gt_compat_l_rev.\napply Rmult_gt_compat_l_rev.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rmult_gt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n case (Rle_or_lt n m); intros H2.\nabsurd (p * n = p * n)%R; auto with real.\napply Rle_ge; apply Rmult_lt_pos_reg_r with p; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos_pos; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos_pos; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos_reg_r with p; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos_pos; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rlt_not_le; apply Rmult_gt_pos_pos_pos; auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H0;\n case (Zle_or_lt n m); auto; intros H1.\nabsurd (p * n > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto with real.\napply Rle_ge; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rlt_not_eq; apply Rmult_gt_reg_l with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H0 H1;\n case (Zle_or_lt n m); auto; intros H3.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_lt_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_gt_pos_pos_pos.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; elim H1; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_trans with (p * n); auto with real.\napply Rlt_le_trans with (p * n); auto with real.\napply Rlt_le_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * n); auto with real.\napply Rlt_trans with (p * nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rmult_lt_compat_l_rev with p; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; pattern (y - x) at 1 in |- *;\n case (Rle_or_lt z y); intros H2.\nabsurd (z < z * x); auto with real.\napply Rle_trans with y; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; red; apply Rlt_trans with y; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; generalize (H1 x H2); clear x y H1 H2;\n intros H1;\n apply H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H'; case (Rle_or_lt x y); auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1;\n apply eq_Rlt_trans with (z * z) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * y) || (z * x) || (z * x) || (z * x) || (z * y) || (z * x) || (z * y) || (z * x) || (z * y) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * y) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x) || (z * x)Qed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1;\n unfold eq in |- *; rewrite H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H H1;\n apply Rmult_gt_reg_l with z; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H H0;\n case (Rle_or_lt x y); auto; intros H2.\nabsurd (z < z)%R; auto with real.\napply Rle_ge; apply Rmult_lt_pos_pos_lt; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H'; apply eq_Rlt_trans with z; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; pattern x at 1;\n case (Rle_or_lt x y); intros H2.\nabsurd (z <= z); auto with real.\napply Rmult_lt_reg_l with (y := z) (z := z) (r := r).\napply Rle_lt_trans with (z := z) (z := r).\napply Rle_trans with (z := z) (z := r).\napply Rle_lt_trans with (z := z).\napply Rle_trans with (z := z) (z := r).\napply Rlt_trans with (z := z).\napply Rle_trans with (z := z).\napply Rle_trans with (z := z).\napply Rle_lt_trans with (z := z).\napply Rlt_trans with (z := z).\napply Rlt_trans with (z := z).\napply Rle_trans with (z := z).\napply Rlt_trans with (z := z).\napply Rle_trans with (z := z).\napply Rle_lt_trans with (z := z).\napply Rlt_trans with (z := z).\napply Rlt_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply sym_equal with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply trans_equal with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply sym_equal.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply trans_equal with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case (le_gt_dec n m); intros; auto.\napply plus_le_reg_l with n; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_ge_reg_l with n; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H1; case H; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with y; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1 H2; case H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; apply eq_lt_trans with y; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case H0.\napply plus_le_reg_l with a; auto.\napply plus_le_reg_l with a; auto.\napply plus_le_reg_l with a; auto.\napply plus_le_reg_l with a; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; case H1.\napply plus_le_reg_l with p; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H0; pattern z; apply lt_le_trans with y; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply le_trans with y; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + b) P.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c < 0).\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npoll (a + c < d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < b + c + d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < a + b + c + d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npolr.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr H.\npolr H.\npattern (pospos (a + b)) at 1 in |- *;\n rewrite <- H0; rewrite H1; auto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + b) P.\n pattern (c + b) at 1.\nfield.\nfield.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c) P.\npattern (a + c) at 1 in |- *.\nreplace (a + c + c + c + c + c) with (c + c + d).\nreplace (a + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + cQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c) (c + c) (c + d).\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npoll.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c + c) P.\nunfoldpols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\npolr (a + c + c + c + c + d) P.\npols.\nauto.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\nrewrite <- H.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\nrewrite <- H.\npattern (Q a) at 1 in |- *.\npattern (Q a) at 1 in |- *.\nrewrite <- (Q a) at 1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros x y H.\npattern (x * y)%R at 1 in |- *.\napply Rmult_le_reg_l with (1 := H).\napply Rmult_le_reg_l with (1 := H).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npols.\nauto with real.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncut (0 < y)%R.\napply Rle_lt_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rle_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rle_lt_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=x).\napply Rlt_le_trans with (1:=xQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncut (0 < x * x * y)%R.\ncontradict H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncut (0 < x * y * (x - y) < 2 * (x * y + 1))%R.\nintros.\ncut (0 < y * x * (x - y) < 2 * (x * y + 1))%R.\nintros.\ncut (0 < y * x * (x - y) < 2 * (x * y - 1))%R.\nintros.\ncut (0 < x * y * (x - y) * (x - y) < 2 * (x - y - 1))%R.\nintros.\ncut (0 < x * (x - y * (x - y) < 2 * x + 1 * (x - y) * (x - y))%R.\nintros.\ncut (0 < x * y * (x - y * (x - y * (x - y)))%R.\nintros.\ncut (0 < x * y * (x - y * (x - y * (x - y)))%R.\nintros.\ncut (0 < x * y * (x - y * (x - y * (x - y)))%R.\nintros.\ncut (0Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern (x * y)%R at 1; replace (x * (y - x))%R with ((x * y - x))%R.\nrewrite H0.\nrewrite (pow2_r radix (x * y) (x * y)); auto.\nrewrite H1.\nrewrite H1.\nrewrite (pow2_r radix (x * y) (x * y)); auto.\nrewrite H0.\napply Rle_trans with (1 := H).\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nrewrite pow_add.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros x y H.\ncut (0 <= x * y * x).\nintros.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2); auto with real.\napply (pow_pos 2);Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncut (0 < y * x).\napply Rle_lt_trans with (1:=x * y + x * y * x).\napply Rplus_le_compat_l.\nrewrite <- (pow_1_r 2).\napply Rle_lt_trans with (1:=x * y + x * y + 1).\nrewrite <- (pow_1_r 2).\napply Rle_lt_trans with (1:=x).\napply Rplus_le_compat_l.\nrewrite <- (pow_1_r 2).\napply Rle_lt_trans with (1:=x).\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply RplusQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npolf.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive y).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutiveQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros x y H0 H1.\ncut (x * ((y - x) * (x + y) < x * (y - x))%R.\nintros.\ncut (0 < x * (y - x) * (x * (y - x) * (y - x) < 0)%R).\nintros.\ncut (0 < x * (y - x) * (y - x * y) < 0)%R.\nintros.\ncut (x * (y - x * y) < 0)%R.\nintros.\ncut (0 < x * y)%R.\nintros.\ncut (0 < x * y)%R.\nintros.\ncut (0 < y)%R.\nintros.\ncut (0 < y)%R.\nintros.\ncut (0 < y)%R.\nintros.\ncut (0 < y)%R.\nintros.\ncut (y - x * (y - x) < 0)%R.\nintros.\ncut (0 < x * y)%R.\nintros.\ncut (0 < x * y)%R.\nintros.\ncut (y - x * (y - xQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncut (x * (x / y) < 1)%R.\nintros.\ncut (0 < x * (y / x + 1))%R.\nintros.\ncut (0 < x * y)%R.\nintros H1 H2; contradict H1; auto.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H.\napply H1.\napply H3.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply HQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npolf.\nunfold pols.\nrewrite <- (Ropp_Ropp_involutive x).\nrewrite Ropp_involutive.\napply Ropp_involutive.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npolf.\nrewrite <- (mons_test3 x).\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nunfold pols.\nrewrite (pow_pow2 _ _ H).\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npolf.\nauto with real.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npols.\nauto with real.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros x y H H0.\npattern y at 1 in |- *.\nreplace y with (1 * x + y * (x * y + x * y))%R.\napply Rplus_le_compat_l.\napply H0.\napply Rle_lt_trans with (1 := H0).\napply H1.\napply Rle_lt_trans with (1 := H0).\napply H1.\napply Rle_lt_trans with (1 := H0).\napply H1.\napply Rle_trans with (1 := H0).\napply H1.\napply Rle_trans with (1 := H1).\napply H1.\napply Rle_trans with (1 := H0).\napply H1.\napply Rle_trans with (1 := H0).\napply H1.\napply Rle_trans with (1 := H1).\napply H1.\napply H2.\napply Rle_trans with (1 := H1).\napply H1.\napply Rle_trans with (1 := H0).\napply H1.\napply Rle_trans with (1 := H1).\napply H1.\napply Rle_transQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npolf.\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- Ropp_involutive.\nrewrite <- (Ropp_involutive (x * y)).\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <- Ropp_involutive.\nrewrite <-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x + y * x + z <= 2 * y * x + 2 * y).\nintros.\napply Rle_lt_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_lt_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rle_lt_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compatQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (ar2 x).\nintros.\ngeneralize (ar2 y).\nintros.\ngeneralize (ar2 x).\nintros.\nrewrite <- H0.\nring.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pols.\nrewrite <- (mons_test1 x y z H1).\napply (mons_test1 y z H1).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (nat_of_P_eq_opp _ H).\nintros.\nrewrite <- (Ropp_involutive z).\napply Ropp_involutive.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply polr_test1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply (comp_eq _ _ H).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (nat_of_P_compare x y).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintros ; apply (nat_of_P_lt 0).\nintrosQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros x y z H1.\nrewrite <- (pow2_mul x y z H1).\nring.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pols_test1.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (mons_test1 x y z).\nintros.\napply (mons_test1 x y z).\nrewrite <- H0.\nreplace (1 + (x - y) * (x - y)) with (1 + x * (y - x)); auto.\nrewrite <- H1.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H1.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H1.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H1.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H2.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H1.\nreplace (1 + x * (x - y)) with (1 + x * (x - y)); auto.\nrewrite <- H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H'; case H'; auto.\nintros H'0 H'1; case (Rlt_irrefl x); auto with real.\nintros H'1; case (Rlt_irrefl x); auto with real.\nintros H'1; case (Rle_irrefl x); auto with real.\nintros H'1; case (Rlt_irrefl x); auto with real.\nintros H'1; case (Rlt_irrefl x); auto with real.\nintros H'1; case (Rlt_irrefl x); auto with real.\nintros H'2; case (Rle_irrefl x); auto with real.\nintros H'2; case (Rle_irrefl x); auto with real.\nintros H'2; case (Rle_irrefl x); auto with real.\nintros H'3; case (Rle_irrefl x); auto with real.\nintros H'3; case (Rle_irrefl x); auto with real.\nintros H'4; case (Rle_irrefl x); auto with real.\nintros H'4; case (Rle_irrefl x); auto with real.\nintros H'4; case (Rle_irrefl x); auto with real.\nintros H'Qed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H'; rewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0 H1; apply Rle_ge; apply H1; apply H1; apply H2; apply H2; apply H1; apply H1; assumption.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; red; apply Rlt_le; assumption.\nrewrite <- (Ropp_involutive y); rewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge; apply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H1.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H0.\napply Rle_ge; apply H0.\napply H0.\napply Rle_ge; apply H0.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; pattern x, y; intros; apply Rlt_Rminus;\n [ assumption | apply Rle_ge; assumption ].\napply Rle_ge; apply Rle_ge; apply Ropp_le_contravar; apply Ropp_le_contravar; apply Ropp_ge_contravar;\n apply Ropp_le_contravar; apply Ropp_gt_contravar; apply Ropp_le_contravar; apply Ropp_gt_contravar;\n apply Ropp_le_contravar; apply Ropp_ge_contravar; apply Ropp_gt_contravar;\n apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar;\n apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar;\n apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar;\n apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar;\n apply Ropp_ge_contravar; apply Ropp_ge_contravar; apply Ropp_ge_contravar;\n apply Ropp_ge_contravar; apply Ropp_Qed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; rewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_le_trans with (y := (- x)%R).\napply Rle_ge; apply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; assumption.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; rewrite <- (Ropp_involutive x) in H.\nrewrite <- (Ropp_involutive x); auto with real.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_lt_contravar.\napply Ropp_ge_contravar.\napply Ropp_lt_contravar.\napply Ropp_lt_contravar.\napply Ropp_lt_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_ge_contravar.\napply Ropp_ge_contravar.\napply Ropp_ge_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_le_contravar.\napply Ropp_ge_contravar.\napply Ropp_le_contravar.\napplyQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; rewrite <- (Ropp_involutive y); auto with real.\napply Rle_ge; apply Rle_ge; apply Rplus_le_reg_l with (x * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_reg_l with (y * y)%R.\napply Rplus_lt_regQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;Qed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; apply Rle_ge; apply Rlt_le.\nintros x y H1 H2; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rlt_le; assumption.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y)%R; auto with real.\napply Rle_ge; apply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\napply Rlt_Rminus; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply RltQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_trans with x; auto with real.\napply Rlt_le; apply Rlt_trans with x; auto with real.\napply Rlt_le; apply Rlt_trans with x; auto with real.\napply Rlt_trans with x; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; assumption.\nintros H3; absurd (0 < x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; assumption.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; applyQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rlt_le; apply Rlt_le.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply RltQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; assumption.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_trans with (1 := H1); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge;\n apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge;\n apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge;\n apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rlt_ge;\n apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge;\n apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rle_ge; apply Rlt_ge;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le.\napply Rlt_le; apply Rlt_le; apply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_trans with (1 := H3).\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le.\napply Rlt_not_le; apply Rlt_le.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.\napply Rlt_trans with (1 := H2); auto with real.\napply Rlt_le.Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le;Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_trans with (1 := H);\n    auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x); auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le.\napply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le.\napply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply RltQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_Rminus; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n      apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_le; apply Rlt_le; apply Rlt_le;\n        apply Rlt_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npolf.\nauto with zarith.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ncut (x < 0)%Z.\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_lt_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_trans with (1 := H).\napply Rle_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ncut (x <= y * x * y * (x - y) < 2 * (x * y)).\nintros.\ncut (x <= y * x * y * (x * y) < 2 * x * y * x).\nintros.\ncut (x * y * x * y * x * y * (x * y - y) < 2 * x * y).\nintros.\nreplace (x * y * x * y * (x * y)) with (x * y * (x * y)).\nrewrite <- (mult_assoc x y).\nrewrite <- (mult_assoc y y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewrite <- (mult_assoc y).\nrewriteQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npolf.\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- x) * y)%Z).\napply (fun x y => (- xQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npolf.\nauto with zarith.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros x y H.\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (x = 0) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (0 < x) by (intros; omega).\ncut (Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npolf.\napply (fun x => 0 < x * x + 1)%Z.\napply (fun x => 0 < x * y)%Z.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros x y H0.\ncut (0 <= x * y * (x * y)).\nintro.\napply H1.\nrewrite <- H0 in H.\napply H.\nrewrite <- H0 in H.\napply H0.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npolf.\napply pols_test5.\nQed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nunfold orthogonal, orthogonal, orthogonal.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nProof.\nintros u v w; elim w; clear w w w; intros w w w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w' w w' w' w' w' w' w' w w' w' w' w' w' w' w' w w' w' w' w w w' w' w w w' w' w w' w' w' w' w w' w' w w' w' w w' w w' w' w w' w w' w w' w' w w' w' w w w' w'Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal).\nProof.\nintros u v; unfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal).\nintros?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal; intros.\napply pairwise_orthogonalP with (add (union (cons u v) (cons u v))).\napply pairwise_orthogonalP with (add (union (cons u v) (cons v v))); auto.\napply pairwise_orthogonalP with (add (union (cons u v) (cons v v))); auto.\napply pairwise_orthogonalP with (add (union (cons u v) (cons v (cons v v))).\napply pairwise_orthogonalP with (add (union (cons u v) (cons v (cons v v))); auto.\napply pairwise_orthogonalP with (add (union (cons v) (cons v (cons v v))); auto.\napply pairwise_orthogonalP with (add (union (cons v) (cons v (cons v (cons v v)))).\napply pairwise_orthogonalP with (add (union (cons v) (cons v (cons v (cons v (cons v v)))).\napply pairwise_orthogonalP with (add (union (cons (cons v) (cons v (cons v (cons v (cons v (cons v v)))).\napply pairwise_orthogonalP with (add (union (cons v) (cons v (cons v (cons v (cons v)))).\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nProof.\nintros u v w H.\nelim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nintros H; elim (eq_dec (u + v)); auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold parallel, dans in |- *; intros.\napply orthogonal_inv with (add (cons u v)) (cons (v v)); auto.\napply sym_equal; apply orthogonal_inv with (add (cons u v)); auto.\napply orthogonal_inv with (add (cons (v0 :: v) (cons (v0 :: v) (cons (v0 :: v))); auto.\napply sym_equal; apply orthogonal_inv with (add (cons v v) (cons (v0 :: v))); auto.\napply sym_equal; apply orthogonal_inv with (add (cons v) (cons (v0 :: v))); auto.\napply sym_equal; apply orthogonal_inv with (add (cons v) (cons (v0 :: v) (cons (v0 :: v))); auto.\napply sym_equal; apply orthogonal_inv with (add (cons v) (cons (v0 :: v) (cons (v0 :: nil))); auto.\napply sym_equal; apply orthogonal_inv with (add (cons (v0 :: v) (cons (v0 :: nil))); auto.\napply sym_equal; apply orthogonal_inv with (add (consQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold disjoint.\nintros.\napply orthogonal_sym.\napply orthogonal_sym.\napply pairwise_orthogonal with (add (cons u v) (cons v v)); auto.\napply pairwise_orthogonal with (add (cons u v) (cons v v)); auto.\napply pairwise_orthogonal with (add (cons v) (cons v v)); auto.\napply pairwise_orthogonal with (add (cons u v) (cons v)); auto.\napply pairwise_orthogonal with (add (cons (cons u v) (cons v) (cons v v))); auto.\napply pairwise_orthogonal with (add (cons (cons u v) (cons v) (cons v)); auto.\napply pairwise_orthogonal with (add (cons v) (cons (cons v) (cons v) (cons v) (cons v))); auto.\napply pairwise_orthogonal with (add (cons v) (cons v) (cons (cons v) (cons (cons v) (cons v) (cons v) (cons v))); auto.\napply pairwise_orthogonal with (add (cons (cons x) (cons (cons v) (cons x) (cons v) (cons (cons x)Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.\nunfold orthogonal.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, free in |- *; intros.\napply orthogonal_cons; auto.\napply orthogonal_cons; auto.\napply orthogonal_cons; auto.\napplyorthogonal_cons; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extensionQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nintros u v w; induction w; simpl in |- *; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply H; auto.\napply sym_equal; auto.\napply H; auto.\napply sym_equal; auto.\napply H; auto.\napply sym_equal; auto.\napply H; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extensionQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_aux.\napply symmetric_point_construction_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply H.\napply sym_eq.\napply sym_eq.\napply H.\napply sym_eq.\napply H.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply H.\napply H.\napply sym_eq.\napply sym_eq.Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel, parallel,Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply H1; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.\napply uniq_map_iff.Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply all_or_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extensionQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply all_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elim_elimQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply ex_intro with (add (cons u v) (cons v w)); auto.\napply ex_intro with (add (cons u v) (add (cons u v))); auto.\napply ex_intro with (add (cons u v) (add (cons v w))); auto.\napply ex_intro with (add (cons u v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); auto.\napply ex_intro with (add (cons x v) (cons v w)); autoQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, free in |- *; intros.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H2.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\napply H1.\napply H2.\napply H2.\napply H2.\napply H2.\napply H3.\napply H3.\napply H1.\napply H1.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H2.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4.\napply H3.\napply H4.\napply H1.\napply H4.\napply H3.\napply H.\napply H3.\napply HQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply (union_uniqueness (cons u v) (cons v w)); auto.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_n_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_n_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_O_Sn.\napply le_n_Sn.\napply le_O_Sn.\napply le_O_Sn.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire in |- *; intros.\napply union_inv with (add a (cons v w)); auto.\napply inter_inv with (union (cons u v) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (cons v w) (cons v w)); auto.\napply inter_inv with (union (Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply beta_1a; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, free in |- *; intros.\napply H with (add v (add a (cons v w))); auto.\napply H with (add (add a (cons v w)); auto.\napply H with (add (add a (cons v w)); auto.\napply H with (add a (cons v w)); auto.\napply H with (add a (cons v w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons (cons v w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons (cons v w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons (cons a w)); auto.\napply H with (add a (cons (cons a w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons a w)); auto.\napply H with (add a (cons a w)); auto.\napply H withQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, free in |- *; intros.\napply pred_le_n_O.\napply empty_hom with (add a (add a (cons v w)) (single v)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)) (add (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply empty_hom with (add a (cons v w)); auto.\napply le_O_n.\napply emptyQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, free in |- *; intros.\napply (diff_inv a (cons v w)); auto.\napply (diff_inv a (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv a (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_inv b (cons v w)); auto.\napply (diff_Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec b); auto.\napply (extension_dec b a); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napply (extension_dec a b); auto.\napplyQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. intros A B P1 P2 H1 H2 H3.\n  unfold dependent_ker.\n  repeat (let x := fresh \"x\" in intro x; destruct x as (x & H2); exists x; assumption).\nQed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\telim (le_or_eq (S n) (S m) (S (max n m) (max n m) H)).\n\tintros.\n\telim (le_or_lt (S m) (S m) (max n m) H)).\n\tintros.\n\telim (le_or_lt (S (max n0) (S m) (max n0 (S n0)) H)).\n\tintros.\n\telim (le_or_lt (S m) (S m) (max n m) H)).\n\tintros.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_r; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_l; auto with arith.\n\trewrite max_r; auto with arith.\n\trewrite max_r; auto with arith.\n\tQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_S_n m n); intros.\n\telim H. intros. simpl in |- *. apply le_n_S.\n\tsplit. simpl in |- *. intros. rewrite H. trivial.\n\trewrite max_l; auto with arith.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\telim (le_lt_or_eq n m).\n\tintros. simpl in |- *. rewrite H. trivial.\n\trewrite max_l; auto with arith.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_S_l m n); trivial.\n\tintros. simpl in |- *. elim (max_le_S_r n0 (max (S m0) (max n0 (S n0))) H0).\n\tintros. simpl in |- *. elim (max_le_S_r n0 (max (S m0) (max n0 (S m0)))) H0).\n\tintros. simpl in |- *. elim (max_le_S_r n0 (max (S m0) (max (S m0) (max n0 (S m0)))) H0).\n\tintros. simpl in |- *. elim (max_le_S_r n0 (max (S n0) (max (S m0) (max n0 (S m0)))) H0).\n\tintros. simpl in |- *. elim (max_le_S_r n0 (max (S n0) (max n0 (S m0)))) H0).\n\tintros. simpl in |- *. elim (max_le_S_l n0 (max (S m0) (max (S mQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; trivial.\n\tsimpl in |- *. rewrite <- (le_n_S m).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_S.\n\tapply le_n_n.\n\tapply le_nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros. simpl in |- *. elim (le_n_S m).\n\texact (le_S_n (max n0 n0) (max n0 n0)).\n\texact (le_n_S m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).\n\texact (le_S_n m).Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. split. exact (le_S_n 0).\n\tintros. elim H. intros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivialQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; simpl in |- *. split. exact (le_n_S m).\n\telim H. intros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *.Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\telim (le_or_lt (S m) (S m)).\n\tintros.\n\trewrite <- (le_n_n_O (max (S m0) n0)).\n\tapply le_n_S.\n\tapply le_n_n.\n\telim (le_or_lt (S m) (S m)).\n\tintrosQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; trivial.\n\tintros. simpl in |- *. elim (le_n_S _ H). intros.\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\tintros. simpl in |- *. apply le_n_S. apply le_n_S.\n\texact (le_S_n _ _ H).\n\tintro. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. elim (le_n_S _ _ H). intros.\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\texact (le_S_n _ _ H).\n\tQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (max_le_S_r n m). intros. exact (le_S_r n).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r n m).\n\texact (le_S_r nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\telim (le_n_O 0).\n\texact (le_n_O 0).\n\texact (le_n_O 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_n 0).\n\texact (le_S_nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\telim (le_Sn_O n). intros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\trewrite H.\n\texact H.\n\tintros.\n\trewrite H. reflexivity.\n\trewrite H.\n\texact H.\n\tintros.\n\trewrite H. reflexivity.\n\tintros.\n\trewrite H. reflexivity.\n\trewrite H.\n\texact H.\n\texact H.\n\tintros.\n\trewrite H.\n\texact H.\n\trewrite H.\n\texact H.\n\texact H.\n\texact H.\n\texact H.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. apply le_n_O.\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).\n\texact (le_Sn_O n).Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (max_le_S_r n m). intros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exact (le_S_r n).\n\tintros. exactQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n; simpl in |- *; trivial.\n\tapply le_n_O.\n\tapply le_n_O.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_n.Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n   intros.\n   elim (max_le_S_l n). intros. apply le_n_S. assumption.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n   intros. elim (max_le_S_l n). intros. rewrite H. reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. apply le_n_O. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_n_O 0). intros. exact (le_n_Sn n).\n\tintros. simpl in |- *. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. elim (max_l_S n m). intros. apply le_n_n. Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. elim (max_le_l_S n m). intros.\n\trewrite H. rewrite le_plus_n_Sm. rewrite plus_comm.\n\trewrite plus_n_Sm. rewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite <- le_plus_n_Sm. rewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite <- plus_n_Sm. rewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_assoc.\n\trewrite <- le_plus_n_Sm. rewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_assoc.\n\trewrite le_plus_n_Sm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_n_Sm.\n\trewrite plus_comm.Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. rewrite (plus_comm n m). rewrite (plus_comm m). rewrite (plus_comm m). rewrite (plus_comm m). rewrite (plus_comm m). rewrite (plus_comm m). rewrite <- (plus_comm m). rewrite plus_comm. rewrite plus_assoc. rewrite plus_comm. rewrite plus_assoc. rewrite <- plus_assoc.\n\t\trewrite <- (plus_comm m). rewrite plus_assoc. rewrite <- plus_assoc. rewrite <- plus_assoc.\n\tapply le_mult_l. rewrite plus_comm. rewrite <- plus_assoc.\n\tapply le_mult_r.\n\trewrite <- (plus_comm m). rewrite <- plus_assoc. rewrite (plus_comm m). rewrite plus_assoc.\n\tapply le_mult_l. rewrite plus_comm. rewrite plus_assoc.\n\trewrite (plus_comm m). rewrite plus_assoc. rewrite <- plus_assoc.\n\tapply le_mult_r. rewrite plus_comm. rewrite <- plus_assoc.\n\tapply le_mult_r. rewrite plus_comm. rewrite <- plus_assoc.\n\trewrite (plus_comm mQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\trewrite (plus_comm (S n)) at 1.\n\trewrite (plus_comm (S n)) at 1.\n\trewrite (plus_comm (S n)) at 1.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite <- plus_n_Sm.\n\trewrite plus_comm.\n\trewrite <- plus_n_Sm.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_n.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. elim H.\n\tintros. elim (le_S_n _ H).\n\tintros. simpl in |- *. elim (le_n_S _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_S_n _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_S_n _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_S_n _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_S_n _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_S_n _ H).\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. intros. elim (le_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. elim (le_O_n _ H).\n\telim (le_n_Sn 0). intros. simpl in |- *. rewrite H. trivial.\n\trewrite (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\trewrite <- (plus_comm (S n0)).\n\tQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. rewrite <- (plus_comm n m). rewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_comm m).\n\trewrite (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite <- (plus_assoc m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite <- (plus_comm m).\n\trewrite <- (plus_comm m). rewrite <- (plus_comm m). rewrite (plus_comm m).\n\trewrite <-Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. elim n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. reflexivity.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simplQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\n\tintros; simpl in |-Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. discriminate H.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. exact (le_mult_lS _ _ H).\n\tapply le_mult_r.\n\tapply le_mult_r.\n\texact (le_plus_r n (S m)).\n\tapply le_mult_r.\n\texact (le_plus_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_plus_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_plus_r n (S m)).\n\texact (le_plus_r n (S m)).\n\texact (le_plus_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_mult_r n (S m)).\n\texact (le_plus_r n (S m)).\n\texact (le_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. assumption.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H. trivial.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- H.\n\tapply le_mult_l.\n\texact (le_plus_r n (S m)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_commQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- le_mult_r.\n\trewrite <- le_mult_l.\n\tapply le_plus_r.\n\tapply le_mult_l.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply leQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tassert (H1 := minus_n_l m (S n)).\n\texact (plus_n_Sm_r n (S n)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm n (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plus_comm (S m)).\n\texact (plusQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\trewrite (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (plus_comm m (S n)).\n\texact (Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- (plus_n_Sm n). rewrite <- plus_n_Sm.\n\trewrite <- plus_n_Sm. rewrite <- plus_n_Sm.\n\trewrite plus_n_Sm. rewrite <- plus_n_Sm.\n\trewrite <- plus_n_Sm. rewrite plus_n_Sm.\n\trewrite <- plus_n_Sm. rewrite plus_n_Sm.\n\trewrite plus_n_Sm. rewrite plus_n_Sm.\n\trewrite <- plus_n_Sm.\n\trewrite plus_n_Sm. rewrite <- plus_n_Sm.\n\trewrite plus_n_Sm.\n\trewrite <- plus_n_Sm.\n\trewrite plus_n_Sm.\n\trewrite plus_n_Sm.\n\trewrite <- plus_n_Sm.\n\tapply plus_n_Sm.\n\texact (plus_n_Sm m (S m) (S n0 * S n0)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m) (S n0 * S n0)).\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- plus_n_Sm.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_n_n.\n\texact (le_n_Sn (S m)).\n\texact (le_n_Sn (S m)).\n\texact (le_n_Sn (S m)).\n\texact (le_Sn_S (S m)).\n\texact (le_n_Sn (S m)).\n\texact (le_n_Sn (S m)).\n\texact (le_Sn_S m)).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_n_Sn (S m)).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Sn_S m).\n\texact (le_Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- (plus_n_Sm m) in |- *.\n\telim (plus_n_O m (n + m * S n)).\n\texact (plus_n_Sm m (S n)).\n\texact (plus_n_Sm m (S n)).\n\texact (plus_n_Sm m (S n)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S n)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S n)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_n_Sm m (S m)).\n\texact (plus_Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- minus_n_O. rewrite <- minus_n_O.\n\texact (plus_comm m n).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\n\texact (plus_comm m (n + n0 * m)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_eq (S p) (S p)).\n\tintros.\n\trewrite H0. exact (le_plus_l n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_l n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_r n p).\n\texact (le_plus_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_eq (S p) (S p)).\n\texact (le_trans _ _ _ H0).\n\texact (le_S_n m p).\n\texact (le_trans _ _ _ H0).\n\texact (le_n_S p).\n\texact (le_S_n m p).\n\texact (le_S_n m p).\n\texact (le_plus_r n m).\n\texact (le_minus_r n m p).\n\texact (le_S_n m p).\n\texact (le_minus_r n p).\n\texact (le_minus_r n m p).\n\texact (le_minus_r n m p).\n\texact (le_minus_r n m p).\n\texact (le_minus_r n m p).\n\texact (le_minus_r n p).\n\texact (le_minus_r n m p).\n\texact (le_minus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_minusQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_mult_l.\n\telim (le_or_lt (S m) (S p)).\n\tintros.\n\trewrite H.\n\trewrite <- plus_assoc.\n\trewrite <- plus_assoc.\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite <- plus_assoc.\n\trewrite <- plus_assoc.\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite <- plus_assoc.\n\trewrite (plus_comm (S p)).\n\trewrite <- plus_assoc.\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite (plus_comm (S p)).\n\trewrite <- plus_assoc.\n\trewrite (Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H. rewrite <- plus_comm.\n\trewrite <- plus_comm.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_lt_or_eq _ _ H).\n\telim (le_or_eq _ _ H).\n\telim (le_lt_or_eq _ _ H).\n\telim (le_or_lt _ _ H).\n\tintros.\n\tapply (le_or_lt _ _ H).\n\telim (le_or_eq _ _ H).\n\tintros.\n\tapply (le_or_lt _ _ H).\n\trewrite (le_S_n_S n0).\n\texact (le_S_n n0 m H).\n\texact (le_S_n n0 m H).\n\texact (le_or_lt _ _ H).\n\texact (le_lt_S_n n0 m H).\n\texact (le_or_lt _ _ H).\n\texact (le_lt_n_n n0 m H).\n\texact (le_trans _ _ H).\n\texact (le_lt_n_S n0 m H0).\n\texact (le_or_lt _ _ H).\n\texact (leQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H.\n\trewrite H.\n\tapply le_mult_l.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite <- le_plus_l.\n\tapply le_mult_l.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_mult_r.\n\tapply le_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt p n). intros. elim H0; intros.\n\telim (le_or_lt p n0). intros. rewrite H0. exact (le_plus_l n0).\n\texact (le_n_S m n0).\n\texact (le_plus_l n (S m) (S m)).\n\texact (le_plus_l n (S m) (S m)).\n\texact (le_plus_l n (S m) (S m)).\n\texact (le_plus_l n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plus_r n (S m) (S m)).\n\texact (le_plusQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\treplace (p * p) with (p * n); trivial.\n\trewrite (plus_comm n (S p)).\n\tapply le_plus_r.\n\texact (le_minus_r n (S p)).\n\texact (le_minus_l n (S p)).\n\texact (le_plus_r n (S p)).\n\texact (le_minus_l n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_plus_l n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\texact (le_minus_r n (S p)).\n\tQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_lt_trans with (m * p); [ apply le_n_S; apply le_n_n; assumption | assumption ].\nQed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n  - now apply Ropp_0_lt_contravar.\n  - now apply Ropp_0_lt_contravar.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - exact Rlt_0_1.\n  - exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - apply is_linear_opp.\n  - apply is_linear_opp.\n  - apply is_linear_opp.\n  - now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - apply is_linear_opp.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - apply is_linear_opp.\n  - apply is_linear_opp.\n  - apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  split.\n  - exists 1%R.\n    exact Rlt_0_1.\n  - apply Rlt_0_1.\n  - apply Rlt_0_1.\n    now apply Rlt_0_1.\n  - apply Rlt_0_2.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - exists 1; split.\n    apply (proj1_sig (proj1_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig_sig (proj2_sig (proj2_sig_sig (proj2_sig (proj2_sig))))))))).\n  - exists 1; split.\n    exact Rlt_0_1.\n    apply Hn2.\n  - exists 1; split.\n    exact Rlt_0Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - now apply is_linear_opp.\n  - now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - exists 1.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - now apply Rlt_0_1.\n    exact Rlt_1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite!scal_r ; apply f_equal.\n    rewrite!scal_r ; apply f_equal.\n    rewrite f_equal.\n    rewrite pow_add.\n    rewrite f_equal.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewrite pow_add.\n    rewriteQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nintros k x.\nrewrite /is_linear.\nnow rewrite is_linear_opp.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  apply is_linear_scal_r with (2 := proj1 (proj1 (proj1 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))) (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))) (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n unfold is_linear in *.\nintros k.\nassert (Hx : (1 <= k)%R).\n  { apply Rle_lt_trans with (1 := proj1 (proj1 (proj1 (proj1 (proj1 (proj1 (proj1 (proj2 (proj1 (proj2 (proj2 (proj1 (proj1 (proj2 (proj1 (proj1 (proj2 (proj2 (proj1 (proj2 (proj1 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj1)))) (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\napply (iffP (fun k => k) => [k1 k2]; exists k1; split.\n  - apply/is_linear_scal_l.\n  - apply Rle_trans with (2 := proj1 (sqrt_inv_r _ _)).\n    rewrite /is_linear_scal_r.\n    apply f_equal.\n    apply f_equal, f_equal, f_equal.\n    apply f_equal, f_equal, f_equal.\n    apply f_equal, f_equal, f_equal.\n    now apply f_equal, f_equal.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  destruct x as [|k|k]; simpl; try easy.\n  - now rewrite!linear_opp,!linear_opp,!linear_opp,!linear_opp,!linear_opp,!linear_opp,!linear_opp,!linear_opp,!linear_opp.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  repeat split.\n  - move => k x.\n    by rewrite /is_linear /sum_def.\n  - move => k x.\n    by apply sym_eq.\n  - move=> k x.\n    by rewrite /is_linear /sum_def.\n  - move => k x.\n    by apply sym_eq.\n  - move => x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move => k x.\n    by apply: inj_eq.\n  - move => k x.\n    by apply: inj_eq.\n  - move => k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move => k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move=> k x.\n    by apply: inj_eq.\n  - move=>Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nintros k x.\ninduction x as [|x l IH].\n- (* x = 0 *)\n  - (* x = 0 *)\n    exists 1; exists 1; split.\n    now rewrite scal_distr_l.\n  - (* x = 0 *)\n    exists 1; split.\n    now rewrite scal_mul.\n  - (* x = 0 *)\n    exists (k * 1); split.\n    now rewrite scal_mul.\n    * rewrite scal_mul.\n      apply f_equal,!scal_mul.\n      apply f_equal.\n      now rewrite scal_mul.\n    * apply f_equal.\n      now rewrite scal_mul.\n    * apply f_equal,!scal_mul.\n      apply f_equal.\n      now rewrite scal_mul.\n    * apply f_equal.\n      now rewrite scal_mul.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nintros k x.\nassert (H0 : k * x <= 0) by apply (is_linear_scal_r _ (proj1 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))) (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\ninduction x as [|x|x IH]; simpl; trivial.\n - apply opp_plus.\n  - apply opp_mult.\n  - apply opp_plus.\n  - apply opp_opp_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  rewrite /is_linear.\n  now apply (is_linear_scal_l).\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  destruct (le_lt_dec k x) as [H | H].\n  - now apply @scal_distr_r.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply Rplus_le_lt_compat_l.\n    apply H.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_le.\n    apply Rplus_le_compat_l.\n    apply Rlt_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  rewrite /is_linear.\n  case: (Req_dec k 0) as [Hx|Hx].\n  - exists 1; split.\n    + apply Rplus_le_0_compat; [exact Hx | apply Hx].\n    + apply Rplus_le_compat_l.\n      apply pow_lt_compat.\n      apply pow_lt_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_lt_0_compat.\n      apply pow_ltQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  rewrite!scal_sum.\n  apply f_equal, f_equal, f_equal.\n  now apply f_equal, f_equal, f_equal.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  assert (H : is_linear (fun x : V => scal k x).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assert (H : is_linear (fun x : V => scal k x)).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assert (H : is_linear (fun x : V => scal k x).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assert (H : is_linear (fun x : V => scal k x)).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assert (H : is_linear (fun x : V => scal k x)).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assert (H : is_linear (fun x : V => scal k x)).\n  { destruct (scal k x) as (x,Hx).\n    now apply @scal_r. }\n  assertQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  rewrite!sum_const.\n  apply (fun k => proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2))))))))) k)) k)) x).\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_compat_r.\n    apply Rplus_le_compat_r.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_r.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_r.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_compat_l.\n    apply Rplus_le_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  destruct (Req_dec k 0) as [Hx|Hx].\n  - (* case [mult] is a linear function *)\n    assert (H : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now apply proj1_sig. }\n    assert (H' : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now apply proj2_sig. }\n    assert (H' : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now apply proj2_sig. }\n    assert (H' : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now apply proj2_sig. }\n    assert (H' : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now apply proj2_sig. }\n    assert (H' : forall n : K, (n + 1) * (n + 1) = (n + 1)).\n    { now applyQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  rewrite is_linear_scal_r, is_linear_scal_r.\n  apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2)))))))) _))).\n  apply is_linear_scal_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  repeat split.\n  - move => x.\n    rewrite /is_linear_scal.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.\n    rewrite /is_linear_opp.Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  revert k x.\n  induction k as [| k IHk]; intros k x.\n  - now rewrite!scal_distr,!scal_distr_l,!scal_distr,!scal_distr_r,!scal_distr_l.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply pow_le_0_compat.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n    exact Rlt_0_2.\n    exact Rlt_1.\n    exact Rlt_0_1.\n    exact Rlt_1.\n    exact Rlt_1.\n    exact Rlt_0_1.\n    exact Rlt_1.\nQed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; unfold divide, divide in |- *; intros; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (c := c) (c := c) (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c) (c := c).\n  apply divide_trans with (c := c).\n  apply divide_trans with (c := c).\n  apply divide_Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with a; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H; elim H; clear H; intros; apply H; clear H; intros;\n    elim (eq_nat_dec a b); intro; try (elim H; clear H; intro;\n      elim (eq_nat_dec a b); intro; try (elim H; clear H; intro;\n        elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n          elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n            elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n              elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n                rewrite H5 in H0; rewrite Zmult_1_r in H1;\n                  elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n                    elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n                    elim (Z_le_dec a b); intro; try (elim H; clear H; intro;\n                    rewrite H5 inQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (b * c).\n  apply divide_trans with (c * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a * c).\n  apply divide_trans with (a *Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - b).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - b).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - b).\n  apply divide_trans with (c - b).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c - b).\n  apply divide_trans with (c - a).\n  apply divide_trans with (c -Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_sym;\n    apply divide_sym; apply divide_sym; apply divide_Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_sym; apply divide_sym; apply divide_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a | b) -> (b | c).\n  intros; apply divide_trans with (a | b) -> (c | c).\n  intros; apply divide_trans with (a | b) -> (c | c).\n  intros; apply divide_trans with (a | b) -> (c | c).\n  intros; apply divide_trans with (b | c) -> (c | d).\n  intros; apply divide_trans with (c | c) -> (c | d).\n  intros; apply divide_trans with (a | b) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_trans with (c | d) -> (c | d).\n  intros; apply divide_Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c); auto with zarith.\n  apply divide_trans with (a := c);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H; clear H; rewrite Zmult_1_l in H;\n    rewrite Zmult_1_l in H;\n    replace (q * p) with (q * q * p0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0 * q0)\n        end);\n    intros; elim H0; clear H0; intros;\n      rewrite H1 in H0; rewrite H1 in H0; rewrite H1 in H0;\n        elim (Z_eq_dec a 0); intro;\n          [ unfold is_upper_bound; intro;\n            rewrite H4 in H1; rewrite <-Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_assoc in H0;\n    apply (divide_trans _ _ _ _ H0 H1); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H0 in H0; clear H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n    rewriteQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1).\n  rewrite H in H; clear H0; rewrite Zmult_1_l in H;\n    apply (Zdivide_intro a c (q0,H1)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H in H; clear H0; rewrite Zmult_comm in H;\n    apply (divide_trans (a | a) (q0,H1)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0) (q0,H0) (q0,H0) (q0,H1)).\n  rewrite H in H0; clear H0; rewrite Zmult_1_l in H0;\n    apply (Zmult_eq_compat_l (a * c) (q0,H0)).\n  apply (Zmult_eq_compat_l (a * c) (q0,H1)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;\n    rewrite Zmult_1_l in H0; clear H0;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H) (q0,H0) (q0,H0) (q0,H0) H0) H1 H2;\n    rewrite H in H1; clear H1; rewrite Zmult_comm in H0;\n    apply (Zdivide_intro a c (q0,H0) (q0,H1) H1); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_comm in H0;\n    apply (Zdivide_intro a c (q0,H1)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0) (q0,H1).\n  rewrite H in H0; clear H0; rewrite Zmult_comm in H0;\n    apply (Zdivide_intro a c (q0,H0) (q0,H1)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H0 in H; clear H; intro; rewrite H in H;\n    destruct (Qmult_rel_prime _ _ _ H) as (q0,H1);\n      [ rewrite H0 in H; rewrite H; ring | split; [ apply Zlt_le_weak; assumption | assumption ]\n      | generalize (Z_le_compat_l (x1 * x1) (x2 * x1));\n        clear H H1; intro; rewrite H;\n        rewrite <- H1 in H; rewrite H;\n        elim (Z_eq_dec x0 0); intro;\n          [ unfold is_upper_bound; intuition; exists x1; intuition\n            | rewrite H; ring ] ]\n      | generalize (Z_le_compat_l (x1 * x1) (x2 * x1));\n        clear H H1; intro; rewrite H;\n        rewrite <- H1 in H; rewrite H;\n        elim (Z_le_dec x 0); intro;\n          [ unfold is_upper_bound; intuition; exists x1; intuition\n            | split; [ apply Zlt_le_Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_1_l in H0;\n    apply (divide_trans _ _ _ H0).\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0) (q0,H1) (q0,H1) H);\n    rewrite H0 in H; clear H; intro; rewrite H in H;\n    apply (divide_trans _ _ H0 H1); assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0) (q0,H1);\n    rewrite H0; rewrite H1; rewrite H1; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; intro; rewrite H in H0;\n    apply (Zdivide_intro b c); assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_comm in H0;\n    apply (Zdivide_intro a c); assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_assoc; rewrite Zmult_comm;\n    apply (Zmult_lt_reg_l (a * b)); assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    replace (c * a) with (c * a); [ apply (Z_eq_dec a b); auto with zarith | ring ].\n  rewrite H0 in H0; rewrite H0 in H0; rewrite Zmult_0_l in H0;\n    rewrite (Zmult_comm a);\n    rewrite (Zmult_1_r b); rewrite (Zmult_comm a);\n      rewrite (Zmult_1_l b); rewrite (Zmult_comm b);\n        rewrite (Zmult_1_r b); rewrite (Zmult_1_l b);\n        rewrite (Zmult_1_l b); rewrite (Zmult_comm b);\n        rewrite (Zmult_1_r b); rewrite (Zmult_comm b);\n          rewrite (Zmult_1_l b); rewrite (Zmult_comm b);\n          rewrite (Zmult_comm b); rewrite (Zmult_1_l b);\n          rewrite (Zmult_1_r b); rewrite (Zmult_comm b);\n          rewrite (Zmult_1_l b); rewrite (Zmult_1_l b); rewrite (Zmult_1_l b);\n          rewrite (Zmult_1_lQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0) (q0,H1);\n    rewrite H0 in H0; clear H0; intro; rewrite H in H0;\n    generalize (Z_eq_dec (q0 * a)); intro;\n      rewrite H0 in H0; elim (Z_eq_dec (q0 * a)); intro;\n        [ apply Z.lt_irrefl with 0; assumption | apply Z.lt_irrefl with 0; assumption ]\n      | apply Z.lt_irrefl with 0; assumption ] ].\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H0) (q0,H1).\n  generalize (divide_0_l b q0); intro; rewrite H0 in H0;\n    generalize (divide_0_r b q0); intro; rewrite H0 in H0;\n      generalize (divide_r b q0); intro; rewrite H0 in H0;\n        generalize (divide_0_r b q0); intro; rewrite H0 in H0;\n          generalize (divide_r b q0); intro; rewrite H0 in H0;\n          generalize (divide_0_r b q0); intro; rewrite H0 in H0;\n          generalize (divide_r b q0); intro; rewrite H0 in H0;\n            rewrite H0 in H0;\n            elim (divide_0_r b q0); intro; rewrite H0 in H0;\n            generalize (divide_r b q0); intro; rewrite H0 in H0;\n            generalize (divide_r b q0); intro; rewrite H0 in H0;\n            generalize (divide_r b q0); intro; rewrite H0 in H0;\n            generalizeQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; elim (Z_eq_dec z 0); intro;\n    [ elim (Z_eq_dec z 0); intro; assumption | intro; rewrite H; assumption ].\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z.\n  apply divide_mult_r; apply divide_mult_r; assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; case z; intros; discriminate || reflexivity.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; red in |- *; intro; rewrite H in H;\n    discriminate || apply Zlt_le_weak; apply divide_mult_l.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; rewrite (Zmult_eq_reg_l _ _ H); auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; red; intro; apply Zdivide_mult_l; assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; elim (divide_0_l z); apply divide_mult_l;\n    [ apply divide_mult_l; assumption | apply divide_mult_l; assumption ].\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; generalize z; generalize z; generalize z; generalize z; clear z; intro;\n    apply Zdivide_intro with (q := z); assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H (q,H0); replace (z * x) with (z * x) by ring.\n  rewrite H0; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; induction z; simpl; auto with zarith.\n  intros; rewrite H; auto with zarith.\n  intros; rewrite H0; auto with zarith.\n  intros; rewrite H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H).\n  destruct (divide_dec z 0) as [H1 | H1].\n  apply divide_mult_l in H; assumption.\n  apply divide_mult_l; assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H0); apply divide_mult_l; assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H0); replace (q * (z * z)) with (q * (z - 1)); [ ring | ring ].\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_r.\n  apply divide_mult_l.\n  apply divide_mult_r.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_r.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_r.\n  apply divide_mult_l.\n  apply divide_mult_r.\n  apply divide_mult_l.\n  apply divide_Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H0); elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1; elim H1; clear H1; intro; elim H1; clear H1; intro;\n    generalize (Zmult_eq_reg_l _ _ _ H1); intro;\n      generalize (Zmult_eq_reg_l _ _ H1); intro;\n        generalize (Zmult_eq_reg_l _ _ H1); intro;\n          generalize (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_reg_l _ _ H1); intro; rewrite H1 in H1;\n            rewrite (Zmult_eq_Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H (q,H0); case (Z_lt_gt_dec z 0); intros;\n    [ case (Z_lt_gt_dec z 0); intro;\n      [ case (Z_lt_gt_dec z 0); intro;\n        [ case (Z_lt_gt_dec z 0); intro;\n        [ case (Z_lt_gt_dec z 0); intro;\n           [ case (Z_lt_gt_dec z 0); intro;\n              [ case (Z_lt_gt_dec z 0); intro;\n                  [ intro; absurd (z < 0);\n                    [ intro; case (Z_lt_gt_dec z 0); intro;\n                    [ apply Z_lt_le; apply Z_lt_le; apply Z_lt_le; apply Z_le_lt_incl; assumption\n                    | case (Z_lt_gt_dec z 0); intro;\n                    [ case (Z_lt_gt_dec z 0); intro;\n                    [ intro; apply Z_lt_le; apply Z_le_lt_incl; assumption\n                    | case (Z_lt_gt_dec z 0); intro;\n                    [ caseQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nintros.\ninversion_clear H.\nexact (Plus p 0).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 2).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 2).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexact (Plus p 1).\nexactSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n H.\nelim (lt_n_O n).\nintros n0 H.\nelim (lt_O_O_Sn n).\nintros n0 H1 H2.\nelim (lt_O_Sn n).\nintros n1 H1.\nelim (lt_O_Sn n).\nintros n2 H2.\nelim (lt_n_O_Sn n).\nintros n3 H3.\nelim (lt_O_Sn n).\nintros n4 H5.\nelim (lt_n_O_Sn n).\nintros n4 H5.\nelim (lt_n_O_Sn n).\nintros n4 H5.\nelim (lt_O_Sn n).\nintros n4 H6.\nelim (lt_n_Sn n).\nintros n5 H6.\nelim (lt_O_Sn n).\nintros n4 H6.\nelim (lt_O_Sn n).\nintros n4 H6.\nelim (lt_O_Sn n).\nintros n5 H6.\nelim (lt_O_Sn n).\nintros n5 H6.\nelim (ltSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\npattern n at 2 in |- *.\napply (lt_O_O_le _ _ H).\nauto with arith.\napply (lt_O_Sn_S _ H).\nauto with arith.\napply (lt_O_Sn_S _ H).\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; intros.\nintros n0 H1; elim n0; intros.\nintros n1 H2; elim n0; intros.\nintros n2 H3; elim n0; intros.\nintros n0 H3; elim n0; intros.\nintros n3 H4; elim n1; intros.\nintros n4 H5; elim n1; intros.\nintros.\nintros n4 H5; elim n2; intros.\nintros.\nintros n4 H5; elim n4; intros.\nintros n4 H6; elim n1; intros.\nintros n5 H6; elim n4; intros.\nintros.\nintros n5 H6; elim n2; intros.\nintros.\nintros n5 H6; elim n2; intros.\nintros.\nintros n5 H6; elim n1; intros.\nintros.\nintros n6 H7; elim n2; intros.\nintros.\nintros n5 H7; elim n2; intros.\nintros.\nintros.\nintros n6 H7; elim n2; intros.\nintros.\nintros.\nintros.\nintros nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\napply refl_equal.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nelim n; intros.\napply star_trans with (n := S 0).\napply plus_n_Sm.\napply plus_n_Sm.\napply plus_n_Sm.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_r.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_l.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_l.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.\napply plus_le_compat_r.Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\napply (plus_comm (n + 1)).\napply plus_comm.\napply plus_n_Sm.\napply plus_n_Sm.\napply plus_comm.\napply plus_n_Sm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_assoc.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_assoc.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_assoc.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napplySave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\napply plus_n_O.\nauto.\napply plus_n_Sm.\nauto.\napply plus_n_Sm.\nauto.\napply plus_n_Sm.\nauto.\napply plus_n_Sm.\nauto.\napply le_n_Sm.\nauto.\napply plus_n_Sm.\nauto.\napply le_n_Sm.\nauto.\napply le_n_Sm.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\napply plus_n_Sm.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\napply le_n_n.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nsimpl in |- *.\nintros n0 H.\nsimpl in |- *.\nintros n1 H0.\nsimpl in |- *.\nintros n2 H0.\nsimpl in |- *.\nintros n3 H0.\nsimpl in |- *.\nintros n3 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n4 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nsimpl in |- *.\nintros n5 H0.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nintros.\napply False_ind.\nintros.\napply False_ind.\napply H0.\napply H1.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; intros; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nintros n m p H H0; elim H0; intros n0 H1 H2.\nelim H1; intros n0 H2.\nelim H2; intros n1 H3.\nelim H3; intros n0 H3.\nelim H3; intros n1 H4.\nelim H3; intros n2 H4.\nelim H3; intros n4 H5.\nelim H5; intros n5 H6.\nelim H6; intros n5 H6.\nelim H6; intros n7 H6.\nelim H6; intros n7 H6.\nelim H6; intros n7 H6.\nelim H6; intros n7 H7.\nelim H7; intros n8 H6.\nelim H7; intros n7 H6.\nelim H7; intros n7 H8.\nelim H8; intros n8 H6.\nelim H8; intros n7 H8 H8.\nelim H9; intros n8 H9 H9.\nelim H9; intros n9 H10 H11.\nelim H10; intros nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; intros; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; intros; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nintros; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\npattern (node t u v v) at 1 in |- *.\nrewrite (H2 t u v); auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\napply le_trans with (S n); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v H.\napply (le_trans _ _ H).\napply le_trans with (m := 0).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).\napply le_trans with (m := S m).Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction 1; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *;Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *; auto with core.\nsimple induction 2; simpl in |- *; auto with core.\nsimple induction 1; simpl in |- *;Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\nelim (lt_not_eq (node u v)); intros.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_O_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_Sn.\napply lt_SnSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction 1; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\nsimple induction u; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with core.\nintros u v0; simpl in |- *; auto with coreSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\n  (* The next line of the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n  * (* the following (constructor) *)\n Save solution'_b.",
                    "Goal solvable b.\nProof.\nintros H; apply H.\nSave solution'_b.",
                    "Goal solvable b.\n  intros.\n  apply H0.\n  apply H1.\n  apply H.\nSave solution'_b.",
                    "Goal solvable b.\nintros H H' H' H' H'0.\ndestruct H'0 as [H' H'0].\ndestruct H'0 as [H' H'1].\ndestruct H'0 as [H' H'0].\ndestruct H'0 as [H'0' H'0].\ndestruct H'0'0 as [H'0' H'1'].\ndestruct H'0' as [H'0' H'0'].\ndestruct H'0' as [H'0' H'1'].\ndestruct H'0'0' as [H'0' H'0'].\ndestruct H'0'0'0' as [H'0' H'1'].\ndestruct H'0' as [H'0' H'1'].\ndestruct H'0'0' as [H'0' H'1'].\ndestruct H'0'0' as [H'0'0' H'1'].\ndestruct H'0' as [H'0' H'1'].\ndestruct H'0' as [H'0'0'0'].\ndestruct H'0'0' as [H'0' H'Save solution'_b.",
                    "Goal solvable b.\nintros.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H1.\napply H.\napply H0.\napply H1.\napply H0.\napply H.\napply H.\napply H0.\napply H1.\napply H.\napply H0.\napply H.\napply H1.\napply H.\napply H0.\napply H1.\napply H1.\napply H.\napply H0.\napply H1.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H1.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H.Save solution'_b.",
                    "Goal solvable b.\n  intros H0.\n  destruct H0 as [H1 H2].\n  destruct H1 as [H3 H4].\n  destruct H4 as [H4 H5].\n  destruct H5 as [H5 H5].\n  destruct H5 as [H6 H6].\n  destruct H6 as [H6 H7].\n  destruct H7 as [H7 H8].\n  destruct H7 as [H8 H9].\n  destruct H8 as [H9 H9].\n  destruct H8 as [H9 H9].\n  destruct H9 as [H10 H9].\n  destruct H9 as [H11 H9].\n  destruct H11 as [H10 H10].\n  destruct H10 as [H11 H11].\n  destruct H11 as [H11 H12].\n  destruct H11 as [H11 H12].\n  destruct H12 as [H12 H13].\n  destruct H12 as [H12 H13].\n  destruct H13 as [H13 H13].\n  destruct H13 as [H13 H14].\n  destruct H14 as [H15 H15].\n  destruct H15 as [H15 H15].\n  destruct H14 as [H15 HSave solution'_b.",
                    "Goal solvable b.\n  intros.\n  apply H.\n  apply H.\nSave solution'_b.",
                    "Goal solvable b.\nintros.\nintros.\ndestruct (H a).\nspecialize (H a).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite HSave solution'_b.",
                    "Goal solvable b.\napply: (R b).\napply: (R b).\napply: (R b).\napply R b.\napply R b.\napply R b.\napply R b.\napply R b.\napply R b.\napply R b.\napply R b.\napply R b.\napply R.\napply R b.\napply R b.\napply R.\napply R.\napply R.\napply b.\napply R.\napply R.\napply b.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.\napply R.Save solution'_b.",
                    "Goal solvable b.\nintro H.\napply H.\napply H.\nSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold solvable.\nunfold sub at 1.\nintros.\napply H.\n(* We do not use the following tactics, we do not use to prove a goal *)\n\n(* TODO: try to simplify the following tactic *)\n\nTactic Notation \"apply\" constr(H) :=\n (apply H; simpl in H);\n(* tactic works *)\n\nTactic Notation \"apply\" constr(H) :=\n (apply H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H;\n(* tactic works *)\n\nTactic Notation \"apply\" constr(H) :=\n (apply H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H; simpl in H;\n(* tactic works *)\n\nLtac apply H :=\n (apply H; simpl in HSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Stepping *)\napply H.\n(* Stepping *)\napply H.\n(* Stepping *)\napply H.\n(* Stepping *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napply H.\n(* Step through *)\napplySave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable in |- *.\nunfold sub_repr in |- *.\n(* Must not be found in the proof that it is not be found in *)\napply H0.\n(* In other cases, we can be found in the proof that it is not *)\napply H0.\n(* In other cases, we can write the proof that it is not *)\napply H0.\n(* In other cases, we can use the proof of the same *)\napply H0.\n(* In other cases, we can use the proof that it is not *)\napply H0.\n(* In other cases, we can apply in the proof that it will be found in *)\napply H0.\n(* In other cases, we need to show that it can find it is not *)\napply H0.\n(* In other cases, we have to prove that it *)\napply H0.\n(* In other cases, we have an [H0] and [H1] *)\napply H0.\n(* In other cases, we can also prove that it is not *)\napply H0.\n(* In other cases, we can use this to use the proof. *)\n(* In other cases, we will proveSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable in |- *.\nunfold sub_in in |- *.\n(* And we have a more general form *)\napply STEP with a; assumption.\napply H0.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable at 1.\nunfold solvable at 1.\nunfold sub at 1; apply/andP; split.\n(* Receptiveness *)\napply centsC.\nunfold sub at 1.\nunfold sub at 1; apply/andP; split.\n(* Receptiveness *)\napply centsC.\nunfold sub at 1; apply/andP; split.\n(* Receptiveness *)\napply centsC.\napply centsC.\napply centsC.\napply centsC.\nunfold sub at 1; apply/andP; split.\n(* Receptiveness *)\napply centsC.\nunfold sub at 1; apply/andP; split.\n(* Receptiveness *)\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.\napply centsC.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold not in |- *; intro.\n(* Step through the relation *)\napply H0.\n(* Step through the relation between the relation between the relation between the relation between the relation between the relation between the relation *)\napply H0.\n(* Step through the relation between the relation between the relation between the relation between the relation between the relation *)\napply H1.\n(* Step through the relation between the relation between the relation between the relation between the relation on the relation between the relation on the relation on the relation *)\napply H1.\n(* Step through the relation between the relation between the relation between relation between relation in the relation in the relation *)\napply H1.\n(* Step through the relation between relation between relation between the relation in the relation relation in a relation *)\napply H0.\n(* Step through the relation between relation between the relation *)\napply H0.\n(* Step through the relation between relation in the relation between relation in the relation in the relation *)\napply H0.\n(* Step through the relation between relation in the relation relation in a relation *)\napply H1.\n(* Step through the relation between relation in the relation in the relation in the relation in a relation *)\napply H1.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable at 1 in |- *.\nunfold not in |- *; intro.\n\n(* And we do this to show that the two components. *)\napply H.\n(* And we do this to show that the other hand side is equivalent to prove that the other\n    the following two components. *)\napply H.\n(* And we show that the first components in the second components of the second components of the second components in the second components. *)\napply H.\n(* And we can use the first components of the second components of the second components of the second components in the second components in the second components: *)\napply H.\n(* And we need to prove that the second components in the second components of the second components in the second components. *)\napply H.\n(* And we need to prove that the second components of the second components in the second components in the second components of the second components in the second components of the second components in the second components\n    in the second components. *)\napply H.\n(* And we have the second components of the second components of the second components in the second components in the second components in the second components. *)\napply H.\n(* And we can go a for second components inSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold b in |- *.\n(* Step through the previous term! *)\napply (H 0).\n(* Step through the second case: *)\n(* Step through the first case: *)\n(* Step through the second case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case. *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the second case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the second case: *)\n(* Step through the first case. *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\n(* Step through the first case: *)\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 3.\nunfoldsol at 1.\nunfoldsol at 1.\nunfoldsol at 1 2.\nunfoldsol at 1.\nunfoldsolSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold solvable in |- *.\nintros.\napply H1.\n(* And we do not need to use the two subgoals. *)\napply H2.\n(* And we do not need to use the two cases *)\napply H2.\n(* And we don't do not need to prove the two subgoals. *)\napply H3.\n(* And we need to show that we want to prove the following lemmas. *)\napply H3.\n(* And we do not need to prove this goal. *)\napply H3.\n(* And we can use the case analysis on the goal. *)\napply H3.\n(* And we prove that the following lemmas will use this goal. *)\napply H4.\n(* And we use the two cases. *)\napply H4.\n(* And we use the case analysis on the case analysis on the case analysis on the case analysis on the case analysis on the case analysis on the case*)\napply H4.\n(* And we can use the case analysis on the case analysis on the case analysis on the case analysis on the case analysis on the case *)\napply H4.\n(* And we prove this case, the case analysis on the case analysis on the case analysisSave microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct a; reflexivity.\ndestruct a; reflexivity.\ndestruct b; reflexivity.\ndestruct b; reflexivity.\ndestruct b;Qed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros a b.\nunfold codeAnd in H.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b; try discriminate.\ndestruct b;\ntry discriminate.\ndestruct b; try discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ndestruct b; try discriminate.\ndestruct b; try discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ntry discriminate.\ndestruct b;\ndestruct b; try discriminate.\ndestruct b; try discriminate.\ndestruct b; try discriminate.\ndestruct b; try discriminate.\ndestruct b; try discriminate.\ndestructQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold codeAnd in H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewriteQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b; unfold codeAnd in *.\ndestruct a.\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold codeOr in H.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\napply codeAndCorrect.\napply codeOrCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeOrCorrect.\napply codeAndCorrect.\napply codeOrCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeOrCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeOrCorrect.\napply codeOrCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napply codeAndCorrect.\napplyQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold codeAnd in H.\ndestruct (codeAnd b); auto.\ndestruct (codeAnd b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeAnd b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeAnd b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.\ndestruct (codeOr b); auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\nunfold codeAnd, codeOr in H.\ndestruct (codeOr (codeAnd (codeOr (codeOr (codeOr (codeAnd b))) (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeAnd (codeOr b)))) (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeOr b)))) (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeOr (codeOr b)))) (codeOr (codeOr (codeOr (codeOr (codeAnd b)))) (codeOr (codeAnd (codeOr (codeOr (codeOr b))))Qed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nunfold codeAnd in *.\ndestruct (code Opop (if b then c else c else c)).\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsPR.\napply mapIsQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply efIsPRTermIsPR.\napply efIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRIsPRisPRTermIsPRisPRTermIsPRTermIsPRIsPRTermIsF.\napply cPairIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRIsPRTermIsPRTermIsPRTermIsPRTermIsPRIsPRsIsPRuTermIsPRisPRTermIsPRIsPRTermIsPRIsPRisPRTermIsPRTermIsPRIsPRisPRisPRvgenIsPRIsPRisPRTermIsPRisPRIsPRisPRisPRelseFIsPRIsPRisPROisPRisPRuFIsPRisPRelsePisPRPNoneFIsPRisPRisPRPisPRuFisPRIsQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply true.\napply true.\napply true.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply true.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.\napply false.Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPR.\napply isPRTermIsPRTermIsPRTermIsPRTermIsPR.Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nunfold isPR 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fComp 3 fCompQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\n  intro t recs.\n  induction recs.\n  + simpl in |- *.\n    apply cPairCo.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPRTermIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply (compose2IsPR _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPRTermIsPR.\napply cPairPiIsPR.\napply cPairPiIsPR.\napply cPairPiIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsPRTermIsPRTermIsPRIsPRTermIsPRTermIsPR.\napply cPairIsPRTermIsQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPRTermIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\napply cPairPiIsPR.\napply cPairPiIsPR.\napply cPairCoIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\napplyQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\napply cPairIsPR.\napply cPairIsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsPR.\napply cPairCoIsQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\napply retSubTermIsPR.\napply retSubTermIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsPR.\napply cPairProdIsQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerm in |- *.\napply compose3IsPR.\napply cPairCoNeg.\napply cPairIsPR.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nmove=> n.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n; move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n ->.\nhave: (n < n) by move=> n.\nhave: (n < n) by moveDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct n.\n  - exists 0%nat; split; intros.\n    - exists 1%nat; split; intros.\n    - exists 1%nat; split; intros.\n      - exists 1%nat; split; intros.\n      - exists 1%nat; split; intros; assumption.\n      - exists 1%nat; split; intros.\n        - exists 1%nat; split.\n        - exists 1%nat; split.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat; split; intros; assumption.\n        - exists 1%nat;Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  split.\n  - constructor.\n  - constructor.\n  - constructor.\n  - constructor.\n  - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  case: n => a b.\n  exact (fun a b => a) (fun _ _ => a) (fun _ _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a) (fun _ => a)Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\ncase: n => a.\ncase: n => a.\ncase: n => a.\ncase: n => a.\ncase: n => a.\ncase: n => a.\nby move/eqP=> /eqP.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct n; simpl; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\ncase n; [case n] //=; case: n => // n IHn; case: n => // n IHn.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  exact (fun _ => nat) (fun _ => nat) (fun _ => nat) a b).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct n; simpl; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\ncase=> a b; case: b => a b => b\n  | S n => fun p => p\n  | S n => fun p => p\n  end.\n\nLemma ext_equiv n a b : extEqual (eq_refl (eq_refl_equal (eq_refl_equal (eq_sym_equal (eq_sym_sym_equal (eq_sym_sym_equal (eq_sym_sym_equal (eq_sym_sym_eq_sym_eq_sym (eq_sym_sym_eq_sym_eq_sym (eq_sym_sym_eq_sym_eq_eq_sym (eq_sym_sym_eq_eq_eq_sym_eq_sym_eq_eq_sym))))\n  end.\n\nLemma ext_equiv n a b : extEqual (eq_refl_equal (eq_sym_sym_sym_eq (eq_sym_sym_eq_sym (eq_sym_sym_eq_sym (eq_sym_eq_sym_sym (eq_sym_eq_sym (eq_sym_eq_sym_eq_sym (eq_sym_sym_eq_eqDefined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nexact (b = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\n  exact (forall c : nat, m < c -> m < n).\nexact (forall c : nat, m < n -> m < n).\nexact (forall c : nat, m < c -> m < c).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (fun n => 0).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nexact (a = b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napplyQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H0.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H0.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H0.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H0.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimplQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\napply Hrecn.\napply H0.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\napply H.\nintro.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply H.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nintro.\napply H.\nsimpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in H.\nunfold lt_depth in HQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A; simpl; auto.\ndestruct A; simpl in *; auto.\ndestruct A; simpl in *; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros; apply (A_comp _ _ _ H); auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros; unfold lt_depth; simpl in |- *; intros; elim n; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros.\napply (H (inf (fun x => Terms x) t)).\nassumption.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\ndestruct A.\nauto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\n intros.\n apply (le_trans (fun x => x)).\n assumption.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B; split; [left; auto | right; auto ].\ndestruct (le_depth A B); auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\ninduction (eq_dec (dec (dec (dec (A:=B) -> A))).\nintros; apply H0.\nintros.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\ninduction (le_dec A B).\nleft.\nrewrite H.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (n := O).\napply le_max_r.\napply lt_le_trans with (n := O).\napply le_max_r.\napply lt_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply lt_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply leQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (n - 1).\napply (le_max_l (length B)); auto.\napply (le_max_r (length B)); auto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\napply lt_max_r.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_maxQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\nrewrite H.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_S.\napply (H _ _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_le_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_S.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_le_n_Sm.\napply lt_le_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_lt_n_Sm.\napply lt_le_S.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\napply lt_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_O.\napply le_max_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (node (x :: nil) * (node (x :: nil) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node x) * (node xQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_n_S.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_n_S.\napply lt_le_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_n_Sm.\napply lt_S_n.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_le_S_n.\napply lt_le_S_n.\napply lt_le_S_n.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_le_n_Sm.\napply le_max_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply lt_trans with (n := S (S (S n))).\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_n_Sm.\napply lt_n_Sm.\napply lt_n_O.\napply lt_le_trans with (2 := O).\napply lt_n_S.\napply le_max_l.\napply lt_le_trans with (2 := O).\napply le_max_r.\napply lt_max_r.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nunfold lt_depth in |- *.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold lt_depth in |- *.\nauto.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold fixLine_depth_rec_rec : forall P : Formula -> Set, P -> forall a :Message, P a -> P a.\nintros P a.\napply (fixLine_depth_rec : forall P : Stream -> Set, P -> P -> P a.\nintros P H.\napply (fixLine_depth_rec_rec : forall P : Stream -> Set, P -> P -> P a.\nintros P H.\napply H0.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold Lt in |- *.\nassert (H1 : forall a :Message, lt_depth a -> P a -> P a -> forall x : Stream, lt_depth a -> P x).\nintros.\napply lt_depth_rec with (P := fun a : Stream => lt_depth a).\nassumption.\napply lt_depth_rec with (P := fun a : Stream => lt_depth a).\nassumption.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold member in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_rDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply lt_le_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_n_S.\napply le_lt_n_n.\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_n_S.\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_lt_trans with (2 := nat_of_P).\napply le_trans with (2 := nat_of_P).\napply le_lt_n_n.\napply le_lt_n.Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite (n_O _ (le_n_O _ _ (le_n_O _ _ (le_n_O _ (le_n_O _ _ (le_n_O _ _ (le_n_O _ _ (le_n_O _ _ (le_n_O _ _ (le_n _ (le_n_O _ _ _ (le_n_n _ _ (le_S _ _ (le_n_n _ _ (le_S _ _ _ (le_n_n _ _ (le_n _ _ (le_S _ (le_n _ _ (S n)))))))));\n [ | rewrite (n_O _ (le_n_O _ (le_S _ (le_n_S _ _ (le_S _ (le_n_S _ _ (le_n_O _ _ (le_n_n _ _ (le_S _ (S n))))))));\n [ reflexivity | rewrite (n_O _ (le_S _ (le_n_O _ _ (le_S _ (le_S _ _ (le_n_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\ndestruct H.\napply le_lt_n_Sm.\napply H.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P.\nunfold lt_depth in |- *.\nauto.\nDefined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply lt_le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H1.\napply le_trans with (beta + delta).\napply H.\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans with (beta + delta).\napply H.\napply le_trans withQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\napply le_trans with beta; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_incl.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_trans with (ord beta); trivial.\napply ord_le_Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply le_le_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta; trivial.\napply le_lt_trans with beta;Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_incl with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_le_incl; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta;Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\napply ord_le_trans with beta; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_le_trans with beta; trivial; apply ord_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_lt_incl; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_respects_succ; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_preserves_succ; trivial.\napply ord_lt_incl; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_le_respects_succ; trivial.\napply ord_le_weak; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_le_incl.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_respects_succ; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_respects_succ; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_le_respects_succ; trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\napply ord_le_respects_succ; trivial.\napply ord_le_incl; trivial.\napply ord_lt_incl; trivial.\napply ord_le_incl; trivial.\napply ord_lt_incl; trivial.\napply ord_lt_incl; trivial.\napply ord_lt_incl; trivial.\napply ord_lt_incl; trivial.\napply ord_lt_incl; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_lt_lower; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_generic; trivial.\napply ord_lt_weak; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_lt_trans with beta; trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\napply ord_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order; trivial.\napply ord_total_order; trivial.\napply ord_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j); trivial.\napply ord_ord_trans with (o j);Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply: well_founded ord_lt.\napply ord_lt_trans with (t := t).\napply ord_lt_trans with (t := t).\napply ord_lt_sup.\napply ord_sup_minimal.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply ord_lt_wf.\napply ord_trans with (i:=i); trivial.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (classic (exists i:I, ord_sup o0 < i)); trivial.\nright; right.\napply ord_sup_minimal.\napply ord_sup_minimal.\nintro.\ndestruct (classic (exists i:I, ord_sup o0 < n)); trivial.\nright; right.\napply ord_sup_minimal.\nintros.\ndestruct (classic (exists i:I, ord_sup o0 < n)); trivial.\nright; right.\napply ord_sup_minimal.\nintro.\ndestruct (classic (exists i:I, ord_sup o0 < n)); trivial.\nright; right.\napply ord_sup_minimal.\nintro.\ndestruct (classic (exists i:I, ord_sup o0 < n)); trivial.\nright; right.\napply ord_sup_minimal.\nintro.\ndestruct (classic (exists i:I, ord_sup o0 < n)); trivial.\nrightQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ord_ord_trans with (o i); trivial].\nsplit; [apply bot_trivial | apply ordQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; intros; apply ordinals_well_founded; auto.\nintros; apply ordinals_well_founded; auto.\nintros; apply ordinals_well_founded; auto.\nintros; apply ordinals_well_founded; auto.\nintros; apply ordinals_well_founded; auto.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintro x; case (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I, ord_sup x)).\ndestruct (classic (exists i:I,Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ninduction n; simpl; intros.\ndestruct (le_gt_dec n n).\ndestruct (lt_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (lt_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_lt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (le_gt_dec n n).\ndestruct (Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\ninduction n.\nintros.\ndestruct (H n) as [|[|]].\ndestruct (H n) as [|[|]].\nright; left.\napply ord_sup_minimal; trivial.\nright; right.\napply ord_sup_minimal; trivial.\napply H2.\napply ord_sup_minimal; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply ord_lt_trans with (Nat.of_nat n); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n)); trivial.\napply (ord_lt_trans (Nat.of_nat n));Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit.\napply well_founded_lt_ind; trivial.\napply well_founded_lt_ind; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set, Same_set, Same_set, Same_set, SameQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\nunfold Same_set, Included.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros; apply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H H0.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nintros.\nunfold Same_set.\nintuition.\nexists (Immediately (union_f (Union F) (Intersection F) (Union F) (Union F) (Union F) (Union F) (Union F) (Union F) (Union F) (Union F G) (Union F) (Union F G) (Union F G).\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\nexists (Immediately (union_f (Union F) (Union F) (Union F) (Union F G) (Union F G) (Union F G)).\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\nunfold Same_set in |- *.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintuition.\napply ExtensionalityQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H0 H1; apply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Same_set.\nintuition.\nelim H0.\nintros x H.\ncase (H x); intros H1.\nrewrite H1 in H1.\ninversion H1.\nexists x.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 x); auto.\napply (H0 xQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nexists x0.\nexists x0.\nexists x1.\nexists (Im E F).\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\napply Extensionality_Ensembles.\nunfold SameQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set, Same_set in |- *.\nintuition.\nintros.\nunfold Same_set, Same_set in |- *.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H0.\napply image_comp with (finite (Intersection F) (Intersection F) (Intersection F) (Intersection F) (Intersection F)).\nexact (Intersection_preserves_finite _ _ _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (Intersection_preserves_finite _ _ _ H0).\nexact (IntersectionQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H0.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_union_intro with S.\napply covering_unionQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply Extensionality_Ensembles.\nunfold Same_set in H.\ndestruct H.\nsplit; auto.\napply empty_family_intersection.\nintro.\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H0.\napply image_preserves_preserves_distinct.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply covering_union_intro with S.\napply H0.\nassumption.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\nunfold Included.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.Qed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H.\napply family_union_intro with S.\napply H0.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H0.\nassumption.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros H x y [Hxy Hxy1 Hxy2] [Hy Hxy2] Hxy3].\n  split; assumption.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f C f x y H.\n  apply (f_equal (fun x => f x) (fun x => f x)).\n  apply (f_equal (fun x => f x) (fun x => f x)).\n  apply (f_equal (fun x => f x) (fun x => f x)).\n  apply (f_equal (fun x => f x) (fun x => f x)).\n  apply (f_equal (fun x => f x) (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f x)).\n  apply (f_equal (fun x => f xQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y H.\n  destruct H as [x y].\n  unfold respectful.\n  intros H.\n  unfold respectful.\n  intros H.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H1.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H1.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros H0.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros H1.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros.\n  unfold respectful.\n  intros.\n  rewrite H0.\n  unfold respectful.\n  intros.\n  rewrite H0.\n  unfold respectful.\n  intros H1.\n  unfold respectful.\n  intros.\n  unfold respectfulQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y C f x y C f x y C f x y C f x y C f x y C f y C f x y C f y C f y C f y C f y C f x y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C f y C y f y f y C f y C y f y C f y C f y f y C f y C f y C f y C f y C f y f y C f y C f y C y C f y f y f y C f y C f y f y C f y C y f y C f y C f y C f y y f y C f y C f y y C f y f y f y C y C f y C y f y CQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y C f x y H1 H2.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H2.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <-Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y H H.\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (f y = f y) by (apply H; assumption).\n  assert (Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y H.\n  unfold SizeMonotonicOpt.\n  apply f_equal_equal.\n  extensionality x.\n  rewrite (H x).\n  apply f_equal.\n  extensionality x.\n  rewrite (H x).\n  apply f_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality y.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (H x).\n  apply g_equal.\n  extensionality x.\n  rewrite (HQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y H.\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H := refl_equal_proofs (fun x y => x) H).\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_proofs (fun x y => x) H').\n  assert (H' := refl_equal_Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y D f C D f C D f C f C D f C D f C D.\n  unfold Co; intros.\n  apply f_equal_dep.\n  assumption.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y C R' S f x y z Hz Hxy.\n  rewrite Hxy.\n  apply Hxy.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  generalize dependent R.\n  induction R as [ | x y ]; auto.\n  inversion H.\n  destruct (f y) as [ | x y ]; auto.\n  inversion H.\n  destruct (f y) as [ | x y ]; auto.\n  inversion H.\n  destruct (f y) as [ | x y ]; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R f x y Hf Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R f x y Hf Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f x y.\n  apply @f_equal_instances.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  assert (H := @f_equal_ ints).\n  subst.\n  apply H.\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hf Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f x y Hf Hxy.\n  unfold reflexive in *.\n  apply (f_equal_separated _ _ _ (f y)).\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f x y Hf Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R f x y Hf Hxy.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  assert (H := f_equal_ 1994 _ _ _ _ _ _ Hxy).\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H inQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  assert (H := f_equal_ ints).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_equal_separated_eq CRmorph).\n  apply (f_Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy Hyz.\n  assert (H : forall x y z, x = y -> y = z) by (intros; apply H; assumption).\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  apply @f_equal_ INRIA; assumption.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  assert (H := f_equal_prf R f x y Hxy).\n  assert (H' := f_equal_prf R f x y Hxy).\n  rewrite H' in Hxy.\n  rewrite H' in Hxy.\n  rewrite H in Hxy.\n  rewrite H in Hxy.\n  assumption.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy Hxy.\n  apply @f_equal_''].\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n  apply @f_equal_Lem.\n Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) (R ==> flip R) f).\n  apply (f_equal_setoid (R ==> flip R) f).\n  apply (f_equalQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f f f.\n  transitivity (flip R); [ | apply flip_flip_eq ].\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_simplify.\n  apply flip_eq_Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  (* It's the [H] applies to be applied to the context. *)\n  intros A R x y Hxy.\n  assert (H : x = y) by (apply (H x y Hxy).\n  assert (H' : x = y) by (apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  assumption.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  rewrite <- H; apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct Hf.\n  unfold respectful, respectful, respectful, respectful, respectful; intros.\n  apply f.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful, respectful, respectful, respectful.\n  firstorder.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapply flip_rel; eauto).\n  assert (R' ==> flip R') by (eapplyQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' := @f_equal_arrow R f Hf).\n  assert (R' :=Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R') in Hf.\n  apply (f_equal_flip R) in Hf.\n  apply (f_equal_flip R) in HfQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  unfold monotonic in *.\n  unfold Basics.flip in *.\n  rewrite <- (flip_sym R).\n  rewrite <- (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).\n  rewrite (flip_sym R).Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  eapply (eq_rect_eq_eq _ _ _ _ Hf) with (R' := fun x => R' x); eauto.\n  auto.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful, respectful; intros;\n  eapply eq_impl_eq_impl_eq_r; eauto.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  assert (R' = flip R' f).\n  { rewrite (flip_eq_equiv _ _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_equiv _ _))) _))). }\n  { rewrite (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ (flip_eq_equiv _ _ (flip_equiv _ _ (flip_eq_equiv _ _ (flip_eq_equiv _ _ (flip_equiv _ _ (flip_eq_equiv _ _ (flip_equiv _ _ (flip_eq_equiv _ _ (flip_equiv _ _ _ (flip_eq_equiv _ _))) _))). }\n  { rewrite (flip_eq_equivQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros; apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful; intros.\n  apply eq_rect.\n  intros A R f Hf.\n  unfold respectful, respectful, respectful, respectful; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b1 c2 d1 e.\n  intros A B C R f a1 a2 b2 c2 d2 e.\n  intros A B C R f a1 a2 b2 d1 e.\n  intros A R f a2 b1 e1 e2.\n  intros A R f a1 e2.\n  intros A R f a2 e1 e2.\n  intros A R f a1 e2 e3.\n  intros A R f a1 e3 e4.\n  intros A R f a1 e3.\n  intros A R f a1 e3.\n  intros A R f a1 e3 e4.\n  intros A R f a1 e3 e5 e4.\n  intros A R f a1 e4 e1 e3 e4 e5 e6 e7.\n  intros A R f a1 e3 e4 e5 e6 e7.\n  intros A R f a1 e3 e4 e5 e6 e7.\n  intros A R f a1 e3 e5 e6 e7.\n  intros A R f a2 e3 e4 e6.\n  intros A RQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B R f a1 a2 b1 c H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H2.\n  setoid_rewrite H2.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H2.\n  setoid_rewrite H2.\n  setoid_rewrite H2.\n  setoid_rewrite H1.\n  setoid_rewrite H1.\n  setoid_rewrite H2.\n  setoid_rewrite H2.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H2.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoid_rewrite H.\n  setoidQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C f a1 a2 b c.\n  split.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C f g.\n  unfold respectful, respectful.\n  intros A B C f g.\n  apply H0.\n  apply H1.\n  apply H2.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f Hf.\n  destruct (H a1) as (b1 & b2 & c2 & c3 & e3 & e3 & e4 & e4 & e4 & e5 & e5 & e6 & e6 & e6 & e7 & e7 & e7 & e8 & e8 & e9 & e9 & e9 & e10 & e9 & e10 & e11 & e11 & e10 & e11 & e11 & e13 & e13 & e13 & e14 & e14 & e14 & e14 & e14 & e15).\n  intros A B C R f Hf.\n  destruct (H a2) as (b1 & b2 & c3 & e3 & e4 & e5 & e6 & e7 & e8 & e10 & e11 & e11 & e12 & e13 & e14 & e14 & e15).\n  intros A B C R f Hf.\n  destruct (H a2) as (b1 & c3 & e4 & e5 & e6 & e8 & e9 & e11 & e11 & e13 & eQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C f a1 a2 b1 c1 H1 H2.\n  assert (H3: forall x y, f x y = f y x).\n    { intros x y H1. apply H2; auto. }\n  rewrite H1 in H1.\n  assert (H4: forall x y, f x y = f y x).\n    { intros x y H1. apply H2; auto. }\n  rewrite H2 in H1.\n  assert (H5: forall x y, f x y = f y x).\n    { intros x y H1. apply H3; auto. }\n  rewrite H1 in H1.\n  assert (H5: forall x y, f x y = f y x).\n    { intros x y H1. apply H3; auto. }\n  rewrite H1 in H1.\n  assert (H6: forall x y, f x y = f y x).\n    { intros x y H1. apply H3; auto. }\n  rewrite H1 in H1.\n  assert (H6: forall x y, f x y = f y x).\n    { intros x y H1. apply H3Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C f a1 a2 b1 c1 d2 f0.\n  eapply (eqrel_impl_cong_eq _ _ _ H0).\n  eapply (eqrel_impl_cong_eq _ _ _ H0).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H0).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H2).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H1).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H2).\n  eapply (eqrel_impl_cong_eq _ _ _ _ H2).\n  eapplyQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C f a1 a2 b c H.\n  destruct (eqrel_impl_|]]; auto.\n  (* The [impl_rel_impl_tac] is the same, but we can\n  have [impl_rel_impl_tac] as the other words, if we\n  the hypothesis [impl_rel_impl_tac], except that [impl_rel_tac] is\n  the same as an equality of [impl_rel_tac]. *)\n\n(** ** The [impl_rel_impl_tac] is an equality of [iff_tac] and\n  the same as [iff_tac] is equivalent to [iff_tac]. *)\n\n(** ** The [iff_rel_tac] is a hypothesis [iff_tac], the\n  relation [iff_tac] is equivalent to [iff_tac]. *)\n\n(** ** The [iff_rel_tac] is a hypothesis [iff_tac],\n  [iff_tac] is a hypothesis of [iff_tac] and\n  [iff_tac]. *)\n\n(** ** The [iff_tac] is a hypothesis [iff_tac] is equivalent to [iff_tac]. *)\n\n(** ** TheQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B R f a1 a2 b1 c1 b2 d2 d3 e f g g h.\n  auto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B R f H.\n  destruct H as (R1 & R2 & R3 & R4 & R4 & R4 & R4 & R4 & R4 & R4 & R4 & R4 & R4 & R4 & R5 & R5 & R6 & R7 & R7 & R8 & R9 & R9 & R10 & R10 & R10 & R10 & R10 & R11 & R11 & R13 & R12 & R12 & R13 & R14 & R15 & R14 & R15).\n  intros A R R H.\n  destruct H as (R1 & R2 & R3 & R4 & R4 & R5 & R5 & R6 & R7 & R7 & R8 & R9 & R10 & R10 & R10 & R10 & R10 & R11 & R12 & R14).\n  intros A R H.\n  destruct H as (R1 & R3 & R4 & R4 & R5 & R6 & R8 & R9 & R10 & R10 & R10 & R12 & R13 & R15).\n  destruct H asQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 b1 b2 Hf.\n  unfold respectful; intros; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b c Hf.\n  unfold respectful; intros A B R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a b c Hf.\n  unfold respectful; intros A R f a1 a2 b c Hf.\n  unfold respectful; intros A R f a b c Hf.\n  unfold respectful; intros A R a1 b c Hf.\n  unfold respectful; intros A R a b c Hf.\n  unfold respectful; intros A R a b c.\n  unfold respectful; intros A R a b c.\n  unfold respectful; intros A R a b.\n  unfold respectful; intros A R a b cQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 f a1 a2 b1 d Hf.\n  unfold respectful; split; auto.\n  rewrite H; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b1 Hf.\n  rewrite <- (rel_impl_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_imp_Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 b1 b2 d Hf.\n  unfold respectful, respectful, respectful.\n  intros A1 B2 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A2 B2 R f a b1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A1 B2 R f a b1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A2 B3 R f a b2 d Hf.\n  unfold respectful, respectful.\n  intros A3 B3 R f a b1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a b1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a b1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R f a b1 b3 d Hf.\n  unfold respectful, respectful.\n  intros A4Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b1 Hf Hx.\n  unfold respectful in *.\n  split; intros;\n    [rewrite <- H0; apply H0 | rewrite <- H1].\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H4.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H4.\n  apply H2.\n  apply H1.\n  apply H4.\n  apply H3.\n  apply H.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H1.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H2.\n  apply H4.\n  apply H2.\n  apply H4.Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b1 Hf Ha.\n  rewrite <- (H x y); auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b1 b2 c Hf.\n  unfold respectful, respectful.\n  intros A1 A2 B1 R f a1 b2 b1 c Hf.\n  unfold respectful, respectful.\n  intros A1 A2 R f a2 b2 d Hf.\n  unfold respectful, respectful.\n  intros A2 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A2 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A2 R f a1 b1 d Hf.\n  unfold respectful, respectful.\n  intros A3 R f a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A3 R f a2 b3 d Hf.\n  unfold respectful, respectful.\n  intros A3 R a1 b2 d Hf.\n  unfold respectful, respectful.\n  intros A3 R a1 b2 d.\n  unfold respectful, respectful.\n  intros A4 R a b2 d Hf.\n  unfold respectful, respectful.\n  intros A4 R a1 b3 d Hf.\n  unfold respectful, respectful.\n  intros A4 R a1 b3 d Hf.\n  unfold respectful.Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R2 f a1 b2 b3 Hf Ha.\n  unfold respectful; simpl.\n  rewrite <- (H a1) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a1) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a1) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2) in Hf.\n  rewrite <- (H a2Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B R f a1 a2 b1 Hf.\n  rewrite <- (R' x y); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  generalize (eq_sym x1 y2).\n  intros s s s s s s' H.\n  rewrite (eq_sym s s' H).\n  rewrite (eq_sym s s' H).\n  rewrite (eq_sym s s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_sym s' H).\n  rewrite (eq_Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  unfold x1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A B x1 y1.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, y2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1; simpl.\n  intros A B x1 y1.\n  unfold y1, x2; simpl.\n  intros A B x1 y2.\n  unfold y1, x2; simpl.\n  intros A x1 y2.\n  unfold y1, y2; simpl.\n  intros A x1 y1.\n  unfold y1, x2; simpl.\n  intros A x2 y2Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y1 y2 y3.\n  rauto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  unfold x1, x2, x3; simpl.\n  intros x1 x2 y3.\n  unfold x1, x2; simpl.\n  intros x1 x2 y3.\n  unfold x1, y3; simpl.\n  intros x3 y4.\n  unfold x2, y4; simpl.\n  intros x4 y5.\n  unfold x1, y4; simpl.\n  intros x5 y6.\n  unfold x1, y5; simpl.\n  intros x6 y6.\n  unfold x2, y6; simpl.\n  intros x6 y7.\n  unfold x1, y6; simpl.\n  intros x7 y8.\n  unfold x2, y4; simpl.\n  intros x8 y9.\n  unfold x2, y3; simpl.\n  intros x9 y11.\n  unfold x2, y3; simpl.\n  intros x7 y9.\n  unfold y2, y6; simpl.\n  intros x8 y9.\n  unfold x2, y3; simpl.\n  intros x9 y10.\n  unfold y3, x1, y6; simplQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y1 y2 x2 y3 y4.\n  rauto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y1 y2 Hf.\n  unfold x1, y1, y2; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y1 y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y2.\n  unfold y1, y2.\n  unfold y2, y2.\n  unfold y1, y2.\n  unfold y1, y2.\n  unfold y2.\n  unfold y2.\n  unfold y1.\n  unfold y2, y1.\n  unfold y2.\n  unfold y2.\n  unfold y1, y2.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y1, y2.\n  unfold y2.\n  unfold y2.\n  unfold y1.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y1.\n  unfold y2.\n  unfold y2.\n  unfold y2.\n  unfold y1, y2.\n  unfold y2.\n  unfoldQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y1 y2.\n  assert (R1 ==> R2 ==> R3) by (symmetry; assumption).\n  assert (R1 ==> R3) by (symmetry; assumption).\n  assert (R2 ==> R3) by (symmetry; assumption).\n  assert (R3 ==> R3 ==> R3) by (symmetry; assumption).\n  assert (R3 ==> R3 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R3) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R4 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R4) by (symmetry; assumption).\n  assert (R4 ==> R3 ==> R4) by (symmetry; assumption).\n  assertQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C1 R2 R1' R2' R2' R3' H4.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 R2 HR12 x y.\n  destruct (eq_dec x y) as [y0 | y0]; simpl in *.\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R2 = y0 *)\n  (* R1 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R2 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R3 = y0 *)\n  (* R1 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R3 = y0 *)\n  (* R2 = y0 *)\n  (* R3 = y0 *)\n  (* R1 = y0 *)\n  (* R3 = y0 *)\n  (* R1 = y0 *)\n  (* R2 = y0 *)\n  (* R2 = yQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 R2 HR12 x y.\n  destruct (rel_prod_rel R1 R2) as [x y] eqn:HeqxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 R2 R3 Heq.\n  rewrite Heq.\n  rewrite Heq.\n  rewrite Heq.\n  rewrite Heq.\n  rewrite Heq.\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 R1 R2 R2 R1 R2 R2 R3 x y.\n  auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R1 R2 R1 HR12 x y.\n  rewrite <- (eq_rel_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_prod_Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C2 R1 R2 R1 R2 HR12 x y.\n  unfold reflexive; split; [ | apply eq_rel_impl_arithmetic_impl_arithmetic_impl_arithmetic_impl_arithmetic_impl_arithmetic_impl_dist_and_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_dist_or_or_dist_or_dist_or_dist_or_dist_or_or_dist_or_dist_or_dist_or_dist_or_or_dist_or_or_dist_or_dist_or_dist_or_or_dist_or_dist_or_or_dist_or_dist_or_or_dist_or_dist_or_or_dist_or_dist_or_or_dist_or_dist_or_or_distQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R2 H1 x y.\n  destruct (R1 x y) as [R1 R2]; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\n  eapply H; eauto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply (list_rel_ext _ _ _ _ H).\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct (list_rel_eq_dec _ _ _ _ H H) as [y [y [? [? [??]]]].\n  destruct (H x y) as [y [z [? [? [??]]]].\n  destruct (H x y) as [z [? [? [??]]]].\n  destruct (H x y) as [z [? [? [? [??]]]].\n  exists z; exists z; exists z; auto.\n  destruct (H x y) as [z [? [? [??]]]].\n  exists z; exists z; exists z; exists z; auto.\n  destruct (H x z) as [z [? [??]]]].\n  exists z; exists z; exists z; auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold list_rel in *.\n  destruct H0 as [y [H0 H1]].\n  exists y; assumption.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold list_rel in *.\n  cut (forall x y, R x y -> R x y).\n  intro.\n  apply H1.\n  apply H2.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R' l1 l2 x y H1 H2.\n  rewrite H1.\n  rewrite H2.\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold list_rel in *.\n  simpl in *.\n  intuition.\n  unfold list_rel in *.\n  intuition.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R l1 l2 x y H.\n  rewrite H.\n  apply H.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  assert (list_rel R l1 l2); [exact (H x y); intros; apply H; apply H; assumption | apply H; assumption].\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R' l1 l2 x y H.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  repeat intro.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapply R.\n  eapplyQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nAbort.\n\n(** ** [rel_pull] *)\n\n(** ** [rel_pull] *)\n\n(** ** [rel_pull] is a boolean function on a boolean function for\n    function over [rel_pull] *)\n\nLtac rel_pull :=\n  match goal with\n    | [ rel_pull] =>\n      match goal with\n        | [ rel_pull] => or_case (rel_pull)\n        | [ rel_pull] => or_case (rel_pull)\n        | [ rel_pull] => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => or_case (rel_pull)\n        | _ => orQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold respectful.\n  simpl.\n  intros.\n  apply (H0 x).\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold reflexive.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\n  apply f.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  applyQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold R.\n  apply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (rel_pull R).\n  intros.\n  eapply (relQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rstep.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y H.\n  apply (rel_pull_2 _ _ _ H).\n  eapply rel_pull_2; eauto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y H.\n  rewrite H.\n  apply rel_pull_2; assumption.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y.\n  unfold Positivstellensatz.\n  apply rel_pull_2; auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rstep.\n  intros.\n  destruct (rel_pull_2 _ _ H) as [y [Hyy Hyy Hyy]].\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rstep.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rstep.\n  auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rstep.\n  intros.\n  apply rel_pull_2.\n  apply rel_pull_2.\n  apply rel_pull_2.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply rel_pull_2; eauto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y H.\n  apply (rel_pull_2 _ _ _ _ _ H).\n  apply rel_pull_2.\n  intro y.\n  rewrite H.\n  apply rel_pull_2.\n  intro y.\n  rewrite H.\n  apply rel_pull_2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold rel_all.\n  intros a x H.\n  apply (rel_all_rel_in_rel_in_rel_in_rel_in_rel_in_rel_in_rel_in_rel_in_rel_in_rel_rel_in_rel_in_rel_in_rel_rel_in_rel_rel_in_rel_in_rel_rel_in_rel_rel_in_rel_rel_in_rel_rel_in_rel_rel_in_rel_rel_r_rel_rel_in_rel_rel_rel_in_rel_rel_rel_l\n _sym.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_all_in.\n  intro.\n  rewrite H0 in H0.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.\n  apply rel_all_in.\n  intro.Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros x.\n  unfold Reflexive in H.\n  split; [assumption | apply H0; assumption ].\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  rstep.\n  destruct (rel_all_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_orQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_pull_2.\n  unfold rel_all.\n  intros a a0 H.\n  apply rel_pull_2.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold rel_all; intuition.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  rstep.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n  all: intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B a b Ha Hb.\n  apply HopA.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B B C D HopA HopA HopA HopA HopB HopB HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopA HopAQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B (x1 x2 y1 y2 y2 Hy1).\n  unfold reflexive, reflexive, transitive, transitive; intros x1 y2 Hy1.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n  unfold transitive, transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy1.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n  unfold transitive, transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy.\n  unfold transitive, transitive, transitive, transitive; intros x1 y2 Hy1.\n  unfold transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n  unfold transitive, transitive, transitive, transitive, transitive; intros x1 y2 Hy1.\n  unfold transitive, transitive, transitive, transitive; intros x1 y2 Hy2.\n Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A1 A2 B1 C1 D2 R2 R1' R2' R2' HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A1 A2 B1 B2 C1 R1' R2 R1' R2' R2' HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B.\n  specialize (HopA (RA ==> RB ==> RB ==> RB ==> RB ==> RB ==> RB) as (x1, y2).\n  intuition.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B HA R1 R2 x y.\n  assert (R1': rel A1' A2' -> rel A2' -> rel A1' A2' -> rel A2' -> rel A2' -> rel A1' A2 -> rel A2' -> rel A1' A2 -> rel A1' A2' -> rel A1' A2 -> rel A2' -> rel A2' A2' -> rel A1' A2 -> rel A2' A2' -> rel A1' A2' -> rel A1' A2 -> rel A2 A2' -> rel A1' A2 -> rel A1' A2 -> rel A1' A2 -> rel A2' A2 -> rel A1' A2' -> rel A1' A2 -> rel A1' A2' -> rel A2 A2' -> rel A1 A2' -> rel A1' A2' -> rel A1 A2 -> rel A1' A2' -> rel A2 A2 -> rel A1' A2' -> rel A2' A2 -> rel A1' A2 -> rel A2' AQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B a a b; simpl; auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C1 R2 R1' R2' R3' R1' R2' R3' R3' R1' R3' R3' R4'0'1'2' R3'0'3'3'3' R4'0'4'0'4'0'1'4'0'4'5'6'7'7'8'8'8'8'9'9'9'9'9'9'9'9'9'9'9'10'10'10'10'121213131313141414141414141414.\nProof.\n  intros A1 A2 B1 B2 C2 R1' R1' R2' R3' R3'4' R3' R4' R4'5'6'7'8'9'9'10'10'10'13131313141415.\nQed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n Hn.\n exists (S n).\n rewrite <- Hn.\n rewrite H.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\n rewrite <- Hn.\n apply le_n_S.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (m := 1).\n apply le_trans with (mQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n rewrite a.\n apply le_trans with (n := 1).\n apply le_trans with (n := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (n := 1).\n apply le_trans with (m := 1).\n apply le_trans with (n := 1).\n apply le_trans with (n := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (n := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (n := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (n := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (2 := 1).\n apply le_trans with (2 := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (1 := 1).\n apply le_trans with (2 := 1).\n apply le_trans with (2 := 1).\n apply le_trans with (1 := H1).\n apply leQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro; elim H; auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold prime, n; intros n; elim n; intros n0 H; elim n0; intros H1;\n   [ intros H2; exists (S n0); split; assumption | idtac ].\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intros n H; elim H; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n Hn.\n apply lt_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\n apply le_trans with (m := n); trivial.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n H.\n case (not_eq n).\n intro H0.\n case (not_eq n).\n intro H0.\n rewrite H0.\n apply H.\n apply H0.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.\n apply H.Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold prime.\n apply lt_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply leQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold prime.\n apply (non_zero _ _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply lt_le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_trans with (S (S (S n))).\n  apply le_transQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply n.\n  apply le_trans with (m := n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.\n  apply (le_trans O n); auto with arith.Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (n := 1).\n  apply le_trans with (n := 1).\n  apply le_trans with (n := 1).\n  apply le_trans with (n := 1).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (n := 1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (n := 1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H1).\n  apply le_trans with (Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply (mult_0_l_l_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_1_l_reverse (b*q)).\n  apply (mult_0_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_1_l_reverse (b*q)).\n  apply (mult_1_reverse (b*q)).\n  apply (mult_0_l_reverse (b*q)).\n  apply (mult_1_l_reverse (b*q)).\n  apply (mult_1_l_reverse (b*q)).\n  apply (mult_0_reverse (b*q)).\n  apply (mult_1_l_reverse (b*q)).\n  apply (mult_0_reverse (b*q)).\n  apply (mult_0_reverse (b*q)).\n  apply (mult_1Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply (le_gt_0_dec n).\n  apply (le_gt_0_dec n).\n  apply (le_gt_0_dec n).\n  apply (le_gt_0_dec n).\n  apply (le_ge_0_dec n).\n  apply (le_gt_0_dec n).\n  apply (le_gt_le_dec n).\n  apply (le_le_lt_dec n).\n  apply (le_gt_lt_dec n).\n  apply (le_le_lt_dec n).\n  apply (le_ge_trans n).\n  apply (le_lt_trans (S n)).\n  apply (le_le_trans _ _ _ H).\n  apply le_le_trans with (S n).\n  apply (le_le_lt_lt_dec n).\n  apply (le_le_trans _ _ _ H).\n  apply (le_lt_le_trans _ _ H).\n  apply (le_le_lt_trans _ _ _ H).\n  apply (le_lt_le_trans _ _ _ H).\n  apply (le_lt_trans _ _ _ H).\n  applyQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (q := n).\n  apply le_trans with (q := n).\n  apply le_trans with (p := n).\n  apply le_trans with (q := n).\n  apply le_trans with (q := n).\n  apply le_trans with (p := n).\n  apply le_trans with (q := n).\n  apply le_trans with (q := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (q := n).\n  apply le_trans with (p := n).\n  apply le_trans with (p := n).\n  apply le_trans with (q := n).\n  apply le_trans with (q := n).\n  apply le_trans with (p := n).Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_trans_or_eq O n).\n  apply (le_transQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply lt_trans with (m := n).\n  apply not_le_lt.\n  apply not_le_lt.\n  apply not_le_lt.\n  apply not_le_lt.\n  apply not_le_lt.\n  apply not_lt.\n  apply not_le_lt.\n  apply not_lt.\n  apply not_le_lt.\n  apply not_lt.\n  apply not_lt.\n  apply not_le.\n  apply not_le_lt.\n  apply not_lt.\n  apply not_lt.\n  apply not_le.\n  apply not_lt.\n  apply not_lt.\n  apply not_le.\n  apply not_lt.\n  apply not_lt.\n  apply H.\n  apply not_lt.\n  apply not_le.\n  apply not_le.\n  apply not_lt.\n  apply not_le.\n  apply not_le.\n  apply not_lt.\n  apply not_lt.\n  apply not_le.\n  apply not_lt.\n  apply not_le.\n  apply not_lt.\n  apply not_le.\n  apply not_le.\n  apply not_le.\n  apply not_le.Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply le_trans with (0 := le_O_n).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H0).\n  apply le_trans with (1 := H1).\n  apply le_trans with (1 := H0).\n  apply le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  case (not_le_or_eq _ _ H).\n  intros.\n  exists (S O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  elim H.\n  intros.\n  exists x.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply prime_refl.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans with (S p).\n  apply prime_trans.\n  apply prime_trans with (S p).\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans.\n  apply prime_trans with (S p).\n  apply prime_trans with (S p).\n  apply prime_trans.\n  apply prime_trans with p.\n  apply prime_trans with (S p).\n  apply prime_trans with p.\n  apply prime_trans.\n  apply prime_trans with p.\n  apply prime_trans with p.\n  apply prime_trans with (S p).\n  apply prime_trans with (S p).\n  apply prime_trans with (S p).\n  apply prime_trans with p.\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply prime_refl.\n  apply H.\n  apply (prime_trans _ H).\n  apply H.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_trans _ H).\n  assumption.\n  apply (prime_Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 0.\n  auto with arith.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply (rel_prime_dec a).\n  apply H.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  apply H.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  assumption.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply (rel_prime_dec a).\n  assumption.\n  assumption.\n  apply H.\n  apply (rel_prime_dec a).\n  assumption.Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply not_false_or_le.\n  exists O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  rewrite (gcd_refl a).\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists (a * b).\n  auto with arith.\n  apply or_sym.\n  intros.\n  apply H.\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply (prime_rel_prime a b); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply le_trans with (1 := H).\n  assumption.\n  apply or_sym.\n  apply H.\n  apply H.\n  apply le_trans with (1 := H).\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumption.\n  apply le_trans with (1 := H).\n  assumption.\n  assumptionQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\n  intros.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\n  intros.\n  elim H.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim HQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro.\n  elim H0; intro q'; elim H0; intro q'; elim H1; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'0; elim H2; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H1; intro q'; elim H2; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H2; intro q';\n  elim H1; intro q'; elim H1; intro q'; elim H2; intro q'; elim H1; intro q';\n  elim H1; intro q'; elim H1;Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply (prime_antisym a b); auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro q; elim H;intro.\n  elim H; intro q'; intro H'.\n  elim H'; intro q'; intro q'; elim H'; intro q'; intro H'.\n  elim H'; intro q'; elim H'; intro H'0; elim H'0; intro H'1.\n  rewrite H'; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H; intro q; elim q; intro q'; intro q';\n    [ intro q'; elim q'; intro q'; intro q';\n    [ intro q'; elim q'; intro q'; intro q';\n      [ intro q'; elim q'; intro q'; intro q';\n        [ intro q'; elim q'; intro q'; intro q';\n          [ intro q'; elim q'; intro q'; intro q';\n            [ intro q'; apply q'; intro q';\n              [ intro q';\n                [ intro q'; [ intro q';\n                [ intro q'; [ intro q';\n                  [ intro q';\n                  [ intro q'; [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q'';\n                  [ intro q';\n                  [ intro q';\n                  [ intro q'; [ intro qQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro q';intro H'.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n  intros.\n  elim H'.\n Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H; intro q'; intro q'; elim q'; intro q'; intro q'; intro q';\n  [ intro q'; elim q'; intro q'; intro q'; intro q';\n  [ intro q'; elim q'; intro q'; intro q';\n  [ intro q'; elim q'; intro q'; intro q'; intro q'; elim q'; intro q';\n  [ intro q'; rewrite q'; intro q'; elim q'; intro q'; intro q';\n  [ intro q'; rewrite q'; intro q'; elim q'; intro q';\n  [ intro q'; elim q'; intro q'; intro q'; elim q'; intro q';\n  [ intro q'; rewrite q'; intro q'; elim q'; intro q';\n  [ intro q'; elim q'; intro q'; intro q'; elim q'; intro q';\n  [ intro q'0'; rewrite q'; intro q'; elim q'; intro q';\n  [ intro q'; rewrite q'; intro q'0'; elim q'; intro q';\n  [ intro q'; elim q'; intro q'; elim q'; intro q';\n    [ intro q'; rewrite q'; intro q'0';\n      [ intro q'; elim q'; intro q'; elim q'; introQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H; intro q';intro.\n  elim H; intro q'; intro q'; elim H'; intro q'; intro q'; intro q'; elim H'; intro q';\n    elim H'; intro q'; intro q'; intro q'; elim H'; intro q'; elim H''; intro q';\n    [ intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n    [ intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n    [ intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0;\n    [ intro q'; elim H'0; intro q'; elim H'0; intro q'0';\n      [ intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n        [ intro q'; elim H'0; intro q'; elim H'0; intro q'; elim H'0; intro q';\n        [ intro q'; elim H'0; intro q'; elim H'0Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro.\n  elim H;intro q'; intro q'; elim H0;intro.\n  elim H0; intro.\n  elim H0; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H3; intro.\n  elim H3; intro.\n  elim H1; intro.\n  elim H1; intro.\n  elim H3; intro.\n  elim H3; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.\n  elim H6; intro.Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro q; elim H;intro q; elim H; intro q';\n    [ intro H'; elim H'; intro H';\n      [ intro H'; elim H'; intro H';\n      [ intro H'; elim H'; intro H';\n        [ intro H'; elim H'; intro H'';\n        [ intro H'0';\n            [ intro H'0';\n            [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';\n               [ intro H'0';Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma1;apply mult_lemma1;apply mult_lemma1;apply mult_lemma2;apply mult_lemma2;apply mult_lemma1;apply mult_lemma1;apply mult_lemma2;apply mult_lemma2;apply mult_lemma2;apply mult_lemma2;apply mult_lemma2;apply mult_lemma3;apply mult_lemma3;apply mult_lemma2;apply mult_lemma2;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply mult_lemma3;apply multlemma3;apply mult_lemma3;apply mult_lemma3;apply multlemma3;apply mult_lemma3;apply multlemma3;apply multlemma3;apply mult_lemma3;apply mult_lemma3;apply multlemma3Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x.\n  simpl.\n  trivial.\n  simpl.\n  destruct m;simpl;trivial.\n  rewrite mult_comm.\n  trivial.\n  simpl.\n  destruct m;simpl;trivial.\n  rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;rewrite mult_comm;simpl;\nrewrite (mult_comm n (b-1));trivial.\n  rewrite (mult_comm n (b-1));trivial.\n  rewrite (mult_comm (b-1));trivial.\n  rewrite (mult_comm n (b-1));trivial.\n  rewrite (mult_comm n (b-1));trivial.\n  rewrite (mult_comm (b-1));trivial.\n  rewrite (mult_comm (b-1));trivial.\n  rewrite (mult_comm (b-1));trivial.\n  rewrite (mult_comm (b-1));trivial.\n  rewrite (mult_comm (b-1Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x;simpl;intros;rewrite plus_comm;rewrite <- mult_assoc;simpl.\n  rewrite <- minus_n_O;trivial.\n  destruct y;simpl in H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (x=y).\n  apply (H (y*t));trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm x y);trivial.\n  assert (x=y).\n  apply (H (y*t));trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm x y);trivial.\n  assert (x=y).\n  apply (H (y*t));trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm x y);trivial.\n  assert (x=y).\n  apply (H (y*t));trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm x y);trivial.\n  assert (x=y).\n  apply (H (y*t));trivial.\n  rewrite <- mult_assoc;simpl;rewrite (mult_comm x y);trivial.\n  assert (x=y).\n  apply (H (yQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl;rewrite <- mult_minus_distr_r.\n  rewrite <- minus_n_O;trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  rewrite <- minus_n_O;trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma2;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma2;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemma1;assumption.\n  rewrite <- mult_minus_distr_r;rewrite (mult_comm z (a-1)).\n  apply mult_lemmaQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite plus_comm;simpl;rewrite <- plus_assoc;rewrite (mult_comm b n);trivial.\n  apply plus_comm.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  apply mult_lemma1;apply mult_lemma1;apply mult_lemma1;apply mult_lemma2;apply mult_lemma2;apply mult_lemma2;auto.\n  assert (n=0 \\/ n=0).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  apply (IH (b-1)).\n  applyQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl;intros.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite <- mult_comm.\n  rewrite plus_assoc.\n  rewrite (mult_comm n (a-1)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n  rewrite (mult_comm z (a-1)).\n Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply plus_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_SQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  apply mult_lemma1;trivial.\n  apply lt_n_O.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n intros.\n apply mult_le_compat_r.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  rewrite mult_minus_distr_l;rewrite minus_plus;trivial.\n  assert (y=z+(y-z)+y).\n  apply plus_minus_lemma2.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z+(y-z)+y).\n  apply plus_minus_lemma2.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z+y).\n  apply plus_minus_lemma2.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z).\n  apply plus_minus_lemma2.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z).\n  apply plus_minus_distr_r.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z).\n  apply plus_minus_distr_r.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z).\n  apply plus_minus_distr_r.\n  rewrite <- (plus_comm y);trivial.\n  assert (y=z).\n  apply plus_minus_distr_r.\n  rewrite <- (Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_minus_lemma2.\n  apply le_minus_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_minus_minus_lemma2.\n  apply le_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  rewrite mult_minus_distr_r;simpl;rewrite minus_minus_distr;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_le_compat_l.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply mult_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_reverse.\n  apply plus_minus_distr_l.\n  apply plus_minus_distr_l.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus x y z);try (auto with arith).\n  rewrite minus_plus;rewrite minus_minus;auto with arith.\n  rewrite (plus_minus_minus y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite (plus_minus_minus y x);try (auto with arith).\n  rewrite <- (lt_plus_minus y x);try (auto with arith).\n  rewrite <- H;trivial.\n  rewrite <- (lt_plus_minus y x);try (auto with arith).\n  rewrite <- H;trivial.\n  apply lt_le_weak.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  apply lt_le_weak.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite (le_plus_minus y z);try (auto with arith).\n  apply le_plus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_plus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_plus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_plus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_minus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_minus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_plus_minus;auto with arith.\n  rewrite <- (lt_minus_minus y z);try (auto with arith).\n  apply le_minus_minus;autoQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- minus_minus;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_minus_minus;simpl;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply plus_minus_lemma1;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  apply le_plus_minus;auto with arith.\n  apply le_plus_minus;auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  assert (y=z);auto with arith.\n  apply le_plus_minus;auto with arith.\n  apply le_plus_minus;auto with arith.\n  apply le_plus_minus;Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (auto with arith).\n  rewrite (le_minus_minus y z);try (autoQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply minus_le;auto with arith.\n  apply minus_le;auto with arith.\n  apply le_trans with (y+x+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+x+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+x+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+x);trivial.\n  apply le_trans with (y+x);trivial.\n  apply le_trans with (y+x);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+x);trivial.\n  apply le_trans with (y+x);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans with (y+y);trivial.\n  apply le_trans withQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite minus_minus;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y z);try (auto with arith).\n  rewrite minus_plus;simpl;rewrite minus_minus;simpl;rewrite minus_minus;simpl;rewrite minus_plus;trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- H;trivial.\n  assert (y=z).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <- (le_plus_minus y z);try (auto with arith).\n  rewrite <-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (lt_plus_minus z y);try (auto with arith).\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite <- minus_plus_simpl_l_reverse;trivial.\n  rewrite <- minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);try (auto with arith).\n  rewrite plus_minus_distr_l;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite (le_minus z y);trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);try (auto with arith).\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite <- (mult_comm x y);trivial.\n  rewrite minus_plus;simpl;rewrite <- (mult_comm y z);trivial.\n  rewrite minus_plus;simpl;rewrite <- (mult_comm y z);trivial.\n  rewrite <- (mult_comm y z);trivial.\n  rewrite minus_plus;simpl;rewrite <- (mult_comm y z);trivial.\n  rewrite <- (mult_comm y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y z);trivial.\n  rewrite minus_plus;rewrite <- minus_plus;trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_minus y x);trivial.\n  rewrite <- (le_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_minus y y);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_minus y y);trivial.\n  rewrite <- (le_minus y x);trivial.\n  rewrite <- (le_plus_minus y x);trivial.\n  rewrite <- (le_minus y x);trivial.\n  rewrite <- (le_minus y x);trivial.\n  rewrite <- (le_minus y y);trivial.\n  rewrite <-Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply plus_minus.\n  rewrite minus_minus;rewrite minus_minus;rewrite <- minus_plus_minus;trivial.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y z);trivial.\n  rewrite minus_minus;rewrite <- minus_minus;trivial.\n  rewrite minus_plus;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_minus_lemma2;auto with arith.\n  apply minus_minus_lemma2;apply minus_minus_lemma2;apply minus_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply le_trans with (S b).\n  apply leQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec y a);intros.\n  rewrite (le_plus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  apply le_minus_minus_lemma2;auto.\n  apply le_minus_minus_lemma2;auto.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus_minus b a);trivialQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_minus a b);trivial.\n  rewrite <- (le_plus_minus b a);trivial.\n  rewrite <- (le_plus_minus b a);trivial.\n  rewrite <- (le_plus_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_minus b a);trivial.\n  rewrite <- (le_Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply multQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply lt_trans with (a+b)+1.\n  apply plus_le_compat_l.\n  apply le_trans with (a+b);trivial.\n  rewrite <- minus_plus;rewrite <- minus_plus;trivial.\n  apply le_trans with (b+b);trivial.\n  apply plus_le_compat_l.\n  apply le_trans with (b+b);trivial.\n  apply plus_le_compat_l.\n  apply le_trans with (b+b);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply plus_le_compat_r.\n  apply le_trans with (b+b);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply le_trans with (b+c);trivial.\n  apply leQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply (le_plus_minus b a);trivial.\n  apply (le_plus_minus b a);trivial.\n  apply (le_plus_minus b a);trivial.\n  apply (le_plus_minus b a);trivial.\n  apply (le_plus_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\n  apply (le_minus b a);trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite <- (le_plus_minus b a);trivial.\n  rewrite minus_plus;rewrite <- plus_minus;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n destruct (mult_lemma1 n m) as [H1 | H2]; trivial.\n destruct (mult_lemma2 n m) as [H2 | H3]; trivial.\n destruct (mult_lemma2 n m) as [H3 | H4]; trivial.\n destruct (mult_lemma2 n m) as [H5 | H5]; trivial.\n destruct (mult_lemma2 n m) as [H6 | H6]; trivial.\n destruct (mult_lemma2 n m) as [H6 | H7]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m) as [H8 | H8]; trivial.\n destruct (mult_lemma2 n m)Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n apply (mult_lemma1 n m).\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_r.\n apply mult_plus_distr_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply (mult_lemma1 n m n); auto with arith.\n apply (mult_lemma2 n m n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n destruct (mult_lemma1 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemma2 n m) as [H|H].\n (* n = m *)\n destruct (mult_lemmaQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros n m.\n  elim (mult_lemma1 n m); intros H1 H2; elim H2; intros H3;\n    [ rewrite H3; auto with arith | auto with arith ].\n  elim (mult_lemma2 n m); intros H3; elim H3; intros H4;\n    [ rewrite H4; auto with arith | auto with arith ].\n  elim (mult_lemma3 n m); intros H4; elim H4; intros H5;\n    [ rewrite H5; auto with arith | auto with arith ].\n  elim (mult_lemma1 n m); intros H4; elim H4; intros H5;\n    [ rewrite H5; auto with arith | auto with arith ].\n  elim (mult_lemma3 n m); intros H4; elim H4; intros H5;\n    [ rewrite H5; auto with arith | auto with arith ].\n  elim (mult_lemma3 n m); intros H5; elim H5; intros H5;\n    [ rewrite H5; auto with arith | auto with arith ].\n  elim (mult_lemma3 n m); intros H5; elim H5; intros H5;\n    [ rewrite H5; auto withQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H.\n apply le_O_n.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_Sn.\n apply le_O_SnQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m; induction n.\nsimpl; auto.\nintros m H.\nrewrite H; auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n apply plus_le_compat_r.\n apply plus_le_compat_r.\n apply le_n_Sm.\n apply le_n_Sm.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H; elim (mult_lemma1 n m); auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n rewrite (mult_comm _ _ H).\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_minus_distr.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_rQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim H;trivial.\n  elim HQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  applyQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivialQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite plus_comm.\n  simpl in |- *.\n  rewrite plus_comm.\n  simpl in |- *.\n  rewrite plus_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite plus_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_assoc.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite mult_comm.\n  simpl in |- *.\n  rewrite multQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma2.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  tauto.\n  simpl in H.\n  apply (mult_lemma1 (S m) (S m)); simpl in H.\n  elim H;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H0;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H0;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H0;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H0;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (S m) (S m)); simpl in |- *; trivial.\n  elim H0;trivial.\n  simpl in |- *.\n  apply (mult_lemma2 (Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma1 with n m.\n  apply mult_lemma1 with n m.\n  apply mult_lemma2 with n m.\n  apply mult_lemma2 with n m.\n  apply mult_lemma2 with m.\n  apply mult_lemma2 with n m.\n  apply mult_lemma1 with m.\n  apply mult_lemma2 with n m.\n  apply mult_lemma1 with m.\n  apply mult_lemma1 with m.\n  apply mult_lemma1 with m.\n  apply mult_lemma1 with n.\n  apply mult_minus_distr_l.\n  apply mult_lemma2 with m.\n  apply mult_lemma1 with m.\n  apply mult_minus_distr_l.\n  apply mult_lemma2 with n.\n  apply mult_minus_distr_r.\n  apply mult_lemma2 with m.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_l.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply mult_minus_distr_r.\n  apply multQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  tauto.\n  simpl in H.\n  apply mult_lemma1.\n  tauto.\n  simpl in |- *.\n  apply mult_le_compat_l.\n  tauto.\n  simpl in |- *.\n  apply mult_le_compat_l.\n  tauto.\n  simpl in |- *.\n  apply mult_le_compat_l.\n  tauto.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  tauto.\n  simpl in H.\n  assert (m <= S n);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  induction n;simpl;auto with arith.\n  elim H;trivial.\n  apply mult_lemma1;auto with arith.\n  elim H;trivial.\n  apply mult_lemma1;auto with arith.\n  elim H;trivial.\n  apply mult_lemma2;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  apply mult_lemma2;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  left.\n  assumption.\n  simpl in H.\n  apply (mult_lemma1 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma2 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m H).\n  apply (mult_lemma3 n m HQed."
                ]
            }
        ]
    }
}